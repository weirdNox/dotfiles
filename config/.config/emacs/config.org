#+TITLE: Emacs configuration
#+AUTHOR: Gonçalo Santos (weirdNox)
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC
* Configuration
:PROPERTIES:
:VISIBILITY: children
:END:
** About
This is Gonçalo Santos's Emacs configuration.

#+BEGIN_SRC emacs-lisp
(setq-default user-full-name "Gonçalo Santos")
#+END_SRC

*** Naming conventions
- nox-...   variables or non-interactive functions
- nox/...   an interactive function
- nox|...   hook function
- nox*...   advising functions
- nox@...   a hydra command
- ...!      a macro or function that configures Emacs
- %...      functions used for in-snippet logic
- +...      variables or functions related to a package

** Essential
*** Built-in packages
#+BEGIN_SRC emacs-lisp
(require 'subr-x)
(require 'cl-lib)
#+END_SRC

*** Variables and constants
#+BEGIN_SRC emacs-lisp
(defvar nox-debug-mode (when (or (getenv "DEBUG") init-file-debug) t)
  "If non-nil, all functions will be verbose. Set DEBUG=1 in the command
line or use --debug-init to enable this.")

(defconst EMACS26+ (eval-when-compile (not (version< emacs-version "26"))))
(defconst EMACS27+ (eval-when-compile (not (version< emacs-version "27"))))

(defconst IS-MAC     (eq system-type 'darwin))
(defconst IS-LINUX   (eq system-type 'gnu/linux))
(defconst IS-WINDOWS (memq system-type '(cygwin windows-nt ms-dos)))
#+END_SRC

*** Directories
#+BEGIN_SRC emacs-lisp
(defconst nox-emacs-dir (eval-when-compile (file-truename user-emacs-directory)))
(defconst nox-local-dir         (concat nox-emacs-dir "local/"))
(defconst nox-etc-dir           (concat nox-local-dir "etc/"))
(defconst nox-cache-dir         (concat nox-local-dir "cache/"))
(defconst nox-repo-packages-dir (concat nox-emacs-dir "repo-packages/"))
#+END_SRC

Also create the directories if they don't exist.

#+BEGIN_SRC emacs-lisp
(dolist (dir (list nox-local-dir nox-etc-dir nox-cache-dir))
  (unless (file-directory-p dir) (make-directory dir t)))
#+END_SRC

*** Functions and macros
**** Helpers
#+BEGIN_SRC emacs-lisp
(defmacro setq! (&rest settings)
  "Like setq-default, but uses custom-set if it is set."
  `(progn ,@(cl-loop for (var val) on settings by 'cddr
                     collect `(funcall (or (get ',var 'custom-set) #'set-default)
                       ',var ,val))))

(defmacro lambda! (&rest body)
  "A shortcut for inline interactive lambdas."
  (declare (doc-string 1))
  `(lambda () (interactive) ,@body))

(defmacro no-sorting! (list)
  `(lambda (string pred action)
     (if (eq action 'metadata)
         '(metadata (display-sort-function . identity))
       (complete-with-action action ,list string pred))))

(defun nox-unquote (exp)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

(defun nox-enlist (exp)
  "Return EXP wrapped in a list, or as-is if already a list."
  (declare (pure t) (side-effect-free t))
  (if (listp exp) exp (list exp)))

(defun nox-pos-at-line (line &optional column)
  (save-excursion
    (goto-char (point-min))
    (forward-line (- line 1))
    (move-to-column (or column 0))
    (point)))

(defun nox-get-line-from-file (file line &optional trim)
  (with-current-buffer (find-file-noselect file)
    (save-excursion
      (goto-char (point-min))
      (forward-line (- line 1))
      (let ((string (thing-at-point 'line)))
        (if trim
            (replace-regexp-in-string "\\(\\`[[:space:]\n]*\\|[[:space:]\n]*\\'\\)" "" string)
          string)))))

(defun nox-get-entire-buffer (buffer)
  (with-current-buffer buffer
    (save-restriction
      (widen)
      (buffer-substring-no-properties (point-min) (point-max)))))

(defun +color-name-lighter-than (a b)
  (> (nth 2 (apply #'color-rgb-to-hsl (color-name-to-rgb a)))
     (nth 2 (apply #'color-rgb-to-hsl (color-name-to-rgb b)))))
#+END_SRC

**** Hooks
#+BEGIN_SRC emacs-lisp
(defun nox-resolve-hook-forms (hooks)
  (declare (pure t) (side-effect-free t))
  (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
           for hook in (nox-enlist (nox-unquote hooks))
           if (eq (car-safe hook) 'quote)
           collect (cadr hook)
           else if quoted-p
           collect hook
           else collect (intern (format "%s-hook" (symbol-name hook)))))

(defmacro add-hook! (&rest args)
  "A convenience macro for `add-hook'. Takes, in order:

   1. Optional properties :local and/or :append, which will make the hook
      buffer-local or append to the list of hooks (respectively),
   2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
      a quoted hook variable or a quoted list of hook variables. If unquoted, the
      hooks will be resolved by appending -hook to each symbol.
   3. A function, list of functions, or body forms to be wrapped in a lambda.

Examples:
    (add-hook! 'some-mode-hook 'enable-something)   (same as `add-hook')
    (add-hook! some-mode '(enable-something and-another))
    (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
    (add-hook! (one-mode second-mode) 'enable-something)
    (add-hook! :append (one-mode second-mode) 'enable-something)
    (add-hook! :local (one-mode second-mode) 'enable-something)
    (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
    (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))

Body forms can access the hook's arguments through the let-bound variable `args'."
  (declare (indent defun) (debug t))
  (let ((hook-fn 'add-hook)
        append-p local-p)
    (while (keywordp (car args))
      (pcase (pop args)
        (:append (setq append-p t))
        (:local  (setq local-p t))
        (:remove (setq hook-fn 'remove-hook))))
    (let ((hooks (nox-resolve-hook-forms (pop args)))
          (funcs (let ((arg (car args)))
                   (if (memq (car-safe arg) '(quote function))
                       (if (cdr-safe (cadr arg))
                           (cadr arg)
                         (list (cadr arg)))
                     (list args))))
          forms)
      (dolist (fn funcs)
        (setq fn (if (symbolp fn)
                     `(function ,fn)
                   `(lambda (&rest _) ,@args)))
        (dolist (hook hooks)
          (push (if (eq hook-fn 'remove-hook)
                    `(remove-hook ',hook ,fn ,local-p)
                  `(add-hook ',hook ,fn ,append-p ,local-p))
                forms)))
      `(progn ,@(if append-p (nreverse forms) forms)))))

(defmacro remove-hook! (&rest args)
  "Convenience macro for `remove-hook'. Takes the same arguments as `add-hook!'."
  (declare (indent defun) (debug t))
  `(add-hook! :remove ,@args))

(defmacro setq-hook! (hooks &rest rest)
  "Convenience macro for setting buffer-local variables in a hook."
  (declare (indent 1))
  (unless (= 0 (% (length rest) 2))
    (signal 'wrong-number-of-arguments (length rest)))
  `(add-hook! ,hooks
     ,@(let (forms)
         (while rest
           (let ((var (pop rest))
                 (val (pop rest)))
             (push `(setq-local ,var ,val) forms)))
         (nreverse forms))))

(defmacro add-transient-hook! (hook-or-function &rest args)
  "Attaches a self-removing function to HOOK-OR-FUNCTION.

HOOK-OR-FUNCTION can be a quoted hook or a sharp-quoted function (which will be
advised).

ARGS can be a function, list of functions, or body forms to be wrapped in a lambda.
When it is a function or a list of functions, they will be called with the hooks args."
  (declare (indent 1))
  (let ((append (if (eq (car args) :after) (pop args)))
        ;; NOTE(nox):
        ;; If args is a function or list of functions, funcs will be a list of functions
        ;; If args is a list of forms, funcs will be a list containing only the list of forms
        (funcs (let ((arg (car args)))
                 (if (memq (car-safe arg) '(quote function))
                     (if (cdr-safe (cadr arg))
                         (cadr arg)
                       (list (cadr arg)))
                   (list args))))
        (func-name (gensym "nox|transient-hook-")))
    `(progn
       (fset ',func-name
             (lambda (&rest call-args)
               ,@(cl-loop for fn in funcs
                          collect (if (symbolp fn)
                                      `(apply #',fn call-args)
                                    `(progn ,@args)))
               (cond ((functionp ,hook-or-function) (advice-remove ,hook-or-function #',func-name))
                     ((symbolp ,hook-or-function)   (remove-hook ,hook-or-function #',func-name)))
               (unintern ',func-name nil)))
       (cond ((functionp ,hook-or-function)
              (advice-add ,hook-or-function ,(if append :after :before) #',func-name))
             ((symbolp ,hook-or-function)
              (put ',func-name 'permanent-local-hook t)
              (add-hook ,hook-or-function #',func-name ,append))))))

(defmacro after! (targets &rest body)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation. This will no-op on features that have been disabled by the user."
  (declare (indent defun) (debug t))
  (list (if (or (not (bound-and-true-p byte-compile-current-file))
                (dolist (next (nox-enlist targets))
                  (unless (keywordp next)
                    (if (symbolp next)
                        (require next nil :no-error)
                      (load next :no-message :no-error)))))
            #'progn
          #'with-no-warnings)
        (if (symbolp targets)
            `(with-eval-after-load ',targets ,@body)
          (pcase (car-safe targets)
            ((or :or :any)
             (macroexp-progn
              (cl-loop for next in (cdr targets)
                       collect `(after! ,next ,@body))))
            ((or :and :all)
             (dolist (next (cdr targets))
               (setq body `((after! ,next ,@body))))
             (car body))
            (_ `(after! (:and ,@targets) ,@body))))))
#+END_SRC

**** Shut things up
#+BEGIN_SRC emacs-lisp
(defmacro quiet! (&rest forms)
  "Run FORMS without making any output."
  `(if nox-debug-mode
       (progn ,@forms)
     (let ((old-fn (symbol-function 'write-region)))
       (cl-letf* ((standard-output (lambda (&rest _)))
                  ((symbol-function 'load-file) (lambda (file) (load file nil t)))
                  ((symbol-function 'message) (lambda (&rest _)))
                  ((symbol-function 'write-region)
                   (lambda (start end filename &optional append visit lockname mustbenew)
                     (unless visit (setq visit 'no-message))
                     (funcall old-fn start end filename append visit lockname mustbenew)))
                  (inhibit-message t)
                  (save-silently t))
         ,@forms))))

(defun nox*shut-up (orig-fn &rest args)
  "Generic advisor for silencing noisy functions."
  (quiet! (apply orig-fn args)))
#+END_SRC

**** File management
#+BEGIN_SRC emacs-lisp
(defun nox/rename-file-and-buffer ()
  "Rename current buffer and the file it is visiting, if any."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (rename-buffer (read-from-minibuffer "New name: " (buffer-name)))
      (let ((new-name (read-file-name "New name: " filename)))
        (if (vc-backend filename)
            (vc-rename-file filename new-name)
          (rename-file filename new-name t))
        (set-visited-file-name new-name t t)))))

(defun nox/delete-file-and-buffer ()
  "Kill the current buffer and delete the file it is visiting, if any."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (kill-buffer)
      (if (vc-backend filename)
          (vc-delete-file filename)
        (when (y-or-n-p (format "Are you sure you want to delete %s? " filename))
          (delete-file filename delete-by-moving-to-trash)
          (message "Deleted file %s" filename)
          (kill-buffer))))))
#+END_SRC

**** Open file externally
#+begin_src emacs-lisp
(defun nox/open-externally (file)
  "Pass FILE to `xdg-open' or equivalent command via the shell."
  (interactive "FFile: ")
  (if (and (eq system-type 'windows-nt)
           (fboundp 'w32-shell-execute))
      (w32-shell-execute "open" file)
    (call-process-shell-command (format "%s %s"
                                        (cl-case system-type
                                          (darwin "open")
                                          (cygwin "cygstart")
                                          (t "xdg-open"))
                                        (shell-quote-argument file))
                                nil 0)))
#+end_src

**** Exiting
#+BEGIN_SRC emacs-lisp
(defun nox/exit-emacs (arg)
  "Exit Emacs, possibly killing the daemon and/or saving buffer.
When ARG is:
- nil or negative, it will kill the current terminal
- `universal-argument' or positive, it will kill the daemon
- a number, it will save all buffers automatically"
  (interactive "P")
  (when (or (numberp arg) (eq arg '-))
    (setq arg (prefix-numeric-value arg)))
  (let* ((save-without-asking (numberp arg))
         (kill-server (or (equal arg '(4))
                          (and save-without-asking
                               (>= arg 0)))))

    (when (and (featurep 'org-clock) (org-clocking-p)
               (y-or-n-p (format "Clock out of '%s'?" org-clock-current-task)))
      (org-clock-out nil t))

    (if kill-server
        (save-buffers-kill-emacs save-without-asking)
      (save-buffers-kill-terminal save-without-asking))))
#+END_SRC

**** Time measurement
#+BEGIN_SRC emacs-lisp
(defmacro nox-measure-time (&rest body)
  "Measure and return the running time of the code block."
  (declare (indent defun))
  (let ((start (make-symbol "start")))
    `(let ((,start (float-time)))
       ,@body
       (- (float-time) ,start))))
#+END_SRC

**** Byte compilation
#+BEGIN_SRC emacs-lisp
(defun nox-byte-compile-init ()
  (byte-compile-file (concat user-emacs-directory "config.el"))
  (byte-compile-file (concat user-emacs-directory "init.el"))
  (byte-compile-file (concat user-emacs-directory "early-init.el")))
#+END_SRC

*** Package ecosystem
#+BEGIN_SRC emacs-lisp
(defvar elpaca-installer-version 0.6)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                 ((zerop (call-process "git" nil buffer t "clone"
                                       (plist-get order :repo) repo)))
                 ((zerop (call-process "git" nil buffer t "checkout"
                                       (or (plist-get order :ref) "--"))))
                 (emacs (concat invocation-directory invocation-name))
                 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                       "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                 ((require 'elpaca))
                 ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+END_SRC

**** Setup use-package
#+BEGIN_SRC emacs-lisp
(elpaca elpaca-use-package (elpaca-use-package-mode))
(elpaca-wait)

(setq! use-package-always-defer t
       use-package-verbose nox-debug-mode
       use-package-compute-statistics nox-debug-mode
       use-package-minimum-reported-time (if nox-debug-mode 0 0.1)
       use-package-hook-name-suffix nil)
#+END_SRC

Add the :after-call keyword, that takes a symbol or list of symbols, where the symbols are
functions or hook variables. It will load the package on the first call to any of those
symbols.

#+BEGIN_SRC emacs-lisp
(defvar nox-deferred-packages-alist '(t))

(after! use-package-core
  (push :after-call use-package-deferring-keywords)
  (setq use-package-keywords
        (use-package-list-insert :after-call use-package-keywords :after))

  (defalias 'use-package-normalize/:after-call 'use-package-normalize-symlist)
  (defun use-package-handler/:after-call (name _keyword hooks rest state)
    (if (plist-get state :demand)
        (use-package-process-keywords name rest state)
      (let ((fn (intern (format "nox|transient-hook--load-%s" name))))
        (use-package-concat
         `((fset ',fn
                 (lambda (&rest _)
                   (when nox-debug-mode
                     (message "Loading deferred package %s from %s" ',name ',fn))
                   (condition-case e (require ',name)
                     ((debug error)
                      (message "Failed to load deferred package %s: %s" ',name e)))
                   (dolist (hook (cdr (assq ',name nox-deferred-packages-alist)))
                     (if (functionp hook)
                         (advice-remove hook #',fn)
                       (remove-hook hook #',fn)))
                   (delq (assq ',name nox-deferred-packages-alist)
                         nox-deferred-packages-alist)
                   (fmakunbound ',fn))))
         (let (forms)
           (dolist (hook hooks forms)
             (push (if (functionp hook)
                       `(advice-add #',hook :before #',fn)
                     `(add-hook ',hook #',fn))
                   forms)))
         `((unless (assq ',name nox-deferred-packages-alist)
             (push '(,name) nox-deferred-packages-alist))
           (nconc (assq ',name nox-deferred-packages-alist)
                  '(,@hooks)))
         (use-package-process-keywords name rest state))))))
#+END_SRC

**** Update built-in packages
#+begin_src emacs-lisp
(defun +elpaca-unload-seq (e)
  (and (featurep 'seq) (unload-feature 'seq t))
  (elpaca--continue-build e))

(defun +elpaca-seq-build-steps ()
  (append (butlast (if (file-exists-p (expand-file-name "seq" elpaca-builds-directory))
                       elpaca--pre-built-steps elpaca-build-steps))
          (list '+elpaca-unload-seq 'elpaca--activate-package)))

(use-package seq :elpaca `(seq :build ,(+elpaca-seq-build-steps)))
#+end_src

**** Repo packages
#+begin_src emacs-lisp
(add-to-list 'load-path nox-repo-packages-dir)
#+end_src

*** Packages
**** General
#+BEGIN_SRC emacs-lisp
(use-package general :elpaca t :demand
  :config
  (general-create-definer nox-leader :prefix "C-c")
  (general-create-definer nox-local-leader :prefix "C-c m"))

(elpaca-wait)
#+END_SRC

**** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra :elpaca t
  :config (setq! lv-use-separator t))
#+END_SRC

** General settings and tweaks
#+BEGIN_SRC emacs-lisp
(setq!
 ad-redefinition-action 'accept
 auto-window-vscroll nil ;; https://emacs.stackexchange.com/a/28746
 autoload-compute-prefixes nil
 byte-compile-verbose nox-debug-mode
 debug-on-error nox-debug-mode
 ffap-machine-p-known 'reject
 idle-update-delay 2
 inhibit-compacting-font-caches t
 minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt)
 auth-source-save-behavior nil
 process-error-pause-time 0
 native-comp-async-report-warnings-errors nil)

(add-hook! 'minibuffer-setup-hook #'cursor-intangible-mode)
#+END_SRC

*** UTF-8 as default
#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
(set-coding-system-priority 'utf-8 'chinese-gbk)
#+END_SRC

*** Quiet startup
#+BEGIN_SRC emacs-lisp
(setq! inhibit-startup-message t
       inhibit-startup-echo-area-message user-login-name
       inhibit-default-init t
       initial-major-mode 'fundamental-mode
       initial-scratch-message nil)
(fset #'display-startup-echo-area-message #'ignore)

(defun nox*server-execute-quiet (orig-fn &rest args)
  "Shup ut `server-execute' once."
  (quiet! (apply orig-fn args))
  (advice-remove 'server-execute 'nox*server-execute-quiet))
(when (daemonp) (advice-add 'server-execute :around 'nox*server-execute-quiet))
#+END_SRC

*** Files
#+BEGIN_SRC emacs-lisp
(setq! abbrev-file-name               (concat nox-local-dir "abbrev.el")
       auto-save-file-name-transforms (list (list ".*" (concat nox-cache-dir "auto-save/") t))
       auto-save-list-file-prefix     (concat nox-cache-dir "auto-save/session-")
       backup-directory-alist         (list (cons "." (concat nox-cache-dir "backup/")))
       custom-file                    (concat nox-local-dir "custom.el")
       pcache-directory               (concat nox-cache-dir "pcache/")
       request-storage-directory      (concat nox-cache-dir "request")
       server-auth-dir                (concat nox-cache-dir "server/")
       shared-game-score-directory    (concat nox-etc-dir "shared-game-score/")
       url-cache-directory            (concat nox-cache-dir "url/")
       url-configuration-directory    (concat nox-etc-dir "url/"))

(make-directory (cadar auto-save-file-name-transforms) t)
#+END_SRC

*** History and backup
#+BEGIN_SRC emacs-lisp
(setq! delete-by-moving-to-trash t
       delete-old-versions t
       history-length 5000000
       kept-new-versions 10
       kept-old-versions 2
       version-control t)
#+END_SRC

*** Enable disabled commands
#+BEGIN_SRC emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'scroll-left 'disabled nil)
#+END_SRC

*** Disable bidirectional editing
#+begin_src emacs-lisp
(setq! bidi-paragraph-direction 'left-to-right
       bidi-inhibit-bpa         t)
#+end_src

*** Save minibuffer history persistently
#+begin_src emacs-lisp
(use-package savehist
  :init
  (setq! savehist-file (concat nox-cache-dir "savehist.el"))
  (savehist-mode))
#+end_src

*** Comint mode fixes
#+begin_src emacs-lisp
(use-package comint
  :config
  (defun comint-read-input-ring (&optional silent)
    (cond ((or (null comint-input-ring-file-name)
               (equal comint-input-ring-file-name ""))
           nil)
          ((not (file-readable-p comint-input-ring-file-name))
           (or silent (message "Cannot read history file %s" comint-input-ring-file-name)))
          (t (let* ((file comint-input-ring-file-name)
                    (count 0)
                    (max-size comint-input-ring-size)
                    (ring-size (min 1500 max-size))
                    (ring (make-ring ring-size))
                    (ring-separator comint-input-ring-separator)
                    (history-ignore comint-input-history-ignore)
                    (ignoredups comint-input-ignoredups))
               (with-temp-buffer
                 (insert-file-contents file)
                 (goto-char (point-max))
                 (let (start end history)
                   (while (and (< count max-size)
                               (re-search-backward ring-separator nil t)
                               (setq end (match-beginning 0)))
                     (setq start (if (re-search-backward ring-separator nil t) (match-end 0) (point-min)))
                     (setq history (buffer-substring start end))
                     (goto-char start)
                     (when (and (not (string-match history-ignore history))
                                (or (null ignoredups) (ring-empty-p ring)
                                    (not (string-equal (ring-ref ring (- count 1)) history))))
                       (when (= count ring-size)
                         (ring-extend ring (min (- max-size ring-size) ring-size))
                         (setq ring-size (ring-size ring)))
                       (ring-insert-at-beginning ring history)
                       (setq count (1+ count))))))
               (setq comint-input-ring ring
                     comint-input-ring-index nil))))))
#+end_src

** UI
*** Settings
#+BEGIN_SRC emacs-lisp
(setq! initial-frame-alist '((fullscreen . maximized)
                             (fullscreen-restore . maximized))
       ring-bell-function #'ignore
       visible-bell nil
       custom-safe-themes t
       frame-inhibit-implied-resize t
       mode-line-default-help-echo nil
       use-dialog-box nil
       pos-tip-internal-border-width 6
       pos-tip-border-width 1
       frame-resize-pixelwise t
       echo-keystrokes 0.2
       frame-title-format '("Emacs - %b")
       tooltip-hide-delay 3600
       use-short-answers t)

(minibuffer-depth-indicate-mode)
#+END_SRC

**** Cursor
#+BEGIN_SRC emacs-lisp
(setq! cursor-in-non-selected-windows t
       highlight-nonselected-windows nil
       visible-cursor nil
       x-stretch-cursor nil)

(blink-cursor-mode -1)
#+END_SRC

**** Windows dividers
#+BEGIN_SRC emacs-lisp
(setq! window-divider-default-places t
       window-divider-default-bottom-width 1
       window-divider-default-right-width 1)
(window-divider-mode)
#+END_SRC

**** Faster (?) font locking
#+BEGIN_SRC emacs-lisp
(setq! font-lock-maximum-decoration 2
       jit-lock-defer-time 0
       jit-lock-stealth-time 2.5
       jit-lock-contextually t
       jit-lock-context-time 2)
#+END_SRC

**** Highlight line
#+BEGIN_SRC emacs-lisp
(use-package hl-line :init (global-hl-line-mode 1))
#+END_SRC

**** Highlight matching parentheses
#+BEGIN_SRC emacs-lisp
(use-package paren
  :after-call (after-find-file nox-exit-buffer-hook)
  :config
  (setq show-paren-delay 0
        show-paren-highlight-openparen t
        show-paren-when-point-inside-paren nil)
  (show-paren-mode))
#+END_SRC

**** Shims
#+BEGIN_SRC emacs-lisp
(unless (fboundp 'define-fringe-bitmap) (defun define-fringe-bitmap (&rest _)))
#+END_SRC

**** Misc
#+BEGIN_SRC emacs-lisp
(use-package server
  :config
  (defun +server|bring-frame-to-front () (select-frame-set-input-focus (selected-frame)))
  (add-hook! '(server-after-make-frame-hook server-switch-hook) #'+server|bring-frame-to-front))
#+END_SRC

*** Font
#+BEGIN_SRC emacs-lisp
(defvar nox-fonts '(("PragmataPro"      10.0 .00)
                    ("Cascadia Code"    10.0 .00)
                    ("Consolas"         10.0 .00)
                    ("Liberation Mono"  10.0 .00)
                    ("DejaVu Sans Mono"  9.0 .00)
                    ("Source Code Pro"  10.0 .00)))

(defvar nox-font-faces-changed nil
  "List ARGS passed to custom-set-faces, in order to fix font.")

(defun nox-font-set-faces (&rest args)
  "Override faces' attributes in the `user' theme.
These settings will remain until a new font is loaded.
ARGS are the same as in `custom-set-faces'."
  (push args nox-font-faces-changed)
  (apply 'custom-set-faces args))

(defun nox/change-font ()
  (interactive)
  (let ((all-fonts (font-family-list))
        available-fonts font-name font-size line-spac)
    (dolist (font nox-fonts)
      (when (member (car font) all-fonts)
        (push font available-fonts)))

    (push (list "Monospace" 10.5 .15) available-fonts)
    (setq available-fonts (nreverse available-fonts))

    (when nox-debug-mode (message "Available fonts: %s" available-fonts))

    (if (called-interactively-p 'interactive)
        (let* ((chosen (assoc-string (completing-read "What font to use? " available-fonts nil t)
                                     available-fonts)))
          (setq font-name (car chosen)
                font-size (read-number "Font size: "    (cadr  chosen))
                line-spac (read-number "Line spacing: " (caddr chosen))))
      (setq font-name (caar   available-fonts)
            font-size (cadar  available-fonts)
            line-spac (caddar available-fonts)))

    (set-face-attribute 'default nil :font font-name :height (floor (* 10 font-size)))
    (setq! line-spacing line-spac)

    (dolist (args nox-font-faces-changed) (apply 'custom-theme-reset-faces 'user args))
    (setq nox-font-faces-changed nil)

    (cond ((string= font-name "PragmataPro")
           (nox-font-set-faces `(org-table ((t . (:family "PragmataPro Mono")))))))))
#+END_SRC

*** Theme
**** Theme customizer
#+BEGIN_SRC emacs-lisp
(defvar nox-customize-theme-hook nil
  "Hook for theme customization, called with the theme name.")

(defvar nox-theme-faces-changed nil
  "List ARGS passed to custom-set-faces, in order to fix theme.")

(defun nox*customize-theme (theme)
  (unless (eq theme 'user)
    (dolist (enabled-theme custom-enabled-themes)
      (unless (eq enabled-theme theme) (disable-theme enabled-theme))))

  (dolist (args nox-theme-faces-changed)
    (apply 'custom-theme-reset-faces 'user args))
  (setq nox-theme-faces-changed nil)

  (run-hook-with-args-until-success 'nox-customize-theme-hook (or theme
                                                                  (car custom-enabled-themes))))
(advice-add 'enable-theme :after #'nox*customize-theme)

(defmacro nox-add-customize-theme-hook (target-theme &rest body)
  "TARGET-THEME may be a list, a symbol or a regexp."
  (declare (indent defun))
  `(add-hook 'nox-customize-theme-hook
             (lambda (theme)
               ,(cond ((symbolp (eval target-theme))
                       `(when (eq theme ,target-theme) ,@body))
                      ((stringp (eval target-theme))
                       `(when (string-match ,target-theme (symbol-name theme)) ,@body))
                      ((listp (eval target-theme))
                       `(when (memq theme ,target-theme) ,@body))))))

(defun nox-theme-set-faces (&rest args)
  "Override faces' attributes in the `user' theme.
These settings will remain until a new theme is loaded.
ARGS are the same as in `custom-set-faces'."
  (push args nox-theme-faces-changed)
  (apply 'custom-set-faces args))
#+END_SRC

**** Theme
#+BEGIN_SRC emacs-lisp
(use-package darktooth-theme :elpaca t
  :config
  (nox-add-customize-theme-hook 'darktooth
    (nox-theme-set-faces
     '(shadow ((t . (:inherit font-lock-comment-face))))
     `(org-block ((t . (:background ,(ignore-errors (color-darken-name (face-attribute 'default :background) 2))))))
     '(org-agenda-structure ((t . (:inherit font-lock-doc-face))))
     '(hl-line ((t . (:background "#32302F")))))))

(use-package doom-themes :elpaca t
  :config
  (setq! doom-one-brighter-comments t
         doom-peacock-brighter-modeline t)

  (nox-add-customize-theme-hook "^doom-one"
    (nox-theme-set-faces
     `(font-lock-comment-face ((t . (:background nil)))))))

(use-package gruvbox-theme :elpaca t
  :config
  (nox-add-customize-theme-hook "^gruvbox"
    (nox-theme-set-faces
     '(org-agenda-structure ((t . (:inherit font-lock-doc-face))))
     '(org-code ((t . (:inherit font-lock-builtin-face))))
     '(org-verbatim ((t . (:inherit font-lock-doc-face))))
     `(org-block ((t . (:background ,(ignore-errors (color-darken-name (face-attribute 'default :background) 2))))))
     `(fringe ((t . (:foreground ,(ignore-errors (color-darken-name (face-attribute 'shadow :foreground) 10)))))))))

(use-package color-theme-sanityinc-tomorrow :elpaca t
  :config
  (nox-add-customize-theme-hook "^sanityinc"
    (nox-theme-set-faces
     `(org-drawer ((t . (:foreground ,(face-attribute 'shadow :foreground)))))
     `(org-headline-done ((t . (:foreground ,(face-attribute 'shadow :foreground) :strike-through nil)))))))

(use-package modus-themes :elpaca t)
#+END_SRC

**** Extra programming keywords
#+BEGIN_SRC emacs-lisp
(defface font-lock-todo-face      '((t (:foreground "#dc322f" :weight bold :underline t)))
  "Face for TODO keywords.")

(defface font-lock-important-face '((t (:foreground "#b58900" :weight bold :underline t)))
  "Face for IMPORTANT keywords.")

(defface font-lock-note-face      '((t (:foreground "#228b22" :weight bold :underline t)))
  "Face for NOTE keywords.")

(defface font-lock-study-face     '((t (:foreground "#8470ff" :weight bold :underline t)))
  "Face for STUDY keywords.")

(add-hook! prog-mode (font-lock-add-keywords
                      nil '(("\\<\\(TODO\\|FIXME\\|OPTIMIZE\\|HACK\\)" 1 'font-lock-todo-face t)
                            ("\\<\\(IMPORTANT\\)" 1 'font-lock-important-face t)
                            ("\\<\\(NOTE\\)" 1 'font-lock-note-face t)
                            ("\\<\\(STUDY\\|REVIEW\\)" 1 'font-lock-study-face t))))
#+END_SRC

*** Fringes
Disable fringes in the minibuffer window.

#+BEGIN_SRC emacs-lisp
(defun nox|no-fringes-in-minibuffer (&rest _)
  "Disable fringes in the minibuffer window."
  (set-window-fringes (minibuffer-window) 0 0 nil))
(add-hook! '(elpaca-after-init-hook minibuffer-setup-hook window-configuration-change-hook) #'nox|no-fringes-in-minibuffer)
#+END_SRC

*** Modeline
#+BEGIN_SRC emacs-lisp
(setq!
 mode-line-buffer-identification
 `((:eval
    (let ((inherit-faces (if (and buffer-file-name (buffer-modified-p)) '(error bold) 'mode-line-buffer-id)))
      (concat (propertize "%b" 'face inherit-faces)))))
 mode-line-modes '("" mode-name mode-line-process " ")
 mode-line-position
 '((line-number-mode (column-number-mode (column-number-indicator-zero-based " %l:%c" " %l:%C") " %l")
                     (column-number-mode (column-number-indicator-zero-based " :%c" " :%C")))
   (" " mode-line-percent-position " ")))

(use-package anzu :elpaca t
  :after isearch :demand
  :init (global-anzu-mode 1))
#+END_SRC

*** Appearance setup
#+BEGIN_SRC emacs-lisp
(elpaca nil
  (defun nox-setup-appearance (frame)
    (with-selected-frame frame
      (load-theme 'modus-vivendi t)
      (nox/change-font)
      (when (> (window-width) 100) (split-window-right))
      (setq! system-time-locale "C")))

  (add-transient-hook! 'elpaca-after-init-hook (nox-setup-appearance (selected-frame)))
  (when (daemonp) (add-transient-hook! 'after-make-frame-functions 'nox-setup-appearance)))

(use-package window
  :config
  (defun +window-sensible-split (&optional window)
    (let* ((window (or window (selected-window)))
           (frame (window-frame window)))
      (and (not (window-minibuffer-p window))
           (catch 'done
             (walk-window-tree (lambda (w) (unless (or (eq w window) (window-dedicated-p w))
                                             (throw 'done nil)))
                               frame nil 'nomini)
             t)
           (or (and (not (eq window-size-fixed 'width))
                    (>= (window-width window) (max 150 (* 2 window-min-width) 4))
	                (with-selected-window window (split-window-right)))
	           (and (>= (window-height window) (* 2 (max window-min-height (if mode-line-format 2 1))))
                    (with-selected-window window (split-window-below)))))))
  (setq! split-window-preferred-function #'+window-sensible-split))
#+END_SRC

** Editor
*** Settings
#+BEGIN_SRC emacs-lisp
(setq! vc-follow-symlinks t
       save-interprogram-paste-before-kill t
       enable-recursive-minibuffers t
       mouse-yank-at-point t
       prettify-symbols-unprettify-at-point 'right-edge)

#+END_SRC

**** Whitespace, indentation & formatting
#+BEGIN_SRC emacs-lisp
(setq! tab-width 4
       indent-tabs-mode nil
       require-final-newline t
       sentence-end-double-space nil
       tab-always-indent t
       tabify-regexp "^\t* [ \t]+"
       fill-column 105
       comment-column 0
       word-wrap t
       truncate-lines t
       truncate-partial-width-windows 70)

(add-hook! 'before-save-hook #'delete-trailing-whitespace)
(add-hook! 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

**** Scrolling
#+BEGIN_SRC emacs-lisp
(setq! scroll-margin 1
       hscroll-margin 2
       hscroll-step 1
       scroll-conservatively 101
       scroll-preserve-screen-position t
       mouse-wheel-scroll-amount '(1)
       mouse-wheel-progressive-speed nil
       recenter-positions '(top middle bottom))
#+END_SRC

**** Limits
#+BEGIN_SRC emacs-lisp
(setq! kill-ring-max 5000
       undo-limit (* 20 1024 1024)
       undo-strong-limit (* 40 1024 1024)
       undo-outer-limit (* 100 1024 1024)
       mark-ring-max 5000
       global-mark-ring-max 5000)
#+END_SRC

**** Automatic revert
#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :after-call after-find-file
  :config
  (setq! auto-revert-verbose nil)
  (global-auto-revert-mode))
#+END_SRC

**** Recent files
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :demand
  :config
  (setq recentf-save-file (concat nox-cache-dir "recentf")
        recentf-auto-cleanup 120
        recentf-max-menu-items 0
        recentf-max-saved-items 10000
        recentf-filename-handlers '(file-truename)
        recentf-exclude
        (list #'file-remote-p "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\)$"
              "^/tmp/" "^/ssh:" "\\.?ido\\.last$" "\\.revive$" "/TAGS$"
              "^/var/folders/.+$"
              (lambda (file) (file-in-directory-p file nox-emacs-dir))))
  (advice-add 'recentf-cleanup :around 'nox*shut-up)

  (quiet! (recentf-mode)))
#+END_SRC

**** Bookmarks
#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :config
  (setq! bookmark-default-file (concat nox-etc-dir "bookmarks")
         bookmark-save-flag t))
#+END_SRC

*** Navigation
**** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy :elpaca t
  :general
  ("C-."   #'avy-goto-char-timer
   "M-g l" #'avy-goto-line
   "M-g w" #'avy-goto-word-1)
  :config
  (setq! avy-all-windows nil
         avy-background t
         avy-timeout-seconds .3))
#+END_SRC

**** xref and simple jump
#+begin_src emacs-lisp
(use-package xref
  :general (:prefix "M-g j"
                    "j" #'xref-find-definitions
                    "o" #'xref-find-definitions-other-window
                    "r" #'xref-find-references
                    "p" #'xref-find-apropos)
  :config (setq! xref-backend-functions '(simple-jump-xref-backend)))

(use-package simple-jump :autoload simple-jump-xref-backend)
#+end_src

**** Imenu
#+BEGIN_SRC emacs-lisp
(use-package imenu
  :general (nox-leader "i" #'+imenu)
  :config
  (setq! imenu-auto-rescan t
         imenu-auto-rescan-maxout 500000)
#+END_SRC

***** Imenu across several buffers
#+BEGIN_SRC emacs-lisp
(defconst +imenu-friendly-modes '((c-mode c++-mode))
  "List of lists which are groups of friend modes.")

(defvar-local +imenu-cache nil
  "Vector [TICK CACHED-VALUE].")

(defun +imenu-buffer-filter (current other)
  (let ((current-mode (buffer-local-value 'major-mode current))
        (other-mode   (buffer-local-value 'major-mode other)))
    (or (eq current-mode other-mode)
        (cl-some (lambda (friend-mode-list) (and (memq current-mode friend-mode-list)
                                                 (memq other-mode   friend-mode-list)))
                 +imenu-friendly-modes))))

(defun +imenu-get-candidates-from (alist &optional prefix)
  (cl-mapcan
   (lambda (element)
     (if (imenu--subalist-p element)
         (+imenu-get-candidates-from (cdr element) (concat prefix (if prefix " | ") (car element)))
       (let ((key (concat (and prefix (propertize (concat prefix  " | ") 'face 'compilation-info))
                          (car element))))
         (list (cons (replace-regexp-in-string "\n" " " key)
                     (cond ((integerp (cdr element)) (copy-marker (cdr element)))
                           ((overlayp (cdr element)) (copy-marker (overlay-start (cdr element))))
                           (t (cdr element))))))))
   alist))

(defun +imenu-buffer-candidates ()
  (setq imenu--index-alist nil)
  (imenu--make-index-alist t)
  (+imenu-get-candidates-from imenu--index-alist (buffer-name)))

(defun +imenu-candidates ()
  (let* (projectile-require-project-root
         (current-buffer (current-buffer))
         (buffers (cl-remove-if-not (lambda (buffer) (+imenu-buffer-filter current-buffer buffer))
                                    (+projectile-project-buffers))))
    (mapcan (lambda (buffer)
              (with-current-buffer buffer
                (let ((tick (buffer-modified-tick buffer)))
                  (unless (and +imenu-cache (= (aref +imenu-cache 0) tick))
                    (setq +imenu-cache (vector tick (+imenu-buffer-candidates))))
                  (copy-sequence (aref +imenu-cache 1)))))
            buffers)))

(defun +imenu-goto (_name marker &optional _rest)
  (cl-assert (markerp marker))
  (let ((buffer   (marker-buffer marker))
        (position (marker-position marker)))
    (switch-to-buffer buffer)
    (when (or (< position (point-min)) (> position (point-max))) (widen))
    (goto-char position)))

(defun +imenu ()
  "Jump to a buffer position indexed by imenu."
  (interactive)
  (let* ((items (+imenu-candidates))
         (imenu-default-goto-function #'+imenu-goto)
         (candidate (completing-read "Jump to... " items nil t nil nil (thing-at-point 'symbol)))
         (target (assoc-string candidate items)))
    (imenu target)
    (recenter)))
#+END_SRC

***** End
#+BEGIN_SRC emacs-lisp
) ;; (use-package imenu)
#+END_SRC

**** Line movement functions
#+BEGIN_SRC emacs-lisp
(defun nox/previous-blank-line ()
  "Move point to the previous blank line"
  (interactive)
  (move-end-of-line nil)
  (if (search-backward-regexp "^[\t ]*\n[\t ]*[^\t\n ]+" nil "NOERROR") nil
    (goto-char (point-min))))

(defun nox/next-blank-line ()
  "Move point to the next blank line"
  (interactive)
  (move-beginning-of-line nil)
  (if (not (search-forward-regexp "[^\t\n ]\n[\t ]*$" nil "NOERROR"))
      (goto-char (point-max))))

(defun nox/open-line-above ()
  "Insert an empty line above the current line.
Position the cursor at its beginning, according to the current mode."
  (interactive)
  (move-end-of-line 0)
  (newline-and-indent))

(defun nox/open-line-below ()
  "Insert an empty line below the current line.
Position the cursor at its beginning, according to the current mode."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))
#+END_SRC

*** Minibuffer completion
#+begin_src emacs-lisp
(use-package vertico :elpaca t
  :init (vertico-mode 1))

(use-package orderless :elpaca t
  :after vertico :demand
  :config
  (defun +orderless--is-partial-tramp (path)
    (string-match-p "\\`/[^/|:]+:[^:]*\\(?:|[^/|:]+:[^:]*\\)*$" (substitute-in-file-name path)))

  (defun basic-remote-try-completion (string table pred point)
    (and (+orderless--is-partial-tramp string)
         (completion-basic-try-completion string table pred point)))

  (defun basic-remote-all-completions (string table pred point)
    (and (+orderless--is-partial-tramp string)
         (completion-basic-all-completions string table pred point)))

  (add-to-list 'completion-styles-alist
               '(basic-partial-remote basic-remote-try-completion basic-remote-all-completions nil))

  (setq! completion-styles '(orderless basic)
         completion-category-overrides '((file (styles basic-partial-remote)))))

(use-package consult :elpaca t
  :demand
  :general
  (nox-leader "h" #'consult-history)
  (nox-leader "m" #'consult-mode-command)
  (nox-leader "k" #'consult-kmacro)

  ([remap repeat-complex-command]        #'consult-complex-command)
  ([remap switch-to-buffer]              #'consult-buffer)
  ([remap switch-to-buffer-other-window] #'consult-buffer-other-window)
  ([remap switch-to-buffer-other-frame]  #'consult-buffer-other-frame)
  ([remap bookmark-jump]                 #'consult-bookmark)
  ([remap project-switch-to-buffer]      #'consult-project-buffer)

  (  "M-#" #'consult-register-load)
  (  "M-'" #'consult-register-store)
  ("C-M-#" #'consult-register)

  ([remap yank-pop] #'consult-yank-pop)

  ("M-g e"   #'consult-compile-error)
  ("M-g g"   #'consult-goto-line)
  ("M-g M-g" #'consult-goto-line)
  ("M-g o"   #'consult-outline)
  ("M-g m"   #'consult-mark)
  ("M-g k"   #'consult-global-mark)
  ("M-g i"   #'consult-imenu)
  ("M-g I"   #'consult-imenu-multi)

  ("M-s d" #'consult-find)
  ("M-s D" #'consult-locate)
  ("M-s g" #'consult-grep)
  ("M-s G" #'consult-git-grep)
  ("M-s r" #'consult-ripgrep)
  ("M-s l" #'consult-line)
  ("M-s L" #'consult-line-multi)
  ("M-s m" #'consult-multi-occur)
  ("M-s k" #'consult-keep-lines)
  ("M-s u" #'consult-focus-lines)

  ("M-s e" #'consult-isearch-history)
  (:keymaps 'isearch-mode-map
            [remap isearch-edit-string] #'consult-isearch-history
            "M-s l"                     #'consult-line
            "M-s L"                     #'consult-line-multi)

  (:keymaps 'minibuffer-local-map
            [remap     next-matching-history-element] #'consult-history
            [remap previous-matching-history-element] #'consult-history)

  :init
  (setq! register-preview-delay 0
         register-preview-function #'consult-register-format)
  (advice-add #'register-preview :override #'consult-register-window)

  (setq! xref-show-xrefs-function #'consult-xref
         xref-show-definitions-function #'consult-xref)

  :config
  (setq! consult-narrow-key "<")

  (defface +consult-project '((t :inherit font-lock-constant-face))
    "Face used to highlight projects.")

  (setq! consult-ripgrep-command
         "rg --null --line-buffered --color=ansi --max-columns=1000 --no-heading --line-number --smart-case . -e ARG OPTS"
         consult-project-function nil)

  ;; NOTE(nox): De-prioritize buffers shown in this frame
  (defun consult--buffer-sort-visibility (buffers)
    (let ((hidden)
          (current (current-buffer)))
      (consult--keep! buffers
        (unless (eq it current)
          (if (get-buffer-window it)
              it
            (push it hidden)
            nil)))
      (nconc (nreverse hidden) buffers (list (current-buffer))))))

(use-package embark :elpaca t
  :demand
  :general
  ("C-h b" #'embark-bindings)
  (:keymaps 'minibuffer-local-map
            "C-;" #'embark-act)
  (:keymaps 'embark-general-map
            [remap embark-act] #'self-insert-command)

  :init
  (setq! prefix-help-command #'embark-prefix-help-command)

  :config
  (defun +embark--which-key-indicator ()
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (kill-buffer which-key--buffer)
        (which-key--show-keymap
         (if (eq (caar targets) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (caar targets)
                   (embark--truncate-target (cdar targets))
                   (if (cdr targets) "…" "")))
         (if prefix (lookup-key keymap prefix) keymap)
         nil nil t))))

  (setq! embark-indicators '(+embark--which-key-indicator
                             embark-highlight-indicator
                             embark-isearch-highlight-indicator)))
(use-package embark-consult :elpaca t
  :hook (embark-collect-mode . consult-preview-at-point-mode))

(use-package marginalia :elpaca t
  :demand
  :config
  (marginalia-mode))
#+end_src

*** Completion
#+begin_src emacs-lisp
(use-package company :elpaca t)
(use-package company-dabbrev
  :config
  (setq! company-dabbrev-downcase nil
         company-dabbrev-ignore-case nil
         company-dabbrev-ignore-invisible t
         company-dabbrev-code-other-buffers t)

  (defun +company-dabbrev-buffer-check (buffer)
    (with-current-buffer buffer
      (derived-mode-p 'pdf-view-mode 'doc-view-mode)))
  (setq! company-dabbrev-ignore-buffers #'+company-dabbrev-buffer-check))

(use-package corfu :elpaca t
  :init
  (global-corfu-mode)

  (add-hook! 'minibuffer-setup-hook
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (corfu-mode 1))))

(use-package cape :elpaca t
  :general ("<tab>" #'completion-at-point)
  :init
  (setq! +cape-dabbrev      (cape-company-to-capf #'company-dabbrev))
  (setq! +cape-dabbrev-code (cape-company-to-capf #'company-dabbrev-code))

  (setq! completion-at-point-functions `(cape-file ,+cape-dabbrev))
  (setq-hook! prog-mode completion-at-point-functions `(cape-file ,+cape-dabbrev-code)))
#+end_src

*** Project management
#+BEGIN_SRC emacs-lisp
(use-package projectile :elpaca t
  :demand
  :general
  (:keymaps 'projectile-mode-map "C-c p" '(:keymap +projectile-map :wk "Projectile"))
  (:keymaps '+projectile-map
            "SPC" #'+projectile
            "o"   #'+projectile/find-other-file
            "p"   #'+projectile/switch-project
            "s g" #'+projectile/git-grep
            "s s" #'+projectile/ripgrep
            "v"   #'projectile-vc
            "V"   #'projectile-browse-dirty-projects)
  :init
  (defvar +projectile-map (make-sparse-keymap))

  :config
  (setq! projectile-completion-system 'default
         projectile-cache-file (concat nox-cache-dir "projectile.cache")
         projectile-known-projects-file (concat nox-cache-dir "projectile.projects")
         projectile-dynamic-mode-line nil
         projectile-globally-ignored-file-suffixes '(".elc" ".pyc" ".o")
         projectile-globally-ignored-files '(".DS_Store" "TAGS")
         projectile-other-file-alist (append projectile-other-file-alist
                                             '(("css"  "scss" "sass" "less" "styl")
                                               ("scss" "css")
                                               ("sass" "css")
                                               ("less" "css")
                                               ("styl" "css"))))
  (push ".project" projectile-project-root-files-bottom-up)

  (defvar +projectile-root nil) ;; NOTE(nox): To be let-bound
  (defun +projectile*root-override (orig &rest args) (or +projectile-root (apply orig args)))
  (advice-add #'projectile-project-root :around #'+projectile*root-override)

  (defun +projectile-ignored-project-p (path)
    (string-prefix-p nox-emacs-dir path))
  (setq! projectile-ignored-project-function #'+projectile-ignored-project-p)

  (defun +projectile-project-buffers ()
    (let* ((project-root (file-truename (projectile-ensure-project (projectile-project-root))))
           (all-buffers (cl-remove-if-not
                         (lambda (buffer) (projectile-project-buffer-p buffer project-root))
                         (buffer-list))))
      (if projectile-buffers-filter-function
          (funcall projectile-buffers-filter-function all-buffers)
        all-buffers)))

  (projectile-mode)

  ;; NOTE(nox): Consult integration
  (defun +projectile/git-grep (&optional root)
    (interactive)
    (when-let (root (or root (projectile-project-root) (+projectile--switch-project)))
      (consult-git-grep root)))

  (defun +projectile/ripgrep (&optional root)
    (interactive)
    (when-let (root (or root (projectile-project-root) (+projectile--switch-project)))
      (consult-ripgrep root)))

  (defvar +projectile--project-history nil)

  (defun +projectile--switch-project ()
    (let ((root (projectile-project-root)))
      (consult--read projectile-known-projects
                     :prompt (projectile-prepend-project-name "Switch to project: ")
                     :require-match t
                     :default (and (projectile-project-p)
                                   (not (projectile-ignored-project-p root))
                                   (abbreviate-file-name root))
                     :category 'project)))

  (defun +projectile--get-project-buffers (root)
    (setq root (expand-file-name root))
    (mapcar #'buffer-name
            (cl-remove-if-not
             (lambda (buffer) (projectile-project-buffer-p buffer root))
             (buffer-list))))

  (defun +projectile--get-project-files (root)
    (when root
      (let ((files (projectile-project-files root))
            (inv-root (propertize root 'invisible t)))
        (mapcar (lambda (f) (concat inv-root f)) files))))

  (defun +projectile--get-relevant-projects (root)
    (cl-remove (abbreviate-file-name root)
               projectile-known-projects
               :test #'string-equal))

  (defun +projectile--annotate-project-item (root)
    (format "Project: %s [%s]" (projectile-project-name root) (projectile-project-vcs root)))

  (defun +projectile--sources (root)
    (when root
      (list
       (list :name     "Buffer"
             :narrow   '(?b . "Buffer")
             :category 'buffer
             :face     'consult-buffer
             :history  'buffer-name-history
             :state    #'consult--buffer-state
             :items    (+projectile--get-project-buffers root))

       (list :name     "File"
             :narrow   '(?f . "File")
             :category 'file
             :face     'consult-file
             :history  'file-name-history
             :action   #'consult--file-action
             :items    (+projectile--get-project-files root))

       (list :name     "Known project"
             :narrow   '(?p . "Project")
             :category 'project
             :face     '+consult-project
             :history  '+projectile--project-history
             :annotate #'+projectile--annotate-project-item
             :action   #'+projectile
             :items    (+projectile--get-relevant-projects root)))))

  (defun +projectile/find-other-file ()
    (interactive)
    (if-let (root (projectile-project-root))
        (projectile-find-other-file)
      (ff-find-other-file)))

  (defun +projectile/switch-project ()
    (interactive)
    (+projectile (+projectile--switch-project)))

  (defun +projectile (&optional root)
    (interactive)
    (when-let (root (or root (projectile-project-root) (+projectile--switch-project)))
      (consult--multi (+projectile--sources root)
                      :prompt "Switch to: "
                      :history 'projectile--project-history
                      :require-match t
                      :sort nil)))

  ;; NOTE(nox): Embark integration
  (defun +projectile--vc-by-name (root)
    (interactive "sProject root: ")
    (projectile-vc root))

  (defun +projectile--git-grep-by-name (root)
    (interactive "sProject root: ")
    (+projectile/git-grep root))

  (defun +projectile--ripgrep-by-name (root)
    (interactive "sProject root: ")
    (+projectile/ripgrep root))

  (defun +projectile--remove-known-project (root)
    (interactive "sProject root: ")
    (projectile-remove-known-project root))

  (defvar-keymap embark-project-map
    "s g" #'+projectile--git-grep-by-name
    "s s" #'+projectile--ripgrep-by-name
    "v"   #'+projectile--vc-by-name
    "C-k" #'+projectile--remove-known-project)
  (add-to-list 'embark-keymap-alist '(project . embark-project-map)))
#+END_SRC

*** Electric
#+BEGIN_SRC emacs-lisp
(use-package electric
  :init (electric-indent-mode)
  :config (setq! electric-indent-inhibit t))

(use-package elec-pair
  :init
  (electric-pair-mode))
#+END_SRC

*** Selection
**** Expand region
#+BEGIN_SRC emacs-lisp
(use-package expand-region :elpaca t
  :general ("C-=" 'er/expand-region))
#+END_SRC

**** Multiple cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors :elpaca t
  :general
  ("C-c l" 'mc/edit-lines
   "C-M-»" 'mc/mark-all-like-this
   "M-»"   'mc/mark-next-like-this
   "M-”"   'mc/skip-to-next-like-this
   "M-«"   'mc/mark-previous-like-this
   "M-“"   'mc/skip-to-previous-like-this
   "M-<mouse-1>" 'mc/add-cursor-on-click)

  :init
  (setq! mc/list-file (concat nox-etc-dir "mc-lists.el")))
#+END_SRC

*** Number incrementation and decrementation functions
From [[https://www.emacswiki.org/emacs/IncrementNumber][EmacsWiki]].

#+BEGIN_SRC emacs-lisp
(defun nox/increment-number-decimal (&optional arg)
  "Increment the number forward from point by 'arg'."
  (interactive "p*")
  (save-excursion
    (save-match-data
      (let (inc-by field-width answer)
        (setq inc-by (if arg arg 1))
        (skip-chars-backward "0123456789")
        (when (re-search-forward "[0-9]+" nil t)
          (setq field-width (- (match-end 0) (match-beginning 0)))
          (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
          (when (< answer 0)
            (setq answer (+ (expt 10 field-width) answer)))
          (replace-match (format (concat "%0" (int-to-string field-width) "d")
                                 answer)))))))
#+END_SRC

*** Large file verification
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 100 1024 1024))

(defvar nox-large-file-size 10
  "Size (in MB) above which the user will be prompted to open the file literally
to avoid performance issues. Opening literally means that no major or minor
modes are active and the buffer is read-only.")

(defvar nox-large-file-modes-list
  '(fundamental-mode special-mode archive-mode tar-mode jka-compr
    git-commit-mode image-mode doc-view-mode doc-view-mode-maybe
    ebrowse-tree-mode pdf-view-mode)
  "Major modes that `nox|check-large-file' will ignore.")

(defun nox|check-large-file ()
  "Check if the buffer's file is large (see `nox-large-file-size'). If so, ask
for confirmation to open it literally (read-only, disabled undo and in
fundamental-mode) for performance sake."
  (when (and (not (memq major-mode nox-large-file-modes-list))
             auto-mode-alist
             (get-buffer-window))
    (when-let* ((size (nth 7 (file-attributes buffer-file-name))))
      (when (and (> size (* 1024 1024 nox-large-file-size))
                 (y-or-n-p
                  (format (concat "%s is a large file, open literally to "
                                  "avoid performance issues?")
                          (file-relative-name buffer-file-name))))
        (setq buffer-read-only t)
        (buffer-disable-undo)
        (fundamental-mode)))))
(add-hook 'find-file-hook #'nox|check-large-file)
#+END_SRC

*** Search and replace
**** wgrep
#+begin_src emacs-lisp
(use-package wgrep :elpaca t
  :general
  (:keymaps 'grep-mode-map
            "C-x C-q" #'wgrep-change-to-wgrep-mode))
#+end_src

*** Tree-sitter
#+begin_src emacs-lisp
(use-package treesit
  :config
  (setq! treesit-language-source-alist
         '((bash       . ("https://github.com/tree-sitter/tree-sitter-bash"))
           (c          . ("https://github.com/tree-sitter/tree-sitter-c"))
           (cmake      . ("https://github.com/uyha/tree-sitter-cmake"))
           (cpp        . ("https://github.com/tree-sitter/tree-sitter-cpp"))
           (dockerfile . ("https://github.com/camdencheek/tree-sitter-dockerfile"))
           (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript"))
           (json       . ("https://github.com/tree-sitter/tree-sitter-json"))
           (python     . ("https://github.com/tree-sitter/tree-sitter-python"))))

  (defun +treesit/install-all-language-grammars ()
    (interactive)
    (mapc #'treesit-install-language-grammar (mapcar #'car treesit-language-source-alist)))

  ;; ====================================================================================================
  ;; Matchers
  (add-to-list 'treesit-simple-indent-presets
               (cons 'n-or-p-is ; NOTE(nox): Checks parent if node is nil
                     (lambda (type)
                       (lambda (node parent &rest _)
                         (string-match-p type (or (treesit-node-type (or node parent)) ""))))))

  (add-to-list 'treesit-simple-indent-presets
               (cons 'any-parent-is
                     (lambda (type)
                       (lambda (_n parent &rest _)
                         (cl-loop for p = parent then (treesit-node-parent p) while p
                                  for ptype = (treesit-node-type p)
                                  if (string-match-p type ptype) return t)))))

  (add-to-list 'treesit-simple-indent-presets
               (cons 'is-named-child ;; NOTE(nox): Like field-is but allows specifying parent type
                     (lambda (name &optional parent-type)
                       (lambda (node parent &rest _)
                         (and (or (null parent-type) (string-match-p parent-type (treesit-node-type parent)))
                              (string-match-p name (or (treesit-node-field-name node) "")))))))

  ;; ====================================================================================================
  ;; Anchors
  (add-to-list 'treesit-simple-indent-presets
               (cons 'standalone-parent-or-uncle
                     (lambda (_n parent &rest _)
                       (save-excursion
                         (cl-loop for p-or-u = parent then (or (treesit-node-prev-sibling p-or-u)
                                                               (treesit-node-parent       p-or-u))
                                  while p-or-u
                                  for np = (goto-char (treesit-node-start p-or-u))
                                  if (looking-back (rx bol (* whitespace)) (line-beginning-position)) return np)))))

  (add-to-list 'treesit-simple-indent-presets
               (cons 'any-parent-nth-child ; NOTE(nox): To be used with any-parent-is
                     (lambda (type &optional child-idx)
                       (lambda (_n parent &rest _)
                         (cl-loop for p = parent then (treesit-node-parent p) while p
                                  for ptype = (treesit-node-type p)
                                  if (string-match-p type ptype)
                                  return (treesit-node-start (treesit-node-child parent (or child-idx 0)))))))))
#+end_src

** Languages
*** Assembly
#+begin_src emacs-lisp
(use-package asm-mode
  :config
  (defun asm-calculate-indentation ()
    (or
     (and (looking-at "[@_[:word:]]+:") 0)
     (and (looking-at "[.%]") 0)
     (and (looking-at "\\s<\\s<\\s<") 0)
     (and (looking-at "c?global\\|section\\|default\\|align\\|INIT_..X") 0)
     4))

  (add-hook! 'asm-mode-hook (local-unset-key (vector asm-comment-char))))
#+end_src
*** (Ba)sh
#+begin_src emacs-lisp
(use-package sh-script
  :init (add-to-list 'major-mode-remap-alist '(sh-mode . bash-ts-mode))
  :config
  (after! simple-jump
    (let ((family (make-simple-jump-family :regexes '("function\\L+JJJ\\b" "\\bJJJ(\\L*\\(|=[^=])"))))
      (setf (alist-get 'sh-mode      simple-jump-family-alist) family)
      (setf (alist-get 'bash-ts-mode simple-jump-family-alist) family))))
#+end_src

*** C/C++
#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :mode (("\\.\\(c\\|h\\)\\(\\.inl\\)?\\'" . c-mode)
         ("\\.\\(c\\|h\\)pp\\(\\.inl\\)?\\'" . c++-mode))
  :config
  (add-hook! (c-mode c++-mode) (setq-local comment-start "// " comment-end ""))

  (defun +cc-anchor-indentation (info)
    (save-excursion
      (goto-char (cdr info)) ;; NOTE(nox): Anchor
      (back-to-indentation)
      (vector (current-column))))

  (defun +cc-style-stmt-case-intro (info)
    (save-excursion
      (goto-char (cdr info)) ;; NOTE(nox): Anchor
      (and (search-forward ":" (line-end-position) t) (not (looking-at "[[:space:]]*$")) 0)))

  (defun +cc-arglist-close (info)
    (and (save-excursion (skip-chars-backward " \t\n" (cdr info)) (eq ?, (char-before)))
         (c-lineup-arglist info)))

  (defun +cc-anchor-column (info) (save-excursion (goto-char (cdr info)) (vector (current-column))))

  (setq! c-default-style "weirdNox")
  (c-add-style c-default-style
               '((c-basic-offset . 4)
                 (c-offsets-alist . ((case-label . +)
                                     (innamespace . [0])
                                     (inextern-lang . 0)
                                     (substatement-open . +cc-anchor-indentation)
                                     (statement-block-intro . (add +cc-anchor-indentation +))
                                     (statement-cont . (c-lineup-ternary-bodies +))
                                     (statement-case-intro . (+cc-style-stmt-case-intro +))
                                     (arglist-cont-nonempty . (c-lineup-gcc-asm-reg c-lineup-ternary-bodies
                                                               c-lineup-arglist))
                                     (arglist-close . (+cc-arglist-close 0))
                                     (brace-list-entry . +cc-anchor-column)
                                     ;; Help with aligning macro false positives
                                     (topmost-intro-cont . 0)
                                     (knr-argdecl-intro . 0))))))

(use-package c-ts-mode
  :config
  (setq! c-ts-mode-indent-offset 4)

  (defvar +c-ts-mode--column-offset 0) ;; NOTE(nox): Set by the anchor functions

  (defsubst +c-ts-mode--skip-preproc (in-node)
    (cl-loop for node = in-node then (treesit-node-parent node)
             for type =              (treesit-node-type   node)
             while (and node (string-match-p "preproc\\|\n" type))
             finally return node))

  ;; NOTE(nox): Same as parent-is, but skips preproc
  (defun +c-ts-mode--parent-is (type)
    `(lambda (_n parent &rest _)
       (setq parent (+c-ts-mode--skip-preproc parent))
       (and parent (string-match-p ,type (treesit-node-type parent)))))

  ;; NOTE(nox): Same as standalone-parent-or-uncle, but skips preproc
  (defun +c-ts-mode--standalone-parent-or-uncle (_n parent &rest _)
    (save-excursion
      (cl-loop for p-or-u = parent then (or (treesit-node-prev-sibling p-or-u)
                                            (treesit-node-parent       p-or-u))
               while (setq p-or-u (+c-ts-mode--skip-preproc p-or-u))
               if (and (goto-char (treesit-node-start p-or-u))
                       (looking-back (rx bol (* whitespace)) (line-beginning-position)))
               return (point))))

  (defun +c-ts-mode--parenthesized-indent (search-for)
    `(lambda (child parent &rest _)
       (cl-loop with is-empty = (member (treesit-node-type (treesit-node-child parent 1)) '(")" "}" "]"))
                for is-first = (or is-empty (= (treesit-node-index child) 1)) then nil
                for p = parent then (treesit-node-parent p)
                until (string= ,search-for (treesit-node-type p))
                finally return
                (cond (is-first
                       (setq +c-ts-mode--column-offset c-ts-mode-indent-offset)
                       (save-excursion (goto-char (treesit-node-start (treesit-node-child p 0)))
                                       (back-to-indentation) (point)))
                      (t (setq +c-ts-mode--column-offset 0)
                         (treesit-node-start (treesit-node-child p 1)))))))

  (defun +c-ts-mode--indent-style ()
    `(((n-or-p-is "preproc_arg") no-indent)
      ((+c-ts-mode--parent-is "translation_unit") column-0 0)
      ((node-is ")") +c-ts-mode--standalone-parent-or-uncle 0)
      ((node-is "}") +c-ts-mode--standalone-parent-or-uncle 0)
      ((node-is "]") +c-ts-mode--standalone-parent-or-uncle 0)
      ((node-is "else") parent-bol 0)
      ((node-is "case") parent-bol c-ts-mode-indent-offset)

      ;; Block comment handling
      ((and (parent-is "comment") c-ts-common-looking-at-star) c-ts-common-comment-start-after-first-star -1)
      (c-ts-common-comment-2nd-line-matcher c-ts-common-comment-2nd-line-anchor 1)
      ((parent-is "comment") prev-adaptive-prefix 0)

      ;; Labels
      ((node-is "labeled_statement") standalone-parent 0)
      ((+c-ts-mode--parent-is "labeled_statement") c-ts-mode--standalone-grandparent c-ts-mode-indent-offset)

      ;; Preproc
      ((node-is "preproc") column-0 0)
      ((node-is "#endif") column-0 0)

      ((+c-ts-mode--parent-is "function_definition") parent-bol 0)
      ((n-p-gp ":" "conditional_expression" nil) (nth-sibling 1) 0)
      ((+c-ts-mode--parent-is "conditional_expression") first-sibling 0)
      ((+c-ts-mode--parent-is "assignment_expression") parent-bol c-ts-mode-indent-offset)
      ((+c-ts-mode--parent-is "concatenated_string") first-sibling 0)
      ((+c-ts-mode--parent-is "comma_expression") first-sibling 0)
      ((+c-ts-mode--parent-is "init_declarator") parent-bol c-ts-mode-indent-offset)
      ((any-parent-is "parenthesized_expression") (+c-ts-mode--parenthesized-indent "parenthesized_expression") +c-ts-mode--column-offset)
      ((+c-ts-mode--parent-is "argument_list")    (+c-ts-mode--parenthesized-indent "argument_list")            +c-ts-mode--column-offset)
      ((+c-ts-mode--parent-is "parameter_list")   (+c-ts-mode--parenthesized-indent "parameter_list")           +c-ts-mode--column-offset)
      ((+c-ts-mode--parent-is "binary_expression") parent 0)
      ((+c-ts-mode--parent-is "call_expression") parent 0)
      ((node-is "access_specifier") parent-bol 0)
      ;; Indent the body of namespace definitions.
      ((+c-ts-mode--parent-is "declaration_list") parent-bol c-ts-mode-indent-offset)

      ;; int[5] a = { 0, 0, 0, 0 };
      ((any-parent-is "initializer_list") (+c-ts-mode--parenthesized-indent "initializer_list") +c-ts-mode--column-offset)
      ;; Statement in enum.
      ((match nil "enumerator_list" nil 1 1) standalone-parent c-ts-mode-indent-offset)
      ((+c-ts-mode--parent-is "enumerator_list") c-ts-mode--anchor-prev-sibling 0)
      ;; Statement in struct and union.
      ((match nil "field_declaration_list" nil 1 1) standalone-parent c-ts-mode-indent-offset)
      ((+c-ts-mode--parent-is "field_declaration_list") c-ts-mode--anchor-prev-sibling 0)

      ;; Statement in {} blocks.
      ((+c-ts-mode--parent-is "compound_statement") +c-ts-mode--standalone-parent-or-uncle c-ts-mode-indent-offset)
      ;; Opening bracket.
      ((node-is "compound_statement") parent-bol 0)
      ;; Bug#61291.
      ((match "expression_statement" nil "body") standalone-parent c-ts-mode-indent-offset)
      ;; These rules are for cases where the body is bracketless.
      ;; Tested by the "Bracketless Simple Statement" test.
      ((+c-ts-mode--parent-is "if_statement") standalone-parent c-ts-mode-indent-offset)
      ((+c-ts-mode--parent-is "for_statement") standalone-parent c-ts-mode-indent-offset)
      ((+c-ts-mode--parent-is "while_statement") standalone-parent c-ts-mode-indent-offset)
      ((+c-ts-mode--parent-is "do_statement") standalone-parent c-ts-mode-indent-offset)

      ((+c-ts-mode--parent-is "for_statement") (nth-sibling 1) 1)
      ((+c-ts-mode--parent-is "case_statement") standalone-parent c-ts-mode-indent-offset)

      ((node-is "field_initializer_list") parent-bol ,(* c-ts-mode-indent-offset 2))))
  (setq! c-ts-mode-indent-style #'+c-ts-mode--indent-style))

(after! simple-jump
  (let ((family (make-simple-jump-family
                 :regexes '("\\bJJJ\\s*(\\((?>[^()]+|(?-1))*\\))(?:\\s|\\/\\/(?-s:.*)|\\/\\*(?s:.)*?\\*\\/)*+\\{"
                            "(struct|union|class)\\b.+\\bJJJ\\s*\\{"
                            "\\btypedef\\b(?:(?!JJJ\\s*;)[^;{]|(\\{(?>[^{}]+|(?-1))*\\}))++\\bJJJ\\s*;"
                            "^\\L*#\\L*define\\L+JJJ\\b"))))
    (setf (alist-get 'c-mode      simple-jump-family-alist) family)
    (setf (alist-get 'c++-mode    simple-jump-family-alist) family)
    (setf (alist-get 'c-ts-mode   simple-jump-family-alist) family)
    (setf (alist-get 'c++-ts-mode simple-jump-family-alist) family)))
#+END_SRC

*** Dockerfile & Containerfile
#+begin_src emacs-lisp
(use-package dockerfile-ts-mode
  :mode (("\\(?:Dockerfile\\(?:\\..*\\)?\\|\\.[Dd]ockerfile\\)\\'"       . dockerfile-ts-mode)
         ("\\(?:Containerfile\\(?:\\..*\\)?\\|\\.[Cc]ontainerfile\\)\\'" . dockerfile-ts-mode)))
#+end_src

*** GLSL
#+begin_src emacs-lisp
(use-package glsl-mode :elpaca t)
#+end_src

*** Go
#+BEGIN_SRC emacs-lisp
(use-package go-mode :elpaca t
  :config
  (setq! gofmt-command "goimports")
  (add-hook! go-mode (add-hook! :local 'before-save-hook 'gofmt-before-save)))
#+END_SRC

*** Jai
#+begin_src emacs-lisp
(use-package jai-mode :elpaca (jai-mode :host github :repo "weirdNox/jai-mode"
                                        :files ("*.el"))
  :config
  (after! simple-jump
    (let ((family (make-simple-jump-family :regexes '("\\bJJJ\\s*::"))))
      (setf (alist-get 'jai-mode simple-jump-family-alist) family))))
#+end_src

*** Javascript (& JSON)
#+begin_src emacs-lisp
(use-package js
  :init (add-to-list 'major-mode-remap-alist '(js-mode . js-ts-mode)))

(use-package json-ts-mode
  :init (add-to-list 'major-mode-remap-alist '(js-json-mode . json-ts-mode))
  :config (setq! json-ts-mode-indent-offset 4))
#+end_src

*** LaTeX
#+BEGIN_SRC emacs-lisp
(use-package latex :elpaca (auctex :pre-build (("./autogen.sh")
                                               ("./configure" "--without-texmf-dir" "--with-lispdir=.")
                                               ("make"))
                                   :build (:not elpaca--compile-info)
                                   :files ("*.el" "doc/*.info*" "etc" "images" "latex" "style")
                                   :version (lambda (_) (require 'tex-site) AUCTeX-version))
  :commands +tex*set-auto-location
  :config
  (setq! TeX-auto-save t
         TeX-parse-self t
         TeX-engine 'luatex
         TeX-default-mode 'latex-mode
         TeX-force-default-mode t
         TeX-source-correlate-start-server t
         TeX-view-program-selection '((output-pdf "PDF Tools"))
         TeX-auto-local (file-truename "~/.cache/emacs/latexauto/fallback"))

  (TeX-global-PDF-mode 1)
  (TeX-source-correlate-mode 1)
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)

  (defun +tex*set-auto-location (&rest _)
    (let ((hash (sha1 (file-truename (TeX-master-directory)))))
      (setq-local TeX-auto-local (expand-file-name hash
                                                   (file-name-directory (default-value 'TeX-auto-local)))
                  TeX-style-local TeX-auto-local)))
  (advice-add #'TeX-tex-mode :after #'+tex*set-auto-location)
  (make-directory TeX-auto-local t))
#+END_SRC

*** Ledger
#+begin_src emacs-lisp
(use-package ledger-mode :elpaca t)
#+end_src

*** Lua
#+begin_src emacs-lisp
(use-package lua-mode :elpaca t
  :config (setq! lua-indent-level 4))
#+end_src

*** Linker scripts (ld)
#+begin_src emacs-lisp
(use-package ld-mode
  :autoload ld-mode
  :init (add-to-list 'major-mode-remap-alist '(ld-script-mode . ld-mode)))
#+end_src

*** (Emacs) Lisp
#+begin_src emacs-lisp
(use-package lisp-mode
  :config
  (after! simple-jump
    (let ((family (make-simple-jump-family :regexes '("\\((cl-)?def(fun|macro|var|custom)\\s+JJJ\\j"))))
      (setf (alist-get 'lisp-mode       simple-jump-family-alist) family)
      (setf (alist-get 'emacs-lisp-mode simple-jump-family-alist) family))))
#+end_src

*** Markdown
#+begin_src emacs-lisp
(use-package markdown-mode :elpaca t)
#+end_src

*** MATLAB & Octave
#+BEGIN_SRC emacs-lisp
(use-package octave
  :mode (("\\.m\\'" . octave-mode))
  :config
  (setq! inferior-octave-startup-args '("-i" "--line-editing")
         inferior-octave-prompt-read-only t
         inferior-octave-prompt "^octave\\(octave\\|[ >]\\)*"
         octave-comment-char ?%
         octave-comment-start (char-to-string octave-comment-char)
         octave-block-comment-start (concat (char-to-string octave-comment-char) " ")
         octave-block-offset 4)

  (add-hook! octave-mode (setq-local comment-add 0))
  (defun octave-indent-comment () nil))

(use-package matlab :elpaca matlab-mode
  :init   (setq! magic-mode-alist (assq-delete-all 'matlab-is-matlab-file magic-mode-alist))
  :config (setq! magic-mode-alist (assq-delete-all 'matlab-is-matlab-file magic-mode-alist)))

(use-package matlab-shell
  :config
  (setq! matlab-shell-command-switches '("-nodesktop" "-nosplash")
         matlab-shell-history-file "~/.matlab/%s/nox-history.m"
         matlab-shell-input-ring-size 1000000)

  (defun matlab-shell-first-prompt-fcn ())

  ;; NOTE(nox): Write history correctly
  (defun +matlab-write-history ()
    (let ((reporter (make-progress-reporter "Writing MATLAB history... ")))
      (comint-write-input-ring)
      (progress-reporter-done reporter)))

  (defun +matlab-shell|sentinel (process event)
    (when (not (process-live-p process)) (+matlab-write-history)))

  (defvar +matlab-shell--process nil)
  (defun +matlab-shell|kill-emacs-hook ()
    (when (and (processp +matlab-shell--process) (process-live-p +matlab-shell--process))
      (with-current-buffer (process-buffer +matlab-shell--process) (+matlab-write-history))))

  (defun +matlab-shell*set-hooks ()
    (let ((process (get-buffer-process (current-buffer))))
      (setq +matlab-shell--process process)
      (add-hook! 'kill-emacs-hook #'+matlab-shell|kill-emacs-hook)
      (set-process-sentinel process #'+matlab-shell|sentinel)))

  (advice-add 'matlab-shell :after #'+matlab-shell*set-hooks))
#+END_SRC

*** MIPS
#+BEGIN_SRC emacs-lisp
(use-package mips-mode
  :config
  (setq! mips-operator-column    (* tab-width 2)
         mips-operands-column (+ (* tab-width 2) mips-operator-column)
         mips-comments-column 40))
#+END_SRC

*** Python
#+begin_src emacs-lisp
(use-package python
  :init (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
  :config
  (when (executable-find "ipython")
    (setq! python-shell-interpreter "ipython"
           python-shell-interpreter-args "--simple-prompt --no-banner"))

  (add-hook! python-ts-mode (setq forward-sexp-function nil))

  (defun python-indent-dedent-line-backspace (arg)
    (interactive "*p")
    (cond
     ((and (use-region-p) delete-active-region) (delete-backward-char 1))
     ((python-indent-dedent-line))
     (t (backward-delete-char-untabify arg))))

  (after! simple-jump
    (let ((family (make-simple-jump-family :regexes '("(^|[,;])\\L*JJJ\\L*(:[\\L\\w\\[\\]|,]+)?=[^=\\n]"
                                                      "(def|class)\\L+JJJ\\L*[(:]"))))
      (setf (alist-get 'python-ts-mode simple-jump-family-alist) family))))
#+end_src

*** SPICE
#+begin_src emacs-lisp
(use-package spice-mode
  :mode (("\\.sp\\'"  . spice-mode)
         ("\\.cir\\'" . spice-mode)
         ("\\.cdl\\'" . spice-mode)
         ("\\.chi\\'" . spice-mode)
         ("\\.mod\\'" . spice-mode)
         ("\\.scs\\'" . spice-mode))
  :config
  (set-face-attribute 'spice-title-face nil :background nil))
#+end_src

*** Verilog & VHDL
#+begin_src emacs-lisp
(use-package verilog-mode
  :config
  (setq! verilog-auto-endcomments nil
         verilog-auto-lineup nil
         verilog-auto-newline nil
         verilog-indent-begin-after-if nil)

  ;; NOTE(nox): Prevent cluttering compilation regexp alist
  (remove-hook 'compilation-mode-hook #'verilog-error-regexp-add-emacs))

(use-package vhdl-mode
  :config
  ;; NOTE(nox): Prevent cluttering compilation regexp alist
  (remove-hook 'compilation-mode-hook #'vhdl-error-regexp-add-emacs))
#+end_src

*** Web
#+BEGIN_SRC emacs-lisp
(use-package web-mode :elpaca t
  :mode (("\\.\\(go\\)?html?\\'" . web-mode)))
#+END_SRC

** Org Mode
*** Base configuration
#+BEGIN_SRC emacs-lisp
(use-package org :elpaca t
  :general
  (nox-leader :infix "o"
    ""  '(:ignore t :wk "Org")
    "l" '(org-store-link :wk "Store link"))

  :init
  (setq! org-directory "~/essential/agenda/")

  :config
  (setq! org-modules '(org-habit org-id org-timer))
#+END_SRC

**** Directories and files
#+BEGIN_SRC emacs-lisp
(defconst nox-org-agenda-file  (concat org-directory "agenda.org"))
(defconst nox-org-tickler-file (concat org-directory "tickler.org"))
(defconst nox-org-tracker-file (concat org-directory "tracker.org"))
(defconst nox-org-journal-file (concat org-directory "journal.org"))
(defconst nox-org-someday-file (concat org-directory "someday.org"))
(setq! org-default-notes-file  (concat org-directory "inbox.org")
       org-agenda-files
       (list org-default-notes-file nox-org-agenda-file nox-org-tickler-file nox-org-tracker-file))
#+END_SRC

**** Helper functions
***** Projects and subtasks identification
#+BEGIN_SRC emacs-lisp
(defun nox-org-has-subtasks-p ()
  "Any heading with subtasks."
  (org-with-wide-buffer
   (let ((subtree-end (save-excursion (org-end-of-subtree t)))
         has-subtasks)
     (end-of-line)
     (while (and (not has-subtasks) (re-search-forward org-todo-line-regexp subtree-end t))
       (when (member (match-string 2) org-todo-keywords-1) (setq has-subtasks t)))
     has-subtasks)))

(defun +org-project-p ()
  "Any task that has subtasks."
  (and (org-get-todo-state) (nox-org-has-subtasks-p)))

(defun +org-is-subtask ()
  "Return t if this task is a subtask."
  (let (return)
    (org-with-wide-buffer
     (org-back-to-heading 'invisible-ok)
     (while (and (not return) (org-up-heading-safe))
       (when (org-get-todo-state) (setq return t))))
    return))
#+END_SRC

***** Tags
#+BEGIN_SRC emacs-lisp
(defun nox|org-offer-all-agenda-tags ()
  (setq-local org-complete-tags-always-offer-all-agenda-tags t))
#+END_SRC

**** Appearance
#+BEGIN_SRC emacs-lisp
(setq! org-startup-indented t
       org-hide-leading-stars t
       org-startup-folded t
       org-startup-with-inline-images nil
       org-startup-with-latex-preview t
       org-pretty-entities t
       org-image-actual-width '(700)
       org-fontify-done-headline t
       org-fontify-whole-heading-line t
       org-fontify-quote-and-verse-blocks t
       org-agenda-deadline-faces '((1.001 . error)
                                   (1.0 . org-warning)
                                   (0.5 . org-upcoming-deadline)
                                   (0.0 . org-upcoming-distant-deadline)))

(add-hook! org-mode #'org-hide-block-all)
#+END_SRC

The next part was taken from DOOM themes
#+begin_src emacs-lisp
(defsubst +org-tag-face (n)
  (let ((kwd (match-string n)))
    (or (and (equal kwd "#") 'org-tag)
        (and (equal kwd "@") 'org-formula))))

(defun +org|custom-fontification ()
  "Correct (and improve) org-mode's font-lock keywords.

  1. Re-set `org-todo' & `org-headline-done' faces, to make them respect
     (inherit) underlying faces.
  2. Make statistic cookies respect (inherit) underlying faces.
  3. Fontify item bullets (make them stand out)
  4. Fontify item checkboxes (and when they're marked done), like TODOs that are
     marked done.
  5. Fontify dividers/separators (5+ dashes)
  6. Fontify #hashtags and @at-tags"
  (let ((org-todo (format org-heading-keyword-regexp-format
                          org-todo-regexp))
        (org-done (format org-heading-keyword-regexp-format
                          (concat "\\(?:" (mapconcat #'regexp-quote org-done-keywords "\\|") "\\)"))))
    (setq
     org-font-lock-extra-keywords
     (append (org-delete-all
              (append `(("\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                         (0 (org-get-checkbox-statistics-face) t))
                        (,org-todo (2 (org-get-todo-face 2) t))
                        (,org-done (2 'org-headline-done t)))
                      (when (memq 'date org-activate-links)
                        '((org-activate-dates (0 'org-date t)))))
              org-font-lock-extra-keywords)
             ;; respsect underlying faces!
             `((,org-todo (2 (org-get-todo-face 2) prepend))
               (,org-done (2 'org-headline-done prepend)))
             (when (memq 'date org-activate-links)
               '((org-activate-dates (0 'org-date prepend))))
             ;; Make checkbox statistic cookies respect underlying faces
             '(("\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                (0 (org-get-checkbox-statistics-face) prepend))
               ;; I like how org-mode fontifies checked TODOs and want this to extend to
               ;; checked checkbox items:
               ("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)"
                1 'org-headline-done prepend)
               ;; make plain list bullets stand out
               ("^ *\\([-+]\\|[0-9]+[).]\\) " 1 'org-list-dt append)
               ;; and separators/dividers
               ("^ *\\(-----+\\)$" 1 'org-meta-line))
             ;; custom #hashtags & @at-tags for another level of organization
             '(("\\s-\\(\\([#@]\\)[^+ \n.,]+\\)" 1 (+org-tag-face 2) prepend))))))

(add-hook! 'org-font-lock-set-keywords-hook #'+org|custom-fontification)
#+end_src

**** Behavior
#+BEGIN_SRC emacs-lisp
(setq! org-tags-column -110
       org-return-follows-link t
       org-list-allow-alphabetical t
       org-loop-over-headlines-in-active-region t
       org-blank-before-new-entry '((heading . auto)
                                    (plain-list-item . auto))
       org-imenu-depth 4)

(defun nox|org-summary-todo (_n-done n-not-done)
  "Update todo keyword after changing the statistics cookie, when needed."
  (let ((keyword (org-get-todo-state))
        org-todo-log-states org-log-done)
    (if (= n-not-done 0)
        (when (not (member keyword org-done-keywords)) (org-todo (car org-done-keywords)))
      (when (member keyword org-done-keywords) (org-todo (car org-not-done-keywords))))))
(add-hook! 'org-after-todo-statistics-hook #'nox|org-summary-todo)

(defun nox|org-project-set-next-after-done ()
  "Ask to TODO to NEXT when changing previous states to DONE."
  (let ((done-keywords (or org-done-keywords org-done-keywords-for-agenda))
        (post-hook (default-value 'post-command-hook)))
    (unwind-protect
        (when (and (member org-state done-keywords) (+org-is-subtask))
          (setq-default post-command-hook nil) ;; NOTE(nox): Prevent asking for log note (eg. when cancelling)

          (org-with-wide-buffer
           (org-back-to-heading t)

           (let (point keyword break)
             (while (and (save-excursion (setq point (org-get-last-sibling))) (not break))
               (goto-char point)
               (setq keyword (org-get-todo-state))
               (when (or (member keyword done-keywords)
                         (and (not (+org-project-p))
                              (string= keyword "TODO")))
                 (setq break t)
                 (org-get-next-sibling))))

           (let (target keyword break)
             (while (not (or target break))
               (setq keyword (org-get-todo-state))
               (unless (+org-project-p)
                 (if (string= keyword "TODO")
                     (setq target (cons (point) (org-get-heading t t t t)))
                   (setq break (string= keyword "NEXT"))))
               (setq break (or break (not (org-get-next-sibling)))))

             (when (consp target)
               (when (y-or-n-p (concat "Do you want to set " (cdr target) " to NEXT?"))
                 (goto-char (car target))
                 (org-todo "NEXT"))))))

      (setq-default post-command-hook post-hook))))
(add-hook 'org-after-todo-state-change-hook #'nox|org-project-set-next-after-done)

(defun nox|update-parent-todo ()
  (org-with-wide-buffer
   (when (and (org-up-heading-safe) (org-get-todo-state))
     (let ((continue t) (restore-point (point)) (org-inhibit-logging t)
           (inhibit-message t) best-keyword best-is-todo)
       (outline-next-heading)
       (while continue
         (let ((keyword (org-get-todo-state)))
           (if best-is-todo
               (catch 'break
                 (dolist (test org-not-done-keywords)
                   (when (string= test best-keyword)
                     (throw 'break t))
                   (when (string= test keyword)
                     (setq best-keyword keyword)
                     (throw 'break t))))

             (if (member keyword org-not-done-keywords)
                 (setq best-keyword keyword
                       best-is-todo t)

               (catch 'break
                 (dolist (test org-done-keywords)
                   (when (string= test best-keyword)
                     (throw 'break t))
                   (when (string= test keyword)
                     (setq best-keyword keyword)
                     (throw 'break t)))))))

         (setq continue (outline-get-next-sibling)))

       (when best-keyword
         (goto-char restore-point)
         (org-todo best-keyword))))))
(add-to-list 'safe-local-eval-forms '(setq-local org-after-todo-state-change-hook '(nox|update-parent-todo)))
#+END_SRC

**** Tasks and states
#+BEGIN_SRC emacs-lisp
(setq!
 org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                     (sequence "HOLD(h@/!)" "WAITING(w@/!)" "|" "CANCELLED(c@/!)"))
 org-treat-S-cursor-todo-selection-as-state-change nil
 org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM"
 org-global-properties '(("Effort_ALL" . "0:05 0:10 0:15 0:30 0:45 1:00 1:30 2:00 3:00 4:00 5:00 7:00")))

(defconst +org-keywords-normal-faces
  '(("TODO"      . (:inherit org-todo :weight normal))
    ("NEXT"      . (:inherit org-todo :weight normal))
    ("HOLD"      . (:inherit org-todo :weight normal))
    ("WAITING"   . (:inherit org-todo :weight normal))
    ("DONE"      . (:inherit org-done :weight normal))
    ("CANCELLED" . (:inherit org-done :weight normal))))

(defconst +org-keywords-bold-faces
  '(("TODO"      . (:inherit org-todo :weight bold))
    ("NEXT"      . (:inherit org-todo :weight bold))
    ("HOLD"      . (:inherit org-todo :weight bold))
    ("WAITING"   . (:inherit org-todo :weight bold))
    ("DONE"      . (:inherit org-done :weight bold))
    ("CANCELLED" . (:inherit org-done :weight bold))))

(defconst +agenda-todo-map-alist
  '(("TODO" . todo) ("NEXT" . next) ("HOLD" . hold) ("WAITING" . waiting)
    ("DONE" . done) ("CANCELLED" . cancelled)))
#+END_SRC

**** Refiling
#+BEGIN_SRC emacs-lisp
(defun +org|refile-target-check ()
  (if (org-entry-is-done-p)
      (progn (org-end-of-subtree t t) nil)
    t))

(setq! org-refile-use-outline-path 'file
       org-outline-path-complete-in-steps nil
       org-refile-allow-creating-parent-nodes 'confirm
       org-refile-target-verify-function #'+org|refile-target-check
       org-refile-targets `((nil . (:maxlevel . 9))
                            (,nox-org-agenda-file .  (:maxlevel . 9))
                            (,nox-org-tickler-file . (:maxlevel . 9))
                            (,nox-org-someday-file . (:maxlevel . 9))))

(add-hook! 'org-after-refile-insert-hook
  (org-up-heading-safe)
  (org-update-statistics-cookies nil))

(advice-add #'org-refile :after (lambda (&rest _) (org-save-all-org-buffers)))
#+END_SRC

**** Priorities
#+BEGIN_SRC emacs-lisp
(setq! org-highest-priority ?A
       org-default-priority ?C
       org-lowest-priority  ?D)
#+END_SRC

**** Logging
#+BEGIN_SRC emacs-lisp
(setq! org-log-done 'time
       org-log-reschedule 'time
       org-log-redeadline 'time
       org-log-into-drawer t)
#+END_SRC

**** Archiving
#+begin_src emacs-lisp
(use-package org-archive
  :config
  (defun org-archive--compute-location (location)
    (let* ((current-file (buffer-file-name (buffer-base-buffer)))
           (file-non-directory (file-name-nondirectory current-file))
           (file-sans-extension (file-name-sans-extension file-non-directory))
           (case-fold-search nil))
      (setq location (replace-regexp-in-string (regexp-quote "%s") file-non-directory location t)
            location (replace-regexp-in-string (regexp-quote "%S") file-sans-extension location t)
            location (replace-regexp-in-string (regexp-quote "%y") (format-time-string "%Y") location t))

      (unless (string-match "::" location) (error "Invalid archive location: %S" location))

      (let ((file (substring location 0 (match-beginning 0)))
            (heading (substring location (match-end 0))))
        (cons (if (org-string-nw-p file) (expand-file-name file) current-file) heading))))

  (advice-add #'org-archive-subtree :after (lambda (&rest _) (org-save-all-org-buffers)))
  (advice-add #'org-archive-to-archive-sibling :after #'org-save-all-org-buffers))
#+end_src

**** Exporting
#+BEGIN_SRC emacs-lisp
(defun +org-export-merge-sections (data _backend info)
  (org-element-map data 'headline
    (lambda (hl)
      (let ((sections
             (cl-loop
              for el in (org-element-map (org-element-contents hl)
                            '(headline section) #'identity info)
              until (eq (org-element-type el) 'headline)
              collect el)))
        (when (and sections
                   (> (length sections) 1))
          (apply #'org-element-adopt-elements
                 (car sections)
                 (cl-mapcan (lambda (s) (org-element-contents s))
                            (cdr sections)))
          (mapc #'org-element-extract-element (cdr sections)))))
    info))

(defun +org-export-ignore-headlines-routine (object)
  (let* ((promote-children (member "ignore" (org-element-property :tags object)))
         (ignore (or (member "ignore_nested" (org-element-property :tags object)) promote-children)))
    (when ignore
      (mapc (lambda (el)
              (when promote-children
                (org-element-map el 'headline
                  (lambda (el)
                    (when (equal 'headline (org-element-type el))
                      (org-element-put-property el :level (1- (org-element-property :level el)))))))
              (org-element-insert-before el object))
            (org-element-contents object))
      (org-element-extract-element object))))

(defun +org-export-ignore-headlines (data backend info)
  "Remove headlines tagged \"ignore\" retaining contents and promoting children.
Each headline tagged \"ignore\" will be removed retaining its
contents and promoting any children headlines to the level of the
parent."
  (org-element-map data 'headline #'+org-export-ignore-headlines-routine info nil)
  (+org-export-merge-sections data backend info)
  data)

(add-hook 'org-export-filter-parse-tree-functions #'+org-export-ignore-headlines)
#+END_SRC

**** Latex
#+BEGIN_SRC emacs-lisp
(setq!
 org-latex-compiler "xelatex"
 org-latex-packages-alist '(("" "mathtools" t)
                            ("binary-units=true" "siunitx" t)
                            ("" "cancel" t)
                            ("" "xcolor" t)
                            ("margin=.7in" "geometry" nil))
 org-preview-latex-default-process 'dvisvgm
 org-latex-preview-ltxpng-directory (concat nox-cache-dir "org-latex/")
 org-format-latex-options '(:foreground default :background default :scale 1.7 :html-foreground "Black"
                            :html-background "Transparent" :html-scale 1.0
                            :matchers ("begin" "$1" "$" "$$" "\\(" "\\["))
 org-latex-hyperref-template
 "\\hypersetup{
 pdfauthor={%a},
 pdftitle={%t},
 pdfkeywords={%k},
 pdfsubject={%d},
 pdfcreator={%c},
 pdflang={%L},
 colorlinks, linkcolor={red!50!black}, citecolor={blue!50!black}, urlcolor={blue!80!black}
}")
#+END_SRC

***** Get different Latex fragments for different themes
#+BEGIN_SRC emacs-lisp
(defvar nox-org-sha-salt nil)
(defun nox*org-format-latex (orig-function &rest args)
  (setq nox-org-sha-salt (concat (face-attribute 'default :foreground)
                                 (face-attribute 'default :background)))
  (cl-letf (((symbol-function 'sha1)
             (lambda (object &optional start end binary)
               (secure-hash 'sha1 (concat object nox-org-sha-salt)
                            start end binary))))
    (apply orig-function args)))
(advice-add 'org-format-latex :around #'nox*org-format-latex)
#+END_SRC

**** Babel
#+BEGIN_SRC emacs-lisp
(setq! org-confirm-babel-evaluate nil)

(org-babel-do-load-languages
 'org-babel-load-languages
 '((calc    . t)
   (gnuplot . t)
   (latex   . t)
   (matlab  . t)
   (octave  . t)
   (python  . t)
   (shell   . t)))

(setq! org-babel-default-header-args:matlab '((:session . "*MATLAB*")))
#+END_SRC

***** MATLAB & Octave
#+BEGIN_SRC emacs-lisp
(use-package ob-octave
  :config
  (setq! org-babel-octave-wrapper-method
         "%s
if ischar(ans) || isstring(ans), fid = fopen('%s', 'w'); fprintf(fid, '%%s\\n', ans); fclose(fid);
else, dlmwrite('%s', ans, '\\t')
end")

  (defun +babel-octave*evaluate-session (orig-func session body result-type &optional matlabp)
    (let ((body-to-remove body))
      (cl-letf* (((symbol-function #'org-babel-strip-quotes) 'identity)
                 ((symbol-function #'org-trim)
                  (lambda (string)
                    (cond
                     (matlabp
                      (let ((N (compare-strings string nil nil body-to-remove nil nil)))
                        (if (eq N t)
                            ""
                          (setq N (1- (abs N))
                                body-to-remove (substring body-to-remove N)
                                string (string-trim-right (string-trim-left (substring string N) "[\n]+")
                                        "\n"))
                          (if (string-empty-p string) "" string))))
                     (t string)))))
        (funcall orig-func session body result-type matlabp))))

  (advice-add 'org-babel-octave-evaluate-session :around #'+babel-octave*evaluate-session))
#+END_SRC

***** Sessions
#+BEGIN_SRC emacs-lisp
(defun +babel-get-src-info ()
  "Return (LANG . SESSION)."
  (let* ((info (org-babel-get-src-block-info t))
         (params (nth 2 info)))
    (cons (car info)
          (cdr (assq :session params)))))

(defun +babel/kill-session ()
  "Kill session for current code block."
  (interactive)
  (org-babel-when-in-src-block
   (let ((config (current-window-configuration)))
     (org-babel-switch-to-session)
     (set-process-query-on-exit-flag (get-buffer-process (current-buffer)) nil)
     (kill-buffer)
     (set-window-configuration config))))

(defun +babel/restart-session-to-point (&optional arg)
  "Restart session up to the src-block in the current point.
Goes to beginning of (narrowed) buffer and executes each code block with `org-babel-execute-src-block'
that has the same language and session as the current block. ARG has same meaning as in
`org-babel-execute-src-block'."
  (interactive "P")
  (org-babel-when-in-src-block
   (save-excursion
     (let ((search-bound (point-marker))
           (info (+babel-get-src-info))
           break)
       (goto-char (point-min))
       (while (and (not break) (re-search-forward org-babel-src-block-regexp nil t))
         (goto-char (match-beginning 0))
         (if (> (point) search-bound)
             (setq break t)
           (when (equal info (+babel-get-src-info)) (org-babel-execute-src-block arg)))
         (forward-line))))))

(defun +babel/execute-region (&optional arg)
  "Execute all code blocks inside region. ARG has same meaning as in `org-babel-execute-src-block'."
  (interactive "P")
  (when (region-active-p)
    (save-excursion
      (let ((search-bound (region-end)) break)
        (goto-char (region-beginning))
        (while (and (not break) (re-search-forward org-babel-src-block-regexp nil t))
          (goto-char (match-beginning 0))
          (if (> (point) search-bound)
              (setq break t)
            (org-babel-execute-src-block arg))
          (forward-line))))))

(defun +babel/remove-session-results ()
  "Remove results from every code block of the selected session, in (narrowed) buffer."
  (interactive)
  (org-babel-when-in-src-block
   (let ((info (+babel-get-src-info)))
     (goto-char (point-min))
     (while (re-search-forward org-babel-src-block-regexp nil t)
       (when (equal info (+babel-get-src-info))
         (org-babel-remove-result))))))
#+END_SRC

**** Fix blank line insertion in lists
#+BEGIN_SRC emacs-lisp
(use-package org-list
  :config
  (defun org-list-separating-blank-lines-number (_pos struct _prevs)
    "Return number of blank lines that should separate items in list.

POS is the position of point where `org-list-insert-item' was called.

STRUCT is the list structure.  PREVS is the alist of previous
items, as returned by `org-list-prevs-alist'.

Assume point is at item's beginning.  If the item is alone, apply
some heuristics to guess the result."
    (save-excursion
      (let ((item (point))
            (insert-blank-p (cdr (assq 'plain-list-item org-blank-before-new-entry)))
            (count-blanks (lambda ()
                            (save-excursion
                              (count-lines (goto-char (point-at-bol))
                                           (progn (skip-chars-backward " \r\t\n")
                                                  (forward-line) (point))))))
            (top (org-list-get-top-point struct)))
        (cond
         ;; NOTE(nox): Trivial cases
         ((not insert-blank-p) 0)
         ((eq insert-blank-p t) 1)
         ;; NOTE(nox): `plain-list-item' is 'auto.
         ((> item top) ;; Item is not the first
          (funcall count-blanks))
         (t 0))))))
#+END_SRC

**** Don't consider angular brackets as parentheses
#+begin_src emacs-lisp
(add-hook! org-mode
  (modify-syntax-entry ?< "_" org-mode-syntax-table)
  (modify-syntax-entry ?> "_" org-mode-syntax-table))
#+end_src

**** File associations
#+begin_src emacs-lisp
(setq! org-file-apps '((auto-mode . emacs)
                       (directory . emacs)
                       ("\\.x?html?\\'" . default)))
#+end_src

***** PDF Tools support
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "pdfview"
 :follow 'org-pdfview-open
 :complete 'org-pdfview-complete-link
 :store 'org-pdfview-store-link)
#+END_SRC

***** BibTeX support
#+begin_src emacs-lisp
(org-link-set-parameters "bibtex" :follow #'+org-bibtex-open)
#+end_src

**** End
#+BEGIN_SRC emacs-lisp
) ;; use-package

(use-package org-element :commands org-element-update-syntax)
#+END_SRC

*** Agenda
[[https://raw.githubusercontent.com/weirdNox/dotfiles/screenshots/Agenda.png][https://raw.githubusercontent.com/weirdNox/dotfiles/screenshots/Agenda.png]]

#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :general
  (nox-leader "a" '(org-agenda :wk "Agenda"))

  :config
  (defun +agenda|check-sync-conflicts ()
    (when (directory-files org-directory nil "sync-conflict")
      (message-box "AVISO: Há conflitos de sincronização!")))
  (add-hook 'org-agenda-finalize-hook #'+agenda|check-sync-conflicts)

  (general-def :keymaps 'org-agenda-mode-map
    "P" #'+agenda/toggle-private
    "W" #'+agenda/toggle-weekly-review)

  (defun +agenda|skip-function ()
    (and (or (and (not +agenda-show-private) (member "PRIVATE" (save-match-data (org-get-tags))))
             (and (boundp 'deadline-items)
                  (let ((deadline (org-agenda--timestamp-to-absolute (match-string 1)))
                        (date-abs (calendar-absolute-from-gregorian date))
                        (span (or (car (last org-agenda-overriding-arguments)) org-agenda-span)))
                    (and (> deadline date-abs)
                         (< deadline (+ today (org-agenda-span-to-ndays span date-abs)))))))
         (or (outline-next-heading) (point-max))))

  (setq!
   org-agenda-custom-commands
   '(("n" "Agenda"
      ((agenda "" ((org-agenda-span 3)
                   (org-agenda-prefix-format " %(+agenda-schedule-get-prefix)%?-12t% s")
                   (org-agenda-skip-function #'+agenda|skip-function)))
       (+agenda-inbox nil ((org-agenda-files (list org-default-notes-file))))
       (+agenda-tasks nil ((org-agenda-files (list nox-org-agenda-file)))))))

   org-agenda-hide-tags-regexp "TICKLER"
   org-agenda-skip-deadline-if-done nil
   org-agenda-skip-scheduled-if-done t
   org-agenda-skip-timestamp-if-done nil
   org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled
   org-agenda-skip-scheduled-if-deadline-is-shown nil
   org-agenda-block-separator ""
   org-agenda-clockreport-parameter-plist `(:link t :maxlevel 6 :fileskip0 t :compact t :narrow 100)
   org-agenda-columns-add-appointments-to-effort-sum t
   org-agenda-dim-blocked-tasks nil
   org-agenda-time-grid '((daily today require-timed) nil "......" "----------------")
   org-agenda-sorting-strategy '((agenda habit-down time-up timestamp-up priority-down category-keep)))

  (add-hook 'org-agenda-mode-hook 'nox|org-offer-all-agenda-tags)
#+END_SRC

**** Entry
#+BEGIN_SRC emacs-lisp
(defun +agenda-is-low-effort (effort-text &optional todo-type)
  (and effort-text
       (or (not todo-type) (eq todo-type 'todo))
       (< (org-duration-to-minutes effort-text) 20)))

(cl-defstruct +agenda-entry
  todo todo-text priority text tags planned low-effort marker is-tickler sched-info
  project-status children hidden-children)

(defun +agenda-entry (headline &optional tags)
  (let ((todo-text (org-element-property :todo-keyword headline))
        (todo-type (org-element-property :todo-type headline))
        (effort (org-element-property :EFFORT headline))
        (tags (or tags (org-element-property :tags headline)))
        (scheduled-ts (org-element-property :raw-value (org-element-property :scheduled headline)))
        (deadline-ts  (org-element-property :raw-value (org-element-property :deadline headline)))
        ts-rel ts-abs ts-compare)

    (cond (scheduled-ts (setq ts-abs (org-time-string-to-absolute scheduled-ts)
                              ts-rel (org-time-stamp-to-now scheduled-ts)
                              ts-compare 0))
          (deadline-ts (setq ts-abs (org-time-string-to-absolute deadline-ts)
                             ts-rel (org-time-stamp-to-now deadline-ts)
                             ts-compare (org-get-wdays deadline-ts))))

    (make-+agenda-entry
     :todo (cdr (assoc-string todo-text +agenda-todo-map-alist))
     :todo-text todo-text
     :priority (org-element-property :priority headline)
     :text (org-element-property :raw-value headline)
     :tags tags
     :low-effort (+agenda-is-low-effort effort todo-type)
     :marker (org-agenda-new-marker (org-element-property :begin headline))
     :is-tickler (member "TICKLER" tags)
     :sched-info (and ts-abs (cons ts-abs (if (> ts-rel ts-compare) 'planned 'past))))))

(defsubst +agenda-is-entry-planned (entry)
  (or (eq (+agenda-entry-project-status entry) 'planned)
      (+agenda-entry-planned entry)))
#+END_SRC

**** Renderer
#+BEGIN_SRC emacs-lisp
(defvar +agenda-structure-face nil)
(defvar +agenda-entry-face nil)

(defun +agenda-filter-tags (tag) (unless (string-match org-agenda-hide-tags-regexp tag) tag))

(defun +agenda-fontify-entry (string)
  (with-temp-buffer
    (insert string)
    (goto-char (point-min))
    (let ((cur -1)
          (new (point)))
      (while (not (= cur new))
        (setq cur new)
        (org-raise-scripts nil)
        (setq new (point))))

    (goto-char (point-min))
    (let ((cur -1)
          (new (point)))
      (while (not (= cur new))
        (setq cur new)
        (org-fontify-entities nil)
        (setq new (point))))
    (buffer-string)))

(defun +agenda-format-entry (prefix entry)
  (let* ((entry-text (+agenda-entry-text entry))
         (wanted-face (get-text-property 0 'face entry-text))
         (props (list 'nox-custom-agenda t
                      'undone-face (or +agenda-entry-face wanted-face 'default)
                      'done-face 'org-agenda-done
                      'mouse-face 'highlight
                      'org-marker (+agenda-entry-marker entry)
                      'org-hd-marker (+agenda-entry-marker entry)
                      'todo-state (+agenda-entry-todo-text entry)
                      'org-todo-regexp org-todo-regexp
                      'org-not-done-regexp org-not-done-regexp
                      'org-complex-heading-regexp org-complex-heading-regexp
                      'org-highest-priority org-highest-priority
                      'org-lowest-priority org-lowest-priority
                      'tags (+agenda-entry-tags entry)
                      'format `(nil ,prefix)))
         (tags (delq nil (mapcar #'+agenda-filter-tags (+agenda-entry-tags entry))))
         (text
          (concat prefix
                  (when (+agenda-entry-todo-text entry) (concat (+agenda-entry-todo-text entry) " "))
                  (when (+agenda-entry-priority entry)
                    (string ?\[ ?# (+agenda-entry-priority entry) ?\] ? ))
                  (+agenda-fontify-entry entry-text)
                  (when (and (+agenda-entry-hidden-children entry)
                             (not (string-match-p "\\[[0-9]*\\(%\\|/[0-9]*\\)\\]" entry-text)))
                    " ")
                  (when tags (concat " :" (mapconcat #'identity tags ":") ":")))))

    (add-text-properties (length prefix) (length text) (list 'org-heading t
                                                             'face (or +agenda-entry-face wanted-face 'default))
                         text)
    (setq text (concat (org-add-props text props) "\n"))
    (org-agenda-highlight-todo text)))

(defun +agenda-tip-for-effort (text low-effort &optional alt-text)
  (if low-effort
      (propertize text 'face '(:foreground "#b58900"))
    (or alt-text text)))

(defun +agenda-schedule-get-prefix ()
  (+agenda-tip-for-effort "▶" (+agenda-is-low-effort effort) " "))

(defun +agenda-project-get-prefix (taskp parent-continuations &optional low-effort)
  ;; IMPORTANT(nox): `parent-continuations' is in reverse order!
  (let ((prefix "")
        (tip t))
    (if taskp
        (dolist (cont parent-continuations)
          (setq prefix (concat (if tip
                                   (+agenda-tip-for-effort (if cont "├▶ " "╰▶ ") low-effort)
                                 (if cont "│  " "   "))
                               prefix)
                tip nil))

      (dolist (cont parent-continuations)
        (setq prefix (concat (if tip (if cont "├─╴" "╰─╴") (if cont "│  " "   ")) prefix)
              tip nil)))
    (concat "  " prefix)))

(defun +agenda-priority-sort (a b)
  (let ((pa (or (+agenda-entry-priority a) org-default-priority))
        (pb (or (+agenda-entry-priority b) org-default-priority))
        (ta (or (car (+agenda-entry-sched-info a)) most-positive-fixnum))
        (tb (and (eq (cdr (+agenda-entry-sched-info b)) 'past) (car (+agenda-entry-sched-info b)))))
    (or (< pa pb) (and (= pa pb) (if tb (< ta tb) (eq (cdr (+agenda-entry-sched-info a)) 'past))))))

(defun +agenda-flatten-list (l)
  (cond ((not l) nil)
        ((atom l) (list l))
        (t (append (+agenda-flatten-list (car l)) (+agenda-flatten-list (cdr l))))))

(defun +agenda-project-printer (list &optional parent-continuations)
  (setq list (sort list #'+agenda-priority-sort))

  (let ((first t) entry)
    (while list
      (setq entry (pop list))
      (if parent-continuations
          (unless list (setf (car parent-continuations) nil))
        (unless first (insert "\n")))

      (cond
       ((eq (+agenda-entry-project-status entry) 'stuck)
        (org-add-props (+agenda-entry-text entry) nil 'face 'org-priority 'nox-face 'org-priority))
       ((+agenda-is-entry-planned entry)
        (org-add-props (+agenda-entry-text entry) nil 'face 'org-date     'nox-face 'org-date)))

      (let ((org-todo-keyword-faces (if (+agenda-entry-project-status entry)
                                        +org-keywords-normal-faces
                                      +org-keywords-bold-faces))
            (prefix (+agenda-project-get-prefix (not (+agenda-entry-project-status entry))
                                                parent-continuations
                                                (+agenda-entry-low-effort entry))))
        (insert (+agenda-format-entry prefix entry)))

      (+agenda-project-printer (+agenda-entry-children entry) (cons t parent-continuations))
      (setq first nil))))

(defun +agenda-simple-printer (list)
  (setq list (sort list #'+agenda-priority-sort))
  (dolist (entry list)
    (insert
     (+agenda-format-entry (+agenda-tip-for-effort " ▶" (+agenda-entry-low-effort entry) "  ") entry))))

(defun +agenda-separator ()
  (unless (or (bobp) org-agenda-compact-blocks
              (not org-agenda-block-separator))
    (insert "\n"
            (if (stringp org-agenda-block-separator)
                org-agenda-block-separator
              (make-string (window-width) org-agenda-block-separator))
            "\n")))

(defun +agenda-render-block (data title &optional printer)
  (when data
    (let ((begin (point)))
      (+agenda-separator)
      (insert (org-add-props title nil 'face (or +agenda-structure-face 'org-agenda-structure)) "\n")
      (funcall (or printer #'+agenda-simple-printer) data)
      (add-text-properties begin (point-max) `(org-agenda-type tags)))))
#+END_SRC

**** Inbox
#+BEGIN_SRC emacs-lisp
(defun +agenda-inbox-process-headline (headline)
  (when (or +agenda-show-private
            (not (member "PRIVATE" (org-element-property :tags headline))))
    (+agenda-entry headline)))

(defun +agenda-inbox (&optional _)
  (catch 'exit
    (let ((files (org-agenda-files nil 'ifmode))
          +agenda-inbox
          org-todo-regexp org-not-done-regexp org-complex-heading-regexp org-done-keywords
          org-done-keywords-for-agenda file buffer ast)
      (while (setq file (pop files))
        (org-check-agenda-file file)
        (setq buffer (if (file-exists-p file)
                         (org-get-agenda-file-buffer file)
                       (error "No such file %s" file)))

        (unless org-todo-regexp
          (dolist (variable '(org-todo-regexp org-not-done-regexp org-complex-heading-regexp
                                              org-done-keywords org-done-keywords-for-agenda))
            (set variable (buffer-local-value variable buffer))))

        (with-current-buffer buffer
          (org-with-wide-buffer
           (unless (derived-mode-p 'org-mode) (error "Agenda file %s is not in Org mode" file))
           (setq ast (org-element-parse-buffer 'headline))
           (setq +agenda-inbox
                 (append (org-element-map ast 'headline #'+agenda-inbox-process-headline nil nil 'headline)
                         +agenda-inbox)))))

      (let ((inhibit-read-only t))
        (goto-char (point-max))
        (+agenda-render-block +agenda-inbox "Coisas a arrumar")))))
#+END_SRC

**** Tasks
#+BEGIN_SRC emacs-lisp
(defvar +agenda-level)
(defvar +agenda-parent-tags)
(defvar +agenda-project-status)
(defvar +agenda-projects)
(defvar +agenda-isolated-tasks)
(defvar +agenda-high-priority)
(defvar +agenda-low-priority)
(defvar +agenda-archivable-tasks)
(defvar +agenda-planned-tasks)
(defvar +agenda-hold-tasks)
(defvar +agenda-date-info)

(defun +agenda-filter-priorities (entry)
  (let ((priority (+agenda-entry-priority entry)))
    (cond ((eq priority ?A) (push entry +agenda-high-priority))
          ((eq priority ?D) (push entry +agenda-low-priority)))))

(defmacro +agenda-process-children (parent &optional task-children)
  (if task-children
      `(let ((+agenda-parent-tags (append (org-element-property :tags ,parent) +agenda-parent-tags))
             (+agenda-level (1+ +agenda-level)))
         (org-element-map (org-element-contents ,parent) 'headline
           #'+agenda-tasks-process-headline nil nil 'headline))
    `(let ((+agenda-parent-tags (append (org-element-property :tags ,parent) +agenda-parent-tags)))
       (org-element-map (org-element-contents ,parent) 'headline #'+agenda-tasks-process-headline
                        nil nil 'headline))))

(defmacro +agenda-set-parent-minimum-status (status)
  `(unless (= +agenda-level 0)
     ,(if (symbolp status)
          (cond ((eq status 'next)    '(setq +agenda-project-status 'next))
                ((eq status 'planned) '(when (not (eq +agenda-project-status 'next))
                                         (setq +agenda-project-status 'planned)))
                (t '(unless +agenda-project-status (setq +agenda-project-status 'stuck))))
        `(cond ((eq ,status 'next)     (setq +agenda-project-status 'next))
               ((eq ,status 'planned)  (when (not (eq +agenda-project-status 'next))
                                         (setq +agenda-project-status 'planned)))
               (t (unless +agenda-project-status (setq +agenda-project-status 'stuck)))))))

(defun +agenda-tasks-process-headline (headline)
  (when (or +agenda-show-private (not (member "PRIVATE" (org-element-property :tags headline))))
    (let* ((tags-list (cl-remove-duplicates (append (org-element-property :tags headline) +agenda-parent-tags)
                                            :test 'string=))
           (entry (+agenda-entry headline tags-list))
           (scheduled-past-or-now (eq (cdr (+agenda-entry-sched-info entry)) 'past))
           (closed-ts  (org-element-property :raw-value (org-element-property :closed headline)))
           (todo (+agenda-entry-todo entry))
           (todo-type (org-element-property :todo-type headline))
           project-status return)

      (if (not todo-type)
          ;; NOTE(nox): No todo keyword
          (let* ((time-to-now (and (car (+agenda-entry-sched-info entry))
                                   (- (car (+agenda-entry-sched-info entry)) (org-today))))
                 (begin (org-element-property :begin headline))
                 first-child search-bound temp-time)

            ;; NOTE(nox): Find the most recent active timestamp
            (when (and (not time-to-now) begin)
              (setq first-child (org-element-map (org-element-contents headline) 'headline #'identity
                                                 nil t 'headline)
                    search-bound (or (and first-child (org-element-property :begin first-child))
                                     (org-element-property :end headline)))
              (goto-char begin)
              (while (re-search-forward org-ts-regexp search-bound t)
                (setq temp-time (org-time-stamp-to-now (match-string 1)))
                (when (or (not time-to-now) (> temp-time time-to-now))
                  (setq time-to-now temp-time))))

            (if time-to-now
                (if (and (= +agenda-level 0) (< time-to-now -60))
                    ;; NOTE(nox): This headline has timestamps (=> event) and they have expired, so it
                    ;; should be archived!
                    (push entry +agenda-archivable-tasks)

                  ;; NOTE(nox): This headline has non-expired timestamps, so it may be a pseudo-project
                  ;; with associated (parallel) tasks
                  (let* ((+agenda-project-status nil)
                         (children (+agenda-process-children headline t))
                         (tail children) prev)
                    (while tail
                      (let ((child (car tail)))
                        (if (+agenda-is-entry-planned child)
                            (if prev
                                (setcdr prev (cdr tail))
                              (setq children (cdr tail))))
                        (setq prev tail))
                      (setq tail (cdr tail)))

                    (when children
                      (setf (+agenda-entry-children entry) children)
                      (setq return entry))))

              ;; NOTE(nox): Just process the children of this headline without todo keyword
              (setq return (+agenda-process-children headline))))

        ;; NOTE(nox): Has todo keyword
        (+agenda-set-parent-minimum-status 'stuck)

        (if (eq todo-type 'done)
            ;; NOTE(nox): Archive all tasks that have been done for longer than 2 months
            (when (and (= +agenda-level 0)
                       (or (not closed-ts) (< (org-time-stamp-to-now closed-ts) -60)))
              (push entry +agenda-archivable-tasks))

          (cond
           ;; NOTE(nox): Planned
           ((and (not (eq todo 'next)) (eq (cdr (+agenda-entry-sched-info entry)) 'planned))
            (setf (+agenda-entry-planned entry) t)
            (if (= +agenda-level 0)
                (unless (or (+agenda-entry-is-tickler entry)
                            (and (>= (car (+agenda-entry-sched-info entry)) (car +agenda-date-info))
                                 (<  (car (+agenda-entry-sched-info entry)) (cdr +agenda-date-info))))
                  (push entry +agenda-planned-tasks))
              (+agenda-set-parent-minimum-status 'planned)
              (setq return entry)))

           ;; NOTE(nox): Hold
           ((or (eq todo 'hold) (eq todo 'waiting))
            (push entry +agenda-hold-tasks))

           (t
            ;; NOTE(nox): Process children
            (let* ((+agenda-project-status nil)
                   (children (+agenda-flatten-list (+agenda-process-children headline t)))
                   tail prev)
              (setq project-status +agenda-project-status)

              (cond
               ;; NOTE(nox): When this project is next, we need to remove the cruft from the list
               ;; (planned, stuck or todo children)
               ((eq project-status 'next)
                (unless +agenda-weekly-review
                  (setq tail children)
                  (while tail
                    (let ((child (car tail)))
                      (cond ((+agenda-is-entry-planned child)
                             (unless (+agenda-entry-is-tickler child) (push child +agenda-planned-tasks))
                             (if prev (setcdr prev (cdr tail)) (setq children (cdr tail))))

                            ((if (+agenda-entry-project-status child)
                                 (and (eq (+agenda-entry-project-status child) 'stuck)
                                      (not (eq (+agenda-entry-todo child) 'next)))
                               (and (eq (+agenda-entry-todo child) 'todo)
                                    (not (eq (cdr (+agenda-entry-sched-info child)) 'past))))
                             (setf (+agenda-entry-hidden-children entry) t)
                             (if prev (setcdr prev (cdr tail)) (setq children (cdr tail))))

                            (t (setq prev tail))))
                    (setq tail (cdr tail)))))

               ;; NOTE(nox): When this project is planned due to it only having planned and non-next
               ;; tasks, we have to show that it is hiding some non-next tasks
               ((eq project-status 'planned)
                (catch 'break
                  (dolist (child children)
                    (when (and (not (+agenda-is-entry-planned child))
                               (if (+agenda-entry-project-status child)
                                   (and (eq (+agenda-entry-project-status child) 'stuck)
                                        (not (eq (+agenda-entry-todo child) 'next)))
                                 (eq (+agenda-entry-todo child) 'todo)))
                      (if +agenda-weekly-review
                          (setf (+agenda-entry-is-tickler entry) nil)
                        (setf (+agenda-entry-hidden-children entry) t))
                      (throw 'break t))))))

              (setf (+agenda-entry-project-status entry) project-status
                    (+agenda-entry-children entry) children))

            ;; NOTE(nox): Update parent project status
            (unless (or (= +agenda-level 0) (eq +agenda-project-status 'next))
              (if project-status
                  (when (memq project-status '(next planned)) (setq +agenda-project-status project-status))
                (when (or (eq todo 'next) scheduled-past-or-now)
                  (setq +agenda-project-status 'next))))

            (if project-status
                (if (and (+agenda-entry-is-tickler entry) (not (+agenda-entry-hidden-children entry)))
                    (unless (eq project-status 'planned) (setq return entry))

                  (if +agenda-weekly-review
                      (setq return entry)
                    (if (and (eq project-status 'planned) (= +agenda-level 0))
                        (push entry +agenda-planned-tasks)
                      (when (or (eq todo 'next) (+agenda-entry-children entry)
                                (not (eq project-status 'stuck)))
                        (setq return entry)))))

              (if (= +agenda-level 0)
                  (unless (or (+agenda-filter-priorities entry) scheduled-past-or-now)
                    (push entry +agenda-isolated-tasks))
                (setq return entry)))))))
      return)))

(defun +agenda-tasks (&optional _)
  (catch 'exit
    (let ((files (org-agenda-files nil 'ifmode))
          (+agenda-date-info
           (cons org-starting-day
                 (+ org-starting-day (org-agenda-span-to-ndays org-agenda-current-span org-starting-day))))
          +agenda-projects +agenda-isolated-tasks +agenda-high-priority
          +agenda-low-priority +agenda-planned-tasks +agenda-hold-tasks
          +agenda-archivable-tasks
          org-todo-regexp org-not-done-regexp org-complex-heading-regexp org-done-keywords
          org-done-keywords-for-agenda file buffer ast)
      (while (setq file (pop files))
        (org-check-agenda-file file)
        (setq buffer (if (file-exists-p file)
                         (org-get-agenda-file-buffer file)
                       (error "No such file %s" file)))

        (unless org-todo-regexp
          (dolist (variable '(org-todo-regexp org-not-done-regexp org-complex-heading-regexp
                                              org-done-keywords org-done-keywords-for-agenda))
            (set variable (buffer-local-value variable buffer))))

        (with-current-buffer buffer
          (org-with-wide-buffer
           (unless (derived-mode-p 'org-mode) (error "Agenda file %s is not in Org mode" file))
           (setq ast (org-element-parse-buffer 'headline))
           (let ((+agenda-level 0)
                 +agenda-parent-tags)
             (setq +agenda-projects
                   (append
                    (+agenda-flatten-list
                     (org-element-map ast 'headline #'+agenda-tasks-process-headline nil nil 'headline))
                    +agenda-projects))))))

      (let ((inhibit-read-only t))
        (goto-char (point-max))
        (+agenda-render-block (nreverse +agenda-high-priority)    "Alta prioridade")
        (+agenda-render-block (nreverse +agenda-isolated-tasks)   "Tarefas isoladas")
        (+agenda-render-block +agenda-projects                    "Projetos" #'+agenda-project-printer)
        (+agenda-render-block (nreverse +agenda-low-priority)     "Baixa prioridade")

        (let ((+agenda-structure-face '(:inherit shadow :weight bold))
              (+agenda-entry-face 'shadow)
              (org-todo-keyword-faces +org-keywords-normal-faces))
          (+agenda-render-block (nreverse +agenda-archivable-tasks) "Tarefas a arquivar")
          (+agenda-render-block (nreverse +agenda-planned-tasks)    "Tarefas planeadas")
          (+agenda-render-block (nreverse +agenda-hold-tasks)       "Tarefas em espera"))))))
#+END_SRC

**** Private information
#+BEGIN_SRC emacs-lisp
(defvar +agenda-show-private t
  "If non-nil, show sensitive information on the agenda.")

(defun +agenda/toggle-private ()
  (interactive)
  (setq +agenda-show-private (not +agenda-show-private))
  (when  (equal major-mode 'org-agenda-mode) (quiet! (org-agenda-redo)))
  (message "Private tasks: %s" (if +agenda-show-private "Shown" "Hidden")))
#+END_SRC

**** Weekly review
#+BEGIN_SRC emacs-lisp
(defvar +agenda-weekly-review nil
  "If non-nil, render agenda in weekly review mode.")

(defun +agenda/toggle-weekly-review ()
  (interactive)
  (setq +agenda-weekly-review (not +agenda-weekly-review))
  (when  (equal major-mode 'org-agenda-mode) (quiet! (org-agenda-redo)))
  (message "Weekly review: %s" (if +agenda-weekly-review "On" "Off")))
#+END_SRC

**** Compatibility with their functions
~org-agenda-change-all-lines~ is called, for example, when an entry is marked as done or clocked in,
after removing the face property. This serves to restore the custom face set in the renderer.

#+BEGIN_SRC emacs-lisp
(defun +agenda*change-all-lines-reapply-face (&rest _)
  (when (org-get-at-bol 'nox-custom-agenda)
    (let* ((inhibit-read-only t)
           (bol (point-at-bol))
           (eol (point-at-eol))
           (position (next-single-property-change bol 'nox-face nil eol)))
      (add-text-properties bol eol `(face ,(and position (get-text-property position 'nox-face)))))))
(advice-add 'org-agenda-change-all-lines :before #'+agenda*change-all-lines-reapply-face)
#+END_SRC

**** End
#+BEGIN_SRC emacs-lisp
) ;; use-package
#+END_SRC

*** Attach
#+BEGIN_SRC emacs-lisp
(use-package org-attach
  :config
  (setq! org-attach-directory "resources/attach/"
         org-attach-method 'mv
         org-attach-auto-tag "ATTACH"))
#+END_SRC

*** Capture and protocol
#+BEGIN_SRC emacs-lisp
(use-package org-protocol :commands org-protocol-check-filename-for-protocol)

(use-package org-capture
  :commands +capture-frame
  :config
  (defun +capture-frame (&optional org-protocol-url)
    (let ((capture-frame (cl-loop for frame in (frame-list)
                                  when (frame-parameter frame 'org-capture-frame)
                                  return frame)))
      (select-frame-set-input-focus (or capture-frame
                                        (make-frame '((name . "Org Capture") (org-capture-frame . t)
                                                      (width . 110) (height . 40) (window-system . x)))))
      (unless capture-frame
        (or (and org-protocol-url (eq (org-protocol-check-filename-for-protocol org-protocol-url t nil) nil))
            (org-capture)))))

  (defun +org-inactive-timestamp (&optional time)
    (format-time-string (concat "[" (cdr org-time-stamp-formats) "]") time))

  (defun +capture|add-created-property ()
    (unless (org-before-first-heading-p) (org-set-property "CREATED" (+org-inactive-timestamp))))
  (add-hook 'org-capture-before-finalize-hook '+capture|add-created-property)

  (defconst +capture-tracker-type-to-heading '(movie "Movies" series "Series" book "Books" game "Games"))
  (defconst +capture-tracker-type-template   '(movie "* WATCH " series "* WATCH " book "* READ " game "* PLAY "))

  (defun +capture-tracker-template ()
    (with-current-buffer (find-file-noselect nox-org-tracker-file)
      (font-lock-ensure (point-min) (point-max))
      (let* ((track-type (org-capture-get :track-type))
             (ast (org-element-contents (org-element-parse-buffer 'headline)))
             (root (org-element-map ast 'headline
                     (lambda (headline)
                       (when (string= (org-element-property :title headline)
                                      (plist-get +capture-tracker-type-to-heading track-type))
                         headline))
                     nil t 'headline))
             (headings (org-element-contents root))
             (collection (org-element-map headings 'headline
                           (lambda (headline)
                             (cons (format "%10s %s"
                                           (org-element-property :todo-keyword headline)
                                           (org-element-property :title headline))
                                   headline))
                           nil nil 'headline))
             (selection (completing-read "Nome: " collection))
             (selection-info (cdr (assoc-string selection collection))))
        (cond
         (selection-info
          (let* ((old-frame (selected-frame))
                 (target-frame (cond ((not (frame-parameter old-frame 'org-capture-frame)) old-frame)
                                     ((not (equal (next-frame) old-frame)) (next-frame))
                                     ((make-frame '((fullscreen . maximized))))))
                 (org-show-context-detail 'tree))
            (with-selected-frame target-frame
              (raise-frame target-frame)
              (x-focus-frame target-frame)
              (find-file nox-org-tracker-file)
              (goto-char (org-element-property :begin selection-info))
              (org-show-context))

            (select-frame old-frame))
          "")
         (t
          (org-capture-put :tracker-location (copy-marker (org-element-property :begin root)))
          (concat (plist-get +capture-tracker-type-template track-type)
                  selection))))))

  (defun +capture-tracker-location ()
    (let ((marker (org-capture-get :tracker-location)))
      (when marker
        (switch-to-buffer (marker-buffer marker))
        (goto-char (marker-position marker))
        (org-capture-put :prepend t))))

  (setq!
   org-capture-templates '(("t" "task" entry (file "") "* NEXT %i%?")
                           ("c" "calendar" entry (file "") "* %^t %?")
                           ("b" "break" entry (file+olp nox-org-agenda-file "Interrupções") "* %?"
                            :clock-in t :clock-resume t)
                           ("j" "journal" entry (file+olp+datetree nox-org-journal-file) "* %?"
                            :clock-in t :clock-resume t :time-prompt t)
                           ("m" "tracking")
                           ("mm" "movie" entry #'+capture-tracker-location #'+capture-tracker-template
                            :track-type movie)
                           ("ms" "series" entry #'+capture-tracker-location #'+capture-tracker-template
                            :track-type series)
                           ("mb" "book" entry #'+capture-tracker-location #'+capture-tracker-template
                            :track-type book)
                           ("mg" "game" entry #'+capture-tracker-location #'+capture-tracker-template
                            :track-type game)
                           ("w" "web")
                           ("wc" "capture" entry (file "") "* [[%:link][%^{Title|%:description}]]\n%?")))

  (add-hook 'org-capture-mode-hook #'nox|org-offer-all-agenda-tags)
  (add-hook 'org-capture-after-finalize-hook #'org-save-all-org-buffers)

  ;;
  ;; NOTE(nox): Handle capture frame
  ;;
  (advice-add 'org-switch-to-buffer-other-window :after
              (lambda (&rest _) (when (frame-parameter nil 'org-capture-frame) (delete-other-windows))))

  (advice-add 'org-capture :around
              (lambda (capture-function &rest args)
                (condition-case nil (apply capture-function args)
                  (error (when (frame-parameter nil 'org-capture-frame) (delete-frame))))))

  (add-hook 'org-capture-after-finalize-hook
            (lambda (&rest _)
              (when (and (frame-parameter nil 'org-capture-frame) (not org-capture-is-refiling))
                (delete-frame))))

  (advice-add 'org-capture-refile :after
              (lambda (&rest _)
                (when (frame-parameter nil 'org-capture-frame) (delete-frame)))))
#+END_SRC

*** Clocking
#+BEGIN_SRC emacs-lisp
(use-package org-clock
  :config
  (defun org-clock-get-clock-string ()
    "Form a clock-string, that will be shown in the mode line."
    (let ((work-str (org-duration-from-minutes (org-clock-get-clocked-time))))
      (if org-clock-effort
          (format " [%s/%s]"
                  work-str (org-duration-from-minutes (org-duration-to-minutes org-clock-effort)))
        (format " [%s]" work-str))))

  (defun org-clock-update-mode-line (&optional refresh)
    "Update mode line with clock information.
When optional argument is non-nil, refresh cached heading."
    (let ((work-in-minutes (org-clock-get-clocked-time))
          (effort-in-minutes (and org-clock-effort (org-duration-to-minutes org-clock-effort))))
      (setq org-clock-task-overrun (and effort-in-minutes (> effort-in-minutes 0)
                                        (>= work-in-minutes effort-in-minutes)))
      (when refresh (setq org-clock-heading (org-clock--mode-line-heading)))

      (let ((clock-string (org-clock-get-clock-string))
            (help-text (concat "Clocked in at " org-clock-heading)))
        (setq org-mode-line-string
              (propertize clock-string
                          'face (if org-clock-task-overrun 'org-priority 'org-mode-line-clock)
                          'help-echo help-text
                          'local-map org-clock-mode-line-map
                          'mouse-face 'mode-line-highlight))))
    (force-mode-line-update t))

  (setq! org-clock-ask-before-exiting nil
         org-clock-in-resume t
         org-clock-out-remove-zero-time-clocks t
         org-clock-report-include-clocking-task t
         org-clock-persist t
         org-clock-persist-file (concat nox-etc-dir "org-clock-save.el")
         org-clock-history-length 25)
  (org-clock-persistence-insinuate))
#+END_SRC

*** Habit
#+BEGIN_SRC emacs-lisp
(use-package org-habit
  :config
  (setq! org-habit-graph-column 75
         org-habit-preceding-days 30
         org-habit-following-days 1
         org-habit-today-glyph ?@))
#+END_SRC

*** IDs
#+BEGIN_SRC emacs-lisp
(use-package org-id
  :config
  (setq! org-id-link-to-org-use-id 'create-if-interactive
         org-id-locations-file (concat nox-cache-dir "org-id-locations")))
#+END_SRC

*** Org Noter
#+BEGIN_SRC emacs-lisp
(use-package org-noter :elpaca (:host github :repo "weirdNox/org-noter")
  :general
  (nox-local-leader :keymaps 'org-mode-map      "n" '(org-noter :wk "Org Noter"))
  (nox-local-leader :keymaps 'pdf-view-mode-map "n" '(org-noter :wk "Org Noter"))

  :config
  (setq! org-noter-default-heading-title "Notas da página $p$"
         org-noter-notes-search-path '("~/archive/literature/notes/")
         org-noter-default-notes-file-names '("notes.org" "notas.org")))
#+END_SRC

*** Persist
#+begin_src emacs-lisp
(use-package org-persist
  :config
  (setq! org-persist-directory (concat nox-cache-dir "org-persist/")))
#+end_src

*** Source blocks
#+BEGIN_SRC emacs-lisp
(use-package org-src
  :config
  (setq! org-src-fontify-natively t
         org-src-tab-acts-natively t
         org-edit-src-content-indentation 0)
  (add-to-list 'org-src-lang-modes '("html" . web)))
#+END_SRC

*** Contributed packages
#+begin_src emacs-lisp
(use-package org-contrib :elpaca t)
#+end_src

** Tools and utilities
*** Bibliography (BibTeX, BibLaTeX, etc)
#+begin_src emacs-lisp
(defvar nox-bibliography-root "~/archive/literature")
(defvar nox-bibliography-refs-file (expand-file-name "references.bib" nox-bibliography-root))
(defvar nox-bibliography-files-dir (expand-file-name "files"          nox-bibliography-root))
(defvar nox-bibliography-notes-dir (expand-file-name "notes"          nox-bibliography-root))

(use-package bibtex
  :config
  (setq! bibtex-dialect 'biblatex
         bibtex-entry-format '(numerical-fields page-dashes whitespace inherit-booktitle realign
                               last-comma delimiters unify-case braces strings sort-fields)
         bibtex-align-at-equal-sign t)

  ;; NOTE(nox): Key generation
  (setq! bibtex-autokey-names 2
         bibtex-autokey-names-stretch 1
         bibtex-autokey-name-case-convert #'capitalize
         bibtex-autokey-name-separator nil
         bibtex-autokey-additional-names "EtAl"
         bibtex-autokey-name-year-separator "-"
         bibtex-autokey-year-length 4
         bibtex-autokey-year-title-separator "-"
         bibtex-autokey-titleword-case-convert-function #'capitalize
         bibtex-autokey-titlewords 5
         bibtex-autokey-titleword-length 5
         bibtex-autokey-titleword-ignore '("[Aa]n?" "[Oo][fn]" "[Tt]he" ".*[^[:upper:][:lower:]0-9].*")
         bibtex-autokey-titleword-separator nil)

  (defun +bibtex-replace-key ()
    "Replace the key in the entry."
    (let ((new-key (bibtex-generate-autokey)) old-key duplicate-pos)
      (bibtex-beginning-of-entry)

      (re-search-forward bibtex-entry-maybe-empty-head)
      (setq old-key (match-string bibtex-key-in-head))

      (unless (string= new-key old-key)
        (when old-key
          (delete-region (match-beginning bibtex-key-in-head)
                         (match-end       bibtex-key-in-head)))

        (save-restriction
          (widen)
          (while (save-excursion (setq duplicate-pos (bibtex-search-entry new-key)))
            (save-excursion
              (goto-char duplicate-pos)
              (bibtex-copy-entry-as-kill)
              (switch-to-buffer-other-window "*duplicate entry*")
              (bibtex-yank))
            (setq new-key (bibtex-read-key "Duplicate Key found, edit: " new-key))))

        (insert new-key)
        (kill-new new-key)

        (let* ((pdf-dir (expand-file-name (file-name-nondirectory nox-bibliography-files-dir)
                                          (file-name-directory buffer-file-name)))
               (old-pdf (and old-key (expand-file-name (concat old-key ".pdf") pdf-dir)))
               (old-exists (and old-pdf (file-exists-p old-pdf)))
               (new-pdf (expand-file-name (concat new-key ".pdf") pdf-dir))
               (new-exists (file-exists-p new-pdf)))
          (when new-exists
            (if old-exists
                (rename-file new-pdf (make-temp-file new-pdf) 'replace)
              (when (y-or-n-p "A PDF exists with that key. Do you want to remove it? ")
                (move-file-to-trash new-pdf))))

          (when old-exists (rename-file old-pdf new-pdf))))))

  (defun bibtex-autokey-get-year ()
    "Return year field contents as a string obeying `bibtex-autokey-year-length'."
    (let* ((yearfield (bibtex-autokey-get-field "year"))
           (date (bibtex-autokey-get-field "date"))
           (year (cond ((and yearfield (> (length yearfield) 0)) yearfield)
                       ((and date (string-match "[0-9]+X*" date)) (match-string 0 date))
                       (t ""))))
      (substring year (max 0 (- (length year) bibtex-autokey-year-length)))))

  (defun bibtex-autokey-get-title ()
    "Get title field contents up to a terminator.
Return the result as a string."
    (let ((case-fold-search t)
          (titlestring
           (bibtex-autokey-get-field "title"
                                     bibtex-autokey-titleword-change-strings)))
      (when (= (length titlestring) 0)
        (setq titlestring (bibtex-autokey-get-field "maintitle"
                                                    bibtex-autokey-titleword-change-strings)))
      ;; ignore everything past a terminator
      (if (string-match bibtex-autokey-title-terminators titlestring)
          (setq titlestring (substring titlestring 0 (match-beginning 0))))
      ;; gather words from titlestring into a list.  Ignore
      ;; specific words and use only a specific amount of words.
      (let ((counter 0)
            (ignore-re (concat "\\`\\(?:"
                               (mapconcat 'identity
                                          bibtex-autokey-titleword-ignore "\\|")
                               "\\)\\'"))
            titlewords titlewords-extra word)
        (while (and (or (not (numberp bibtex-autokey-titlewords))
                        (< counter (+ bibtex-autokey-titlewords
                                      bibtex-autokey-titlewords-stretch)))
                    (string-match "\\b\\w+" titlestring))
          (setq word (match-string 0 titlestring)
                titlestring (substring titlestring (match-end 0)))
          ;; Ignore words matched by one of the elements of
          ;; `bibtex-autokey-titleword-ignore'.  Case is significant.
          (unless (let (case-fold-search)
                    (string-match ignore-re word))
            (setq counter (1+ counter))
            (if (or (not (numberp bibtex-autokey-titlewords))
                    (<= counter bibtex-autokey-titlewords))
                (push word titlewords)
              (push word titlewords-extra))))
        ;; Obey `bibtex-autokey-titlewords-stretch':
        ;; If by now we have processed all words in titlestring, we include
        ;; titlewords-extra in titlewords.  Otherwise, we ignore titlewords-extra.
        (unless (string-match "\\b\\w+" titlestring)
          (setq titlewords (append titlewords-extra titlewords)))
        (mapconcat 'bibtex-autokey-demangle-title (nreverse titlewords)
                   bibtex-autokey-titleword-separator))))

  (defun bibtex-clean-entry (&optional new-key called-by-reformat)
    (interactive "P")
    (let ((case-fold-search t)
          (start (bibtex-beginning-of-entry))
          (_ (or (looking-at bibtex-any-entry-maybe-empty-head)
                 (error "Not inside a BibTeX entry")))
          (entry-type (bibtex-type-in-head))
          (key (bibtex-key-in-head)))

      (cond ((bibtex-string= entry-type "preamble") (error "No clean up of @Preamble entries"))
            ((bibtex-string= entry-type "string") (setq entry-type 'string))
            (t (bibtex-format-entry)))

      (when (or new-key (not key))
        (+bibtex-replace-key)
        (bibtex-beginning-of-entry)
        (looking-at bibtex-any-entry-maybe-empty-head)
        (setq key (bibtex-key-in-head)))

      (unless called-by-reformat
        (let* ((end (save-excursion
                      (bibtex-end-of-entry)
                      (if (re-search-forward
                           bibtex-entry-maybe-empty-head nil 'move)
                          (goto-char (match-beginning 0)))
                      (point)))
               (entry (buffer-substring start end))
               ;; include the crossref key in index
               (index (let ((bibtex-maintain-sorted-entries 'crossref))
                        (bibtex-entry-index))) ; moves point to end of head
               error)
          ;; sorting
          (if (and bibtex-maintain-sorted-entries
                   (not (and bibtex-sort-ignore-string-entries
                             (eq entry-type 'string))))
              (progn
                (delete-region start end)
                (setq error (not (bibtex-prepare-new-entry index))
                      start (point)) ; update start
                (save-excursion (insert entry)))
            (bibtex-search-entry key)
            (setq error (or (/= (point) start)
                            (bibtex-search-entry key nil end))))
          (if error
              (error "New inserted entry yields duplicate key"))
          (dolist (buffer (bibtex-initialize))
            (with-current-buffer buffer
              (if (cdr (assoc-string key bibtex-reference-keys))
                  (error "Duplicate key in %s" (buffer-file-name)))))

          ;; Only update `bibtex-strings' and `bibtex-reference-keys'
          ;; if they have been built already.
          (cond ((eq entry-type 'string)
                 ;; We have a @String entry.
                 (unless (or (functionp bibtex-strings)
                             (assoc key bibtex-strings))
                   (push (cons key (bibtex-text-in-string
                                    (bibtex-parse-string) t))
                         bibtex-strings)))
                ;; We have a normal entry.
                ((not (functionp bibtex-reference-keys))
                 (let ((found (assoc key bibtex-reference-keys)))
                   (cond ((not found)
                          (push (cons key t) bibtex-reference-keys))
                         ((not (cdr found))
                          ;; Turn a crossref key into a header key
                          (setq bibtex-reference-keys
                                (cons (cons key t)
                                      (delete (list key) bibtex-reference-keys))))))
                 ;; If entry has a crossref key, it goes into the list
                 ;; `bibtex-reference-keys', too.
                 (if (and (nth 1 index)
                          (not (assoc (nth 1 index) bibtex-reference-keys)))
                     (push (list (nth 1 index)) bibtex-reference-keys)))))

        ;; final clean up
        (if bibtex-clean-entry-hook
            (save-excursion
              (save-restriction
                (bibtex-narrow-to-entry)
                (run-hooks 'bibtex-clean-entry-hook)))))

      ;; NOTE(nox): Check if there are any missing fields
      (let ((bibtex-entry-format '(required-fields)))
        (cond ((bibtex-string= entry-type "preamble") (error "No clean up of @Preamble entries"))
              ((bibtex-string= entry-type "string") (setq entry-type 'string))
              (t (bibtex-format-entry)))))))

(use-package reftex :config (setq! reftex-default-bibliography nox-bibliography-refs-file))

(use-package citar :elpaca t
  :config
  (setq! citar-bibliography  (list nox-bibliography-refs-file)
         citar-library-paths (list nox-bibliography-files-dir)
         citar-notes-paths   (list nox-bibliography-notes-dir)
         citar-file-additional-files-separator "-"
         citar-indicators (list (citar-indicator-create :symbol "" :function #'citar-has-files :tag "has:files")
                                (citar-indicator-create :symbol "" :function #'citar-has-links :tag "has:links")
                                (citar-indicator-create :symbol "" :function #'citar-has-notes :tag "has:notes"))))

(use-package citar-embark :elpaca t
  :after citar embark :demand
  :config (citar-embark-mode))
#+end_src

*** Calc
#+begin_src emacs-lisp
(use-package calc
  :config
  (setq! calc-float-format '(eng 0)))
#+end_src

*** CMake
#+begin_src emacs-lisp
(use-package cmake-ts-mode
  :mode (("CMakeLists\\.txt\\'" . cmake-ts-mode)
         ("\\.cmake\\'"         . cmake-ts-mode))
  :config
  (setq! cmake-ts-mode-indent-offset 4
         cmake-ts-mode--indent-rules `((cmake ((node-is ")") parent-bol 0)
                                              ((node-is "else_command") parent-bol 0)
                                              ((node-is "elseif_command") parent-bol 0)
                                              ((node-is "endforeach_command") parent-bol 0)
                                              ((node-is "endfunction_command") parent-bol 0)
                                              ((node-is "endif_command") parent-bol 0)
                                              ((parent-is "source_file") parent-bol 0)
                                              ((parent-is "argument_list") parent-bol cmake-ts-mode-indent-offset)
                                              ((parent-is "body") parent-bol cmake-ts-mode-indent-offset)))))
#+end_src

*** Compilation
**** General settings and bindings
#+BEGIN_SRC emacs-lisp
(use-package compile
  :general
  (nox-leader "c" '(+compile :wk "Compile"))
  ("M-g n" '(nox@error/next-error :wk "Next error")
   "M-g p" '(nox@error/previous-error :wk "Previous error"))

  :config
  (defhydra nox@error ()
    "Errors"
    ("f" first-error "First")
    ("n" next-error "Next")
    ("p" previous-error "Previous")
    ("c" +compile "Recompile")
    ("q" nil "Quit"))

  (setq! compilation-always-kill t
         compilation-scroll-output 'first-error
         compilation-context-lines 2)

  (put 'compilation-error-regexp-alist 'safe-local-variable 'listp)

  (defun +compile|ansi-color-apply ()
    "Applies ansi codes to the compilation buffers. Meant for `compilation-filter-hook'."
    (with-silent-modifications (ansi-color-apply-on-region compilation-filter-start (point))))
  (add-hook! 'compilation-filter-hook #'+compile|ansi-color-apply)

  (defun +compile|resolve-wine-names (oldfun marker filename directory &rest formats)
    (setq filename (replace-regexp-in-string (rx letter ":") ""
                                             (replace-regexp-in-string (regexp-quote "\\") "/" filename)))
    (apply oldfun marker filename directory formats))
  (advice-add 'compilation-find-file :around #'+compile|resolve-wine-names)
#+END_SRC

**** Error matching
#+begin_src emacs-lisp
(setq! compilation-error-regexp-alist-alist nil
       compilation-transform-file-match-alist nil

       compilation-error-regexp-alist
       `(;; NOTE(nox): C/C++ (and Go)
         (,(rx bol (group-n 1 (*? nonl))
               (: ":" (* " ") (group-n 2 (+ num)))
               (? ":" (* " ") (group-n 4 (+ num)))
               ": " (* " ")
               (? (| (group-n 6 (| "warning"))
                     (group-n 7 (| "info" "information" "informational" "instantiated from"
                                   "required from" "note")))))
          1 (2 . 3) (4 . 5) (6 . 7))

         ;; NOTE(nox): Jai
         (,(rx bol (* space) (group-n 1 (*? nonl))
               (: ":" (group-n 2 (+ num)))
               (? "," (group-n 4 (+ num)))
               ": " (* " ") (? (| "Error" (group-n 6 (| "Warning"))) ":"))
          1 (2 . 3) (4 . 5) (6 . 7))

         ;; NOTE(nox): NVCC
         (,(rx bol (group-n 1 (*? nonl))
               (: "(" (group-n 2 (+ num)) ")")
               ":" (* " ") (: (| (group-n 6 (| "warning")) "error") (* nonl) ":"))
          1 (2 . 3) (4 . 5) (6 . 7))

         ;; NOTE(nox): IAR
         (,(rx (? "\"" (group-n 1 (*? nonl)) "\"," (*? space) (group-n 2 (+ num)))
               (*? space) (| "Fatal error" "Error" (group-n 6 "Warning") (group-n 7 "Remark"))
               "[" (+ alnum) "]:")
          1 2 nil (6 . 7))

         ;; NOTE(nox): Keil
         (,(rx "*** "
               (| "ERROR" (group-n 6 "WARNING"))
               " C" (+ num)
               " IN LINE " (group-n 2 (+ num))
               " OF " (group-n 1 (*? nonl)) ":")
          1 2 nil (6 . 7))))
#+end_src

**** Compilation command
#+BEGIN_SRC emacs-lisp
(defconst +compile-look-for
  '(("build_nox\\.sh"        sh   0)
    ("build_nox\\.jai"       jai  0)
    ("build\\(_.+\\)?\\.sh"  sh   1)
    ("build\\(_.+\\)?\\.jai" jai  1)
    ("first\\.jai"           jai  1)
    ("main\\.jai"            jai  1)
    ("\\(GNU\\)?[Mm]akefile" make 5)))

(defvar-local +compile-info nil)
(cl-defstruct +compile-info type path cmd sort-key (last-time '(0 0 0 1)) (rank-time '(0 0 0 1)) delete-window)
(defvar +compile-info-table (make-hash-table :test 'equal))

(defvar +compile-cmd-history nil)

(defsubst +compile-builder (path &optional type-desc)
  (let* ((type (or (car-safe type-desc) type-desc))
         (sort-key (if (consp type-desc) (cadr type-desc) 999))
         (info (or (gethash path +compile-info-table)
                   (and type (make-+compile-info :type type :path path
                                                 :cmd (cond ((eq type 'sh)   "%s")
                                                            ((eq type 'jai)  "jai %s")
                                                            ((eq type 'make) "make -k")
                                                            (t ""))
                                                 :sort-key sort-key)))))
    (and info (cons path info))))

(defun +compile (arg)
  (interactive "P")
  (let* ((set-default  (equal arg '(16)))
         (override-cmd (and arg t))
         (save-cmd     (or set-default (equal arg 0)))
         (calling-from (expand-file-name (or (buffer-file-name) "./")))
         (candidates (cl-loop for dir = (expand-file-name "./") then next
                              for next = (file-name-directory (directory-file-name dir))
                              until (string= dir next)
                              for custom-builder = (+compile-builder dir) if custom-builder collect custom-builder into list
                              nconc (cl-loop for lf in +compile-look-for
                                             for paths = (file-expand-wildcards (expand-file-name (car lf) dir) t t)
                                             nconc (cl-loop for path in paths
                                                            unless (assoc path dir-results)
                                                            collect (+compile-builder path (cdr lf)))
                                             into dir-results finally
                                             return (reverse dir-results))
                              into list
                              finally return
                              (nconc (sort (reverse list) (lambda (a b) (< (+compile-info-sort-key (cdr a))
                                                                           (+compile-info-sort-key (cdr b)))))
                                     (append (and (string= (file-name-extension calling-from) "jai")
                                                  (not (assoc calling-from list))
                                                  (list (+compile-builder calling-from 'jai)))
                                             (and set-default
                                                  (list (+compile-builder "Add custom builder..." 'new-custom)))))))
         chosen)
    (unless candidates (error "No builder found"))

    (setq chosen (or (and (not set-default) +compile-info)
                     (cdr (if set-default
                              (assoc (completing-read "Which builder? " (no-sorting! candidates) nil t nil nil nil) candidates)
                            (cl-loop with result = (car candidates)
                                     for builder in candidates
                                     if (time-less-p (+compile-info-rank-time (cdr result))
                                                     (+compile-info-rank-time (cdr builder)))
                                     do (setq result builder)
                                     finally return result)))))

    (when (eq (+compile-info-type chosen) 'new-custom)
      (setf (+compile-info-type chosen) 'custom)
      (setf (+compile-info-path chosen) (expand-file-name (read-directory-name "Base directory: " nil nil t)))
      (unless (string-prefix-p (+compile-info-path chosen) calling-from)
        (error "Directory '%s' isn't a prefix of '%s'" (+compile-info-path chosen) calling-from)))

    (let* ((path (+compile-info-path chosen))
           (dir (file-name-directory path))

           (real-root (projectile-project-root dir))
           (+projectile-root (or real-root dir))

           (buffer-name (format "*[%s] - Compile %s*"
                                (if real-root (projectile-project-name) (directory-file-name dir))
                                (file-relative-name path +projectile-root)))
           (buffer (get-buffer-create buffer-name))
           (existing-window (get-buffer-window buffer))
           (num-windows-before (length (window-list)))

           (cmd (+compile-info-cmd chosen)))

      (when override-cmd (setq cmd (read-string "Command: " cmd '+compile-cmd-history)))
      (setf (+compile-info-last-time chosen) (current-time))

      (when save-cmd    (setf (+compile-info-cmd chosen) cmd))
      (when set-default (setf (+compile-info-rank-time chosen) (+compile-info-last-time chosen)))

      (projectile-save-project-buffers)

      (setq cmd (string-replace "%s" (shell-quote-argument path) cmd))
      (setq cmd (string-replace "%f" (shell-quote-argument (or (file-remote-p calling-from 'localname) calling-from)) cmd))

      (with-current-buffer buffer
        (cd dir)
        (compilation-start cmd nil (lambda (&rest _) (buffer-name)))
        (setq-local +compile-info chosen))

      (unless existing-window (setf (+compile-info-delete-window chosen) (/= (length (window-list)) num-windows-before)))
      (puthash (+compile-info-path chosen) chosen +compile-info-table))))

(defun +compile|bury-buffer (buffer string)
  "Bury compilation buffer if it succeeded."
  (with-current-buffer buffer
    (when-let ((info +compile-info))
      (message "Compilation time: %.3fs" (float-time (time-subtract (current-time) (+compile-info-last-time info))))
      (when (and (string= string "finished\n")
                 (save-excursion (not (ignore-errors (compilation-next-error 1 nil 1)))))
        (let ((windows (get-buffer-window-list buffer t)))
          (dolist (window windows)
            (if (and (> (length (window-list (window-frame window))) 1)
                     (+compile-info-delete-window info))
                (delete-window window)
              (switch-to-prev-buffer window))))
        (bury-buffer buffer)))))
(add-hook 'compilation-finish-functions '+compile|bury-buffer)
#+END_SRC

**** End
#+BEGIN_SRC emacs-lisp
) ;; (use-package compile)
#+END_SRC

*** Denote
#+begin_src emacs-lisp
(use-package denote :elpaca t
  :general
  (:prefix "C-c n"
           "n"   #'denote-open-or-create
           "s"   #'+denote/search-in-all-notes
           "N"   #'denote-type
           "d"   #'denote-date
           "t"   #'denote-template
           "i"   #'denote-link
           "I"   #'denote-add-links
           "b"   #'denote-backlinks
           "f f" #'denote-find-link
           "f b" #'denote-find-backlink
           "r"   #'denote-rename-file
           "R"   #'denote-rename-file-using-front-matter)
  (:prefix "C-c n" :keymaps 'dired-mode-map
           "C-i" #'denote-link-dired-marked-notes
           "C-r" #'denote-dired-rename-marked-files
           "C-R" #'denote-dired-rename-marked-files-using-front-matter)
  :init
  (add-hook! dired-mode #'denote-dired-mode-in-directories)
  (after! org-capture
    (add-to-list 'org-capture-templates
                 '("n" "New denote" plain (file denote-last-path) #'denote-org-capture
                   :no-save t :immediate-finish nil :kill-buffer t :jump-to-captured t)))

  :config
  (setq! denote-directory "~/archive/notes"
         denote-known-keywords '()
         denote-date-prompt-use-org-read-date t
         denote-backlinks-show-context t)

  (defun +denote/search-in-all-notes ()
    (interactive)
    (consult-ripgrep denote-directory)))
#+end_src

*** Dired
**** Base and utility functions
#+BEGIN_SRC emacs-lisp
(use-package dired
  :config
  (after! dired+ ;; This overrides the keys, so only after loading
    (general-def :keymaps 'dired-mode-map
      "e" #'nox/ediff-files
      "X" #'+dired/open-externally))

  (setq! dired-auto-revert-buffer t
         dired-dwim-target t
         dired-hide-details-hide-symlink-targets nil
         dired-listing-switches "-laGh1v --group-directories-first"
         dired-recursive-copies 'always
         dired-recursive-deletes 'always
         image-dired-dir (concat nox-cache-dir "image-dired/")
         image-dired-db-file (concat image-dired-dir "db.el")
         image-dired-gallery-dir (concat image-dired-dir "gallery/")
         image-dired-temp-image-file (concat image-dired-dir "temp-image")
         image-dired-temp-rotate-image-file (concat image-dired-dir "temp-rotate-image"))

  (defun dired|create-non-existent-directory ()
    "Create missing directories when creating new files."
    (let ((parent-directory (file-name-directory buffer-file-name)))
      (when (and (not (file-exists-p parent-directory))
                 (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
        (make-directory parent-directory t))))
  (push #'dired|create-non-existent-directory find-file-not-found-functions)
#+END_SRC

***** Open externally
#+begin_src emacs-lisp
(defun +dired/open-externally ()
  (interactive)
  (let ((file (dired-get-filename nil t)))
    (when file (nox/open-externally file))))
#+end_src

***** PDF compressor and merger
#+BEGIN_SRC emacs-lisp
(defun nox-pdf-compress-merge-sentinel (process event)
  (unless (process-live-p process)
    (let ((exit-code (process-exit-status process)))
      (if (/= exit-code 0)
          (error "Something went wrong with the process! Exit code: %d" exit-code)
        (let* ((data (process-get process 'data))
               (output (car data))
               (temp-output-name (car output))
               (output-name (cdr output))
               (files (cdr data)))
          (dolist (file files)
            (move-file-to-trash file))
          (ignore-errors (rename-file temp-output-name output-name 1))
          (message "Done compressing/merging PDF(s)."))))))

(defun nox/pdf-compress-merge (arg)
  (interactive "P")
  (let ((files (dired-get-marked-files))
        (quality "ebook")
        (color-conv-strat "UseDeviceIndependentColor")
        (temp-output-name (format "MERGED_FILE_%d.pdf" (random 100000)))
        output-name)
    (if (< (length files) 1)
        (user-error "You must select at least one file!")
      (when arg
        (setq quality (completing-read
                       "Compression type: "
                       '("default" "screen" "ebook" "printer" "prepress")
                       nil t nil nil quality)
              color-conv-strat (completing-read
                                "Color conversion strategy: "
                                '("LeaveColorUnchanged" "Gray" "RGB" "sRGB" "CMYK" "UseDeviceIndependentColor")
                                nil t nil nil color-conv-strat)))
      (setq output-name (completing-read "Output name: "
                                         (when (= (length files) 1)
                                           files)))
      (when (= (length output-name) 0) (setq output-name "Output.pdf"))
      (process-put (make-process
                    :name "PDF Compressor/Merger"
                    :buffer "*PDF Compress*"
                    :connection-type 'pipe
                    :sentinel 'nox-pdf-compress-merge-sentinel
                    :command
                    (append
                     (list "gs" "-dBATCH" "-dNOPAUSE" "-q" "-sDEVICE=pdfwrite"
                           (concat "-dColorConversionStrategy=/" color-conv-strat)
                           (concat "-sOutputFile=" temp-output-name)
                           (concat "-dPDFSETTINGS=/" quality))
                     files))
                   'data (cons (cons temp-output-name output-name)  files)))))
#+END_SRC

***** Whiteboard image creator
#+BEGIN_SRC emacs-lisp
(defun nox/whiteboard ()
  (interactive)
  (unless (executable-find "whiteboard") (error "No whiteboard script :("))
  (let ((window-config (current-window-configuration))
        (files (dired-get-marked-files)))
    (dolist (file files)
      (let ((result-name (file-name-sans-extension file))
            (pos (make-vector 4 nil))
            (command-arguments "whiteboard"))
        (find-file file)
        (if (not (eq major-mode 'image-mode))
            (message "%s is not an image!" file)

          (let* ((displayed-image (image-get-display-property))
                 (original-image (image--image-without-parameters displayed-image))
                 (factor (/ (float (car (image-size original-image t)))
                            (float (car (image-size displayed-image t)))))
                 (index 0)
                 event)
            (plist-put (cdr (image-get-display-property)) :pointer 'arrow)

            (while (and (not (eq event 'return)) (not (aref pos 3)))
              (delete-other-windows)
              (setq event (read-event "Next corner..."))
              (when (and (listp event) (eq 'mouse-1 (car event))
                         (eq (selected-window) (posn-window (event-start event))))
                (setf (aref pos index) (cons (* (car (posn-x-y (event-start event))) factor)
                                             (* (cdr (posn-x-y (event-start event))) factor)))
                (setq index (1+ index)))))

          (when (aref pos 3)
            (setq command-arguments
                  (concat command-arguments " -c \""
                          (mapconcat (lambda (x) (format "%d,%d" (car x) (cdr x)))
                                     pos " ")
                          "\"")))

          (setq command-arguments (concat command-arguments " " (read-string "Extra arguments: ") " "
                                          (shell-quote-argument file) " " (shell-quote-argument result-name)
                                          "-whiteboard.png"))

          (async-shell-command command-arguments))))
    (set-window-configuration window-config)
    (dired-unmark-all-marks)))
#+END_SRC

***** Diff two files
#+BEGIN_SRC emacs-lisp
(defun nox/ediff-files ()
  (interactive)
  (let ((files (dired-get-marked-files))
        (wnd (current-window-configuration)))
    (if (<= (length files) 2)
        (let ((file1 (car files))
              (file2 (if (cdr files)
                         (cadr files)
                       (read-file-name
                        "file: "
                        (dired-dwim-target-directory)))))
          (if (file-newer-than-file-p file1 file2)
              (ediff-files file2 file1)
            (ediff-files file1 file2))
          (add-hook 'ediff-after-quit-hook-internal
                    (lambda ()
                      (setq ediff-after-quit-hook-internal nil)
                      (set-window-configuration wnd))))
      (error "no more than 2 files should be marked"))))
#+END_SRC

***** Rsync
#+BEGIN_SRC emacs-lisp
(defun nox/dired-rsync (dest)
  (interactive
   (list
    (expand-file-name
     (read-file-name
      "Rsync to:"
      (dired-dwim-target-directory)))))
  (let ((files (dired-get-marked-files
                nil current-prefix-arg))
        (rsync-command
         "rsync -arvz --progress "))
    (dolist (file files)
      (setq rsync-command
            (concat rsync-command
                    (shell-quote-argument file)
                    " ")))
    (setq rsync-command
          (concat rsync-command
                  (shell-quote-argument dest)))
    (async-shell-command rsync-command "*rsync*")
    (other-window 1)))
#+END_SRC

***** End
#+BEGIN_SRC emacs-lisp
) ;; (use-package dired)
#+END_SRC

**** Diredfl and Dired+
#+BEGIN_SRC emacs-lisp
(use-package diredfl :elpaca t
  :after dired :demand
  :config (diredfl-global-mode))

(use-package dired+ :elpaca (dired+ :host github :repo "emacsmirror/emacswiki.org" :branch "master"
                                    :files ("dired+.el"))
  :after dired :demand)
#+END_SRC

*** Document viewers
**** Doc View
#+BEGIN_SRC emacs-lisp
(use-package doc-view
  :config
  (setq! doc-view-resolution 400))
#+END_SRC

**** PDF Tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools :elpaca t
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :commands (org-pdfview-open org-pdfview-store-link org-pdfview-complete-link)
  :general
  (:keymaps 'pdf-view-mode-map
            "C-s" 'isearch-forward
            [remap consult-goto-line] 'pdf-view-goto-page

            "C-b" '+pdf-view-scroll-page-left
            "C-f" '+pdf-view-scroll-page-right
            "<M-mouse-4>" 'image-backward-hscroll
            "<M-mouse-5>" 'image-forward-hscroll)
  :config
  (unless (or noninteractive (eq this-command 'pdf-tools-install))
    (pdf-tools-install))

  (defun +pdf-view-scroll-page-left ()
    (interactive)
    (image-backward-hscroll (window-width)))

  (defun +pdf-view-scroll-page-right ()
    (interactive)
    (image-forward-hscroll (window-width)))

  ;; Adapted from https://github.com/markus1189/org-pdfview
  (defun org-pdfview-open (link)
    "Open LINK in pdf-view-mode."
    (cond ((string-match "\\(.*\\)::\\([0-9]*\\)\\+\\+\\([[0-9]\\.*[0-9]*\\)"  link)
           (let* ((path (match-string 1 link))
                  (page (string-to-number (match-string 2 link)))
                  (height (string-to-number (match-string 3 link))))
             (org-open-file path 1)
             (pdf-view-goto-page page)
             (image-set-window-vscroll
              (round (/ (* height (cdr (pdf-view-image-size))) (frame-char-height))))))
          ((string-match "\\(.*\\)::\\([0-9]+\\)$"  link)
           (let* ((path (match-string 1 link))
                  (page (string-to-number (match-string 2 link))))
             (org-open-file path 1)
             (pdf-view-goto-page page)))
          (t (org-open-file link 1))))

  (defun org-pdfview-store-link ()
    "Store a link to a pdfview buffer."
    (when (eq major-mode 'pdf-view-mode)
      (let* ((path buffer-file-name)
             (page (number-to-string (pdf-view-current-page)))
             (link (concat "pdfview:" path "::" page))
             (description (concat (file-name-nondirectory path) " at page " page)))
        (org-store-link-props
         :type "pdfview"
         :link link
         :description description))))

  (defun org-pdfview-complete-link (&optional arg)
    "Use the existing file name completion for file.
Links to get the file name, then ask the user for the page number
and append it."
    (concat (replace-regexp-in-string "^file:" "pdfview:" (org-file-complete-link arg))
            "::"
            (read-from-minibuffer "Page:" "1")))

  ;; NOTE(nox): Show page number
  (define-pdf-cache-function pagelabels)
  (add-hook 'pdf-view-mode-hook
            (lambda ()
              (setq-local mode-line-position
                          '(" ["
                            (:eval (nth (1- (pdf-view-current-page))
                                        (pdf-cache-pagelabels)))
                            "/"
                            (:eval (number-to-string (pdf-view-current-page)))
                            "/"
                            (:eval (number-to-string (pdf-cache-number-of-pages)))
                            "]")))))

(use-package pdf-annot :config (setq! pdf-annot-tweak-tooltips nil))
(use-package pdf-cache :config (setq! pdf-cache-image-limit 200))
(use-package pdf-view
  :config
  (setq! pdf-view-display-size 'fit-page
         pdf-view-use-imagemagick t))
#+END_SRC

**** Nov.el
#+BEGIN_SRC emacs-lisp
(use-package nov :elpaca t
  :mode (("\\.epub\\'" . nov-mode))
  :config
  (setq! nov-save-place-file (concat nox-cache-dir "nov-places")))
#+END_SRC

*** Diff viewers and conflict resolvers
#+BEGIN_SRC emacs-lisp
(use-package ediff
  :config
  (setq! ediff-split-window-function #'split-window-horizontally
         ediff-window-setup-function #'ediff-setup-windows-plain
         ediff-diff-options "-w")

  (add-hook! 'ediff-prepare-buffer-hook (when (derived-mode-p 'outline-mode) (outline-show-all)))

  (defvar ediff--saved-wconf nil)
  (add-hook! 'ediff-before-setup-hook (setq ediff--saved-wconf (current-window-configuration)))
  (add-hook! :append '(ediff-quit-hook ediff-suspend-hook) (set-window-configuration ediff--saved-wconf))

  (defun +ediff/copy-both-to-C ()
    (interactive)
    (ediff-copy-diff ediff-current-difference nil 'C nil
                     (concat
                      (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                      (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
  (add-hook! 'ediff-keymap-setup-hook (define-key ediff-mode-map "d" 'ediff/copy-both-to-C)))

(use-package smerge-mode
  :config
  (defhydra +smerge@commands
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _SPC_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("SPC" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("ZZ" (lambda ()
            (interactive)
            (save-buffer)
            (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  (add-hook! 'magit-diff-visit-file (when smerge-mode (+smerge@commands/body))))
#+END_SRC

*** Eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :config
  (setq! eshell-directory-name (concat nox-cache-dir "eshell/")))
#+END_SRC

*** GDB
#+BEGIN_SRC emacs-lisp
(use-package gdb-mi :elpaca (gdb-mi :host github :repo "weirdNox/emacs-gdb"
                                    :files ("*.el" "*.c" "*.h" "Makefile"))
  :init
  (fmakunbound 'gdb)
  (fmakunbound 'gdb-enable-debug)
  (fmakunbound 'gud-gdb))
#+END_SRC

*** Git
#+BEGIN_SRC emacs-lisp
(use-package transient :elpaca t
  :init
  (setq! transient-levels-file  (concat nox-etc-dir   "transient/levels.el")
         transient-values-file  (concat nox-etc-dir   "transient/values.el")
         transient-history-file (concat nox-cache-dir "transient/history.el")))

(use-package magit :elpaca t
  :when (executable-find "git")
  :config
  (setq! magit-diff-refine-hunk 'all
         magit-bury-buffer-function 'magit-mode-quit-window))

(use-package magit-submodule
  :config
  (transient-define-suffix magit-submodule-update (modules args)
    "Update MODULES by checking out the recorded commits."
    :class 'magit--git-submodule-suffix
    :description "Update         git submodule update [--init] [--remote] [--no-fetch]
                      [--force] [--checkout|--rebase|--merge] [--recursive]"
    (interactive (list (magit-module-confirm "Update" 'magit-module-worktree-p)
                       (magit-submodule-arguments "--init" "--remote" "--no-fetch" "--force"
                                                  "--checkout" "--rebase" "--merge" "--recursive")))
    (magit-with-toplevel (magit-run-git-async "submodule" "update" args "--" modules)))

  (transient-define-suffix +magit-submodule-update-all (args)
    "Update all submodules"
    :class 'magit--git-submodule-suffix
    :description "Update all modules    git submodule update [--init] [--remote] [--no-fetch]
                             [--force] [--checkout|--rebase|--merge] [--recursive]"
    (interactive (list (magit-submodule-arguments "--init" "--remote" "--no-fetch" "--force"
                                                  "--checkout" "--rebase" "--merge" "--recursive")))
    (magit-with-toplevel (magit-run-git-async "submodule" "update" args)))

  (transient-append-suffix 'magit-submodule '(0 -1) '("-i" "Also initialize" "--init"))
  (transient-append-suffix 'magit-submodule '(2 -1) '("U" +magit-submodule-update-all))

  (transient-append-suffix 'magit-fetch '(0 0) '("-P" "Prune tags" "--prune-tags")))

(use-package magit-patch
  :config
  (transient-define-argument magit-format-patch:--output ()
    :description "Output to file"
    :class 'transient-option
    :key "-o     "
    :argument "--output="
    :reader #'transient-read-file)
  (transient-append-suffix 'magit-patch-create "C-m o" '(magit-format-patch:--output)))
#+END_SRC

*** Misc
**** Apropos
#+BEGIN_SRC emacs-lisp
(use-package apropos
  :config
  (setq! apropos-do-all t))
#+END_SRC

**** Calendar and holidays
#+BEGIN_SRC emacs-lisp
(use-package calendar
  :config
  (setq! calendar-week-start-day 1
         calendar-location-name "Porto"
         calendar-latitude  41.1579
         calendar-longitude -8.6291
         calendar-date-display-form calendar-european-date-display-form))

(use-package holidays
  :config
  (setq! calendar-holidays
         '((holiday-fixed  1  1    "New Year's Day")
           ;; (holiday-easter-etc -47 "Carnival")
           (holiday-easter-etc  -2 "Good Friday")
           (holiday-easter-etc   0 "Easter")
           (holiday-fixed  4 25    "Freedom Day")
           (holiday-fixed  5  1    "Labour Day")
           (holiday-easter-etc  60 "Corpus Christi")
           (holiday-fixed  6 10    "Portugal Day")
           (holiday-fixed  8 15    "Assumption")
           (holiday-fixed 10  5    "Republic Day")
           (holiday-fixed 11  1    "All Saints Day")
           (holiday-fixed 12  1    "Restoration of Independence")
           (holiday-fixed 12  8    "Immaculate Conception")
           (holiday-fixed 12 25    "Christmas"))))
#+END_SRC

**** Help
#+BEGIN_SRC emacs-lisp
(use-package help
  :config
  (setq! help-window-select t))
#+END_SRC

**** Spelling
#+BEGIN_SRC emacs-lisp
(use-package ispell
  :config
  (setq! ispell-program-name (or (executable-find "hunspell")
                                 (executable-find "aspell")
                                 (executable-find "ispell")
                                 "ispell")))
#+END_SRC

**** Uniquify
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config
  (setq! uniquify-buffer-name-style 'forward
         uniquify-separator "/"
         uniquify-after-kill-buffer-p t))
#+END_SRC

**** Time
#+BEGIN_SRC emacs-lisp
(use-package time
  :init
  (setq! display-time-24hr-format t
         display-time-default-load-average nil)
  (display-time-mode))
#+END_SRC

*** SageMath
#+begin_src emacs-lisp
(use-package sage-shell-mode :elpaca t
  :init
  (sage-shell:define-alias))
#+end_src

*** Tramp
#+BEGIN_SRC emacs-lisp
(use-package tramp
  :config
  (setq! tramp-default-method "ssh"
         tramp-remote-path '(tramp-own-remote-path "/usr/bin" "/usr/sbin" "/bin" "/sbin")
         tramp-backup-directory-alist '(("." . "/tmp/tramp-backup-files/"))
         tramp-auto-save-directory   (concat nox-cache-dir "tramp-auto-save/")
         tramp-persistency-file-name (concat nox-cache-dir "tramp-persistency.el")
         tramp-default-proxies-alist '(((regexp-quote (system-name)) nil nil)))

  ;; NOTE(nox): Add version that forwards ssh-agent
  (let ((cdr (copy-tree (cdr (assoc "ssh" tramp-methods)))))
    (cl-pushnew '("-A") (cadr (assoc 'tramp-login-args cdr)) :test #'equal)
    (cl-pushnew (cons "sshA" cdr) tramp-methods :test #'equal)))
#+END_SRC

** Keybindings
*** Global keybindings
#+BEGIN_SRC emacs-lisp
(general-def
  "<C-return>"   #'nox/open-line-below
  "<C-M-return>" #'nox/open-line-above
  "<backtab>" #'indent-for-tab-command
  "<C-tab>" #'indent-region
  "M-o" #'other-window
  "M-O" (lambda! (other-window -1))
  "C-x C-c" #'nox/exit-emacs)

(nox-leader
  :infix "f"
  ""  '(:ignore t :wk "Files")
  "f" '(find-file :wk "Open")
  "s" '(save-buffer :wk "Save")
  "r" '(nox/rename-file-and-buffer :wk "Rename current")
  "k" '(nox/delete-file-and-buffer :wk "Delete current")
  "b" '(hexl-find-file :wk "Open binary")
  "l" '(find-file-literally :wk "Open literally"))
#+END_SRC

*** Which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key :elpaca t
  :defer 1
  :after-call pre-command-hook
  :config
  (setq! which-key-sort-order #'which-key-prefix-then-key-order
         which-key-sort-uppercase-first nil
         which-key-add-column-padding 1
         which-key-max-display-columns nil
         which-key-min-display-lines 6
         which-key-side-window-slot -10)
  (which-key-mode))
#+END_SRC
