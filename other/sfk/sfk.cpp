/*
   The Swiss File Knife Command Line Multi Function Tool
   =====================================================
   StahlWorks Technologies, http://stahlworks.com/
   Provided under the BSD license.

   The whole source code was created with Depeche View Professional,
   the world's fastest source code browser and editor.

   1.9.8
   -  rel: 12.04.2021, Major Update
   -  sum: instant web server for mobile image upload
           now allows folder access.
           added uuencode, uudecode, xxencode, xxdecode
           to embed binary files in plain text,
           e.g. in email or documentation.
           web client now supports basic authentication.
           sfk oload can now insert .xlsx sheet headers.
   -  CHG: sfk webserv: now allows sub directory access
           by default. use option -nosub for old behaviour.
           folders are listed in green and can be entered.
           adding -rw allows upload into sub directories.
   -  add: sfk uuencode, uudecode, xxencode, xxdecode
           to convert binary files to plain ASCII text,
           for embedding in email or documentation.
   -  add: sfk oload, ofilter: option -subnames to insert
           header lines with .xlsx sheet file names.
   -  add: sfk (x)find: option -notnames to list names
           of files not containing a pattern.
   -  add: sfk web, wget: options -user and -pw to set
           http basic authentication.
   -  add: general option -webuser, -webpw for commands
           that can acces http:// urls like filter.
   -  add: sfk pingdiff, find new devices in network.
   -  fix: sfk webserv: did not support filenames
           with accent and umlaut characters.
   -  fix: sfk webserv: -nolist did not work.
   -  add: sfk web, wget: option -noclose
           to disable "Connection: close" header.
   -  add: sfk fromclip: if clipboard is locked by another app
           then sfk auto retries to access it up to 5 times,
           waiting up to 500 msec. number of tries can be
           changed by general option -cliptries=n.
   -  chg: sfk fromclip: command chain is no longer stopped
           if no text is available, or access failed.
           a return code is now set for evaluation.
   -  add: sfk variables: #(size(v)) now tells the number
           of bytes in variable v, with text or binary data.
   -  add: sfk tcping, check if a server accepts connections.
   -  add: sfk snapto: -pure=2 now drops the :snapfile header.
   -  add: sfk run: sfk variable run.lastrc now contains
           the return code of the called program.
   -  chg: webserv: now drops "?parms" or "#bookmark"
           from given url to provide a file.
   -  chg: max filename/url length increased to 1024.
   -  add: sfk help var: variable expression 'ends' now tells
           if a string ends with a given text.
   -  add: run and -to output masks: now supports $relpath
           to insert sub path relative to start folder.
   -  add: webserv: more content types.
   -  add: sfk batch webreq.bat to create an example script
           with a fully defined web request.
   -  add: sfk webserv -rw: now shows a minimal progress
           indicator on file uploads.
   -  add: sfk udpdump/udpsend -broad for broadcast support.
   -  add: sfk atow, utow: option -nobom.
   -  add: sfk ... +calc -sum, add values from chain text.
   -  fix: better chain input detection with setvar, calc.
   -  chg: sfk ping: no longer requires admin rights
           on Windows 10. changed help text on that.
   -  chg: sfk webserv: now also accepts proxy-style requests
           starting with http://servername.
   -  del: sfk webserv: -wide listing w/o downloadable links.
   -  fix: sfk list mydir -tofile out.txt did not work.
   -  fix: sfk listcodes: examples
   -  fix: sfk snapto, md5gento: output file could not 
           be read by subsequent commands.
   -  add: knxsend/dump support for 16 bit values and text.
   internal:
   -  add: SFK_COLORS shortcuts b,w

   1.9.7
   Revision 2:
   -  rel: 17.09.2020, Major Update
   -  sum: important bugfix when reading text from stdin.
           improved web server. copy now copies folder times
           by default. improved web access options.
   -  FIX: Windows: type in.txt | sfk ... produced unexpected
           joined input lines due to a Visual 2015 runtime bug.
   -  fix: sync: unexpected difference listings on folder objects, 
           on sync to external disk. now size diffs are checked 
           only with files, not folders.
   -  CHG: copy/sync: now copies folder times by default.
           a one-time copy of many folder times may occur
           during the next backup. this can be disabled
           by option -nodirtime, or SET SFK_CONFIG=nodirtime
   -  add: copy/sync: -nodirtime to not copy folder times.
   -  add: sfk web: option -head[er] to add custom headers.
   -  add: sfk web: option -request to fully define
           the http request to use.
   -  add: sfk webserv -rw: multi file upload support.
   -  add: sfk webserv: -headers to show incoming headers.
   -  add: windows: auto adaption to changed console width.
   -  add: sfk run: write #(qname) to enquote variable 'name'
           by double quotes.
   -  chg: sfk calc: no longer expects chain input data
           if expression without #text is given.
   -  fix: sfk webserv: wrong content type for .JPG with
           capital letters.
   -  fix: copy/sync: -verbose did not work.
   -  fix: make-random-file with -text: wrong line ends
           and output file sizes under windows.
   -  add: unzip: -force to continue after errors.
   -  add: sfk video, how to edit video files.
           sfk batch vedit.bat creates a script
           to combine VLC and ffmpeg for video cutting.
   -  add: sft: -spat support, for run expressions.
   -  chg: main help: show sfk batch instead of sfk script.
   -  doc: script: rework of example commands.
   Initial Release:
   -  rel: 23.05.2020, Major Update
   -  sum: Improved file copy and backup, shown in a new script template.
           SFK for Mac OS/X is now available as a 64-bit binary.
           Improved FTP/SFT clients. Mobile friendly web server.
           Improved batch support on linux. Many bug fixes and detail improvements.
   -  CHG: SFK for Windows: now uses the Visual Studio 2015 runtime
           also for 32-bit binaries (it always used it for the
           64 bit binaries). This may cause a one-time recopy of files
           with sfk copy/sync and sft cput, as the new runtime
           interprets file dates in daylight savings time different.
   -  CHG: SYNTAX CHANGE: sfk filter ++word1 ++word2 is deprecated.
           Use instead sfk filter -and+word1 -and+word2,
           or sfk filter "-+word1*word2" to search in given order.
           The "++" will be used in a future version to control
           command chaining data flow.
   -  CHG: SYNTAX CHANGE: script remarks starting like //text
           without any whitespace are now deprecated.
           sfk script, call, perline now require that "//" 
           remarks are followed by one space,
           to avoid ambiquities with //pathname UNC paths.
   -  FIX: sfk sel mydir +del a.txt deleted mydir files.
           now the parameter conflict produces an error.
   -  CHG: FTP/SFT CLIENT SYNTAX CHANGE: filenames containing
           whitespace like 'the dir/the file.txt' can no longer
           be typed as is, but must be surrounded by quotes "".
           this is because ftp/sft now allows to add another
           parameter, which is a different target filename.
   -  CHG: errors and warnings are now prefixed by the current
           sfk command name, to find script errors easier.
   -  chg: sfk batch: new example scripts. default is a small script
           with a simple file copy example. added option -full
           to create a large backup example script with different
           commands on the same file set.
   -  add: sfk ftp/sft put now supports a different remote file name.
   -  add: sfk ftp/sft get now supports a different local file name.
   -  add: sfk sft put: option -setexec to set executable flag
           on files when sending to a linux server.
   -  add: sfk webserv: mobile friendly layout
   -  add: script: empty parameters "" are now accepted the same
           way as option -noop (no operation), avoiding many
           unexpected syntax errors on optional input parameters.
   -  opt: sfk big, sfk late: massive performance improvement
           when listing many files.
   -  chg: unknown options now produce an immediate error with
           most commands, instead of a delayed or no error.
   -  chg: command chain no longer stops at +view.
   -  add: script -anyparms, alias for script -literal.
   -  chg: sfk clipsrc now also expands % to %%.
   -  chg: sfk dir/stat mydir +view now shows stats in dview.
   -  add: sfk list -withhead now passes header infos
           like 'listing n of n files' to command chain.
   -  add: sfk dir/big/late full colored +view support.
   -  add: sfk syncnames, heuristic file name change sync.
   -  add: sfk calc: experimental brackets support.
   -  add: sfk time: option -strfpat to use strftime format.
   -  add: sfk date: just show the current date.
   -  add: sfk batch on linux/mac: now does chmod +x on the
           created batch.
   -  add: sfk alias, mkcd on linux: detailed help in case
           of error how to use it.
   -  add: sfk alias, mkcd on linux: if done using sudo then
           the batch file owner is now set to the normal user.
   -  add: sfk sft: ~ as alias for localhost
   -  fix: sfk ftp/sft missing error text with single file.
   -  fix: sfk ... +view color of warnings was unreadable yellow,
           now it is magenta like the sfk white background scheme.
   -  fix: dir, snapto: wrong typed options caused to select
           all files of current folder.
   -  fix: -fileset: memory leaks on multiple use
           in subsequent commands.
   -  fix: sfk sel -fileset fname did not work.
   -  chg: warning "cannot read file stat" is now just "cannot read".
   -  doc: sft -showip
   internal:
   -  chg: tcpcon::read now returns -1 on connection close.
   -  add: tcpsend: support for -timeout option.
   -  chg: tcpsend: no longer adds CRLF by default.
           add 0x0d0a for the old behaviour.
   -  add: sfk rerun, sfk sft rerun based on new runtime
   -  add: -noqwild, yet incomplete and just for file selection
   -  fix: sfk sft mput /foo, mget /foo to send/receive only
           files starting like foo did not work. (internal)
   -  add: sfk sfs9, sf9 aliases.
   -  chg: chain.print for multi line text extended to 8 kb max
   -  dep: fileset remarks starting ";" (undocumented) are deprecated
   -  chg: internal filter +ls+ is now also deprecated
   -  del: options -addbin -copy -zip in processDirParms
   -  rv3: FileStat.read did not set utc,
           causing cput time diff with vc14
   -  rv3: added udpcast -revserv, udpget

   1.9.6
   Revision 2:
   -  rel: 22.02.2020, Minor Update
   -  sum: Fixed CRC checksum calculation with 64-bit sfk.
           Better handling of multiple network interfaces with sfk ip.
   -  FIX: sfk 64 bit: wrong crc checksum calculations.
           sfk zip created wrong crc checksums.
           sfk unzip showed wrong crc error messages.
           sfk crc, crcgento, crccheck produced
           wrong results.
   -  CHG: OUTPUT CHANGE: sfk ip under windows:
           now gives a list of all possible ip's
           if more than one network interface exists.
           the preferred ip can now be filtered by
           environment variable SFK_OWN_NET.
           for batch files the output of 'sfk ip'
           can also be predefined by SFK_OWN_IP.
   -  add: calc: now tolerates whitespace text.
   -  add: udpdump: sfk for windows: when listening 
           for multicast traffic sfk now listens
           on all network interfaces.
   -  doc: xed: reasons for unexpected line breaks.
   -  fix: compile: vc14 (vs2015) support.
   Initial Release:
   -  rel: 08.02.2020, Major Update
   -  sum: important bugfixes for file selection.
           improved help for general options.
           improved web server and scripting.
   -  FIX: multi directory file selection using
            -dir ... -subdir ... -dir ... [-file]
           selected far too few files, or stopped
           with an error if another -file was given.
           check your scripts for this combination.
   -  FIX: crash on some -dir -subdir usages in two
           subsequent chain commands.
   -  chg: httpserv: improved page layout with
           more compact file list output.
           added option -wide for old format.
   -  add: script: system variables
           sys.ownscript.name
           sys.ownscript.text
           to get the filename and text data
           of the current running script.
   -  add: crccheck -sane to skip files which are
           newer than the crc list.
   -  fix: option -fileset stopped the command chain,
           following commands like +filter were ignored.
   -  chg: select: can now use a list of filenames
           given by -flist.
   -  chg: xfind: now accepts filenames produced by
           a previous command (just as extract and
           xhexfind already did), allowing to run
           a nested search.
   -  chg: ascii: alignment of first hex codes,
           change of headline text.
   -  chg: sfk web: download limit default size
           increased from 30 to 100 mb.
   -  doc: full rework of sfk help options.
   -  doc: select, zip: -flist examples.
   -  doc: stat: option -flist.
   -  doc: xfind: how to run a nested search with
           xfind -names ... +xfind.
   -  doc: xfind: how to get result text and filename
           within the same line.
   -  doc: xfind: example how to search a mail inbox.
   -  add: support for zip extension .jmod
   internal:
   -  fix: possible crash with -fileset
   initial:
   -  add: webserv: option -usehta
   -  chg: rework of tcping, tohtml.
   -  add: tcpsend -force empty data support
   -  add: -every=2nd, 3rd etc.
   -  add: syncnames
   -  add: snapto outer time, size
   -  fix: chain.justNamesFilter nptr check
   -  add: mput, alias of putall

   1.9.5
   Revision 2:
   -  rel: 28.08.2019, Major Update
   -  sum: improved difflines and reading from std input.
   -  add: sfk jsonform, reformat JSON data for easy
           reading and searching
   -  add: SFKTray V1.1 now supports display of patterns
           up, down, left, right, all instead of just
           a single slot. for documentation and example
           see: sfk status
   -  add: SFKTray Full V1.1 now supports up to 3
           instances running in parallel,
           with a total of up to 27 lights.
   -  add: sfk sft(serv) option -notify=h to show an
           up or down arrow in SFKTray on file transfer
   -  add: tdifflines to use chain text
           together with a file name
   -  add: difflines option -swap to change
           order of input data
   -  add: windows: snapto -slow option to run with
           a lower process priority.
   -  add: windows: fromclip option -tofile x.
   -  chg: hexdump: can now use -pure -recsize=n
           to dump n input bytes per output record.
   -  fix: crash when using -i with empty input
   -  fix: mac compile
   Initial Release:
   -  rel: 04.06.2019, Major Update
   -  sum: sfk snapto can now include text from
           office files like .docx .xlsx .odt,
           allowing fast loading and browsing
           of the output file by Depeche View.
   -  add: sfk olist, list only office files
           within a folder.
   -  add: snapto: option -office to include text
           from office files like .docx .xlsx .odt
   -  add: snapto, ofind: option -justoffice to read only
           office files, but not plain text files.
   -  chg: no longer loading binaries with commands
           like snapto just due to a file mask,
           but still by .extension. use option -wlbin
           for the old behaviour.
   -  add: difflines: option to read from stdin.
   -  fix: difflines: example with variables.
   -  fix: require: if no version info was found
           it produced a non speaking error.
           now it assumes version 0.0.0
   -  fix: sfk ose: missing office file support.
   -  doc: help office: snapto examples.
   -  doc: sfk view: dview office notes.

   1.9.4
   Revision 3:
   -  rel: 21.03.2019, Minor Update
   -  sum: improved sfk name and rand. bugfix
           for simple expressions using ortext.
   -  fix: simple expressions: crash when using
           many [ortext] in the same search pattern.
   -  chg: name: no longer searches in meta data
           by default, e.g. sfk name 1234 no longer
           produces unexpected results because
           their filesize is 1234.
   -  add: name: option -withmeta and -meta
           to also search in meta data of index.
   -  add: name: -spat support.
   -  add: sfk fileserv, alias of sfk sftserv.
   -  add: sfk ... +put, alias of +sft ... cput.
   -  add: sfk ... +putall, alias of +sft ... mput.
   -  fix: rand: first value per process start
           contained very few random
   -  add: rand: now supports larger values,
           hex output, and setting a seed
   -  add: treesize: option -gb[yte] to list
           all sizes in gigabytes.
   -  add: ping: option -time to display reply
           time when pinging a single host
   -  doc: ping: info on graphical ping output
   Revision 2:
   -  rel: 16.02.2019, Major Update
   -  sum: Improved office file text search
           with options to produce UTF-8 output.
   -  fix: .xlsx content loading showed wrong
           output text in some cases.
   -  add: ofind, oload, ofilter: option -utfout 
           to keep UTF-8 encoding on output text.
   -  add: ofind: option -utfin to allow use of
           UTF-8 encoded search terms with -utfout.
   -  add: oload: option -raw to show xml content.
   -  chg: oload, ofilter: no longer shows 
           zip file comment.
   Initial Release:
   -  rel: 10.02.2019, Major Update
   -  sum: SFK can now search and load office
           file text contents, in Open Office
           format files like .docx .xlsx .ods .odt.
           Search functions now search only in
           text files by default.
   -  CHG: Syntax Change: xfind now only searches
           in plain text files, but not in binaries.
           use xfindbin to search also binary files.
   -  CHG: Syntax Change: find now only searches
           in plain text files, but not in binaries.
           use findbin to search also binary files.
   -  add: ofind, search text in office files like
           .docx .xlsx .ods .odt and plain text files.
   -  add: ofilter, filter text of an office file.
   -  add: oload, load text of an office file
           for display or further processing.
   -  add: sfk help office, for details about
           supported office file extensions.
   -  add: sfk alias, mkcd: support for SFK_PATH
           environment variable, to write batch files
           only into this folder.
   -  chg: sfk getdv: now also suggests to save
           to SFK_PATH if given.
   -  add: echo: option -stream for best output
           transfer to setvar or xed.
   -  dep: xtext is deprecated (redundant to xfind)
   -  dep: ftext is deprecated (redundant to find)
   -  fix: zipto: crash on sub folder names
           containing accent characters,
           especially on select ... +zipto.
   -  chg: sfk data: max content per symbol
           is now 8 kbytes instead of 1.
   -  fix: xed: sfk ... +xed without any patterns
           created unwanted color output.
   internal:
   rev3:
   -  add: fromtcp, replytcp
   -  del: olist documentation
   -  chg: unified execxfind

   1.9.3
   Revision 4:
   -  rel: 08.12.2018, Minor Update
   -  sum: improved scripting support.
           the free SFKTray lite can now display
           4 status lights.
   -  add: SFKTray Lite now supports 4 status slots.
   -  add: windows: fromclip +copy/move support.
           allows to mark filenames in cmd.exe
           then copy/move the marked names.
   -  add: sfk sel a.txt b.txt +copy out support.
   -  add: sfk filt in.txt -+pat +copy out support.
   -  add: addtovar: option -noline to not append
           extra linefeeds.
   -  add: setvar: support slash patterns by -spat.
   -  add: getvar: option -tofile to write
           variable content to a file.
   -  add: num: support of negative numbers.
   -  add: dir -juststat to show just statistics.
   -  add: ftpserv: -verbose now shows path info
           on invalid path error, -verbose=2 shows
           dump of input line.
   -  chg: ftp client: now -quiet no longer tells 
           "no filenames from previous commands".
   -  fix: rmtree: short confirm "rmtree." did not work.
   -  fix: dir repeated with +loop showed wrong
           number of total bytes.
   -  chg: sfk dir now supports -noname.
   -  doc: setvar: examples for string editing.
   -  doc: xtext: find lines not matching a pattern.
   -  doc: filter: file copy examples.
   Revision 3:
   -  rel: 01.11.2018, Major Update
   -  sum: improved scripting support. bugfix for scripts
           running in folders with spaces in their name.
   -  FIX: sfk batch: script did not work within
           folder names containing spaces,
           like C:\users\Foo Bar\myscript.bat.
           now sfk script "%~f0" with quotes is used.
           fixed also related commands like
           sfk samp sfk, sfk samp sfkbash.
   -  CHG: chaining: if chaining is stopped due to missing
           filenames it now shows a notice again by default,
           to avoid unexpected chain stops without any infos.
           the notice can no longer be suppressed by -quiet,
           but as always by -nonote.
   -  fix: option -quiet did not work globally.
   -  chg: chaining: -verbose no longer tells how the
           command chain is stepped. use -tracechain instead.
   -  add: general option -keepchain to never stop the
           command chain, even if commands that expect
           filenames get none.
   -  add: label: support for all general options.
   -  add: setglobalopt to set global options.
   -  add: chaining support with where, index, script, home.
   -  add: encode -base64: option -nowrap to keep
           output as one long line.
   -  fix: getcol: unexpected set of global -upat option.
   -  chg: sfk chars: now supports multiple code parameters.
   -  add: ffilter: warning on wrong parameter sequence.
   -  fix: copy -ltarg under windows showed source name.
   -  chg: zip reading: better error message on missing file.
   -  doc: tell: example how to print text starting with '+'.
   -  doc: wtou: added perline example.
   -  doc: if: info about limited nesting.
   -  doc: end: was not searchable.
   -  doc: status: infos about limited colors.
   -  doc: label: more detailed info about global options.
   -  doc: help opt: -tracechain.
   -  doc: help chain: info on "no files, stopping x".
   Revision 2:
   -  rel: 03.10.2018, Major Update
   -  sum: added easy installation under windows
           by a double click on sfk.exe, then key 1. 
           this copies sfk.exe to a folder c:\tools 
           and creates a shell icon on the desktop.
   -  add: sfk base: optional installation when running sfk
           by double click from windows explorer.
   -  CHG: Data Change: sfk index, name under windows
           no longer use files directly within C:\ 
           but only in a folder C:\zz-index, to avoid 
           user local storage in a VirtualStore folder.
           use sfk name -useold to read old index files.
           the new behaviour allows one C:\\ index file for
           all users on the same windows machine.
   -  add: predefined variable: sys.sfkver for sfk version
   -  add: predefined variable: sys.numcols for number of
           columns available in console
   -  fix: getcol, tabcol: caused unexpected double execution
           of following chain commands.
   -  add: clipsrc: -h help option
   -  del: clipxml: does not work, no longer documented.
   Initial Release:
   -  rel: 18.09.2018, Major Update
   -  sum: added sfk addtovar to collect text lines 
           in a variable, sfk crc to create crc-32 checksums,
           sfk difflines to list different unique lines 
           between two text files. improved ftp client
           compatibility. many detail improvements
           for scripting, like new variable functions.
   -  chg: Syntax Change: command chaining no longer allows
           data tunneling through non consuming commands.
           in a chain like cmd1 +cmd2 +cmd3 +cmd4 +cmd5
           it is no longer possible to send data from
           cmd1 to cmd3/4/5 if cmd2 uses no chain data
           (e.g. if, tell). this tunneling was inconsistent
           and caused endless conflicts by unwanted chain data
           in cmd3/4/5. use -keepdata or SET SFK_CONFIG=keepdata
           for the old behaviour which was inconsistent 
           and worked only sometimes.
   -  chg: Syntax Change: sfk if: no longer passes through
           any chain data, as this behaviour was ambiguous
           and caused endless unwanted chain input.
           this means combinations like
           +xed /a/b/ +if ... +xed /b/c/
           are no longer possible. use '+tif' instead,
           or global option -keepdata.
   -  add: sfk ... +tif for conditional execution
           requesting text and stream data explicitely.
   -  add: sfk ... +tgoto to jump to a label passing
           text and stream data explicitely.
   -  chg: Syntax Change: sfk md5: now only prints the
           checksum without filename if only a single
           filename is given. use option -name 
           for the old behaviour.
   -  chg: Data Change: sfk getvar -line no longer
           appends CR or LF at extracted line.
   -  chg: Data Change: web: no longer produces shell
           return code 9 on error, but 1, to be
           consistent with command chaining rc.
   -  FIX: linux: case insensitive pattern match
           and text extraction did not work,
           esp. with xed or xex.
   -  CHG: improved scripting: combinations like
           sfk echo foo +setvar a=text
           sfk echo foo +setvar a +if ... setvar b=text
           sfk echo foo +xex ... +setvar b=1
           no longer require 'then' in many cases.
   -  add: Simple Expressions: tag [skip] at the start
           of a pattern now skips this text completely
           and does not count it as a hit.
   -  chg: archive file extensions: extended the list 
           of archive files recognized by -[q]arc by
           more office file extensions. 
           for full details type: sfk help opt
   -  chg: no longer activating archive file read 
           implicitely with most functions.
           use -[q]arc instead.
   -  fix: ftpserv, httpserv: unwanted listing of
           zip file contents instead of zip file itself.
   -  add: sfk addtovar, append text as lines to a variable
   -  add: variables: #(strpos(a,b)) and #(contains(a,b))
           now searches content of variable b within
           text of variable a.
   -  add: variables: #(begins(a,'word')) now tells if 
           text of variable a starts with word.
   -  chg: scripts: #(rsubstr(s,o,l)) now also supports
           offset/length beyond string length,
           producing an empty string instead of error.
   -  fix: scripts: #(substr(a,n)) with n beyond
           length of a stopped the script with
           "invalid variable expression".
           now it evaluates to an empty string.
   -  add: sfk variables: function #(numlines(a))
           to tell number of lines in variable a.
   -  add: sfk md5var, create md5 hash
           from sfk variable content.
   -  add: sfk difflines, show text lines that differ
           between two text files or variables
   -  add: sfk crc, crcgento, crccheck to create
           and verify crc32 checksums (the same as
           used in zip files).
   -  add: sfk list: now sets return code if any
           matching files or dirs were found.
   -  add: sfk web: now sets return code 1 on any error.
   -  add: sfk sft: now sets return code if any
           files were sent.
   -  add: del[tree] now sets return code on failure
   -  add: deltree now retries a failed folder deletion 
           2 times with a 100 msec wait inbetween.
   -  add: del[tree] option -stoponerr to stop chain
           execution if deletion fails
   -  chg: del[tree] now produces a warning
           if deletion is incomplete.
   -  fix: ftp client: 30 second wait after listing
           of directory or file download with some servers.
   -  fix: run: -printcmd was ignored.
   -  chg: zip reading: invalid zip file now produces
           a warning instead of an error.
   -  fix: xfind, replace functions, xrename: variables
           were not expanded for dir parameters.
   -  chg: sfk run: now shows a notice if no filenames
           are processed on chaining.
   -  chg: xed, xrename now ignore empty pattern parameters
           instead of stopping with an error.
           useful for scripting with optional parms.
   -  chg: command chaining: -verbose now shows a notice
           "chaining stops before ...: no data"
           if execution stops due to no data.
   -  chg: command chaining: no longer showing
           "chaining stops ...: no filenames"
           unless -verbose is given.
   -  chg: sfk batch out.sh under linux:
           added exit after sfk call.
   -  chg: sfk sft cput: if no files are sent
           then -quiet no longer tells anything.
   -  add: copy -flat2 to copy all files of a dir tree
           to an output folder with relative names.
   -  add: make-random-file -lock option, to keep
           a file locked for testing.
   -  fix: xfind with -justrc: chaining to if 
           was not possible if nothing was found.
   -  fix: xfind -showrc produced an error.
   -  add: ifnotexist, check if a file does not exist.
   -  add: swap, reverse chain text character order
   -  add: Windows: sfk clock: pressing enter
           now resets the relative time.
   -  add: Windows: sfk clock3 shows overall start time
           and, when pressing Enter, relative time since
           overall start in a second column.
   -  add: sfk clock2 to show just a relative time.
   -  add: sft client: multi file send: now showing
           total mb info.
   -  add: xed: option -tolines to force line output.
   -  fix: xed: listing of mem leaks if given filename
           cannot be read, or input too large.
   -  doc: end: xed -tolines reference
   -  doc: tofile: addtovar reference
   -  doc: sft: upload loop example.
   -  doc: index: reworked linux examples.
   -  doc: xfind: -showrc removed, wrong context.
   -  doc: filter: difflines reference.
   -  doc: help opt: new list of archive extensions
           and -qarc info
   -  doc: xed: reference to sfk swap
   -  doc: sfk help chain: data tunneling notice.
   internal:
   Revision 4:
   -  add: pingdiff, ping local net two times.
   Revision 3:
   -  add: SFK_CONFIG support for keepchain
   -  chg: windows: 32 bit time cleanup
   -  chg: timetToFileTime 64 bit rework
   -  add: chaining with sysinfo
   -  add: index: chaining of output filename
   -  add: script: chaining of output text
   Revision 2:
   -  add: option -slow for lower prio
   -  chg: cleanup of call by unified callLabel.
   -  fix: ftp client: correction of close/readline
           sequence in many cases
   -  add: ftp client: -timeout option

   1.9.2
   Initial Release:
   -  rel: 05.07.2018, Major Update
   -  sum: added sfk move to move files,
           getcol and tabcol to easily get a column
           from space or tab separated text.
           improvements of xed, getvar, scripting.
           fixed context cleanup of perline.
   -  chg: Syntax Change: sfk zip: no longer adds .zip
           to output filename if it contains any dot '.'.
           this allows to create zip files with any
           extension, like .odt or .jar.
           use option -zipext for the old behaviour.
   -  add: checkzip: option -md5 to show md5 checksums
           of zip file contents
   -  add: general option -more to pause output
           per page.
   -  add: xhexfind: option -context=n to show
           n bytes of context around results.
   -  add: sfk for: now supports counting down,
           negative start/end values, and optional
           step size.
   -  add: sfk zip: option -rel to strip top level
           folder name of filenames within zip.
   -  add: sfk xed: option -write to rewrite a given
           file with changed output.
   -  fix: sfk if: now supports expression starting
           with plus like: if "+a = +a" ...
   -  fix: perline: context and options were not
           fully reset between two lines, e.g.
           load files.txt +perline "list #qtext" -yes
           produced wrong output.
   -  add: sfk move: move files between two folders.
   -  add: sfk mkdir: option -forfile to create dir tree
           for a given filename
   -  add: scripts: #(substr(s,o,l)) now also supports
           variable (names) for o and l.
   -  add: scripts: #(rsubstr(s,o,l)) to get substring
           from the right side in left direction.
   -  add: sfk getcol, tabcol to get one column from
           whitespace or tab separated text.
           alias of sfk filter.
   -  add: sfk ping: option -every to ping every n sec.
   -  add: make-random-file: output folder creation.
   -  add: sfk times, alias for sfk list -times.
   -  add: list: now also accepts -times with 's'.
   -  add: sfk getvar: option -numline=n to get
           a line by number.
   -  add: zip/unzip: option -offtime to support
           file times which are one hour off.
   -  fix: xtext: with -to out\$file it produced error -4
           during simulation.
   -  fix: xtext: -to out\$file no longer writes :file
           headers into output files.
   -  fix: rand: missing range check.
   -  fix: ifexist file stop -all ... was not possible.
   -  fix: windows mingw g++ compile.
   -  chg: sfk if: improved "need a command" error info.
   -  doc: list: example how to keep only existing
           filenames from a list of filenames
   -  doc: count: example for filter/setvar/count.
   -  doc: copy: reference to move.
   -  doc: xtext: how to extract text starting at a line.
   -  doc: help var: new (r)substr behaviour.
   -  doc: addcr: example for current folder.
   -  doc: sfk times example.
   -  doc: sfk zip: example to unzip/zip an .odt file.
   internal:
   -  add: ping mynet: option -mac for linux

   1.9.1
   Revision 3:
   -  rel: 28.05.2018, Minor Update
   -  sum: sfk copy new option -flat to collect all into
           one folder with flat filenames. the sfk book
           is now available in print on Amazon.
           search "100 command line tools", or "sfk tutorial".
   -  add: copy: option -flat to copy all files into a
           single output dir without sub folders.
   -  doc: zipto: removed redundant example.
   -  doc: name: copy -flat example.
   -  doc: filter: -tolower/upper notice correction.
   Revision 2:
   -  rel: 17.04.2018, Minor Update
   -  sum: Better support for folder zipping if no sub folder
           contents are needed. Added script command ifexist
           to check if a file or folder exists.
   -  fix: sfk zip: created empty subdir entries with -nosub.
   -  add: sfk ifexist to check if a file or folder exists.
   -  fix: sfk getvar +tofile produced unwanted empty lines.
   -  doc: sfk zip: option -nosub
   -  doc: sfk list: option -nosub
   Initial Release:
   -  rel: 12.04.2018, Major Update
   -  sum: The Swiss File Knife can now create zip files
           and extract zip files, supporting UTF-8 unicode
           filenames and 64 bit contents with sizes over 2 gb.
           This allows highly flexible file selection with
           the full SFK syntax, like selecting all files
           changed today, or all files containing a searched
           pattern, and to pack them into a .zip directly.
   -  add: sfk zip, create zip file from folder.
   -  add: sfk zipto, zip selected file list.
   -  add: sfk unzip, list or extract zip file.
   -  add: sfk checkzip, verify zip file content.
   -  add: sfk run: quick confirm by sfk run. (with a dot)
   -  chg: sfk getdv unter windows no longer does a direct
           download, but shows an info text and then
           opens a web browser to download dview.
   -  add: scripts with -var: #(sys.slash) creates
           \ under windows, / under linux.
   -  add: require: option -nostop to continue chain.
   -  fix: sfk xfind -names ... +run etc. also
           printed the names to terminal.
   -  fix: rand: when chained with other random generator
           commands like make-random-file the seed was
           permanently reinitialized, producing redundant
           number sequences.
   -  fix: script: command chaining stopped after md5gento,
           make-random-file, snapto, joinlines, bin-to-src,
           deblank, color, fixfile, split, join, partcopy,
           setbytes, media, rename
   -  add: ftpserv: better windows 10 ftp client support
           by replying to OPTS UTF8 ON.
   -  chg: sfk num: little endian conversion is now always
           done as 32 bits, even with small numbers.
           use option -small for old behaviour.
   -  fix: sfk num: text output chaining did not work.
   -  add: sfk num: option -show x to print just a single
           format instead of all formats.
   -  chg: hexdump: now supports -off n with chain data.
   -  doc: xed: [2 chars] explained.
   -  doc: xed: example to swap char groups.
   -  doc: run: time measurement example.
   internal:
   revision 3:
   -  clp: code cleanup of udpdump.
   revision 2:
   -  add: general option -nosub2 to exclude subfolders
           and also hide subfolder names like in:
           sfk list -withdirs -nosub2 mydir5
   initial:
   -  chg: rework of tcpsend client.

   1.9.0
   Revision 2:
   -  rel: 12.03.2018, Minor Update
   -  sum: SFK for Windows now supports accent insensitive search
           and file selection according to the active codepage.
           added direct conversion between UTF-8 and Ansi.
   -  chg: behaviour change with wtoa, utoa:
           if chars fail to convert these now stop
           command chaining with return code 9.
           use option -nostop to continue processing
           with return code 1, without warning.
   -  add: windows: general option -deacc to search text
           and select files accent insensitive, meaning
           a == A == a_accent == A_accent.
   -  add: windows: listcodes support for -deacc.
   -  add: windows: sfk utftoansi, ansitoutf to convert
           8-bit text directly between your Ansi codepage
           and UTF-8 format.
   -  add: windows: wtoa, utoa return code support.
   -  add: listcodes: advanced option -codepage to select
           other codepages.
   -  fix: sfk inst: files with UTF-8 BOM header were changed
           incorrectly, producing a compile error near line 2.
           now the BOM is detected and text inserted after that.
   -  fix: sfk inst: line ending format lf vs. crlf is now kept.
   -  chg: sfk inst: now runs in simulation mode by default.
   -  doc: sfk filt, xex: -case with ref to help nocase.
   -  doc: sfk help unicode ref to utoa, atou.
   -  doc: main help ref to utoa.
   Initial Release:
   -  rel: 28.02.2018, Major Update
   -  sum: SFK for Windows now supports case insensitive search
           and file selection within the codepage of your
           Windows system. Depending on your codepage this allows
           to search umlauts, accents, cyrillic or greek characters
           case insensitive. Added functions to convert text 
           from and to UCS-2 wide character data.
   -  add: windows: case insensitive search and file selection
           within the codepage of your windows system.
           depending on your codepage this allows to search
           german umlauts, french accents, cyrillic and greek
           characters case insensitive.
   -  add: sfk help nocase, about case insensitive search.
   -  add: sfk listcodes, list all characters that can be searched
           case insensitive with your Windows codepage.
   -  add: sfk help chars, about locale specific characters.
   -  add: general option -nocasemin to match only latin
           chars a-z case insensitive without any accents.
   -  add: windows: sfk wtoa and atow, convert UCS-2 wide character 
           text to 8-bit Ansi codepage text and vice versa.
   -  add: sfk wtou and utow, convert UCS-2 wide character
           text to 8-bit UTF-8 text and vice versa.
   -  chg: windows: sfk chars output format changed,
           now showing both Ansi and OEM code, and character
           name where available, with a table header.
           use option -min for the old minimal format.
   -  fix: xex: option -case was ignored.
   -  fix: xtext, xfind: error -1 on output with files
           of 2 or 3 gbytes size. 
   -  add: xfind, xtext: now shows an improved progress indicator
           by default. use -quiet for old behaviour.
   -  add: sfk make-zero-file, create a file full of zero bytes
           to clean unused space on a filesystem.
   -  add: sfk status: new field layout=n to change SFKTray layout
           to 2, 4 or 9 slots display. requires SFKTray 1.0.2.
   -  add: windows: sfk prompt now converts input from dos
           to ansi codepage by default.
   -  add: windows: sfk script option -dos to load DOS/OEM
           codepage encoded script files.
   -  fix: windows: delayed terminal after filtering of text content
           with special characters.
   -  add: sfk strings: option -allchars to extract all printable
           chars from binary files.
   -  add: snapto: option -binallchars to extract all printable
           chars from binary files.
   -  add: sysinfo: display of SFK_CONFIG variable.
   -  add: xtext: display of written file with -to outdir\$file.
   -  fix: xtext: error message with -to outdir\$file
           as long as in simulation, without text output.
   -  chg: option -nocconv can now be used locally per command.
   -  dep: option -iso is deprecated/ignored.
   -  dep: option -umlauts is deprecated/ignored.
   -  doc: main help title changed
           from: The Swiss File Knife File Tree Processor
           to:   The Swiss File Knife Multi Function Tool.
   -  doc: sfk index, name now reference sfk home.
   -  doc: sfk setvar, load, storetext, stop in main help.
   -  doc: wtoa, wtou in main help.
   -  doc: xrep: notice to use [eol] to replace line endings.
   -  doc: filter: reference to help nocase, help unicode.
   -  doc: find, replace: reference to help nocase.
   -  doc: general option -binallchars
   -  doc: sfk ose: xfind help did not show expression syntax.
   -  doc: sfk ren: top reference to sfk renfile.
   -  doc: sfk copy: single file copy example.
   internal:
   -  chg: wtoa, atow now also support -isochars.
   -  chg: sfk ascii now also supports -codepage option.
   -  add: -codepage=a-o to set fixed ansi/oem codepage.
   -  add: -deacc for accent insensitive match.
   -  add: option -isoc as alias for -isochars.
   -  fix: xtext, xfind: iContextUsed 2 gb overflow caused error -1.
   -  chg: option -noacc undocumented, conflicts with -deacc.

   1.8.9
   Revision 2:
   -  rel: 10.01.2018, Minor Update
   -  sum: improved scripting error messages.
           better rename support in scripts.
           added filter option to skip first lines.
   -  add: sfk renfile, rename just a single file,
           for use in sfk scripts.
   -  add: filter -skipfirst=n to skip first n lines.
   -  chg: -nocol given locally at a command no longer
           changes the global color mode.
   -  chg: scripts: every command given like +cmdname
           can now be used in a script, no longer producing
           the error "does not support input chaining".
   -  add: sfk ren, xren: option -quiet to print nothing.
   -  add: sfk ren, xren: now tells number of changed files.
           option -[no]stat to show or hide statistics.
   -  add: sfk rmtree: option -quiet to print nothing,
           option -stat to show statistics with -quiet.
   -  fix: scripts: unknown commands were ignored silently,
           they now produce an error "unknown command".
   -  fix: -memlimit=3000 did not work.
   -  fix: sfk prompt help text.
   -  doc: improved prompt example.
   Initial Release:
   -  rel: 06.12.2017, Major Update
   -  sum: improved scripting with if begin endif blocks.
           better display of windows filenames on more codepages.
           added sfk rand to create random numbers,
           sfk prompt to allow user input.
           fixed xex return code handling
           and stop of script after sfk status.
   -  chg: windows: improved display of european filenames
           using non latin characters in the own codepage.
   -  chg: sfk batch tmp.bat: the example is now
           a short number game with status lights.
   -  add: scripting: +if expr +begin ... +endif
           to execute multiple commands as one block
           if given expression is true.
   -  add: scripting: easy check if a variable text contains
           a phrase by: if "#(contains(mystr,'text'))"
   -  add: if: support for if "rc<>1" to check if command rc
           is different to a value.
   -  add: sfk rand to create a random number.
   -  add: sfk prompt to ask for user input.
   -  chg: sfk status: no longer requires protocol version.
   -  fix: xex: return code was always 1 if previous
           command set it, no matter if xex found data.
   -  fix: fixfile: option -dewide displayed invalid date 1900...
           in simulation preview.
   -  fix: possible crash on setvar with empty value.
   -  fix: status: silent stop of command chain with
           some following commands like +list
   -  chg: windows OSE compile support for MSVC 14.
   -  chg: chaining from +tell to other commands like +setvar
           no longer requires +then.
   -  chg: improved tracing of variable expansion
           by -debug like +tell -debug "#(strlen(a))"
   -  doc: xex: how to check if a variable contains a word.
   -  doc: help var: how to search a variable in a variable.
   Revision 3:
   -  add: status: info that SFKTray 1.0.2 now supports
           layout=n to change number of slots shown.
   -  add: fromucs: option -ansi under Windows
   Revision 2:
   -  add: fromucs, toucs
   -  fix: fixfile: possible crash with some runtimes
           due to negative time given to strftime

   1.8.8
   Revision 2:
   -  rel: 21.09.2017, Minor Update
   -  sum: improved scripting with perline and getvar commands.
   -  add: perline: option -setvar x to put whole line text
           into variable x, for easy call of sub functions
           without parameters.
   -  add: getvar: option -line to extract first line
           matching a pattern. allows fast table lookups
           by a unique id if text is in a variable.
   -  add: hexdump: option -nolf for -pure format.
   -  doc: touch: how to touch a single dir.
   -  doc: filetime: how to list a single dir.
   -  doc: filter: link to getvar.
   Initial Release:
   -  rel: 04.09.2017, Major Update
   -  sum: added new GUI tool to display status infos
           by several lights in the system tray.
           added sfk status command to control these lights.
           added more flexible rename for files and folders.
   -  add: sfk xrename, a flexible rename for files and
           folder names, supporting full SFK Simple Expressions
           and many patterns per command.
   -  add: sfk status, send a colored status to the SFKTray
           Windows GUI tool for display.
   -  fix: fromnet: when used with command chaining
           it called following commands endless even with
           no input at all. now e.g. fromnet +filter ...
           will block until actual input data is received.
           use new option -nowait for old behaviour.
   -  fix: sfk web: input conflict error after some
           commands like setvar.
   -  chg: web download limit default is now 30 mb.
   -  add: sfk if: warning on "rc = 0" comparison which
           should be "rc=0".
   -  chg: syntax change: stat: further command name chars
           like "sfk statistics" are no longer supported.
   -  doc: sfk rename: -spat example and xrename reference.

   1.8.7
   Revision 2:
   -  rel: 15.07.2017, Minor Update
   -  sum: further improvements of http and udp message sending
           for easier scripting and convenience.
   -  chg: web: option -cweb renamed to -chainweb to avoid
           ambiguities with new commands. old -cweb is kept 
           for compatibility, but no longer documented.
   -  fix: sfk update: always told there was a newer version
           if new version info contained a trailing dot.
   -  add: cweb, an alias for web -nodump -quiet to call
           web url's quick without any output.
   -  add: udp, an alias for udpsend, but does not use
           any chain input data.
   -  add: cudp, call udp quickly without any output.
           same as udp -quiet.
   -  chg: wget: improved error message when trying https.
   -  chg: ftp server: SIZE command on non existing file
           now returns code 550 instead of 213.
   Initial Release:
   -  rel: 06.07.2017, Major Update
   -  sum: syntax corrections with sfk web, addhead and addtail.
           easier web automation in sfk scripts.
   -  CHG: SYNTAX CHANGE: command +web no longer uses chain input
           text by default, so commands like
              sfk filter ... +web ...
           will no longer work. use instead +tweb like
              sfk filter ... +tweb ...
           to explicitely read chain text, or set global option 
           -chainweb for the old behaviour. if you need your 
           old scripts to run without any changes, set environment 
           variable:
              SET SFK_CONFIG=chainweb
           reason: in sfk scripts +web is used most of the time 
           with an URL given as a parameter, but not read from
           chain text input, so permanent writing of +then web 
           was required. the new default makes web automation 
           scripts much easier.
   -  CHG: OUTPUT CHANGE: sfk addhead, addtail no longer
           add blanks between added words by default.
           use option -blank for the old behaviour.
   -  add: sfk addhead, addtail: command chaining support.
   -  add: sfk load: load text or data for further processing
           in a command chain. just like xex or filter,
           but more intuitive in scripts if you do not
           want to apply any filtering.
   -  add: web: -delay option to wait per request
   -  add: tweb, an alias of web that reads url's
           from chain text of previous command.
   -  add: global options -chainweb and -nochainweb to change
           +web chain input default.
   -  add: sort: -skiphead to keep table headers
   -  add: echo: option -joinline to reformat quoted multi line
           parameters with full trim. includes option -noblank
           which is now deprecated but kept for compatibility.
   -  add: sfk data: now supports multi line template in scripts.
   -  add: sfk data: support for $minute, $second
   -  add: doc: sfk help chain, script: reference to load.
   internal:
   -  fix: update: wrong curl syntax in case of download failure
   -  add: web -enc[ode] to encode blanks in urls
   -  add: mweb to run many commands quietly.
   -  add: copy: experimental move option.
   -  add: sort: option -tabcol 3,2,1
   -  add: setGeneralOption sim support

   1.8.6
   Revision 3:
   -  rel: 09.06.2017, Minor Update
   -  sum: detail improvements of calc and partcopy.
   -  add: sfk partcopy: option -fromtoinc to include
           the end offset in output.
   -  fix: sfk calc: expressions starting with a negative
           number were not supported.
   Revision 2:
   -  rel: 03.06.2017, Minor Update
   -  sum: fixed output formatting of multiple variables
           in the same command.
   -  FIX: Output Change: when formatting multiple variables
           in the same command like "#(3.3a) #(b) #(c)"
           then the formatting of the first variable was
           applied to all following. now only the given
           formatting per variable is applied.
   Initial Release:
   -  rel: 30.05.2017, Major Update
   -  sum: added easy variable output formatting
           like #(05i) which pads i to 5 characters
           with leading zeros. calculator now supports
           long expressions with many values.
   -  add: variable formatting on output in C-style
           notation like #(3.5varname) allowing to fill 
           text with leading blanks or zeros, and to limit 
           text to a given number of characters.
           for details see "sfk help var"
   -  add: sfk run, perline: now support ufile, upath
           or qufile, qupath to use unix slashes "/".
           useful to create html output.
   -  add: sfk calc: now supports long expressions
           with more than two values.
   -  chg: sfk calc: if chain input is used as #text
           it now fills in the whole text, no longer
           ignoring characters after first whitespace.
   -  fix: sfk touch: did not support chaining
           to following commands.
   -  fix: sfk httpserv: truncated bad formatted url's
           like "foo bar.txt" with unencoded blank
           as "foo". now these produce code 404 only.
   -  doc: sfk for: example how to copy files.
   -  doc: sfk perline: example how to create an
           html file listing images.
   -  chg: variable functions lpad, rpad are no longer
           documented but still supported. padding by
           the new C-style notation is easier.
   internal:
   Initial Release:
   -  web: url encoding of blanks

   1.8.5
   Revision 3:
   -  rel: 18.05.2017, Minor Update
   -  sum: sfk version output fixed, which was wrong
           especially under linux. ftpserv now shows
           the time of a client connect and disconnect.
   -  fix: sfk version: did not work esp. on linux.
   -  add: ftpserv: console connect time infos.
   Revision 2:
   -  rel: 06.05.2017, Minor Update
   -  sum: reduced ftp terminal output on error replies.
   -  chg: ftp server: no longer printing 5xx replies
           to terminal by default. added option -showerror
           to print them, except for 550 no such file.
   -  chg: ftp: protocol info is now shown only with 
           ftp(server) but not with sft commands.
   -  doc: xed: example how to replace a line by file content.
   Initial Release:
   -  rel: 26.04.2017, Major Update
   -  sum: fix of FTP server which blocked folder transfers
           with many ftp clients. rework of FTP server 
           and client for improved connectivity under Windows.
           improved scripting by for loop.
           added listle to list line end infos for text files.
           detail improvements of udpdump, list, setbytes.
   -  CHG: FTP Client Change under Windows: when using "sfk ftp" 
           with an sfk ftp server, via port 21, the client now
           uses plain FTP protocol by default to avoid firewall
           restrictions. use option -sft or SFK_CONFIG=usesft
           for the old behaviour if no firewall interferes.
   -  FIX: ftp server: transfer of folders with most ftp
           clients was blocked as CWD /mydir/ was not possible,
           since sfk 1.8.4. (side effect from dir traversal fix)
   -  fix: ftp server: unexpected close connection errors
           at client on QUIT command. QUIT now produces 
           a reply 221 before closing the connection.
   -  fix: ftp client: missing display of error reply from
           server on ftp put, mput, sel ... +ftp mput.
   -  add: ftp client: options -raw to force plain ftp
           and -sft to allow sft even via port 21.
   -  chg: ftp server: 5xx error replies are now always shown
           on console unless -quiet is given.
   -  chg: ftp: now tells protocol used (ftp/sft)
           on every file transfer.
   -  add: ftp server: display of verify in verbose mode.
   -  add: sfk for, like for var from s to e +... +endfor.
   -  add: sfk listle, list line end infos for text files.
   -  fix: sfk for windows: absolute paths with forward slash
           like /tmp were not detected with some commands like
           sfk sel /mydir +copy -ltarg /outdir
   -  add: sfk setbytes: option -repeat=n to repeat data
           n times.
   -  add: sfk list: option -abs to list full absolute paths.
   -  add: sfk udpdump: now accepts both "," or blank separator
           for multi ip mask.
   -  add: sfk udpdump: warning on wrong chars in ip mask.
   -  chg: sfk view: changed some colors to look more like
           the white color theme.
   -  fix: sfk ask -abs used only -ab
   -  doc: sfk replace: help now always lists the possible
           shell return codes.
   -  doc: sfk script: improved infos on parameter name collision.
   -  doc: sfk filter: -format examples improved.
   -  doc: sfk udpdump: examples for multi ip filtering.
   -  doc: sfk xfind: windows return code handling example.
   -  doc: sfk addcr/remcr: reference to listle.
   -  doc: sfk ftpserv and ftp: help text rework.
   internal:
   -  opt: +setvar reuse of memory on same length.
   -  fix: isAbsolutePath now also detects /tmp etc.

   1.8.4
   Revision 2:
   -  rel: 09.03.2017, Minor Update
   -  sum: version command can now list standard windows 
           version infos contained in .exe files.
   -  chg: hextobin: no longer tells conversion statistics
           when output is sent to another command
   -  add: sfk version: support for windows binary version infos.
   -  doc: encode/decode was not contained in dumphelp.
   -  doc: main
   Initial Release:
   -  rel: 28.02.2017, Major Update
   -  sum: security fix for windows ftp and http server.
           added encoding and decoding of base64, hex
           and url text formats. added setbytes command to set 
           bytes directly in a file. improved scripting.
   -  FIX: ftpserv and httpserv under Windows: with option -rw
           write to a forbidden absolute path like C:\thedir\...
           was not blocked.
   -  CHG: Syntax Change: sfk ... +hexdump no longer expects
           filename lists from previous commands, but only text
           and binary data. use +hexfile or +fhexdump for the
           old behaviour. this fixes issues that data sent
           by the command chain was always misinterpreted
           as filename lists, producing file open errors.
   -  add: sfk clock, permanent display of absolute and
           relative time.
   -  add: sfk hexdump: automatic highlight of line end chars
           with pure text input data.
   -  fix: sfk for windows: repeated calls of sfk sft ... 
           in scripts not possible.
   -  add: sfk old, alias for sfk list -old to show oldest
           files of a folder.
   -  add: sfk small, alias for sfk list -small to show smallest
           files of a folder.
   -  add: sfk chars now supports command chain input.
   -  add: ftp client in sft mode: display of 55x error replies
           on file send, also without -verbose.
   -  add: sfk encode and decode, convert data to and from
           base64, hex or prefixed hex data.
   -  add: sfk setbytes, write a byte sequence into a file
           at a given offset.
   -  del: the undocumented +text and +files keywords
           in command chaining are no longer supported.
   -  chg: sfk base: sfk sel ... +extract was not enabled.
   -  chg: sfk base+xd: sfk sel ... +xrep demo was not enabled.
   -  chg: echo -literal -noline ... followed by a command
           accepting binary data, like xed, no longer appends (CR)LF.
   -  add: echo -pure as an alias for -literal -noline,
           to prepare chain input data as unchanged as possible.
   -  doc: hexfind.
   internal:
   Revision 2:
   -  add: fromclipw, toclipw.
   -  chg: ver unified output using only chain.print.
   Initial Release:
   -  chg: unified path traversal check method.
   -  fix: wsacleanup now called central once on process exit.

   1.8.3
   Revision 3:
   -  rel: 07.02.2017, Minor Update
   -  sum: improved scripting, better error messages,
           small bug fixes.
   -  add: linux: main help info for more output columns.
   -  add: diverse cannot open file error messages:
           detail infos if filename contains cr/lf characters.
   -  chg: sfk fromnet: renamed -nocache to -raw,
           with -nocache still being supported.
   -  add: udpsend is now chainable and may send chain input.
   -  add: udpdump option -text for easy plain text display.
   -  chg: Syntax Change: "sfk ... +list" no longer lists
           the whole content of the current folder if previous
           command did not send a list of filenames.
           use "sfk ... +list ." instead.
   -  chg: Syntax Change: sfk spell: no longer prints spelling
           table by default, but shows help text.
           use option -table for old behaviour.
   -  add: sfk spell: support for chain text input,
           spelled output is now prefixed by input words.
   -  fix: sfk ... +toclip now tells an error instead of
           blocking without notice if previous command
           provides no input data.
   -  fix: sfk colortest under windows did not restore
           default color after test.
   -  fix: xe: knxdump didn't work.
   -  add: sfk ruler, to measure console text width.
   -  ren: sfk diskspace primary name is now sfk space.
           sfk fsinfo    primary name is now sfk filesys.
           old names are supported for compatibility.
   -  chg: scripting: these commands can now be called
           without previous +then although they never use
           chain input data: fromnet, color, make-random-file,
           time, data, home, space, filesys, ruler.
   -  doc: sfk getvar
   Revision 2:
   -  rel: 31.01.2017, Minor Update
   -  sum: fix of unexpected stop of sfk scripts after commands
           like xex or filter.
   -  fix: unexpected stop of scripts after some commands
           like web ... +xex ...
   Initial Release:
   -  rel: 21.01.2017, Major Update
   -  sum: detail improvements for index file handling,
           udp message sending, text filter, windows/linux
           unified scripts. easier scripting by sfk tell which
           never sends given text to following commands.
           scripts can now call more nested sub functions.
           bug fixes for run, tail, hexdump.
   -  chg: option -upat now also support "/" for start of name
           comparison as in -subdir :/tmp or -file :/tmp
   -  chg: "sfk lindex" renamed to "sfk index" for easier use.
           sfk lindex is still supported for compatibility.
   -  add: "sfk iname" renamed to "sfk name" for easier use.
           sfk iname is still supported for compatibility.
   -  add: sfk udpsend: if a short ip is expanded the full
           target ip is now shown. option -showip to force
           showing of ip instead of host in sent info.
   -  add: sfk ip: optional expansion of given short ip.
           chaining support to pass ip text to other commands.
   -  add: sfk filter -toupper, -tolower to convert a-z
           to upper- or lowercase. does not convert any
           special characters like accents or umlauts.
   -  add: file selection option -tomake outdir\$base.ext
           to select all files having no or an older counterpart
           file in output folder outdir. see "sfk run" for 
           an example of .wav to .mp3 conversion with ffmpeg.
   -  fix: sfk udpsend, tonetlog could net send to different
           targets in the same command chain or script.
   -  add: sfk tell, same as echo but only prints to terminal
           and never sends given text to following commands,
           allowing scripts with fewer "+then" statements.
   -  add: sfk data, create random test data records.
   -  chg: reduced stack load per call and perline
           allowing more nested calls.
   -  fix: sfk dumphelp: now prints main help text first.
   -  fix: sfk run with a single string containing # or $
           did nothing.
   -  fix: sfk tail under windows: handling of files > 2 GB
           without option -altsize.
   -  fix: sfk ... +hexdump unexpected dump of all files
           of current folder.
   -  chg: sfk knxdump, knxsend: GA support up to 31/7/255,
           support to send to unicast address.
   -  doc: updated list, run, help opt, echo/tell, xed,
           filter, media, call, perline, dupfind
   internal:
   Revision 3:
   -  add: setbytes.
   -  fix: loadInput did not support non-color mode.
   Revision 2:
   -  add: ftpserv -usedir optional local limits.
   Initial Release:
   -  add: sfk web access: redirection notes now also show
           from which url the redirect starts.
   -  del: undocumented mindump, hexle.
   -  chg: code move from submain to extmain,
           reduced stack load per call from 140k to 50k.
   -  add: sfk stacksize.
   -  del: SFK_STRICT_MATCH name comparison.
   -  chg: chain.print redirect on colany().
   -  add: sfk encode/decode -url -hex -_hex ...
   -  add: sfk filter -fromurl -fromhex -from_hex -frombase64
   -  add: sfk filter -tourl -tohex -to_hex -tobase64

   1.8.2
   Initial Release:
   -  rel: 15.11.2016, Major Update
   -  sum: sfk xfind, a powerful text search tool for the command line,
           is now open source. compared to grep it features an easy, 
           human readable pattern syntax based on the english language.
           improved scripting by string functions like substr
           and direct access to environment variables.
   -  chg: sfk OSE: xfind, xhexfind, xtext and extract
           are now open source.
   -  add: sfk variable functions like #(substr(a,3,2)).
           type "sfk help var" for details.
   -  add: access to environment variables like #(env.varname).
           type "sfk help var" for details.
   -  chg: error text "incomplete replacement pattern"
           changed to "imcomplete search pattern"
           with improved correction hints.
   -  fix: ftpserver with -usedir: empty listing in ftp clients
           like cyberduck due to invalid rwx attribute infos.
   -  fix: sfk ose compile: sfkbase.hpp did not define SFKOSE.
   -  doc: xfind, xtext help reworked. improved "see also" list,
           -enddir before -text is not needed, 
           -text is listed before -pat.
   -  doc: marked find, hexfind as basic commands
           with reference to xfind, xhexfind.
   internal:
   -  add: list option -tomake enabling run (q)targ.

   1.8.1
   Revision 4:
   -  rel: 19.10.2016, Minor Update
   -  sum: improved scripting with sfk if.
           improved sfk count.
   -  chg: sfk batch, sfk samp sfkbat with windows:
           now using %~f0 instead of %0 to insert the
           full absolute batch name including extensions.
           this allows to type "mycmd" instead of
           "mycmd.bat" to run a script.
   -  add: sfk count: direct file reading support.
   -  fix: sfk if: now also accepts expressions starting
           like an option, like "-yes = -yes".
   -  add: sfk tail: option -nowait to avoid blocking
           in a command chain using +loop.
   -  fix: progress info output after wget even with -quiet=2.
   -  fix: sfk web: error message "wrong date/time" because
           web server uses a different locale than client.
           now there is only a notice if -verbose is used.
   -  doc: sfk goto: infos about broken chain data flow.
   -  doc: sfk batch: improved template batch with
           help text display on empty parameters.
   -  doc: wget info on -quiet=2.
   Revision 3:
   -  fix: sfk call, perline: error "missing or wrong script
           parameter" with empty parameters.
   -  fix: sfk run and other: empty parameter before dir
           parameter list produced errors.
   -  doc: info about no variable support with -bylist.
   Revision 2:
   -  ADD: sfk if with generic comparison of parameters,
           variables, strings and numbers.
   -  CHG: sfk script: empty parameters and variables
           which are not surrounded by quotes are now removed.
   -  add: sfk (x)hexfind, (x)replace, extract:
           option -fullheader to show offset/length infos 
           of found hits both with decimal and hexadecimal.
   -  add: sfk goto, jump to a local label.
   -  add: sfk label: option -var to enable variable use
           for all following commands.
   -  fix: xhexfind: results >= 4048 bytes were not printed.
   -  add: xhexfind: option -maxdump=n to show only n bytes.
   -  fix: call mylabel called mylabel2 if present.
   -  fix: sfk update: did not detect new version
           if 1.8.1 is compared with 1.8.1.2
   -  fix: command chaining: when using short file selection
           in a command then using long file selection in
           following commands produced an error sometimes.
   -  doc: sfk web: script example for access with
           connection error handling.
   -  doc: sfk label: info about global options.
   -  doc: sfk script: info about -var after label.
   Initial Release:
   -  rel: 29.09.2016, Major Update
   -  sum: added support for sfk variables, allowing to store data
           from a command and to reuse it in other commands.
           massive improved scripting.
   -  ADD: sfk variables. type "sfk help var" for infos.
           allows to store data produced by one command,
           and to reuse it in another command like #(name)
   -  ADD: sfk perline, run sfk commands per text input line.
           similar to sfk run, but without starting an
           external program, and with full access
           to sfk variables produced by previous commands.
   -  CHG: Syntax Change: sfk call, if: no longer clears
           chain text after command. call will now flush
           chain text before entering the label.
   -  CHG: Syntax Change: sfk echo ... +call +xex
           no longer passes text of echo as chain data
           through to xex. use tcall for that.
   -  CHG: Syntax Change: sfk gettext output changed with
           text produced by storetext -append. more below.
   -  add: sfk samp http, create an example script
           for web access automation.
   -  add: sfk xed, xex, xreplace, simple expressions:
           [setvar name]...[endvar] to set an sfk variable,
           [getvar name] to fill in data from an sfk variable.
   -  add: sfk xed, simple expressions: keyword [ortext]
           to search literals OR combined. can only be used
           between literals.
   -  add: sfk xed, simple expressions: keyword [keep]
           to search text that should be kept in input,
           without consume or replace.
   -  add: sfk echo -lines to print every string as one line.
   -  add: sfk xed: option -firsthit to use only first matching result.
   -  add: sfk filter: option -line=n to read nth line from input.
   -  add: sfk web: option -showreq, similar to -status.
   -  add: sfk find: option -head=n to read only n lines.
   -  add: sfk batch, alias of sfk samp sfkbat.
           may also create .sh files under windows.
   -  add: sfk xf, alias for xmlform.
   -  fix: command chaining: unexpected drop of data when
           chaining to echo, fromclip, var, gettext, getvar.
           e.g. sfk echo foo +echo bar +tofile out.txt
           dropped "foo", now it is printed.
   -  add: command chaining: +tcall to consume text data
           and +tend to return text data.
   -  fix: sfk script -from begin: if script contained
           a label begin2 this was called.
   -  chg: sfk xex, xed: improved help examples, separate
           examples for xex and xed.
   -  chg: sfk samp sfkbat, sfkbash now use %0 or $0
           instead of the script filename.
   -  chg: Simple Expressions: now support zero length tokens
           like in "/[start][0 chars][1 char]/"
   -  chg: sfk samp: path now allowed in output file
           with some language types.
   -  add: sfk xex, xed: option -justrc to just set return code
           without printing any output.
   -  add: sfk ... +tovoid to drop current chain text.
   -  add: sfk stop: optional text to print, info on rc 9
           to stop a script from within call.
           dump of chain text on rc >= 9.
   -  add: sfk call: improved help text.
   -  FIX: sfk script, call: missing parameters produced errors
           or even crashed. now these are just empty.
   -  fix: sfk ... +run was blocked with http:// url's.
   -  fix: sfk web -status=... +xex didn't work.
   -  fix: sfk echo: quoted multi line parms output
           contained unwanted CR characters and trailing
           blank line.
   -  fix: sfk web: always produced rc 9.
   -  fix: run -stoprc: did not work in a script.
   -  fix: script: +if ... stop -all didn't work,
           as "if" misinterpreted options.
   -  fix: script: +stop no longer requires +then stop.
   -  fix: gettext: missing linefeeds on terminal output
           after multiple storetext -append. workarounds
           appending with "\n" must be changed.
   -  fix: sfk version -own +filter didn't work.
   -  fix: expression part info didn't show # chars.
   -  chg: sfk samp sfkbat, sfkbash new templates.
   -  add: sfk knxsend: support for alternative IP group,
           send of search request.
   -  add: sfk knxdump: option -verbose to print search
           response verbosely.
   -  doc: extended echo help.
   -  doc: reworked help for sfk script.
   -  doc: help text for sfk then.
   internal:
   rev. 3:
   -  add: env variable read support.
   -  add: sfk calc: hex support.
   initial:
   -  chg: sfk run: option -strict
   -  add: sfk ruler
   -  del: sfk help firefox, samp firefox
   -  add: cmd1 +to cmd2 draft
   -  add: sfk rerun(loop) with output redirect.
   -  add: sfk echo -indent=n to keep indentation in scripts.
   -  fix: sfk echo ... +run ... chaining small improvement.
   -  add: sft(serv) aliases sfs3, sf3.
   -  fix: xex [setvar] no terminal output.
   -  add: sfk variable use with most commands
   -  chg: rework of perline, endper dropped

   1.8.0
   Initial Release:
   -  rel: 30.08.2016, Major Update
   -  sum: sfk xed, a powerful stream text editor, is now free
           and Open Source. it allows text and binary editing
           with a simple, human readable syntax.
           improved handling of multi line parameters in sfk scripts.
   -  CHG: SYNTAX CHANGE: sfk script and sfk label:
           quoted multi line parameters are now trimmed by default,
           no longer requiring option -qtrim. see "sfk script"
           for details. scripts requiring the old behaviour
           may now need option -qraw after "sfk label".
   -  chg: the SFK Mobile Booklet was fully reworked
           and now covers the latest SFK version,
           including an 38 page tutorial.
           see stahlworks.com/pdf for details.
   -  chg: sfk script: support for quoted multi line parms with
           filter -rep, filter -form, web, wget, rename
   -  add: sfk windows: clipsrc, clipphp, clipjava
           to convert clipboard text to source code.
           type "sfk bin-to-src" for documentation.
   -  fix: linux: autoconf compile didn't work.
   -  fix: compile: -DSFKOSE no longer necessary
           to produce a Base/OSE binary info.
   -  fix: web -nodump missing option documentation.
   -  fix: xmlform: unwanted blank lines in output,
           lost lines on some multi line tags.
   internal:
   -  chg: see sfk180 for dv build adaptions
   -  add: sfk tohtml

   1.7.7
   Initial Release:
   -  rel: 29.07.2016, Major Update
   -  sum: easy web data access with functions
           sfk web, wfilter, xex. added sfk calc to do
           simple calculations. improvements of wget,
           ftpclient, udpdump, find, xfind, script.
           diverse bug fixes.
   -  inf: Compatibility Notice: sfk scripts with
           quoted multi line parameters will change
           their default behaviour in the future.
           see "sfk label" options -qtrim and -qraw.
   -  dep: Deprecation Warning: sfk webreq should
           no longer be used. use sfk web instead.
   -  chg: Compatibility Notice: sfk pause: no longer
           sets a non zero shell return code if Esc
           key is pressed (which was undocumented).
   -  add: sfk update: check for SFK updates.
   -  add: sfk pause: option -keyrc to set the
           shell return code by ascii code of the
           pressed key.
   -  add: sfk filter: option -head=n to read only
           first n lines of text files.
   -  add: sfk filter: option -tail=n to read only
           last n lines of text files.
   -  add: web access support with sfk filter, xex.
           help text examples for web access.
   -  add: xe: sfk xreplace: option -astext to print
           search/replace hits as plain text.
   -  add: sfk web, send a simple web request.
           new implementation replacing webreq.
   -  add: sfk label: option -qtrim to strip whitespace
           from quoted multiline parameters.
   -  add: sfk ftpserv: support for environment variables
           SFK_FTP_SUSER, SFK_FTP_SPW, SFK_FTP_SRUNPW
           which are used only by sfk ftpserv, not sfk ftp.
   -  add: sfk ftp: support for environment variables
           SFK_FTP_CUSER, SFK_FTP_CPW which are used
           only by sfk ftp, not sfk ftpserv.
   -  add: main help now lists the most important
           active environment variables.
   -  add: full documentation of option -upat for using
           unix patterns : and # under windows.
   -  add: option -upat2 to use sfk linux wildcard %
           instead of * under windows
   -  add: sfk windows: set SFK_CONFIG=upat or upat2
           support to use unix syntax in bash files
   -  add: sfk for windows now also supports environment
           variable option SFK_CONFIG=wildstar:c
           to support a different wildcard character.
   -  add: sfk calc, do a simple calculation of two values.
   -  add: xfind, xhexfind: option -names to show just
           the names of files containing hits.
   -  fix: udpsend: no error on missing port or data.
   -  fix: find: option -justrc produced blank lines.
   -  add: udpdump: option -from now supports multiple
           ip patterns separated by comma.
   -  add: udpdump: option -notfrom.
   -  add: wget: auto expansion of url to http://url
   -  chg: ftp client: "server speaks sft" message
           is now shown only with -verbose.
   -  chg: ftp client: "using SFK_FTP_PW" message
           is now shown only with -verbose.
   -  add: wget: option -maxwait to stop on timeout.
   -  opt: wget: no longer sends head request.
   -  add: httpserv: -raw option to send content
           without any reply headers.
   -  fix: wget: download from a primitive server
           that sends no http headers produced
           incomplete first text line.
   -  fix: sfk gettext: did not work in many cases.
   -  chg: sfk if, sfk call: no longer consume chain text
           without any output.
   -  add: sfk fromclip -h: example how to append
           clipboard changes to a logfile in a loop.
   internal:
   -  fix: resetLoadCaches no longer reset ConCache
           as this conflicts with glblSFL.
   -  add: -errtotext
   -  add: setvar, getvar
   -  add: perline, endper
   -  del: dropped internal testfwrite.
   -  chg: sfkmatch: renderOutput optim if no data.

   1.7.6
   Revision 3:
   -  fix: command chaining: failed to work with
           sfk ping ... +then webreq +filter ...
           now every chain i/o type after +then is ignored.
   -  add: webreq: option -maxwait=n to wait up to
           n msec for a connection.
   -  add: ping: option -quiet=2 to not show OK etc.
   Revision 2:
   -  fix: sfk alias didn't work.
   -  fix: sfk ping help: first example didn't work.
   -  chg: improved help on output chaining error message.
   -  chg: improved help on input chaining error message.
   -  chg: udpsend: no longer use gethostbyname on pure ip's.
   -  chg: global rework of all gethostbyname calls (setaddr).
   -  add: sfk for windows: option -noesckey to disable
           stop by escape key.
   Initial Release:
   -  add: windows: sfk fixfile, change bad filenames
           and file times created by embedded devices
           like PVR video recorders.
   -  fix: sfk rename: crash on accent chars or umlauts
           within the search pattern.
   -  add: ftpserv: LIST now accepts -la, same as -a.
   -  fix: ftpserv: endless loop on unexpected LIST option.
   -  add: ftpserv: option -pasvport=n to define PASV port.
   -  add: windows: option -nofo[llow] now skips symbolic links.
   -  chg: windows: sfk lindex no longer follows symbolic links
           by default. use -follow to change this.
   -  add: sfk num: print number in all kinds of formats.
   -  fix: sfk snapto: empty files were not added.
   -  fix: sfk alias -list did not work.
   -  fix: sfk xe: (x)replace -firsthit truncated file.
   -  fix: improved cygwin compile.
   -  add: sfk knxsend: now supports 4 bit messages.
   -  add: sfk strlen: windows batch example.
   internal:
   Revision 3:
   -  fix: Stringmap::remove: missing key cleanup.
   -  run: option -upath for url support under windows.
   Revision 2:
   -  add: udpsend: option -raw for minimal send.
   Initial Release:
   -  add: option -yes+ and -clog command log support
           with optional SFK_CMD_LOG configuration.
*/

// NOTE: if you change the source and create your own derivate,
// fill in the following infos before releasing your version of sfk.
#define SFK_BRANCH   ""
#define SFK_VERSION  "1.9.8" // ver_ and check the _PRE definition
#define SFK_FIXPACK  ""
#ifndef SFK_PROVIDER
#define SFK_PROVIDER "unknown"
#endif
#define SFK_PREVER   ""

// in case of linking problems concerning libsocket etc.,
// you may out-comment this to compile without tcp support:
#ifndef USE_SFK_BASE
 #define WITH_TCP
 #define SFK_FTP_TIMEOUT "30" // seconds, as string
#endif // USE_SFK_BASE

#define USE_SFT_UPDATE

// should you get problems with fsetpos/fgetpos compile,
// activate this to disable zip/jar file content listing:
// #define NO_ZIP_LIST

#ifdef SFK64
 #define SFK_OS_BITSTR "-64"
#else
 #define SFK_OS_BITSTR ""
#endif

#if defined(__APPLE__) && !defined(MAC_OS_X)
 #define MAC_OS_X
#endif

#if !defined(VER_STR_OS) && defined(_WIN32)
 #ifdef _WIN64
  #define VER_STR_OS "windows-64"
 #else
  #define VER_STR_OS "windows-any"
 #endif
 #define _WIN32_WINNT 0x0400 // for copyFileEx
 #define SFK_HAVE_ARC // win32
#endif

#if !defined(VER_STR_OS) && defined(MAC_OS_X)
  #ifdef MAC_OS_X_PPC
   #define VER_STR_OS "mac-osx-ppc"
   #define SFK_HAVE_ARC // mac-ppc
  #endif
  #ifdef MAC_OS_X_I686
   #define VER_STR_OS "mac-osx-i686"
   #define SFK_HAVE_ARC // mac-i686
  #endif
  #ifndef VER_STR_OS
   #define VER_STR_OS "mac-osx"
  #endif
#endif

// generic ARM linux, "soft float" or float independent
#if !defined(VER_STR_OS) && defined(LINUX_ARM)
 #define VER_STR_OS "linux-arm"
 #define SFK_HAVE_ARC // linux-arm
#endif

// if doing an explicite "hard float" compile
#if !defined(VER_STR_OS) && defined(LINUX_ARM_HF)
 #define VER_STR_OS "linux-arm-hf"
 #define SFK_HAVE_ARC // linux-arm-hf
#endif

#if !defined(VER_STR_OS) && defined(SOLARIS)
 #define VER_STR_OS "solaris"
#endif

// generic detection
#if !defined(VER_STR_OS) && defined(_WIN32)
 #define VER_STR_OS "windows-any"
#endif
#if !defined(VER_STR_OS) && defined(__arm__)
 #define VER_STR_OS "linux-arm"
#endif
#if !defined(VER_STR_OS) && defined(SFK_LIB5)
 #define VER_STR_OS "linux-i686-lib5"
#endif
#if !defined(VER_STR_OS)
 #define VER_STR_OS "linux-i686" SFK_OS_BITSTR
#endif

#define SFK_STRINGIFY(x) #x
#define SFK_TOSTRING(x) SFK_STRINGIFY(x)

#if defined(_MSC_VER)
 #define SFK_CPL_VER "vc" SFK_TOSTRING(_MSC_VER)
 #if defined(_WIN64)
  #define SFK_CPL_BITS ";x64"
 #else
  #define SFK_CPL_BITS ";x32"
 #endif
#else
 #define SFK_CPL_VER  ""
 #define SFK_CPL_BITS ""
#endif

#if defined(SFK_STATIC)
 #define SFK_BUILD_INFO SFK_CPL_VER SFK_CPL_BITS "static"
#else
 #define SFK_BUILD_INFO SFK_CPL_VER SFK_CPL_BITS ""
#endif

#ifdef USE_SFK_DATE
 #include "sfkdate.hpp"
#else
 #define VER_DAT_RAW __DATE__
#endif
#define VER_DAT_STR "date=" VER_DAT_RAW

#define  MTKTRACE_CODE
#include "sfkbase.hpp"

const char *getPureSFKVersion() 
{ 
   if (strlen(SFK_FIXPACK) > 0)
      return SFK_VERSION "." SFK_FIXPACK;
   else
      return SFK_VERSION; 
}

const char *getShortOSName() 
{
   #ifdef _WIN32
   return "win";
   #else
    #ifdef MAC_OS_X
    return "mac";
    #else
    return "linux";
    #endif
   #endif
}

#ifdef VFILEBASE
#endif // VFILEBASE

#ifdef USE_SFK_BASE
 #define NO_VER_STR
#endif

#ifndef NO_VER_STR
// binary version tag, is also parsed in version command.
// $version:vernum,shortid,full name,type$\0"
 #ifndef SFK_VERTYPE
  #define SFK_VERTYPE "Base" // version type
 #endif
 #ifndef SFK_VERTEXT
  #define SFK_VERTEXT "/OSE" // open source edition
 #endif
static const char *pszGlblVersion =
   "$version:vernum=" SFK_VERSION ",name=sfk,title=Swiss File Knife,"
   "info=" SFK_BUILD_INFO ","
   "os=" VER_STR_OS ",type=" SFK_VERTYPE SFK_VERTEXT ",fix=" SFK_FIXPACK "," VER_DAT_STR "$\0";
static const char *pszGlblVerType = SFK_VERTYPE;
const char *getSFKVersion() { return pszGlblVersion; }
#endif

#define SFK_BOTH_RUNCHARS

#ifdef _WIN32
 #define SFK_BOTH_RUNCHARS_HELP
 #define SFK_MAP_ANSI_NEW // sfk189
#endif

// #define SFK_STRICT_MATCH
#define SFKVAR // 1770

#ifdef SFKINT2
 #define SFKPRINTREDIR
 #define SFKEXTERR
#endif

#ifndef USE_SFK_BASE
 #define WITH_FN_INST
#endif // USE_SFK_BASE

#ifdef _WIN32
 #ifdef SFK_MEMTRACE
  #include "memdeb.cpp"
 #endif
#endif
#ifndef SFK_MEMTRACE
void sfkmem_checklist(const char *pszCheckPoint) { }
#endif

#ifdef _WIN32

      char  glblNotChar     = '!';
      char  glblRunChar     = '$';
      char  glblWildChar    = '*';

const char  glblPathChar    = '\\';
const char  glblWrongPChar  = '/';
const char *glblPathStr     = "\\";
const char *glblDubPathStr  = "\\\\";
const char *glblDotSlash    = ".\\";

// Windows default compile has a stack size of 1 mb.

#else

      char  glblNotChar     = ':';
      char  glblRunChar     = '#';
      char  glblWildChar    = '%';

const char  glblPathChar    = '/';
const char  glblWrongPChar  = '\\';
const char *glblPathStr     = "/";
const char *glblDubPathStr  = "//";
const char *glblDotSlash    = "./";

// Most linux have a stack larger than 1 mb, some smaller.
#define SFKBIGSTACK  // linux default

#endif

bool glblUPatMode = 0;
void *pGlblStartStack = 0;

#if defined(SFKOFFICE)
bool bGlblOffice = 1;
#else
bool bGlblOffice = 0;
#endif

extern struct CommandStats gs;
extern struct CommandStats cs;
extern struct CommandStats cspre;
extern struct CommandStats dummyCommandStats;

void initWildCards()
{
   #ifdef _WIN32
   char c = '*'; // windows wildcard default
   #else
   char c = '%'; // linux wildcard default
   #endif

   do {
      char *pszWC = getenv("SFK_CONFIG"); // wildstar
      if (!pszWC) break;
      pszWC = strstr(pszWC, "wildstar:");
      if (!pszWC) break;
      pszWC += strlen("wildstar:");
      if (!*pszWC) break;
      c = *pszWC;
   } while (0);
   glblWildChar = c;
}

bool isWildChar(char c) {
   // 1770: optional dual wildchar support with windows.
   //       was always the case with sfk linux.
   return (c == '*' || c == glblWildChar) ? 1: 0;
}
bool isWildStr(char *p) {
   if (strlen(p) != 1) return false;
   return isWildChar(p[0]);
}
bool isNotChar(char c) {
   #ifdef _WIN32
   // sfk windows: support dual not char
   return (c == '!' || c == glblNotChar) ? 1 : 0;
   #else
   // sfk linux: avoid possible conflicts with "!"
   return (c == glblNotChar) ? 1 : 0;
   #endif
}
bool isUniPathChar(char c) { // sfk183
   if (c == glblPathChar) return true;
   if (glblUPatMode==1 && c=='/') return true;
   return false;
}
void setLinuxSyntax(int iLevel) {
   glblUPatMode=1;
   glblNotChar  = ':';
   glblRunChar  = '#';
   if (iLevel >= 2) {
      glblWildChar = '%';
   }
}

void setTextColor(int n, bool bStdErr=0, bool bVerbose=0);
int perr(const char *pszFormat, ...);
int pwarn(const char *pszFormat, ...);
int pinf(const char *pszFormat, ...);
int containsWildCards(char *pszName);
num numFromSizeStr(char *psz, cchar *pszLoudInfo=0, bool bRelaxed=0);
int execToHtml(int imode, int iaspect, char *plist, char *pszOutFile);
int execPhraser(char *pszAll, char *pszSrc, int iNumRec);
extern const char *szGlblPhraseData;
int mySetFileTime(char *pszFile, num nTime);
int installSFK(char *pszFolder, bool byes);
bool strbeg(char *psz, cchar *pstart);
bool stribeg(char *psz, cchar *pstart);
// strends  -> strEnds
// striends -> striEnds
int reformatjson(char *pinbuf, char *poutbuf, char *poutattr, int ioutmax);

bool bGlblRandSeeded = 0;

// ========== lowest level printf redirect ============

#ifdef printf
 #undef printf
#endif
int sfkprintf(const char *pszFormat, ...);
#define printf sfkprintf

// ========== 64 bit abstraction layer begin ==========

#ifdef SFK_W64
extern "C" 
{
int _fseeki64(FILE *stream, __int64 offset, int origin);
__int64 _ftelli64(FILE * _File);
}
#endif // SFK_W64

char *numtostr(num n, int nDigits, char *pszBuf, int nRadix)
{
   static char szBuf[100];
   if (!pszBuf)
        pszBuf = szBuf;

   #ifdef _WIN32
   if (nRadix == 10)
      sprintf(pszBuf, "%0*I64d", nDigits, n);
   else
      sprintf(pszBuf, "%0*I64X", nDigits, n);
   return pszBuf;
   #else
   if (nRadix == 10)
      sprintf(pszBuf, "%0*lld", nDigits, n);
   else
      sprintf(pszBuf, "%0*llX", nDigits, n);
   return pszBuf;
   #endif
}

char *numtoa_blank(num n, int nDigits)
{
   static char szBuf2[100];
   #ifdef _WIN32
   sprintf(szBuf2, "%*I64d", nDigits, n); // FIX: 1674
   return szBuf2;
   #else
   sprintf(szBuf2, "%*lld", nDigits, n);  // FIX: 1674
   return szBuf2;
   #endif
}

char *numtoa(num n, int nDigits, char *pszBuf) {
   return numtostr(n, nDigits, pszBuf, 10);
}

char *numtohex(num n, int nDigits, char *pszBuf) {
   return numtostr(n, nDigits, pszBuf, 0x10);
}

num atonum(char *psz)
{
   #ifdef _WIN32
   return _atoi64(psz);
   #else
   return atoll(psz);
   #endif
}

// atonum with support for decimal and 0x hex values
num myatonum(char *psz)
{
   if (!strncmp(psz, "0x", 2)) {
      #ifdef _MSC_VER
      return _strtoui64(psz+2, 0, 0x10);
      #else
      return strtoull(psz+2, 0, 0x10);
      #endif
   } else {
      return atonum(psz);
   }
}

mytime_t getSystemTime()
{
   static mytime_t stSysTime = 0;
   return mytime(&stSysTime);
}

#ifdef _WIN32
int mygetpos64(FILE *f, num &rpos, char *pszFile)
{
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   rpos = (num)npos1;
   return 0;
}
int mysetpos64(FILE *f, num pos, char *pszFile)
{
   fpos_t npos1 = (fpos_t)pos;
   if (fsetpos(f, &npos1))
      return 9+perr("setpos failed on %s\n", pszFile);
   return 0;
}
#else
// todo: check fpos_t size with linux, mac
int mygetpos64(FILE *f, num &rpos, char *pszFile)
{
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   #if defined(MAC_OS_X) || defined(SOLARIS)
   rpos = (num)npos1;
   #else
   rpos = (num)npos1.__pos;
   #endif
   return 0;
}
int mysetpos64(FILE *f, num pos, char *pszFile)
{
   // fetch "status" first
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   #if defined(MAC_OS_X) || defined(SOLARIS)
   npos1 = (fpos_t)pos;
   #else
   npos1.__pos = (__off_t)pos;
   #endif
   if (fsetpos(f, &npos1))
      return 9+perr("setpos failed on %s\n", pszFile);
   return 0;
}
#endif

// ========== 64 bit abstraction layer end ============

// ====== SFK primitive function library begin ========

char *ownIPList(int &rhowmany, uint nOptPort, const char *psep, int nmode);

#if (defined(WITH_TCP) || defined(VFILENET) || defined(DV_TCP))

bool bGlblTCPInitialized = 0;

int prepareTCP()
{
   if (!bGlblTCPInitialized)
   {
      bGlblTCPInitialized = 1;

      #ifdef _WIN32
      WORD wVersionRequested = MAKEWORD(1,1);
      WSADATA wsaData;
      if (WSAStartup(wVersionRequested, &wsaData)!=0)
         return 9+perr("WSAStartup failed\n");
      #endif
   }
   return 0;
}

void shutdownTCP()
{
   if (!bGlblTCPInitialized)
      return;

   bGlblTCPInitialized = 0;

   #ifdef _WIN32
   WSACleanup(); // sfk1840 central, on process exit
   #endif
}

// all closesocket calls are redirected to:
void myclosesocket(SOCKET hsock, bool bread, bool bwrite)
{
   int nmode = 0;

   if (bread  && !bwrite)
      nmode = SHUT_RD;     // no more receptions
   else
   if (!bread && bwrite)
      nmode = SHUT_WR;     // no more transmissions
   else
   if (bread  && bwrite)
      nmode = SHUT_RDWR;   // no more transfers at all

   // signal the tcp stack that transmission stops,
   // so the receiver side may receive remaining data.
   shutdown(hsock, nmode);

   #ifdef _WIN32
   closesocket(hsock);
   #else
   close(hsock);
   #endif
}

#endif // WITH_TCP or VFILENET

// just close on a socket is not enough.
// myclosesocket also does the shutdown().
#define closesocket myclosesocket

num getCurrentTime()
{
   #ifdef _WIN32
   return (num)GetTickCount();
   #else
   struct timeval tv;
   gettimeofday(&tv, NULL);
   return ((num)tv.tv_sec) * 1000 + ((num)tv.tv_usec) / 1000;
   #endif
}

// returns high resolution timer ticks, if available
num getCurrentTicks()
{
   #ifdef _WIN32
   LARGE_INTEGER val1;
   QueryPerformanceCounter(&val1);
   return val1.QuadPart;
   #else
   struct timeval tv;
   gettimeofday(&tv, NULL);
   return ((num)tv.tv_sec) * 1000 + ((num)tv.tv_usec) / 1000;
   #endif
}

num msecFromTicks(num nTicksDiff)
{
   #ifdef _WIN32
   LARGE_INTEGER val1;
   QueryPerformanceFrequency(&val1);
   num nMicroSecPeriod = val1.QuadPart;

   if (nMicroSecPeriod <= 0)
      return 1;

   num nMSecDiff = nTicksDiff * 1000 / nMicroSecPeriod;

   if (nMSecDiff <= 0)
      return 1;

   return nMSecDiff;
   #else
   return nTicksDiff;
   #endif
}

class StopWatch {
public:
   StopWatch   (num &rAddTicksToThis)
      : rOutputAddRef(rAddTicksToThis)
      { nClStart = getCurrentTicks(); }
  ~StopWatch   ( )
      { rOutputAddRef += (getCurrentTicks() - nClStart); }
num nClStart, &rOutputAddRef;
};

// copies a maximum of nMaxDst MINUS ONE chars,
// AND adds a zero terminator at pszDst (within nMaxDst range!).
// to use this like strncpy, always add +1 to nMaxDst.
// NOTE: if nMaxDst == 0, NO zero terminator is added.
void mystrcopy(char *pszDst, cchar *pszSrc, int nMaxDst) {
   if (nMaxDst < 2) {
      if (nMaxDst >= 1)
         pszDst[0] = '\0';
      return;
   }
   int nLen = strlen(pszSrc);
   if (nLen > nMaxDst-1)
      nLen = nMaxDst-1;
   memcpy(pszDst, pszSrc, nLen);
   pszDst[nLen] = '\0';
}
#define strcopy(dst,src) mystrcopy(dst,src,sizeof(dst)-10)

int mystrwlen(const ushort *psz) {
   int ilen=0;
   while (psz[ilen])
      ilen++;
   return ilen;
}

void mystrwcopy(ushort *pszDst, const ushort *pszSrc, int nMaxChr) {
   if (nMaxChr < 2) {
      if (nMaxChr >= 1)
         pszDst[0] = '\0';
      return;
   }
   int nChr = mystrwlen(pszSrc);
   if (nChr > nMaxChr-1)
      nChr = nMaxChr-1;
   memcpy(pszDst, pszSrc, nChr*2);
   pszDst[nChr] = '\0';
}
#define strwcopy(dst,src) mystrwcopy(dst,src,(int)(sizeof(dst)-10)/2)

ushort *mystrwdup(ushort *psrc,int *pnchars=0)
{
   int nchr=mystrwlen(psrc);
   ushort *pres=new ushort[nchr+2]; // with tolerance
   if (!pres) return 0;
   memset(pres,0,(nchr+2)*2);
   memcpy(pres,psrc,(nchr+1)*2); // with term
   if (pnchars) *pnchars=nchr;
   return pres;
}

uchar *mymemdup(char *psz, int nlen)
{
   uchar *p = new uchar[nlen+2];
   if (!p) return p;
   memcpy(p, psz, nlen);
   p[nlen] = '\0'; // tolerance
   return p;
}

// remove blanks from right side of a string
void myrtrim(char *pszBuf) {
   int nlen = strlen(pszBuf);
   while (nlen > 0 && pszBuf[nlen-1] == ' ') {
      pszBuf[nlen-1] = '\0';
      nlen--;
   }
}

void myrtrimany(char *pszBuf, cchar *pfilt) {
   int nlen = strlen(pszBuf);
   while (nlen > 0 && strchr(pfilt, pszBuf[nlen-1])) {
      pszBuf[nlen-1] = '\0';
      nlen--;
   }
}

void skipUntil(char **pp, cchar *pdelim) {
   char *p = *pp;
   while (*p && !strchr(pdelim, *p))
      p++;
   *pp = p;
}

void skipOver(char **pp, cchar *pdelim) {
   char *p = *pp;
   while (*p && strchr(pdelim, *p))
      p++;
   *pp = p;
}

bool isws(char c,bool bext=0)
{
   if (c == ' ') return 1;
   if (c == '\t') return 1;
   if (bext) {
      if (c=='\r' || c=='\n')
         return 1;
   }
   return 0;
}

bool iseol(char c) {
   if (c == '\r') return 1;
   if (c == '\n') return 1;
   return 0;
}

bool isRemarkStart(char *psz) // like !strncmp(ptok, "//", 2) but with space check
{ 
   if (strncmp(psz, "//", 2)) return 0;
   if (isspace(psz[2])) return 1;
   // sfk197 deprecation of "//" remarks without whitespace
   static bool btold=0;
   if (btold) return 1;
   btold=1;
   pwarn("missing space after '//' remark is deprecated: %.32s\n", dataAsTrace(psz));
   return 1;
}

void skipToWhite(char **pp) { skipUntil(pp, " \t\r\n"); }
void skipWhite(char **pp)   { skipOver(pp, " \t\r\n");  }

int nextLine(char **pp) {
   char *p = *pp;
   while (*p!=0 && *p!='\r' && *p!='\n')
      p++;
   if (*p!='\r' && *p!='\n')
      return 1;
   while (*p!=0 && (*p=='\r' || *p=='\n'))
      *p++ = '\0';
   *pp = p;
   return 0;
}

void swapchars(char *p, num nlen)
{
   if (nlen < 2)
      return;

   num nhalf = nlen / 2;
   num imax  = nlen - 1;

   for (num i=0; i<nhalf; i++) 
   {
      char c = p[i];
      p[i] = p[imax-i];
      p[imax-i] = c;
   }
}

bool alldigits(char *psz) {
   for (; *psz; psz++)
      if (!isdigit(*psz))
         return 0;
   return 1;
}

char szSafeRunBuf[MAX_LINE_LEN+10]; // sfk1972

// change "mycmd" to "mycmd 2>&1".
char *safeRunCommand(char *psz) {
   if (strstr(psz, " 2>"))
      return psz;
   mystrcopy(szSafeRunBuf, psz, MAX_LINE_LEN);
   strcat(szSafeRunBuf, " 2>&1");
   return szSafeRunBuf;
}

unum getFlexNum(char *psz, bool bAllHex)
{
   /*
      123
      123.123.123.123
      010101011101010
      010.011.101.010
      ab2f37e9
      0x123
      0o234
      0b100
   */

   // pass 1: get overall type
   bool bbin=0,bdig=0,bxdig=bAllHex,bdots=0,bchar=0;
   if (strBegins(psz, "0x"))
      { bxdig=1; psz+=2; }
   else
   if (strBegins(psz, "0b"))
      { bbin=1; psz+=2; }
   else
   if (strBegins(psz, "0t"))
      { bchar=1; psz+=2; }
   else
   for (char *psz2=psz; *psz2; psz2++) {
      char c = tolower(*psz2);
      if (isdigit(c))
         { bdig=1; continue; }
      if (isxdigit(c))
         { bxdig=1; continue; }
      if (c=='0' || c=='1')
         { bbin=1; continue; }
      if (c=='.')
         { bdots=1; continue; }
      bchar=1;
   }

   int ibase=1;
   if (bxdig) ibase=16;
   else
   if (bdig)  ibase=10;
   else
   if (bbin)  ibase=2;

   // pass 2: collect number(s)
   unum ncur=0,nout=0;
   for (; *psz; psz++) {
      char c = tolower(*psz);
      if (c=='.') {
         nout = nout + ncur;
         nout = nout * 256;
         ncur = 0;
         continue;
      }
      if (bchar) {
         ncur = ncur * 256;
         ncur = ncur + (unum)(*psz);
         continue;
      }
      ncur = ncur * ibase;
      switch (c) {
         case '0': case '1': case '2': case '3': case '4':
         case '5': case '6': case '7': case '8': case '9':
            ncur = ncur + ((unum)c - '0');
            continue;
         case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
            ncur = ncur + 10 + ((unum)c - 'a');
            continue;
      }
   }

   nout = nout + ncur;

   return nout;
}

double getcalcval(char *psz, char **pcont)
{
   if (!strncmp(psz, "0x", 2)) {
      // must be unsigned long integer
      #ifdef _MSC_VER
      return (double)_strtoui64(psz+2, pcont, 0x10);
      #else
      return (double)strtoull(psz+2, pcont, 0x10);
      #endif
   } else {
      // accept signed double
      return strtod(psz, pcont);
   }
}

extern cchar *pszGlblBlank;

int sfkcalc(double &r, char *pszFrom, char **ppNext, int iLevel, bool bStopPM=0)
{
   double v1=0.0,v2=0.0;

   if (cs.debug) printf("%.*s[%s]\n",iLevel*2,pszGlblBlank,pszFrom);

   char *pszNext=0;
   int   iOwnBra=0;

   skipWhite(&pszFrom); // sfk1962

   if (isdigit(*pszFrom)!=0 || *pszFrom=='-') {
      v1=getcalcval(pszFrom,&pszNext);
      pszFrom=pszNext;
   } else if (cs.brackets==1 && *pszFrom=='(') {
      pszFrom++;
      iOwnBra++;
      if (sfkcalc(v1,pszFrom,&pszNext,iLevel+1))
         return 9;
      pszFrom=pszNext;
   }
     else return 9+perr("invalid: %s\n",pszFrom);

   bool bstop=0;
   while (*pszFrom!=0 && bstop==0)
   {
      skipWhite(&pszFrom); // sfk1962
      if (*pszFrom==0)     // sfk1962
         break;

      if (cs.debug) printf("%.*s[%s]\n",iLevel*2,pszGlblBlank,pszFrom);

      // get * / + -
      char c = *pszFrom++;
      switch (c)
      {
         case ')':
            if (!cs.brackets)
               return 9+perr("invalid: %s\n",pszFrom-1);
            if (cs.debug) printf("%.*s) %f\n",iLevel*2,pszGlblBlank,v1);
            if (iOwnBra-- <= 0) {
               bstop=1;
               pszFrom--;
            }
            continue;
         case '*':
            if (cs.brackets==1 && *pszFrom=='(') {
               pszFrom++;
               iOwnBra++;
               if (sfkcalc(v2,pszFrom,&pszNext,iLevel+1))
                  return 9;
            } else {
               v2=getcalcval(pszFrom,&pszNext);
            }
            if (cs.debug) printf("%.*s%f * %f = %f\n",iLevel*2,pszGlblBlank,v1,v2,v1*v2);
            v1 *= v2;
            pszFrom=pszNext;
            continue;
         case '/':
            if (cs.brackets==1 && *pszFrom=='(') {
               pszFrom++;
               iOwnBra++;
               if (sfkcalc(v2,pszFrom,&pszNext,iLevel+1))
                  return 9;
            } else {
               v2=getcalcval(pszFrom,&pszNext);
            }
            if (v2 == 0.0)
               return 9+perr("division by zero: %s\n",pszFrom);
            if (cs.debug) printf("%.*s%f / %f = %f\n",iLevel*2,pszGlblBlank,v1,v2,v1/v2);
            v1 /= v2;
            pszFrom=pszNext;
            continue;
         case '+':
            if (bStopPM) {
               pszFrom--;
               bstop=1;
               continue;
            }
            if (sfkcalc(v2, pszFrom, &pszNext, iLevel+1, 1))
               return 9;
            if (cs.debug) printf("%.*s%f + %f = %f\n",iLevel*2,pszGlblBlank,v1,v2,v1+v2);
            v1 += v2;
            pszFrom=pszNext;
            continue;
         case '-':
            if (bStopPM) {
               pszFrom--;
               bstop=1;
               continue;
            }
            if (sfkcalc(v2, pszFrom, &pszNext, iLevel+1, 1))
               return 9;
            if (cs.debug) printf("%.*s%f - %f = %f\n",iLevel*2,pszGlblBlank,v1,v2,v1-v2);
            v1 -= v2;
            pszFrom=pszNext;
            continue;
         default:
            return 9+perr("invalid: %s\n",pszFrom-1);
      }
   }

   r=v1;
   if (ppNext) *ppNext=pszFrom;

   return 0;
}

struct tm *mylocaltime(mytime_t *ptime)
{
   #ifdef SFK_W64
   return _localtime64(ptime);
   #else
   return localtime(ptime);
   #endif
}

struct tm *mygmtime(mytime_t *ptime)
{
   #ifdef SFK_W64
   return _gmtime64(ptime);
   #else
   return gmtime(ptime);
   #endif
}

#ifdef _WIN32
 #define getcwd _getcwd
 #define rmdir  _rmdir
#endif

bool bGlblGotToMake = 0;

uchar *newBitField(int iTotalEntries)
{
   int iByteSize = (iTotalEntries / 8) + 1;
   int iTolerance= 4;
   uchar *pField = new uchar[iByteSize+iTolerance];
   if (!pField)
      return 0;
   memset(pField, 0, iByteSize+iTolerance);
   int *pSize = (int *)pField;
   *pSize = iTotalEntries;
   return pField;
}
// can be freed by delete [] pField
// sfkSetBit, sfkGetBit see sfkbase.hpp

UTF8Codec::UTF8Codec(char *pOptInData, int iOptionalInputLength)
{
   memset(this, 0, sizeof(*this));

   if (pOptInData)
      init(pOptInData, iOptionalInputLength);
}

void UTF8Codec::init(char *p, int ilen)
{
   icur = 0;
   psrc = (uchar*)p;

   if (ilen < 0)
      imax = strlen(p);
   else
      imax = ilen;
}

int UTF8Codec::readRaw()
{
   if (icur >= imax)
      return 0;
   return psrc[icur++] & 0xFF;
}

int UTF8Codec::readSeq()
{
   int c = readRaw();
   return ((c & 0xC0) == 0x80) ? (c & 0x3F) : -1;
}

bool UTF8Codec::hasChar() { return (icur < imax) ? 1 : 0; }

bool UTF8Codec::eod() { return (icur >= imax) ? 1 : 0; }

int  UTF8Codec::validSeqLen(char *pszSrc, int iMaxSrc)
{
   UTF8Codec obj;
   return obj.validSeqLenInt(pszSrc, iMaxSrc);
}

int  UTF8Codec::validSeqLenInt(char *pszSrc, int iMaxSrc)
{
   if (iMaxSrc < 2)
      return 0;

   init(pszSrc, iMaxSrc);

   if (icur >= imax)
        return 0;

   int c = readRaw();

   int iold = icur;

   if ((c & 0x80) == 0)
      return 0;

   int c1,c2,c3,n;

   if ((c & 0xE0) == 0xC0) {
      if ((c1 = readSeq()) < 0)
         return 0;
      n = ((c & 0x1F) << 6) | c1;
      if (n >= 128)
         return 2;
      return 0;
   } else if ((c & 0xF0) == 0xE0) {
      if ((c1 = readSeq()) < 0)
         return 0;
      if ((c2 = readSeq()) < 0)
         return 0;
      n = ((c & 0x0F) << 12) | (c1 << 6) | c2;
      if (n >= 0x800 && (n < 0xD800 || n > 0xDFFF))
         return 3;
      return 0;
   } else if ((c & 0xF8) == 0xF0) {
      if ((c1 = readSeq()) < 0)
         return 0;
      if ((c2 = readSeq()) < 0)
         return 0;
      if ((c3 = readSeq()) < 0)
         return 0;
      return 4;
   }

   return 0;
}

uint UTF8Codec::nextChar()
{
   if (icur >= imax)
      return 0;

   if (bdecodexml==1 && psrc[icur]=='&')
   {
      // decode xml predefined entities
      int irem=imax-icur;
      if (irem>=6 && !strncmp((char*)psrc+icur, "&quot;", 6))
        { icur+=6; return '\"'; }
      if (irem>=6 && !strncmp((char*)psrc+icur, "&apos;", 6))
        { icur+=6; return '\''; }
      if (irem>=5 && !strncmp((char*)psrc+icur, "&amp;", 5))
        { icur+=5; return '&'; }
      if (irem>=4 && !strncmp((char*)psrc+icur, "&lt;", 4))
        { icur+=4; return '<'; }
      if (irem>=4 && !strncmp((char*)psrc+icur, "&gt;", 4))
        { icur+=4; return '>'; }
      icur++;
      return '&';
   }

   int c = readRaw();

   int iold = icur;

   if (bkeeputf == 1 || (c & 0x80) == 0)
      return c;

   banychars = 1;

   int c1,c2,c3,n;

   do {
      if ((c & 0xE0) == 0xC0) {
         if ((c1 = readSeq()) < 0)
            break;
         n = ((c & 0x1F) << 6) | c1;
         if (n >= 128)
            return n;
      } else if ((c & 0xF0) == 0xE0) {
         if ((c1 = readSeq()) < 0)
            break;
         if ((c2 = readSeq()) < 0)
            break;
         n = ((c & 0x0F) << 12) | (c1 << 6) | c2;
         if (n >= 0x800 && (n < 0xD800 || n > 0xDFFF))
            return n;
      } else if ((c & 0xF8) == 0xF0) {
         if ((c1 = readSeq()) < 0)
            break;
         if ((c2 = readSeq()) < 0)
            break;
         if ((c3 = readSeq()) < 0)
            break;
         return (((c & 0x0F) << 18) | (c1 << 12) | (c2 << 6) | c3) + 0x10000;
      }
   }
   while (0);

   // invalid sequence:
   bbadchars = 1;

   // return undecoded text
   icur = iold;

   return c;
}

bool UTF8Codec::isValidUTF8(char *psz)
{
   UTF8Codec utf(psz);

   while (utf.nextChar());

   if (utf.banychars==0)
      return 0;
   if (utf.bbadchars==1)
      return 0;

   return 1;
}

int UTF8Codec::toutf8(char *pszOut, int iMaxOut, uint ch)
{
   uint c = ch;
   int len = 0;
   uint first = 0;
 
   if (c < 0x80) {
      first = 0;
      len = 1;
   }
   else if (c < 0x800) {
      first = 0xc0;
      len = 2;
   } else if (c < 0x10000) {
      first = 0xe0;
      len = 3;
   } else if (c < 0x200000) {
      first = 0xf0;
      len = 4;
   } else if (c < 0x4000000) {
      first = 0xf8;
      len = 5;
   } else {
      first = 0xfc;
      len = 6;
   }

   if (len >= iMaxOut)
      return 0;

   if (!pszOut)
      return 0;

   for (int i = len - 1; i > 0; i--)
   {
      pszOut[i] = (char)((c & 0x3f) | 0x80);
      c >>= 6;
   }
   pszOut[0] = c | first;
 
   return len;
}

int UTF8Codec::toutf8(char *pszOut, int iMaxOut, char *pszSrc, bool bSafe)
{
   if (iMaxOut < 2)
      return 0;

   *pszOut = '\0';

   char *pDstCur = pszOut;
   char *pDstMax = pszOut+iMaxOut;
   int   iSrcLen = strlen(pszSrc);

   uchar *pSrcCur = (uchar*)pszSrc;
   uchar *pSrcMax = pSrcCur + iSrcLen;

   UTF8Codec obj;

   while (pSrcCur<pSrcMax && *pSrcCur != 0)
   {
      if (bSafe) {
         // skip existing utf8 sequences in mixed text
         int l = obj.validSeqLenInt((char*)pSrcCur, pSrcMax-pSrcCur);
         if (l > 0) {
            if (pDstCur+l >= pDstMax)
               break;
            memcpy(pDstCur, pSrcCur, l);
            pDstCur += l;
            pSrcCur += l;
            continue;
         }
      }

      uint c = *pSrcCur;
      int  n = toutf8(pDstCur, pDstMax-pDstCur, c);
      if (n < 1)
         break;
      if (pDstCur >= pDstMax)
         break;
      pDstCur += n;
      pSrcCur++;
   }

   if (pDstCur >= pDstMax)
      pDstCur = pDstMax-1;

   *pDstCur = '\0';

   return pDstCur - pszOut;
}

// ====== SFK primitive function library end   ========

// =========== Profiling ==========

#ifdef SFK_PROFILING

// CRITICAL: static constructor sequence
// <-> StaticPerformancePoint
StaticPerformanceStats glblPerfStats;

StaticPerformanceStats::StaticPerformanceStats( )
{
   memset(this, 0, sizeof(*this));
}

void StaticPerformanceStats::addPoint(StaticPerformancePoint *pPoint)
{
   if (iClPoints >= MAX_PERF_POINTS)
   {
      fprintf(stdout, "ERROR: too many profiling points\n");
      fprintf(stderr, "ERROR: too many profiling points\n");
      return;
   }

   apClPoints[iClPoints++] = pPoint;
}

int StaticPerformanceStats::numberOfPoints( )
   { return iClPoints; }

StaticPerformancePoint *StaticPerformanceStats::getPoint(int iIndex)
   { return apClPoints[iIndex]; }

// CRITICAL: static constructor sequence
// <-> StaticPerformanceStats
StaticPerformancePoint::StaticPerformancePoint(const char *pszID,
   const char *pszFile, int iTraceLine)
{
   pszClID = pszID;
   pszClFile = pszFile;
   iClTraceLine = iTraceLine;
   iClHits = 0;
   iClTotalTime = 0;
   iClSubTimes = 0;
   glblPerfStats.addPoint(this);
}

void StaticPerformancePoint::blockEntry( )
   { iClHits++; }

void StaticPerformancePoint::blockExit(int iElapsedTicks)
   { iClTotalTime += iElapsedTicks; }

DynamicPerformancePoint::DynamicPerformancePoint(StaticPerformancePoint *pStaticPoint)
{
   nClEntryTickCount = getPerfCnt();
   pClStaticPoint = pStaticPoint;

   // enter next level
   pClStaticParent = glblPerfStats.pClCurrentPoint;
   glblPerfStats.pClCurrentPoint = pClStaticPoint;

   pClStaticPoint->blockEntry();
}

DynamicPerformancePoint::~DynamicPerformancePoint( )
{
   num iElapsed = getPerfCnt() - nClEntryTickCount;

   pClStaticPoint->blockExit((int)iElapsed);

   // up one level
   if (pClStaticParent)
      pClStaticParent->iClSubTimes += iElapsed;
   glblPerfStats.pClCurrentPoint = pClStaticParent;
}

void logProfile( )
{
   num nTicksPerMSec = getPerfFreq() / 1000;
   if (!nTicksPerMSec)
       nTicksPerMSec = 1;

   printf("performance (%d points):\n", glblPerfStats.numberOfPoints());

   int iTotalMSec = 0;
   int iTotalPerc = 0;

   for (int ipass=0; ipass<2; ipass++)
   for (int i=0; i<glblPerfStats.numberOfPoints(); i++)
   {
      StaticPerformancePoint *p = glblPerfStats.getPoint(i);

      num nNetto = p->iClTotalTime - p->iClSubTimes;
      num nMSec  = nNetto / nTicksPerMSec;

      if (!ipass) {
         iTotalMSec += (int)nMSec;
      } else {
         int iPerc = nMSec * 100 / (iTotalMSec ? iTotalMSec : 1);
         iTotalPerc += iPerc;
         printf("% 10s : % 10I64d % 5d % 3d%% % 8I64d   %s:%d   (%d-%d)\n",
            p->pszClID,
            nNetto, (int)nMSec, iPerc,
            p->iClHits,
            p->pszClFile,
            p->iClTraceLine,
            (int)p->iClTotalTime, (int)p->iClSubTimes
            );
      }
   }

      printf("% 10s : % 10I64d % 5d % 3d%% % 8I64d   %s:%d   (%d-%d)\n",
         "total",
         (num)0, iTotalMSec, iTotalPerc,
         (num)0,
         "any",
         0,
         0, 0
         );
}

#else

void logProfile( )
{
}

#endif

// ====== SFK crash handler begin ========

struct SFKSysLog
{
   SFKSysLog ( );

   uint aSysLog[256];
   unsigned char iSysLog;
};

char *pszGlblSysLogFileName = 0;

SFKSysLog::SFKSysLog( ) { memset(this, 0, sizeof(*this)); }

struct SFKSysLog glblDefaultSysLog, glblDummySysLog;

struct SFKSysLog *pGlblSysLog = &glblDefaultSysLog;

#define MyModuleId 0 // not yet used

#ifndef MTK_TRACE
 #ifndef USE_SFK_BASE
  #undef __
  #define __                 \
     pGlblSysLog->aSysLog[pGlblSysLog->iSysLog++] = \
        (__LINE__     << 16) \
      | (MyModuleId & 0xFFFFU);
 #endif
#endif

static void showSysLog( )
{
   static char szBuf[2048];
   static char szWord[100];
   static const char *ahex = "0123456789ABCDEF";

   struct SFKSysLog *pCurLog = pGlblSysLog;

   // disable further writes to main log
   pGlblSysLog = &glblDummySysLog;

   int istart=0,icur=0,isteps=0;
   uint imix,iline=0,ithread=0;
   char *pdst=0,*pmax=szBuf+sizeof(szBuf)-100;

   istart = pCurLog->iSysLog;
   icur   = istart;
   if (icur > 0) icur--; else icur = 0xFFU;

   pdst = szBuf;

   strcat(pdst, "program version: SFK " SFK_VERSION SFK_FIXPACK "\n"
                "\n=== last steps: ===\n");
   pdst += strlen(pdst);

   for (; isteps < 100 && pdst < pmax; isteps++)
   {
      imix = pCurLog->aSysLog[icur];
      iline = (imix >> 16) & 0xFFFFU;
      ithread = (imix & 0xFFFFU);

      // 01.00000
      // 012345678
      pdst[0+1]  = ahex[(ithread >>  0) & 0x0F];
      pdst[0+0]  = ahex[(ithread >>  4) & 0x0F];
      pdst[0+2]  = '.';
      pdst[3+4]  = ahex[(iline /     1) % 10];
      pdst[3+3]  = ahex[(iline /    10) % 10];
      pdst[3+2]  = ahex[(iline /   100) % 10];
      pdst[3+1]  = ahex[(iline /  1000) % 10];
      pdst[3+0]  = ahex[(iline / 10000) % 10];
      pdst[8]    = ((isteps % 5)==4) ? '\n' : ' ';
      pdst += 9;

      if (icur > 0) icur--; else icur = 0xFFU;
   }

   *pdst = '\0';

   if (pszGlblSysLogFileName)
   {
      strcat(pdst, "=== see also: ");
      strcat(pdst, pszGlblSysLogFileName);
      strcat(pdst, " ===\n");
 
      // try to write a report file
      FILE *fout = fopen(pszGlblSysLogFileName,"w");
      if (fout)
      {
         fwrite(szBuf, 1, strlen(szBuf), fout);
         fclose(fout);
      }
   }
 
   #ifdef _WIN32

   MessageBox(0, szBuf, "fatal error", MB_OK);

   #else

   fprintf(stderr, "=== fatal error during execution ===\n%s\n", szBuf);

   #endif

   exit(-1);
}

// - - - - -

static void crashTest( )
{
   char *p = 0;
   *p = 'a';
}

static void traceModeCrashHandler(int sig)
{
   static int crashRecursionCounter = 0;
   crashRecursionCounter++;
   if (crashRecursionCounter < 2)
   {
      crashRecursionCounter++;

      #ifdef WITH_TRACING
      // dump stack trace to error log
      mtkDumpLastSteps(0);
      mtkDumpStackTrace(0);
      #else
      showSysLog();
      #endif
   }
   printf("sfk exits due to segment violation.\n");
   exit(255);
}

#ifndef USE_SFK_BASE
void initCrashHandler(char *pszDumpFile)
{
   pszGlblSysLogFileName = pszDumpFile; // if any

   void (*pfhand)(int) = traceModeCrashHandler;
   sigset_t mask;
   sigemptyset(&mask);
#ifdef SIGSEGV
   signal (SIGSEGV, pfhand);
   sigaddset(&mask, SIGSEGV);
#else
   #error no_sigsegv_defined
#endif
#ifdef SIGFPE
   signal (SIGFPE, pfhand);
   sigaddset(&mask, SIGFPE);
#else
   #error no_sigfpe_defined
#endif
#ifdef SIGILL
   signal (SIGILL, pfhand);
   sigaddset(&mask, SIGILL);
#else
   #error no_sigill_defined
#endif
#ifdef SIGABRT
   signal (SIGABRT, pfhand);
   sigaddset(&mask, SIGABRT);
#else
   #error no_sigabrt_defined
#endif
   sigprocmask(SIG_UNBLOCK, &mask, 0);
}
#endif // USE_SFK_BASE

// ====== SFK trace mode crash handler end ========

int iGlblInScript = 0;

// see also cs.curcmd
static bool bGlblCurCmdSet = 0;
static char szGlblCurCmd[50];

class CommandScope {
public:
      CommandScope (cchar *pszcmd);
     ~CommandScope ( );
};

CommandScope::CommandScope(cchar *pszcmd) {
   strcopy(szGlblCurCmd, pszcmd);
   bGlblCurCmdSet = 1;
}

CommandScope::~CommandScope() {
   bGlblCurCmdSet = 0;
}

#ifdef VFILEBASE

const char *pGlblHttpUserAgent = 0;

static char szGlblUserAgent[100];

void setHTTPUserAgent(const char *psz)
   { pGlblHttpUserAgent = psz; }

char *getHTTPUserAgent()
{
   if (pGlblHttpUserAgent)
      return str(pGlblHttpUserAgent); // sfk1933

   if (bGlblCurCmdSet)
      snprintf(szGlblUserAgent, sizeof(szGlblUserAgent)-10,
         "Swiss File Knife/" SFK_VERSION " (sfk %s, " VER_STR_OS ")",
            szGlblCurCmd);
   else
      snprintf(szGlblUserAgent, sizeof(szGlblUserAgent)-10,
         "Swiss File Knife/" SFK_VERSION " (" VER_STR_OS ")");

   char *psz = strstr(szGlblUserAgent, "windows-any)");
   if (psz) strcpy(psz, "windows)");

   return szGlblUserAgent;
}

#endif // VFILEBASE

// fwrite on windows network drives may fail with blocks > 60 MB,
// therefore a single block write is limited to this size:
#define SFK_IO_BLOCK_SIZE 10000000 // about 10 MB

// optional callback tracing for hot spots
void (*pGlblTraceCallback)(char *pmsg) = 0;
static char szTraceBuf[1024+10];
void cbtrace(const char *pszFormat, ...)
{
   if (!pGlblTraceCallback) return;
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szTraceBuf, sizeof(szTraceBuf)-10, pszFormat, argList);
   szTraceBuf[sizeof(szTraceBuf)-10] = '\0';
   pGlblTraceCallback(szTraceBuf);
}

int getFileStat( // RC == 0 if exists anything
   char  *pszName,
   int   &rbIsDirectory,
   int   &rbCanRead,
   int   &rbCanWrite,
   num   &rlFileTime,
   num   &rlFileSize,
   num   *ppcatimes  = 0,  // optional: creation and access time
   void  *prawstat   = 0,  // optional: create copy of stat structure
   int    nrawstatmax= 0,  // size of above buffer
   uint   nmodeflags = 0   // bit 0: use alternative stat, if available
   );

#define delstring(x) \
   if (x) {          \
      delete [] x;   \
      x = 0;         \
   }

// this also sets zero terminator at end of string,
// i.e. nmaxlen means including zero terminator.
void setattr(char *pdst, uchar uc, uint nlen, uint nmaxlen)
{
   if (nlen > nmaxlen) nlen = nmaxlen;
   if (nlen > 0) {
      memset(pdst, uc, nlen-1);
      pdst[nlen-1] = '\0';
   } else {
      pdst[0] = '\0';
   }
}

bool myisxdigit(char c) {
   if (c >= '0' && c <= '9') return 1;
   if (c >= 'a' && c <= 'f') return 1;
   if (c >= 'A' && c <= 'F') return 1;
   return 0;
}

int getTwoDigitHex(char *psz)
{
   char szHex[10];

   if (!*psz) return -1;
   szHex[0] = tolower(*psz++);
   if (!myisxdigit(szHex[0])) return -1;

   if (!*psz) return -1;
   szHex[1] = tolower(*psz++);
   if (!myisxdigit(szHex[1])) return -1;

   szHex[2] = '\0';

   return (int)strtoul(szHex,0,0x10);
}

int getThreeDigitDec(char *psz)
{
   char szDec[10];

   if (!*psz) return -1;
   szDec[0] = tolower(*psz++);
   if (!isdigit(szDec[0])) return -1;

   if (!*psz) return -1;
   szDec[1] = tolower(*psz++);
   if (!isdigit(szDec[1])) return -1;

   if (!*psz) return -1;
   szDec[2] = tolower(*psz++);
   if (!isdigit(szDec[2])) return -1;

   szDec[3] = '\0';

   return (int)strtoul(szDec,0,10);
}

void doSleep(int nmsec)
{
   #ifdef _WIN32
   Sleep(nmsec);
   #else
   // sleep(1);
   const timespec ts = { nmsec / 1000, nmsec % 1000 * 1000000 };
   nanosleep(&ts, NULL);
   #endif
}

void doYield( )
{
   #ifdef _WIN32
   SwitchToThread();
   #else
   // yield();
   ::usleep(50);
   #endif
}

int nGlblShellRC = 0;

struct CommandStats gs;    // global settings accross whole chain
struct CommandStats cs;    // command local statistics or settings
struct CommandStats cspre; // of previous command
struct CommandStats dummyCommandStats;

num getTotalBytes()    { return cs.totalbytes; }
void clearTotalBytes() { cs.totalbytes=0; }

#ifdef WINFULL

#define wstrlen  wcslen    // use mystrwlen
#define wstrchr  wcschr
#define wstrrchr wcsrchr

bool vname() { return cs.uname || cs.tname || cs.aname; }

sfkname::sfkname(const char *psz, bool bpure)
{
   memset(this, 0, sizeof(*this));
   strcopy(szname, psz);
   nstate = 1;
}

sfkname::sfkname(ushort *pwsz)
{
   memset(this, 0, sizeof(*this));
   wcsncpy((wchar_t*)awname, (wchar_t*)pwsz, sfkmaxname);
   nstate = 2;
}

ushort *sfkname::wname( )
{
   bbadconv = 0;

   if (nstate & 2)
      return awname;
   if (!(nstate & 1))
      return 0;

   awname[0] = 0;

   // convert from szname
   #ifdef SFK_UNAME
   if (cs.uname)
   {
      mclear(awname);
      int irc = MultiByteToWideChar(   // win.wname
         CP_UTF8, 0,
         szname, strlen(szname),
         (wchar_t*)awname, sfkmaxname
         );
      if (!irc) bbadconv = 1;
   }
   else if (cs.aname)
   {
      mclear(awname);
      int irc = MultiByteToWideChar(   // win.aname
         CP_ACP, 0,
         szname, strlen(szname),
         (wchar_t*)awname, sfkmaxname
         );
      if (!irc) bbadconv = 1;
   }
   #endif // SFK_UNAME

   if (cs.tname) // tname.decode
   {
      ushort *pdstcur = awname;
      ushort *pdstmax = pdstcur+sfkmaxname;
      int i=0;
      for (; pdstcur<pdstmax && szname[i]!=0; i++)
      {
         if (   szname[i+0]=='<'
             && isxdigit(szname[i+1])
             && isxdigit(szname[i+2])
             && isxdigit(szname[i+3])
             && isxdigit(szname[i+4])
             && szname[i+5]=='>'
            )
         {
            ushort c = (ushort)strtoul(szname+i+1,0,0x10);
            *pdstcur++ = c;
            i += 5;
            continue;
         }
         *pdstcur++ = ((ushort)szname[i]) & 0xFFU;
      }
      *pdstcur = 0;
   }

   return awname;
}

char *sfkname::vname( )
{
   bbadconv = 0;

   if (nstate & 1)
      return szname;
   if (!(nstate & 2))
      return 0;

   szname[0] = '\0';

   // convert from wname
   #ifdef SFK_UNAME
   if (cs.uname)
   {
      // result is NOT zero terminated!
      mclear(szname);
      int irc = WideCharToMultiByte(   // vname.utf8
         CP_UTF8, 0,
         (wchar_t*)awname, wcslen((wchar_t*)awname),
         szname, sfkmaxname, 0, 0);
      if (!irc) bbadconv = 1;
   }
   else if (cs.aname)
   {
      int irc = sfkchars.strunitoansi(awname, sfkchars.wlen(awname),
         szname, sfkmaxname);
      if (irc > 0) bbadconv = 1;
   }
   #endif // SFK_UNAME

   if (cs.tname) // tname.encode
   {
      char *pdstcur = szname;
      char *pdstmax = szname+sfkmaxname;
      int i=0;
      for (; pdstcur<pdstmax && awname[i]!=0; i++)
      {
         ushort c = awname[i];
         if (c < 0x0100U) {
            *pdstcur++ = (char)c;
            continue;
         }
         sprintf(pdstcur, "<%04X>", c);
         pdstcur += 6;
      }
      *pdstcur = '\0';
   }

   return szname;
}

#endif // WINFULL

bool infoAllowed() {
   if (cs.quiet)  return 0;
   if (cs.noinfo) return 0;
   return 1;
}

int quietMode() { return cs.quiet; }
int fastMode()  { return cs.fast;  }

#ifdef VFILEBASE
void setxelike(bool byes) { gs.xelike = cs.xelike = byes; }
#endif // VFILEBASE

#if (defined(WITH_TCP) || defined(VFILENET) || defined(DV_TCP))

// IN: flags bit 0: include port
//           bit 1: triple digits
char *ipAsString(struct sockaddr_in *pAddr, char *pszBuffer, int iBufferSize, uint uiFlags=0)
{
   if (iBufferSize > 0)
      pszBuffer[0] = '\0'; // safety
 
   if (iBufferSize < 20)
      return str("?");

   uint uiIP  = ntohl(pAddr->sin_addr.s_addr);
   int  iPort = ntohs(pAddr->sin_port);

   char szPortInfo[50];
   if (uiFlags & 1)
      sprintf(szPortInfo, ":%d", iPort);
   else
      szPortInfo[0] = '\0';
 
   snprintf(pszBuffer, iBufferSize-4,
      (uiFlags & 2) ? "%03u.%03u.%03u.%03u%s" : "%u.%u.%u.%u%s",
      (uiIP >> 24) & 0xFFU,
      (uiIP >> 16) & 0xFFU,
      (uiIP >>  8) & 0xFFU,
      (uiIP >>  0) & 0xFFU,
      szPortInfo
      );
 
   return pszBuffer;
}

char *ipAsString(uint uiIP, int iPort)
{
   static char szBuf[100];

   char szPortInfo[50];
   if (iPort > 0)
      sprintf(szPortInfo, ":%d", iPort);
   else
      szPortInfo[0] = '\0';
 
   snprintf(szBuf, sizeof(szBuf)-4,
      "%u.%u.%u.%u%s",
      (uiIP >> 24) & 0xFFU,
      (uiIP >> 16) & 0xFFU,
      (uiIP >>  8) & 0xFFU,
      (uiIP >>  0) & 0xFFU,
      szPortInfo
      );
 
   return szBuf;
}

// mode 0: full list, or not, depending on environment
// mode 1: just a single ip
// mode 2: always full list
char *ownIPList(int &rhowmany, uint nPort, const char *psep, int nmode)
{
   static char szIPListBuf[200];
   szIPListBuf[0] = '\0';

   char szEnvNet[100]; szEnvNet[0]='\0';

   // if option -ownip=x is given
   if (cs.szownip[0]) {
      strcopy(szIPListBuf, cs.szownip);
      return szIPListBuf;
   }
   if (nmode < 2)
   {
      char *pszEnvIP = getenv("SFK_OWN_IP"); // sfk1962
      if (pszEnvIP) {
         strcopy(szIPListBuf, pszEnvIP);
         rhowmany = 1;
         return szIPListBuf;
      }
      char *pszEnvNet = getenv("SFK_OWN_NET"); // sfk1962
      if (pszEnvNet!=0 && strlen(pszEnvNet)>0) {
         strcopy(szEnvNet, pszEnvNet);
         if (szEnvNet[strlen(szEnvNet)-1]!='.')
            strcat(szEnvNet, ".");
      }
   }

   prepareTCP();

   char szPortStr[50];
   szPortStr[0] = '\0';
   if (nPort > 0)
      sprintf(szPortStr, ":%u", nPort);

   char *psz = 0;
   int ndone = 0;
   const char *pprefix = "";

   #ifdef _WIN32

   struct in_addr addr;

   hostent *pinfo = gethostbyname(""); // fails under linux
   if (pinfo) 
   {
      for (int i=0; pinfo->h_addr_list[i]; i++)
      {
         memcpy(&addr,pinfo->h_addr_list[i],sizeof(struct in_addr));

         const char *pszIP = inet_ntoa(addr);

         if (strcmp(pszIP, "127.0.0.1"))
         {
            // sfk1962: filter by sfk_own_net if not forced list
            if (nmode<2 && szEnvNet[0]!=0 && strncmp(pszIP,szEnvNet,strlen(szEnvNet))!=0)
               continue;

            int nlen = strlen(pszIP);
            int nrem = (int)sizeof(szIPListBuf) - (int)strlen(szIPListBuf);
            if (nlen < nrem - 10) {
                strcat(szIPListBuf, pprefix);
                strcat(szIPListBuf, pszIP);
                if (nmode==1)
                  return szIPListBuf;
                strcat(szIPListBuf, szPortStr); // if any
                pprefix = psep;
                ndone++;
            }
         }
      }
   }
   rhowmany = ndone;

   #else

   // linux: list all existing interface IPV4 addresses
   struct ifaddrs *pAdrObj = NULL;
   char szAdrBuf[200]; mclear(szAdrBuf);
   getifaddrs(&pAdrObj);
   while (pAdrObj != NULL)
   {
     if (   pAdrObj->ifa_addr != 0
         && pAdrObj->ifa_addr->sa_family == AF_INET
         && pAdrObj->ifa_name != 0
         && strcmp(pAdrObj->ifa_name, "lo0")
        )
     {
       void *pIPData = &((struct sockaddr_in *)pAdrObj->ifa_addr)->sin_addr;
       const char *pszIP = inet_ntop(AF_INET, pIPData, szAdrBuf, sizeof(szAdrBuf)-10);
       if (strcmp(pszIP, "127.0.0.1"))
       do
       {
          // sfk1962: filter by sfk_own_net if not forced list
          if (nmode<2 && szEnvNet[0]!=0 && strncmp(pszIP,szEnvNet,strlen(szEnvNet))!=0)
             break;

          int nlen = strlen(pszIP);
          int nrem = (int)sizeof(szIPListBuf) - (int)strlen(szIPListBuf);
          if (nlen < nrem - 10) {
             strcat(szIPListBuf, pprefix);
             strcat(szIPListBuf, pszIP);
             if (nmode==1)
               return szIPListBuf;
             strcat(szIPListBuf, szPortStr); // if any
             pprefix = psep;
             ndone++;
          }
       }
       while (0);
     }
     pAdrObj = pAdrObj->ifa_next;
   }
   rhowmany = ndone;

   #endif
 
   return szIPListBuf;
}

// linux only
char *getMacForIP(uint uiIP)
{
   #ifdef SFK_NATIVE_LINUX

   static char szBuf[100];
   static int  iBuf = 0;
   static int  iCtlSocket = INVALID_SOCKET;

	struct arpreq       areq;
	struct sockaddr_in *sin;
	struct in_addr      ipaddr;

   // get internet domain socket
   if (iCtlSocket == INVALID_SOCKET)
   {
      int s;
		if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
	      return 0;
      iCtlSocket = s;
   }
   // it stays allocated for process lifetime.

   // make arp request	
	memset(&areq, 0, sizeof(areq));
	sin = (struct sockaddr_in *) &areq.arp_pa;
	sin->sin_family = AF_INET;

   ipaddr.s_addr = uiIP;

	sin->sin_addr = ipaddr;
	sin = (struct sockaddr_in *) &areq.arp_ha;
	sin->sin_family = ARPHRD_ETHER;
	
	strncpy(areq.arp_dev, "eth0", 15);
	
	if (ioctl(iCtlSocket, SIOCGARP, (caddr_t) &areq) == -1)
      return 0;

   sprintf(szBuf, "%02x:%02x:%02x:%02x:%02x:%02x",
      areq.arp_ha.sa_data[0] & 0xFF,
      areq.arp_ha.sa_data[1] & 0xFF,
      areq.arp_ha.sa_data[2] & 0xFF,
      areq.arp_ha.sa_data[3] & 0xFF,
      areq.arp_ha.sa_data[4] & 0xFF,
      areq.arp_ha.sa_data[5] & 0xFF
      );

   return szBuf;

   #else

   return 0;

   #endif
}

#endif // WITH_TCP or VFILENET

void setArcTravel(bool bYesNo, bool bPreCache, int iProbeFiles)
{
   gs.travelzips  = bYesNo;
   cs.travelzips  = bYesNo;
   if (iProbeFiles != 2)
   {
      gs.probefiles  = iProbeFiles;
      cs.probefiles  = iProbeFiles;
   }
   #ifdef VFILEBASE
   cs.precachezip = bPreCache;
   #endif // VFILEBASE
}

bool getArcTravel( ) { return cs.travelzips; }

// for dview
void setLoadOffice(int iYesNo) {
   gs.office = iYesNo;
   cs.office = iYesNo;
   if (!iYesNo) {
      gs.justoffice = 0;
      cs.justoffice = 0;
   }
}

// for dview
void setLoadJustOffice(int iYesNo) {
   gs.justoffice = iYesNo;
   cs.justoffice = iYesNo;
}

void setSubLoad(bool bYesNo) {
   mtklog(("setsubload %d", bYesNo));
   gs.subdirs = bYesNo;
   cs.subdirs = bYesNo;
}

void setHiddenLoad(bool bYesNo) {
   mtklog(("sethidload %d", bYesNo));
   gs.hidden = bYesNo;
   cs.hidden = bYesNo;
}

void setBinaryLoad(bool bYesNo) {
   mtklog(("setbinload %d", bYesNo));
   gs.incbin = bYesNo;
   cs.incbin = bYesNo;
}

void setUTFLoad(bool bYesNo) {
   mtklog(("setutfload %d", bYesNo));
   gs.wchardec = bYesNo;
   cs.wchardec = bYesNo;
}

int getWrapLoad(bool &rrewrap) {
   rrewrap = cs.rewrap;
   return cs.wrapcol;
}
void setWrapLoad(int n, bool brewrap) {
   cs.wrapcol = n;
   gs.wrapcol = n;
   cs.wrapbincol = (n >= 80) ? ((n * 90) / 100 - 10) : 80;
   gs.wrapbincol = cs.wrapbincol;
   cs.rewrap = brewrap;
   gs.rewrap = brewrap;
}

// tells if cur matches mask, including variations:
// if mask="-sep" then "-sep" and "-ssep" is allowed.
bool isxopt(char *pszcur, cchar *pszmask)
{
   char szBuf[100];
   if (pszmask[0] != '-') return 0;
   if (strlen(pszmask) > sizeof(szBuf)-10) return 0;

   // check for indirect hit: "-seps".
   // if so, auto-activate slash patterns for this command.
   sprintf(szBuf, "%ss", pszmask);
   if (!strncmp(pszcur, szBuf, strlen(szBuf))) {
      cs.spat = 1;
      return 1;
   }

   // check for direct hit: "-sep"
   if (!strncmp(pszcur, pszmask, strlen(pszmask))) return 1;

   // check for indirect hit: "-ssep"
   cchar *pszbase = pszmask+1;

   // if so, auto-activate slash patterns for this command.
   sprintf(szBuf, "-s%s", pszbase);
   if (!strncmp(pszcur, szBuf, strlen(szBuf))) {
      cs.spat = 1;
      return 1;
   }

   // check for "-uform" to activate -upat syntax.
   sprintf(szBuf, "-u%s", pszbase);
   if (!strncmp(pszcur, szBuf, strlen(szBuf))) {
      setLinuxSyntax(1); // -uform
      return 1;
   }

   return 0;
}

// tells if cur matches mask, without variations.
bool isopt(char *pszcur, char *pszmask) {
   if (!strncmp(pszcur, pszmask, strlen(pszmask))) return 1;
   return 0;
}

CommandStats::CommandStats()
{
   memset(this, 0, sizeof(*this));
   reset();
}

void CommandStats::reset()
{
   memset(this, 0, sizeof(*this));
   wpat        =  1;
   runCmd      = str("");
   treeStopRC  = 19; // NOT 9
   subdirs     =  1;
   utf8dec     =  0;
   wchardec    =  0; // experimental, NOT yet default
   usecirclemap=  1;
   wrapbincol  = 80; // default
   addsnaplf   = "\n";
   withrootdirs=  1;
   #ifdef _WIN32
   strcpy(szeol, "\r\n");
   #else
   strcpy(szeol, "\n");
   #endif
   toisodef    = '.';
   maxwebsize  = 100 * 1000000; // sfk196

   // sfk180: label -qtrim is default.
   mlquotes    = 'f';
   cs.curcmd[0] = '\0';

   cs.cweb     = 1;

   #ifdef _WIN32
   usecolor       =  1;
   usehelpcolor   =  1;
   #else
   usecolor       =  0;
   usehelpcolor   =  0;
   #endif

   outcconv       = 1;  // sfkwin only
   forcecconv     = 0;  // sfkwin only
   curport        = -1; // sfk197
   chan           = 1;
   chanserv       = 2;
   cliptries      = 6;

   if (cs.headers) {
      delete [] cs.headers;
      cs.headers = 0;
   }
}

bool CommandStats::stopTree(int nrc, bool *psilent)
{
   int lRC = 0;
   int nShellRC = 0;
   if (cs.stopfiletree) {
      if (psilent)
         *psilent = 1;
      return 1;
   }
   if (nrc >= treeStopRC) {
      if (!toldTreeStop) {
         toldTreeStop = 1;
         #ifndef USE_SFK_BASE
         int pinf(const char *pszFormat, ...);
         pinf("directory tree processing stopped by error.\n");
         #endif // USE_SFK_BASE
      }
      lRC = 1;
      // on stop, always map fatal rc to shell rc
      if (nrc >= 9) nShellRC = 9;   // error occurred, processing stopped.
      else          nShellRC = nrc; // should not happen
   } else {
      // map masked rc to shell rc
      if (cs.rcFromError) {
         if (nrc >= 7) nShellRC = 7;   // error occurred, processing continued.
         else          nShellRC = nrc; // any other code below 7
      }
   }
   // build maximum shell rc, if any
   if (nShellRC > nGlblShellRC)
      nGlblShellRC = nShellRC;
   // continue or stop tree processing
   return lRC ? 1 : 0;
}

bool CommandStats::showstat( )
{
   if (cs.nostat) return 0;
   if (cs.dostat) return 1;
   if (cs.quiet)  return 0;
   return 1;
}

struct CommandPermamentStorage
{
public:
   CommandPermamentStorage ( );

   num  tailnsize;   // current file size of tail
   num  tailnpos;    // current read position of tail
   num  tailtime;    // current file modification time
   bool keeptmp;     // do not autodelete tmp files
   bool showtmp;     // verbosely list names of created tmpfiles
}
   cperm;

CommandPermamentStorage::CommandPermamentStorage() { memset(this, 0, sizeof(*this)); }

// sfk197 parse host:port, ~, ~port, ~:port.
// cs.curport stays unchanged if port is left out.
int csGetHostPort(char *psz)
{
   // ~ ~port ~:port
   if (*psz == '~') {
      strcopy(cs.curhost, "localhost");
      psz++;
      if (*psz == ':') psz++;
      if (isdigit(*psz)) {
         cs.curport = atoi(psz);
         if (cs.curport < 0 || cs.curport > 65535)
            return 9+perr("invalid port: %s", psz);
      }
      return 0;
   }

   // host host:port
   strcopy(cs.curhost, psz);
   char *pcol = strchr(cs.curhost, ':');
   if (pcol) {
      *pcol++ = '\0';
      cs.curport = atoi(pcol);
      if (cs.curport < 0 || cs.curport > 65535)
         return 9+perr("invalid port: %s", pcol);
   }
   return 0;      
}

#if (defined(WITH_TCP) || defined(VFILENET) || defined(DV_TCP))

extern int netErrno();
extern char *netErrStr();

// flags.0: silent.
// flags.1: tell expanded ip as rc 1.
// rc 0: ok done
// rc 1: ip expanded (only on flags.1)
// rc 9: error
int setaddr(struct sockaddr_in *paddr, char *pstr, int iflags)
{
   bool bsilent  = (iflags & 1) ? 1 : 0;
   bool btellexp = (iflags & 2) ? 1 : 0;
   bool bdidexp  = 0;

   char szExpBuf[100];

   int  idig=0,idot=0,iother=0;
   int  ilen=strlen(pstr);
   int  istate=0,nseg=0;

   for (int i=0; i<ilen; i++)
   {
      char c = pstr[i];
      if (isdigit(c)) {
         idig++;
         if (istate==0) {
            istate=1;
            nseg++;
         }
      }
      else if (c == '.') {
         idot++;
         istate=0;
      }
      else {
         iother++;
      }
   }

   if (!cs.noipexpand && iother==0 && nseg >= 1 && nseg <= 2)
   {
      //    22 -> 192.168.1.22
      //   .22 -> 192.168.1.22
      //  1.22 -> 192.168.1.22
      // .1.22 -> 192.168.1.22
      mclear(szExpBuf);

      int   nnum  = 0; // number of own ip's
      char *plist = ownIPList(nnum, 0, "\t", 1); // setaddr

      // copy first 3 segments of own ip, if any
      char *pseg2=0,*pseg3=0,*pseg4=0;
      pseg2 = strchr(plist, '.');
      if (pseg2) pseg3 = strchr(pseg2+1, '.');
      if (pseg3) pseg4 = strchr(pseg3+1, '.');
      if (pseg4)
      {
         char *pseg = (nseg == 2) ? pseg3 : pseg4;
         int   nlen = (pseg - plist) + 1;
         memcpy(szExpBuf, plist, nlen);
         if (*pstr=='.')
            pstr++;
         strcpy(szExpBuf+nlen, pstr);
         if (cs.showip)
            pinf("[nopre] [using %s]\n", szExpBuf);
         pstr = szExpBuf;
         bdidexp = 1;
      }
   }

   if (iother==0)
   {
      // pure ip given
      paddr->sin_addr.s_addr = inet_addr(pstr);

      if (cs.debug)
         printf("using inetaddr %x\n", paddr->sin_addr.s_addr);
   }
   else
   {
      // must be a hostname
      struct hostent *pTarget = gethostbyname(pstr);

      if (pTarget == NULL) {
         if (!bsilent)
            perr("cannot get hostname %s, rc=%d (%s)\n", pstr, netErrno(), netErrStr());
         return 9;
      }

      memcpy(&paddr->sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);

      if (cs.debug) {
         uint uiIP = paddr->sin_addr.s_addr;
         printf("using gethost %u.%u.%u.%u\n",
            (uiIP >>  0) & 0xFFU,
            (uiIP >>  8) & 0xFFU,
            (uiIP >> 16) & 0xFFU,
            (uiIP >> 24) & 0xFFU);
      }
   }

   if (btellexp)
      return bdidexp;

   return 0;
}

// a hostbyname with automatic extension of "22" to "192.168.1.22"
struct hostent *sfkhostbyname(const char *pstr, bool bsilent)
{
   char szExpBuf[100];
   int  idig=0,idot=0,ioth=0;
   int  ilen=strlen(pstr);
   int  istate=0,nseg=0;

   for (int i=0; i<ilen; i++)
   {
      char c = pstr[i];
      if (isdigit(c)) {
         idig++;
         if (istate==0) {
            istate=1;
            nseg++;
         }
      }
      else if (c == '.') {
         idot++;
         istate=0;
      }
      else {
         ioth++;
      }
   }

   if (!cs.noipexpand && ioth==0 && nseg >= 1 && nseg <= 2)
   {
      //    22 -> 192.168.1.22
      //   .22 -> 192.168.1.22
      //  1.22 -> 192.168.1.22
      // .1.22 -> 192.168.1.22
      mclear(szExpBuf);

      int   nnum  = 0; // number of own ip's
      char *plist = ownIPList(nnum, 0, "\t", 1); // sfkhostbyname

      // copy first 3 segments of own ip, if any
      char *pseg2=0,*pseg3=0,*pseg4=0;
      pseg2 = strchr(plist, '.');
      if (pseg2) pseg3 = strchr(pseg2+1, '.');
      if (pseg3) pseg4 = strchr(pseg3+1, '.');
      if (pseg4)
      {
         char *pseg = (nseg == 2) ? pseg3 : pseg4;
         int   nlen = (pseg - plist) + 1;
         memcpy(szExpBuf, plist, nlen);
         if (*pstr=='.')
            pstr++;
         strcpy(szExpBuf+nlen, pstr);
         if (cs.showip)
            pinf("[nopre] [using %s]\n", szExpBuf);
         pstr = szExpBuf;
      }
   }

   return gethostbyname(pstr);
}

#endif // USE_TCP

void getUpto(int iMaxCopy, char *pszSrc, int iMaxSrc, char *pszBuf, int iMaxBuf)
{
   int i=0;
   for (i=0; (i<iMaxCopy) && (i<iMaxBuf-1); i++)
   {
      if (iMaxSrc > 0) {
         pszBuf[i] = pszSrc[i];
         iMaxSrc--;
      } else {
         pszBuf[i] = ' ';
      }
   }
   pszBuf[i] = '\0';
}

int shrinkFormTextVar(char *psz, int &rLen, uchar **ppFlags)
{
   if (!cs.spat)
      return 0; // nothing to do

   bool bstrict = (cs.spat >= 2) ? 1 : 0;

   return shrinkFormTextBlock(psz, rLen, bstrict, cs.xchars, ppFlags);
}

// replace \\t and \\xnn by a single character,
// within a binary block that is not zero-terminated.
int shrinkFormTextBlock(char *psz, int &rLen, bool bstrict, bool xchars, uchar **ppFlags)
{
   char szBuf[20];

   int iCodePoints = 0;
 
   uchar uc = 0;
   bool bAnyX = 0;
   uchar *pFlags = 0;
   uchar *pDst = 0;

   char *pszMax = psz + rLen;

   for (int ipass=0; ipass<2; ipass++)
   {
      char *pszCur = psz;

      if (ipass)
      {
         if (!xchars && bAnyX && ppFlags)
         {
            if (!(pFlags = newBitField(iCodePoints+4)))
               return 9+perr("out of memory");
            *ppFlags = pFlags;
         }

         pDst = (uchar*)psz;
      }

      iCodePoints = 0;

      while (pszCur < pszMax)
      {
         uc = *pszCur++;

         if (uc == '\\' && pszCur < pszMax)  // spat.1 shrinktext 2
         {
            switch (*pszCur++)
            {
               case '\\':  uc = '\\';  break;
               case 't' :  uc = '\t';  break;
               case 'q' :  uc = '"';   break;
               case 'n' :  uc = '\n';  break;
               case 'r' :  uc = '\r';  break;
               case ' ' :  uc = ' ';   break;
               case 'x' :
               {
                  if (pszCur+2 > pszMax) {
                     getUpto(4, pszCur-2, 4, szBuf, sizeof(szBuf)-4);
                     perr("incomplete hex slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                     return 9;
                  }
                  int n = getTwoDigitHex(pszCur);
                  if (n < 0) {
                     getUpto(4, pszCur-2, 4, szBuf, sizeof(szBuf)-4);
                     perr("wrong hex slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                     return 9;
                  }
                  pszCur += 2;
                  uc = (uchar)n;
                  if (pFlags)
                     sfkSetBit(pFlags, iCodePoints);
                  bAnyX = 1;
                  break;
               }
               case 'd' : // sfk 1723 added: "\d255"
               if (bstrict)
               {
                  if (pszCur+3 > pszMax) {
                     getUpto(5, pszCur-2, 5, szBuf, sizeof(szBuf)-4);
                     perr("incomplete decimal slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                     return 9;
                  }
                  int n = getThreeDigitDec(pszCur);
                  if (n < 0 || n > 255) {
                     getUpto(5, pszCur-2, 5, szBuf, sizeof(szBuf)-4);
                     perr("wrong decimal slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                     return 9;
                  }
                  pszCur += 3;
                  uc = (uchar)n;
                  if (pFlags)
                     sfkSetBit(pFlags, iCodePoints);
                  bAnyX = 1;
                  break;
               }
               default:
                  if (bstrict) {
                     getUpto(2, pszCur-1, 2, szBuf, sizeof(szBuf)-4);
                     perr("undefined slash pattern: %.2s   (use \\%.2s instead)\n", szBuf, szBuf);
                     return 9;
                  }
            }  // endswitch
         }  // endif

         if (ipass && pDst)
            *pDst++ = uc;

         iCodePoints++;
      }
   }

   if (pDst < (uchar*)pszMax)
      *pDst = '\0';

   rLen = (int)(pDst - (uchar*)psz);

   return 0;
}

int copyFromFormText(char *pSrc, int iMaxSrc, char *pDstIn, int iMaxDst, uint nflags=0)
{
   char szBuf[20];

   char *pszCur = pSrc;
   char *pszMax = pSrc+iMaxSrc;

   char *pDst   = pDstIn;
   char *pDstMax= pDstIn+iMaxDst;

   if (iMaxDst > 0)
      pDstIn[0] = '\0'; // sfk1972 safety

   uchar uc;

   while (pszCur < pszMax && pDst+10 < pDstMax)
   {
      uc = *pszCur++;

      if (uc == '\\' && pszCur < pszMax)  // spat.2 copytext 2
      {
         // optionally escape phraser sequences
         char c = *pszCur;
         if ((nflags & 2) && (c==',' || c=='+' || c=='\t'))
            { }
         else
         switch (*pszCur++)
         {
            case '\\':  uc = '\\';  break;
            case 't' :  uc = '\t';  break;
            case 'q' :  uc = '"';   break;
            case 'n' :  uc = '\n';  break;
            case 'r' :  uc = '\r';  break;
            case ' ' :  uc = ' ';   break;
            case 'x' :
            {
               if (pszCur+2 > pszMax) {
                  getUpto(4, pszCur-2, 4, szBuf, sizeof(szBuf)-4);
                  perr("incomplete hex slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                  return -1;
               }
               int n = getTwoDigitHex(pszCur);
               if (n < 0) {
                  getUpto(4, pszCur-2, 4, szBuf, sizeof(szBuf)-4);
                  perr("wrong hex slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                  return -1;
               }
               pszCur += 2;
               uc = (uchar)n;
               break;
            }
            case 'd' :
            {
               if (pszCur+3 > pszMax) {
                  getUpto(5, pszCur-2, 5, szBuf, sizeof(szBuf)-4);
                  perr("incomplete dec slash pattern: %.5s   (use \\%.5s instead?)\n", szBuf, szBuf);
                  return -1;
               }
               int n = getThreeDigitDec(pszCur);
               if (n < 0) {
                  getUpto(5, pszCur-2, 5, szBuf, sizeof(szBuf)-4);
                  perr("wrong dec slash pattern: %.5s   (use \\%.5s instead?)\n", szBuf, szBuf);
                  return -1;
               }
               pszCur += 3;
               uc = (uchar)n;
               break;
            }
            default:
               getUpto(2, pszCur-1, 2, szBuf, sizeof(szBuf)-4);
               perr("undefined slash pattern: %.2s   (use \\\\%.2s instead?)\n", szBuf, szBuf);
               return -1;
         }
      }

      *pDst++ = uc;
   }

   *pDst = '\0';

   return (int)(pDst-pDstIn);
}

int nGlblFunc         = 0;
bool bGlblSyntaxTest  = 0;
int  bGlblCollectHelp = 0;
int  iGlblCollectCmd  = 0;
int nGlblActiveFileAgeLimit = 30; // days
int nGlblErrors   = 0; // perr counter
int nGlblWarnings = 0;
int nGlblTraceSel = 0; // b0:dirs b1:files
bool bGlblMD5RelNames = 0;
bool bGlblHaveInteractiveConsole = 0;
bool bGlblStartedInEmptyConsole = 0;
// bool bGlblEnableOPrintf = 1; // allow codepage conversion w/in oprintf
// bool bGlblForceCConv = 0;    // enfore codepage conversion w/in oprintf
bool bGlblAllowGeneralPure = 0; // command dependent
bool bGlblPauseOnError = 0;  // pause after every error
bool bGlblPauseOnEnd   = 0;  // pause before program end
bool bGlblOldMD5 = 0;
char *pszGlblOutFile = 0;  // if set, some funcs will take care not to read this file
char *pszGlblSaveTo  = 0;  // if set, some funcs will save output files to this path
FILE *fGlblOut     = 0; // general use

#ifdef VFILEBASE
   #include "sfkext.hpp"
#endif // VFILEBASE

unsigned char abBuf[MAX_ABBUF_SIZE+100];
char szLineBuf[MAX_LINE_LEN+10];
char szLineBuf2[MAX_LINE_LEN+10];
char szLineBuf3[MAX_LINE_LEN+10];
char szAttrBuf[MAX_LINE_LEN+10];
char szAttrBuf2[MAX_LINE_LEN+10];
char szAttrBuf3[MAX_LINE_LEN+10];
char szRefNameBuf[MAX_LINE_LEN+10];
char szRefNameBuf2[MAX_LINE_LEN+10];
char szOutNameRecent[MAX_LINE_LEN+10];
char szTopURLBuf[MAX_LINE_LEN+10];
char szIOTraceBuf[200];
bool bGlblToldAboutRecent = 0;
char szOutNameBuf[MAX_LINE_LEN+10];
char szRunCmdBuf[MAX_LINE_LEN+10];
#define MAX_MATCH_BUF 500
char szMatchBuf[MAX_MATCH_BUF+10];  // strmatch word buffer
bool szMatchEsc[MAX_MATCH_BUF+10];  // strmatch escape flags
char *pszGlblPreRoot = 0;
char szGlblMixRoot[MAX_LINE_LEN+10];
char *pGlblDumpBuf = 0;
int   iGlblDumpBufSize = 0;
bool bErrBufSet = 0;
cchar *pszGlblJamPrefix = ":file:";
char *pszGlblJamRoot = 0;
int   bGlblJamPure = 0;
#define MAX_JAM_TARGETS 1000
char *apJamTargets[MAX_JAM_TARGETS];
num   alJamTargetTime[MAX_JAM_TARGETS];
num   nJamSnapTime = -1;
int  nJamTargets  = 0;
char *pszGlblRepSrc = 0;
char *pszGlblRepDst = 0;
cchar *pszGlblBlank =
   "                                                "
   "                                                ";
num  nGlblStartTime = 0;
num  nGlblListMinSize = 0; // in bytes
int nGlblListMode = 0;    // 1==stat 2==list
int  nGlblListDigits = 12;
bool bGlblDisableEscape = 0;
bool bGlblEscape = 0;
bool bGlblEnter = 0;
char *pszGlblDstRoot = 0;
char *pszGlblDirTimes = 0;
cchar *pszGlblTurn = "\\|/-";
int  nGlblTurnCnt = 0;
bool  bGlblQuoted     = 0; // list: add quotes around filenames
bool  bGlblNoRootDirFiles = 0; // list -dir +dirmask
uint nGlblConvTarget = 0; // see eConvTargetFormats
uint aGlblConvStat[10];
#ifdef WITH_FN_INST
bool  bGlblInstRevoke = 0;
bool  bGlblInstRedo   = 0;
bool  bGlblInstEol    = 0;
cchar *pszGlblInstInc  = "";
cchar *pszGlblInstMac  = "";
static bool bGlblTouchOnRevoke = 1;
#endif
bool  bGlblRefRelCmp    = 1;
bool  bGlblRefBaseCmp   = 0;
bool  bGlblRefWideInfo  = 0;
int  nGlblRefMaxSrc    = 10;
bool  bGlblRefLimitReached = 0;
bool  bGlblStdInAny     = 0;  // all cmd except run: take list from stdin
bool  bGlblStdInFiles   = 0;  // run only: take filename list from stdin
bool  bGlblStdInDirs    = 0;  // run only: take directory list from stdin
int  nGlblMD5Skip      = 0;
bool  bGlblMirrorByDate = 0;  // inofficial, might be removed.
int nGlblTCPMaxSizeMB   = 500; // MB
SOCKET hGlblTCPOutSocket = 0;
bool bGlblFTPReadWrite   = 0;
bool bGlblFTPListFlatTS  = 0; // server: send flat timestamp on list
bool bGlblFTPListAsHTML  = 0;
bool bGlblFTPListTextBin = 0;
bool bGlblBinGrep           = 0;
bool bGlblBinGrepAutoDetect = 1;
int nGlblDarkColBase    = 0;
int nGlblBrightColBase  = 1;
bool bGlblSysErrDetail  = 0;

// highlight=1 red=2 green=4 blue=8
#ifdef _WIN32
// windows default safety colors for ANY background.
// will be changed automatically if black background is detected.
// help part
int nGlblHeadColor      =  5; // green
int nGlblExampColor     = 11; // purple
// functional part
int nGlblFileColor      = 12; // cyan
int nGlblLinkColor      = 12; // cyan
int nGlblHitColor       =  5; // green
int nGlblRepColor       = 11; // purple
int nGlblErrColor       =  3; // red
int nGlblWarnColor      = 11; // purple
int nGlblPreColor       = 12; // cyan
int nGlblTimeColor      = 12; // cyan
int nGlblTraceIncColor  = 12; // cyan
int nGlblTraceExcColor  = 11; // purple
#else
// unix default colors for white background
int nGlblDefColor       =  0; // default
int nGlblHeadColor      =  4; // green
int nGlblExampColor     = 10; // purple
// functional part
int nGlblFileColor      = 10; // purple
int nGlblLinkColor      = 12; // cyan
int nGlblHitColor       =  4; // green
int nGlblRepColor       = 12; // blue
int nGlblErrColor       =  2; // red
int nGlblWarnColor      =  2; // red
int nGlblPreColor       = 12; // blue
int nGlblTimeColor      = 12; // blue
int nGlblTraceIncColor  = 12; // cyan
int nGlblTraceExcColor  = 11; // purple
#endif

bool bGlblGrepLineNum    = 0;
bool bGlblHtml           = 0;  // for html help creation
// bool bGlblShortSyntax    = 0;
// bool bGlblAnyUsed        = 0;
bool bGlblAllowAllPlusPosFile = 0;
char *pszGlblSinceDir    = 0;
bool bGlblSinceDirIncRef = 0;
int nGlblMissingRefDirs  = 0;
int nGlblMatchingRefDirs = 0;
int nGlblSinceMode       = 0; // b0:add b1:dif
bool bGlblIgnoreTime     = 0;
bool bGlblIgnore3600     = 0;
char  *pszGlblCopySrc    = 0;
char  *pszGlblCopyDst    = 0;
uchar *pGlblWorkBuf      = 0;
num    nGlblWorkBufSize  = 0;
int   nGlblCopyStyle     = 2; // how filenames are dumped onto terminal
int   nGlblCopyShadows   = 0;
num   nGlblShadowSizeLimit = 0;
bool  bGlblUseCopyCache  = 0;
bool  bGlblShowSyncDiff  = 0;
bool  bGlblHavePlusDirMasks = 0; // deprecated
num   nGlblMemLimit      = 300 * 1048576;
bool  bGlblMemLimitWasSet = 0;
bool  bGlblNoMemCheck     = 0;
bool  bGlblSFKCreateFiles = 0;
char  *pGlblCurrentScript = 0; // while within a script command
char  *pGlblCurScriptName = 0; // and it's file name

bool bGlblHexDumpWide    = 0;
int nGlblHexDumpForm     = 0;
num  nGlblHexDumpOff     = 0;
num  nGlblHexDumpLen     = 0;

#ifdef _WIN32
cchar *pszGlblAliasBatchHead = "@rem sfk alias batch";
#else
cchar *pszGlblAliasBatchHead = "# sfk alias batch";
#endif

int nGlblFzMisArcFiles = 0;
int nGlblFzConArcFiles = 0;
int nGlblFzConArchives = 0;
int nGlblFzMisCopFiles = 0;
int nGlblFzConCopFiles = 0;

void cleanupTmpCmdData();
void shutdownAllGlobalData();

// circular link processing blocker.
// used only in a vertical walkFiles() processing run,
// e.g. parameters -dir dir1 -file .cpp -dir dir1 -file .hpp
// will run walkFiles() twice, each time resetting this:
KeyMap glblCircleMap;

// used with rename: map of simulated output filenames
KeyMap glblOutFileMap;

#ifndef USE_SFK_BASE
void resetStats()
{__
   void resetFileCounter();
   void resetFileSet();

   // reset command statistics:
   // copy global settings into local command settings
   memcpy(&cs, &gs, sizeof(cs));
   resetFileCounter();

   // reset command settings
   // cs.quiet = 0; // sfk1933 enable global use
   pszGlblSaveTo = 0;
   if (pszGlblSinceDir) { delete [] pszGlblSinceDir; pszGlblSinceDir=0; }

   // reset selected dirs and files
   resetFileSet();

   // reset all temporary command data
   cleanupTmpCmdData();

   // reset circular dependency blocker
   glblCircleMap.reset();
}
#endif // USE_SFK_BASE

class FileList;
class StringPipe;
class Coi;

int execDetab       (char *pszFile, char *pszOutFile);
int execEntab       (char *pszFile, char *pszOutFile);
int execScantab     (char *pszFile);
int getFileMD5      (char *pszFile, SFKMD5 &md5, bool bSilent=0, bool bInfoCycle=0);
int getFileMD5      (Coi  *pcoi, SFKMD5 &md5, bool bSilent=0, bool bInfoCycle=0);
int execFormConv    (char *pszFile, char *pszOutFile);
int execHexdump     (Coi  *pcoi, uchar *pBuf, uint nBufSize, int iHighOff=-1, int iHighLen=0, FILE *fout=0, num nListOffset=0);
int walkFiles       (Coi  *pcoi, int lLevel, int &nGlobFiles, FileList &oDirFiles, int &lDirs, num &lBytes, num &ntime1, num &ntime2);
int execSingleFile  (Coi  *pcoi, int lLevel, int &lGlobFiles, int nDirFileCnt, int &lDirs, num &lBytes, num &ntime1, num &ntime2);
int execSingleDir   (Coi  *pcoi, int lLevel, int &lGlobFiles, FileList &oDirFiles, int &lDirs, num &lBytes, num &ntime1, num &ntime2);
int execFileCopy    (Coi  *pcoi);
int execDirCopy     (char *pszSrc, FileList &oDirFiles);
int execFileCleanup (char *pszFile);
int execDirCleanup  (char *pszSrc, FileList &oDirFiles);
int execFileMove    (Coi  *pcoi);
int execDirMove     (char *pszSrc, FileList &oDirFiles);
bool tryGetRelTime  (cchar *psz, num &nRetTime);
int diffDump        (uchar *p1, uchar *p2, num nlen, num nListOffset, int iHiOff, int iHiLen);
int execReplaceFix  (Coi *pcoi);
int execReplaceVar  (Coi *pcoi);
int execReplaceNew  (Coi *pcoi, char *pszOptOutFile, bool bSameLengthAndFile);
size_t myfread       (uchar *pBuf, size_t nBytes, FILE *fin , num nMaxInfo=0, num nCur=0, SFKMD5 *pmd5=0);
size_t myfwrite      (uchar *pBuf, size_t nBytes, FILE *fout, num nMaxInfo=0, num nCur=0, SFKMD5 *pmd5=0);
char *rootRelativeName(char *pszFileName, char *pszOptRoot);
char *relativeFilename(char *pszPath);
void myfgets_init    ( );
int myfgets         (char *pszOutBuf, int nOutBufLen, FILE *fin, bool *rpBinary=0, char *pAttrBuf=0);
int execFilter      (Coi *pcoi, FILE *fin = 0, StringPipe *pin = 0, int nMaxLines = -1, char *pszOutFile = 0);
int execLoad        (Coi *pcoi);
int execDelFile     (char *pszName);
int execDelDir      (char *pszName, int lLevel, int &lGlobFiles, FileList &oDirFiles, int &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2);
int execVersion     (Coi *pcoi);
int execMedia       (char *pszSrc, char *pszOutFile);
int execCsvConv     (bool bToCsv, Coi *pcoi, FILE *fin = 0, StringPipe *pin = 0, int nMaxLines = -1, char *pszOutFile = 0);
int execRename      (Coi *pcoi);
int execXRename     (Coi *pcoi);
int execUUEncode    (Coi *pcoi);
int pointedit       (char *pszMaskIn, char *pszSrc, int *pOutMatchLen, char *pszDst, int iMaxDst, bool verb=0);
int lineedit        (char *pszMaskIn, char *pszSrc, char *pszDst, int iMaxDst, char *pAtt1, char *pAtt2, uint flags, int *poff=0, int *plen=0);
#ifdef SFKPACK
int execZipFile     (Coi *pin, int bDir, int iLevel);
int execUnzip       (char *pszInFile, char *pszSubFile=0, int iOffice=0, char **ppSharedStrings=0);
int execPackFile    (Coi *pin, Coi *pout, bool bPack);
#endif // SFKPACK
#ifdef _WIN32
 #ifdef SFK_W64
 int execFixFile    (ushort *aname, sfkfinddata64_t *pdata);
 #endif
#endif

#ifdef SFKPIC
int execPic         (Coi *pcoi, char *pszOutFile);
#endif // SFKPIC

// set/provide a minimum info about the current I/O operation.
// if called multithreaded, this should not crash but in the
// worst case return only incomplete info strings.

class IOStatus {
public:
      IOStatus  ( );

      void   setInfo (cchar *pinfo);
      char  *getInfo (num &nagemsec, num &nbytes, num &nmaxbytes);

      num   countBytes  (num nbytes);
      void  setMaxBytes (num nbytes);
      void  resetBytes  ( );

private:
      char  szClStatus[200+20];
      num   nClSince;
      num   nClBytes;
      num   nClMaxBytes;
};
static IOStatus iostat;

IOStatus::IOStatus() {
   memset(this, 0, sizeof(*this));
}

void IOStatus::setInfo(cchar *pinfo) {
   memset(szClStatus, 0, sizeof(szClStatus));
   if (!pinfo) {
      nClSince = 0;
      return;
   }
   strncpy(szClStatus, pinfo, sizeof(szClStatus)-20);
   nClSince = getCurrentTime();
}

char *IOStatus::getInfo(num &nagemsec, num &nbytes, num &nmaxbytes) {
   if (!szClStatus[0]) return 0;
   if (nClSince > 0) {
      num nage  = getCurrentTime() - nClSince;
      nagemsec  = nage;
      nbytes    = nClBytes;
      nmaxbytes = nClMaxBytes;
   } else {
      nagemsec  = 0;
      nbytes    = 0;
      nmaxbytes = 0;
   }
   return szClStatus;
}

num IOStatus::countBytes(num nbytes) {
   nClBytes += nbytes;
   return nClBytes;
}

void IOStatus::setMaxBytes(num nbytes) {
   nClMaxBytes = nbytes;
}

void IOStatus::resetBytes() {
   nClBytes = 0;
   nClMaxBytes = 0;
}

IOStatusPhase::IOStatusPhase(cchar *pinfo) {
   iostat.setInfo(pinfo);
}

IOStatusPhase::~IOStatusPhase( ) {
   // iostat.setInfo(0);
}

char *getIOStatus(num &nage, num &nbytes, num &nmaxbytes) {
   return iostat.getInfo(nage, nbytes, nmaxbytes);
}
num   countIOBytes(num nbytes)   { return iostat.countBytes(nbytes); }
void  setIOStatMaxBytes(num n)   { iostat.setMaxBytes(n); }
void  resetIOBytes( )   { iostat.resetBytes(); }
void  resetIOStatus( )  { iostat.setInfo(0); iostat.resetBytes(); }

// extended skip functions, ignore line ends,
// handle quotes and escaped quotes:

void nextToken(char **pp, char &rclast, bool &rbnewline)
{
   char *p = *pp;
   while (*p && ((*p == ' ') || (*p == '\t') || (*p == '\r') || (*p == '\n') || (*p == '#')) ) {
      // skip # only if it's first char of line
      if (*p == '#' && rclast != '\n')
         break;
      rclast = *p++;
      if (rclast == '\n')
         rbnewline = 1;
   }
   *pp = p;
}

void skipPastToken(char **pp, char &rclast)
{
   char *p = *pp;
   bool besc = 0;
   char cold = 0;
   while (*p)
   {
      if (*p == '\"' && cold != '\\')
         besc ^= 0x1;
      if (!besc && ((*p == ' ') || (*p == '\t') || (*p == '\r') || (*p == '\n')) )
         break;
      rclast = cold = *p++;
   }
   *pp = p;
}

// .
// strip quotes, transform inner quotes \" to normal quotes "
// uses: szLineBuf, szLineBuf2
// sfk181: no longer returns 1 on empty token
int postProcessToken(char **pptok, StringTable &oDynaStrings,
   int argc, char *argv[], int iParmOffs, int nParm)
{
   bool bquoted = 0;

   char *ptok = *pptok;

   // strip outer quotes, if any
   if (*ptok == '\"') {
      // strip quotes
      int nlen = strlen(ptok);
      if (ptok[nlen-1] != '\"')
         return 9; // missing end quote
      bquoted = 1;
      memmove(ptok, ptok+1, nlen-1);
      nlen -= 2;         // count both quotes
      ptok[nlen] = '\0'; // readjust terminator
      if (cs.trimscript) {
         char *pscur=ptok;
         char *pdcur=ptok;
         // drop initial blank line, if any
         if (!strncmp(pscur,"\r\n",2)) pscur+=2;
         else if (*pscur=='\n') pscur++;
         while (*pscur) {
            char *peol=pscur;
            while (*peol && !iseol(*peol)) peol++;
            char *psnex=peol;
            // reduce left
            while (*pscur && isws(*pscur)) pscur++;
            // do not reduce rite
            // while (peol>pscur && isws(peol[-1])) peol--;
            // copy remainder
            while (pscur<peol)
               *pdcur++=*pscur++;
            // skip eol, now in psnex
            while (iseol(*psnex))
               psnex++;
            // continue on next line
            pscur=psnex;
         }
         // drop trailing blank line, if any
         // \r\n\r\n or \n\n
         if (pdcur>=ptok+4 && !strncmp(pdcur-4,"\r\n\r\n",4)) pdcur-=2;
         else
         if (pdcur>=ptok+2 && !strncmp(pdcur-2,"\n\n",2)) pdcur-=1;
         *pdcur='\0';
      }
   }

   // transform inner quotes, if any
   char *psz = ptok;
   while (*psz) {
      if (!strncmp(psz, "\\\"", 2)) {
         int nlen = strlen(psz);
         memmove(psz, psz+1, nlen-1);   // cut backslash
         psz[nlen-1] = '\0'; // new terminator
      }
      if (*psz) psz++;
   }

   // substitute parameters. accept both $1,$2,$3 and %1,%2,%3.
   strcopy(szLineBuf, ptok);
   char szName1[50],szName2[50];
   mclear(szName1);
   mclear(szName2);
   bool bDoneAny = 0;

   // accept "$" and "%" parameters, or user defined?
   bool buserpre = cs.paramprefix[0] ? 1 : 0;

   for (int iparm=0; iparm<9; iparm++)
   {
      char *pcur = szLineBuf;
      while (1)
      {
         int nlen1=0,nlen2=0;
         if (buserpre) {
            sprintf(szName1, "%.20s%d" , cs.paramprefix, (int)(iparm+1));
            nlen1 = strlen(szName1);
         } else {
            sprintf(szName1, "$%d" , (int)(iparm+1));
            sprintf(szName2, "%%%d", (int)(iparm+1));
            nlen1 = strlen(szName1);
            nlen2 = strlen(szName2);
         }
         char *psz  = pcur;
         char clast = (char)-1, cesc = 0;
         int nlenx = 0;
         while (*psz) {
            if (!strncmp(psz, szName1, nlen1)) {
               nlenx = nlen1;
               // allow escapes only if not user defined
               if (!buserpre) cesc = '$';
               break;
            }
            if (!buserpre && !strncmp(psz, szName2, nlen2))
               { nlenx = nlen2; cesc = '%'; break; }
            clast = *psz++;
         }
         if (!*psz) break;
         if (clast == cesc) {
            /*
               // do NOT replace parm, just unescape it:
               psz--;
               memmove(psz, psz+1, strlen(psz+1)+1); // WITH terminator
               pcur = psz+1;
               // remember we have to dup szLineBuf
               bDoneAny = 1;
               continue;
            */
         }
         // replace $param... by actual value
         cchar *pval = "";
         // fix sfk193: iparm >= 0 check
         if (iparm >= 0 && iparm < nParm && iParmOffs+iparm < argc)
            pval = argv[iParmOffs+iparm];
         int nleft = psz-pcur;
         memcpy(szLineBuf2, pcur, nleft);
         int nmid  = strlen(pval);
         if (nmid > 0)
            memcpy(szLineBuf2+nleft, pval, nmid);
         char *prite= psz+nlenx;
         strcpy(szLineBuf2+nleft+nmid, prite);
         strcpy(pcur, szLineBuf2);
         // step pcur, may have to replace $1 many times
         pcur += nleft+nmid;
         // remember we have to dup szLineBuf
         bDoneAny = 1;
      }
   }

   // do we have to manage a copy of the token?
   if (bDoneAny) 
   {
      // sfk1812: remove empty tokens
      if (!bquoted && !szLineBuf[0])
         return 1;

      // sfk181: no special handling of empty tokens.
      if (oDynaStrings.addEntry(szLineBuf, -1, &ptok)) // is copied
         return 9+perr("outofmem");
      // ptok should now contain the copy
      if (!ptok) return 9+perr("internal #2310271958");
      // write back ptok, in case it was changed:
      *pptok = ptok;
   }

   return 0;
}

int fixMultiLineParm(char *ptok, char cmode, int iind=0)
{
   if (!strchr(ptok, '\n'))
      return 1; // nothing to do

   if (cs.mlquotes == 'r')
      return 1;

   if (cs.mlquotes != 'f') {
      static bool btold=0;
      if (!btold) {
         btold=1;
         // pwarn("missing -qraw or -qtrim with multi line quotes. type \"sfk label\" for help.\n");
      }
      return 1;
   }

   // printf("---%s\n---\n",dataAsTrace(ptok,strlen(ptok)));

   bool bTrim   = (cmode=='t') ? 1 : 0;  // without extra blank
   bool bParms  = (cmode=='p') ? 1 : 0;  // with extra blank
   bool bIndent = (cmode=='i') ? 1 : 0;  // auto indent keeping lf
   bool bWebReq = (cmode=='w') ? 1 : 0;  // keep lines force crlf

   char *pscur=ptok;
   char *pdcur=ptok;
   char *pdmax=ptok+strlen(ptok);
   int   iparm=0;
   int   ibase=0; // base indent

   // drop initial blank line, if any
   if (!strncmp(pscur,"\r\n",2)) pscur+=2;
   else if (*pscur=='\n') pscur++;

   while (*pscur!=0 && pdcur<pdmax)
   {
      char *peol=pscur;
      bool  ballws=1;
      while (*peol && !iseol(*peol)) {
         if (!isws(*peol))
            ballws=0;
         peol++;
      }
      char *psnex=peol;

      // drop trailing blank line, if any
      if (!bWebReq && bIndent && !*peol && ballws)
         break;

      // reduce left
      if (bIndent) {
         if (iparm == 0) {
            // first line: find base index
            int i=0;
            while (pscur[i] && isws(pscur[i]))
               i++;
            if (iind>0) {
               if (iind<i)
                  i -= iind;
               else
                  i = 0;
            }
            pscur += i;
            ibase += i;
         } else {
            // further lines: reduce only base index
            int irange=ibase;
            while (*pscur && isws(*pscur) && irange)
               { pscur++; irange--; }
         }
      } else {
         while (*pscur && isws(*pscur)) pscur++;
      }

      // do not reduce rite
      // while (peol>pscur && isws(peol[-1])) peol--;

      // insert parm separator blank?
      if (bParms && iparm && (pdcur<pdmax))
         *pdcur++=' ';

      // copy remainder
      while (pscur<peol && pdcur<pdmax)
         *pdcur++ = *pscur++;

      iparm++;

      if (bWebReq) {
         if (*psnex=='\r') psnex++;
         // force crlf
         if (*psnex=='\n' && pdcur+2<pdmax) {
            psnex++;
            *pdcur++ = '\r';
            *pdcur++ = '\n';
         }
      }
      else if (bIndent) {
         // copy eol, now in psnex
         while (iseol(*psnex)!=0 && pdcur<pdmax) {
            if (*psnex == '\r')
               psnex++;
            else
               *pdcur++ = *psnex++;
         }
      } else {
         // skip eol, now in psnex
         while (iseol(*psnex))
            psnex++;
      }

      // continue on next line
      pscur=psnex;
   }

   // last line must not end with LF, is added on output
   if (bIndent!=0 && pdcur>ptok && pdcur[-1]=='\n')
      pdcur--;

   *pdcur='\0';

   // printf("---%s\n---\n",dataAsTrace(ptok,strlen(ptok)));

   if (cs.debug) {
      printf("--- multi line parm changed using mode %c: ---\n",cmode);
      printf("%s\n---\n",ptok);
   }

   return 0;
}

char *mystrrstr(char *psrc, cchar *ppat)
{
   if (!psrc || !ppat) return 0;

   char c = *ppat;
   int nsrclen = strlen(psrc);
   int npatlen = strlen(ppat);
   if (npatlen > nsrclen) return 0;

   char *pcur = psrc + nsrclen - npatlen;
   while (pcur >= psrc) {
      if (*pcur == c && !strncmp(pcur, ppat, npatlen))
         return pcur;
      pcur--;
   }
   return 0;
}

char *mystrristr(char *psrc, cchar *ppat)
{
   if (!psrc || !ppat) return 0;

   int nsrclen = strlen(psrc);
   int npatlen = strlen(ppat);
   if (npatlen > nsrclen) return 0;

   char *pcur = psrc + nsrclen - npatlen;
   while (pcur >= psrc) {
      if (!mystrnicmp(pcur, ppat, npatlen))
         return pcur;
      pcur--;
   }
   return 0;
}

int   nGlblConsColumns    = 80;
int   bGlblConsColumnsSet =  0;
int   nGlblConsRows       = 30;
int   bGlblConsRowsSet    =  0;

int setWriteEnabled(char *pszFile)
{
   #ifdef _WIN32

   BOOL bok = 0;

   #ifdef WINFULL
   WIN32_FILE_ATTRIBUTE_DATA oinf;
   bok = GetFileAttributesEx(pszFile, GetFileExInfoStandard, &oinf);
   if (!bok) return 9;

   oinf.dwFileAttributes &= (0xFFFFFFFFUL ^ FILE_ATTRIBUTE_READONLY);
   bok = SetFileAttributes(pszFile, oinf.dwFileAttributes);
   #else
   uint nattrib = GetFileAttributesA(pszFile);
   nattrib &= (0xFFFFFFFFUL ^ FILE_ATTRIBUTE_READONLY);
   SetFileAttributes(pszFile, nattrib);
   #endif

   if (!bok) return 9;

   #else

   struct stat64 buf;
   if (stat64(pszFile, &buf)) return 9;

   mode_t nmode = buf.st_mode | _S_IWRITE;
   if (chmod(pszFile, nmode)) return 9;
 
   #endif

   return 0;
}

FILE *pGlblOpenWriteFile   = 0;
char  szGlblOpenWriteName[MAX_LINE_LEN+10];

void beginFileWrite(char *pszName, FILE *p) {
   pGlblOpenWriteFile = p;
   strcopy(szGlblOpenWriteName, pszName);
}
void endFileWrite() {
   pGlblOpenWriteFile = 0;
   szGlblOpenWriteName[0] = 0;
}
void checkFileWrite() {
   if (pGlblOpenWriteFile)
      perr("unexpected: file left open for write: %s\n", szGlblOpenWriteName);
}
void cleanupFileWrite() {
   if (pGlblOpenWriteFile) {
      // close and remove incomplete (trash) file.
      // may not work here as this is called during interrupt.
      fclose(pGlblOpenWriteFile);
      remove(szGlblOpenWriteName);
   }
}
FILE *myfopen(char *pszName, cchar *pszMode) {
   FILE *f = fopen(pszName, pszMode);
   if (!f && !strcmp(pszMode, "wb") && fileExists(pszName)) {
      // file is probably write protected
      if (setWriteEnabled(pszName))
         return 0;
      // retry on write-enabled file
      f = fopen(pszName, pszMode);
   }
   if (f) {
      if (pGlblOpenWriteFile)
         pwarn("open for write on %s not registered\n", pszName);
      else
         beginFileWrite(pszName, f);
   }
   return f;
}
void myfclose(FILE *f) {
   if (f == pGlblOpenWriteFile)
      endFileWrite();
   fclose(f);
}

bool bGlblAllowCtrlCExit = 1;

class CtrlCCover {
public:
      CtrlCCover  (bool bAllowExit);
     ~CtrlCCover  ( );
};

CtrlCCover::CtrlCCover(bool b)
   { bGlblAllowCtrlCExit = b; }
 
CtrlCCover::~CtrlCCover( )
   { bGlblAllowCtrlCExit = 1; }

#define DisableCtrlCProcessExit() CtrlCCover oCtrlCCover(0)

#ifdef _WIN32
HANDLE hGlblConsole     =  0;
WORD   nGlblConsAttrib  =  0;
HANDLE hGlblStdIn       =  0;
DWORD  nGlblStdRead     =  0;

#define CCMASK_FOREGROUND (FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE|FOREGROUND_INTENSITY)
#define CCMASK_BACKGROUND (BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE|BACKGROUND_INTENSITY)
#define CCMASK_FORE_BACK  (CCMASK_FOREGROUND|CCMASK_BACKGROUND)
#define CCMASK_NOT_FGCOL  (0xFFFF ^ CCMASK_FOREGROUND)

// need this to ensure that commands dumping colored output
// do never leave the shell in a non-std color.
BOOL WINAPI ctrlcHandler(DWORD type)
{
   if (type != CTRL_C_EVENT && type != CTRL_BREAK_EVENT)
      return 0;

   bGlblEscape = 1;
 
   setTextColor(-1);

   if (bGlblAllowCtrlCExit)
   {
      // do this only with exit allowed,
      // otherwise main program may crash
      // as it continues on the file handle.
      cleanupFileWrite();
      ExitProcess(8);
   }

   return 1;
}
#else
// unix todo: ctrl+c handler to reset color
void ctrlcHandler(int sig_number)
{
   bGlblEscape = 1;
 
   setTextColor(-1, 0); // stdout
   setTextColor(-1, 1); // stderr

   if (bGlblAllowCtrlCExit)
   {
      // do this only with exit allowed,
      // otherwise main program may crash
      // as it continues on the file handle.
      cleanupFileWrite();
      exit(8);
   }
}
#endif

void setColorScheme(cchar *psz1)
{
   char *psz2 = 0;
   bool bany = 0;

   if (!strncmp(psz1, "off", 3)) {
      gs.usecolor = gs.usehelpcolor = 0;
      cs.usecolor = cs.usehelpcolor = 0; 
   }
   else
   if (!strncmp(psz1, "on", 2)) {
      gs.usecolor = 1;
      cs.usecolor = 1;
   }

   if (strstr(psz1, "bright"))
      { nGlblDarkColBase = 1; bany=1; }

   if (strstr(psz1, "dark"))
      { nGlblBrightColBase = 0; bany=1; }

   #ifdef MAC_OS_X // 1694
   if (strstr(psz1, "theme:black") || !strcmp(psz1, "b")) {
      nGlblDarkColBase    =  0;
      nGlblBrightColBase  =  0;
      nGlblHeadColor      =  4;
      nGlblExampColor     =  6;
      nGlblFileColor      = 10;
      nGlblHitColor       =  4;
      nGlblRepColor       =  6;
      nGlblLinkColor      = 12;
      nGlblWarnColor      =  6;
      nGlblDefColor       = 14;
      bany=1;
   }
   if (strstr(psz1, "theme:white") || !strcmp(psz1, "w")) {
      nGlblDarkColBase    =  0;
      nGlblBrightColBase  =  0;
      nGlblHeadColor      =  4;
      nGlblExampColor     = 10;
      nGlblFileColor      = 10;
      nGlblLinkColor      = 12;
      nGlblHitColor       =  4;
      nGlblRepColor       =  6;
      nGlblErrColor       =  2;
      nGlblWarnColor      = 10;
      nGlblPreColor       =  8;
      nGlblTimeColor      =  8;
      nGlblTraceIncColor  = 12;
      nGlblTraceExcColor  = 10;
      nGlblDefColor       =  0;
      bany=1;
   }
   #else
   if (strstr(psz1, "theme:black") || !strcmp(psz1, "b")) {
      // bright colors with black background
      nGlblDarkColBase =  1;
      nGlblExampColor  =  7; // bright yellow
      nGlblHeadColor   =  5; // green
      nGlblFileColor   =  5; // green
      nGlblHitColor    = 11; // purple
      nGlblRepColor    =  7; // bright yellow
      nGlblLinkColor   = 13; // bright cyan
      nGlblWarnColor   =  7; // bright yellow
      #ifndef _WIN32
      // nGlblDefColor = 14; // fix: 1732: don't use gray but terminal default
      #endif
      bany=1;
   }
   if (strstr(psz1, "theme:white") || !strcmp(psz1, "w")) {
      // with white background, user may want to select
      // bright or dark colors case by case.
      nGlblHeadColor      =  4; // green
      nGlblExampColor     = 11; // purple
      nGlblFileColor      =  4; // green
      nGlblHitColor       = 11; // purple
      nGlblRepColor       =  3; // red
      nGlblLinkColor      = 12; // cyan
      nGlblErrColor       =  3; // red
      nGlblWarnColor      = 11; // purple
      nGlblPreColor       =  8; // blue
      nGlblTimeColor      =  8; // blue
      nGlblTraceIncColor  = 12; // dark magenta
      nGlblTraceExcColor  = 11; // purple
      bany=1;
   }
   #endif

   if (strstr(psz1, ",nobold")) // 1694
      { nGlblDarkColBase = 0; nGlblBrightColBase = 0; bany=1; }
   else
   if (strstr(psz1, ",bold"))   // 1694
      { nGlblDarkColBase = 1; nGlblBrightColBase = 1; bany=1; }

   psz2 = (char*)strstr(psz1, "head:");  if (psz2) { nGlblHeadColor  = atol(psz2+5); bany=1; }
   psz2 = (char*)strstr(psz1, "examp:"); if (psz2) { nGlblExampColor = atol(psz2+6); bany=1; }
   psz2 = (char*)strstr(psz1, "file:");  if (psz2) { nGlblFileColor  = atol(psz2+5); bany=1; }
   psz2 = (char*)strstr(psz1, "link:");  if (psz2) { nGlblLinkColor  = atol(psz2+5); bany=1; }
   psz2 = (char*)strstr(psz1, "hit:");   if (psz2) { nGlblHitColor   = atol(psz2+4); bany=1; }
   psz2 = (char*)strstr(psz1, "rep:");   if (psz2) { nGlblRepColor   = atol(psz2+4); bany=1; }
   psz2 = (char*)strstr(psz1, "err:");   if (psz2) { nGlblErrColor   = atol(psz2+4); bany=1; }
   psz2 = (char*)strstr(psz1, "warn:");  if (psz2) { nGlblWarnColor  = atol(psz2+5); bany=1; }
   psz2 = (char*)strstr(psz1, "pre:");   if (psz2) { nGlblPreColor   = atol(psz2+4); bany=1; }
   #ifndef _WIN32
   psz2 = (char*)strstr(psz1, "def:");   if (psz2) { nGlblDefColor   = atol(psz2+4); bany=1; }
   #endif
   //                   0123456789
   psz2 = (char*)strstr(psz1, "time:");     if (psz2) { nGlblTimeColor     = atol(psz2+5); bany=1; }
   psz2 = (char*)strstr(psz1, "traceinc:"); if (psz2) { nGlblTraceIncColor = atol(psz2+9); bany=1; }
   psz2 = (char*)strstr(psz1, "traceexc:"); if (psz2) { nGlblTraceExcColor = atol(psz2+9); bany=1; }
 
   if (bany) {
      gs.usecolor = 1;
      cs.usecolor = 1;
   }
}

int nGlblCurColor = -1; // currently active color

void setTextColor(int nIn, bool bStdErr, bool bVerbose)
{
   int n = nIn;

   if (n == nGlblCurColor) {
      mtklog(("color: ignore %d, is set already", n));
      return;
   }
   nGlblCurColor = n;

   if (bGlblHtml)
   {
      static bool bAnySet = 0;
      static bool bIsBold = 0;
      uint ncol = 0;
      if (bAnySet) { printf("</font>"); bAnySet=0; }
      if (bIsBold) { printf("</b>"); bIsBold=0; }
      if (n == -1)
         return;
      bAnySet=1;
      if (n == 1) { bIsBold=1; printf("<b>"); }
      if (n &  2) ncol |= (n&1) ? 0xFF0000 : 0x990000;
      if (n &  4) ncol |= (n&1) ? 0x00FF00 : 0x009900;
      if (n &  8) ncol |= (n&1) ? 0x0000FF : 0x000099;
      if (n & 16) { bIsBold=1; printf("<b>"); }
      printf("<font color=\"%06X\">", ncol);
      return;
   }

   if (!cs.usecolor) {
      mtklog(("color: ignore %d, no colors used", n));
      return;
   }

   #ifdef _WIN32

   #ifdef WINFULL
   if (n == 0) {
      // FIX: n==0 produces invisible text both with a white
      //      or black background shell. a visible compromise:
      n = 14;
   }

   WORD nAttrib = 0;
   if (n & 1) nAttrib |= FOREGROUND_INTENSITY;
   if (n & 2) nAttrib |= FOREGROUND_RED;
   if (n & 4) nAttrib |= FOREGROUND_GREEN;
   if (n & 8) nAttrib |= FOREGROUND_BLUE;

   if (n == -1) {
      // default color: set all attribs as they were.
      SetConsoleTextAttribute(hGlblConsole, nGlblConsAttrib);
      mtklog(("color: scta %lxh (is default)", nGlblConsAttrib));
   } else {
      // set new FOREGROUND text color, but make sure that
      // background color and anything else stays unchanged.
      uint nval = (nGlblConsAttrib & CCMASK_NOT_FGCOL) | nAttrib;
      SetConsoleTextAttribute(hGlblConsole, nval);
      mtklog(("color: scta %lxh (default=%lxh)", nval, nGlblConsAttrib));
   }
   #endif

   #else

   #define UXATTR_RESET     0
   #define UXATTR_BRIGHT    1
   #define UXATTR_DIM       2
   #define UXATTR_UNDERLINE 3
   #define UXATTR_BLINK     4
   #define UXATTR_REVERSE   7
   #define UXATTR_HIDDEN    8

   #define UXCOL_BLACK      0
   #define UXCOL_RED        1
   #define UXCOL_GREEN      2
   #define UXCOL_YELLOW     3
   #define UXCOL_BLUE       4
   #define UXCOL_MAGENTA    5
   #define UXCOL_CYAN       6
   #define UXCOL_WHITE      7

   FILE *fout = stdout;
   if (bStdErr)
         fout = stderr;

   if (n==-1) {
      // unix: have to use a user-defined default color
      n = nGlblDefColor;
   }

   int nAttr = (n & 1) ? UXATTR_BRIGHT : UXATTR_RESET;

   switch (n & 14) {
      case  2: n = UXCOL_RED;     break;
      case  4: n = UXCOL_GREEN;   break;
      case  6: n = UXCOL_YELLOW;  break;
      case  8: n = UXCOL_BLUE;    break;
      case 10: n = UXCOL_MAGENTA; break;
      case 12: n = UXCOL_CYAN;    break;
      case 14: n = UXCOL_WHITE;   break;
      default: n = UXCOL_BLACK;   break;
   }

   if (nIn == -1 && nGlblDefColor == 0) {
      // fix: 1732: linux default color if def:0
      if (bVerbose)
         fprintf(fout, "using color sequence: \\x1b[0;0m\n");
      fprintf(fout, "%c[0;0m", 0x1B);
   } else {
      if (bVerbose)
         fprintf(fout, "using color sequence: \\x1b[%d;%dm\n", nAttr, n+30);
      fprintf(fout, "%c[%d;%dm", 0x1B, nAttr, n+30);
   }

   #endif
}

void oprintf(cchar *pszFormat, ...);
void oprintf(StringPipe *pOutData, cchar *pszFormat, ...);

uchar unicodeToIso(uint ucode)
{
   switch (ucode)
   {
      // normalize stupid apostrophes
      case 0x2018: ucode = 0x27; break;
      case 0x2019: ucode = 0x27; break;
      case 0x0000: ucode = cs.toisodef; break;
      default:
         // replace all non-8bit by default
         if (ucode >= 0x0100)
            ucode = cs.toisodef;
            break;
   }
   return (uchar)ucode;
}

void utf8ToIso(char *psz, int *pChg=0)
{
   UTF8Codec utf(psz);
   char *pDstCur = psz;
   char *pDstMax = psz+strlen(psz);
   uint ucode = 0;
   while (pDstCur<pDstMax && utf.hasChar()!=0)
   {
      *pDstCur++ = (char)unicodeToIso(utf.nextChar());
   }
   if (pDstCur<pDstMax) {
      *pDstCur = '\0';
      if (pChg) (*pChg)++;
   }
}

void changeLineCase(char *psz, int iMode, int *pChg=0)
{
   char u;
   switch (iMode) {
      case 1:
         for (;*psz;psz++) {
            u = sfktoupper(*psz);
            if (*psz != u) {
               *psz = u;
               if (*pChg) (*pChg)++;
            }
         }
         break;
      case 2:
         for (;*psz;psz++) {
            u = sfktolower(*psz);
            if (*psz != u) {
               *psz = u;
               if (*pChg) (*pChg)++;
            }
         }
         break;
   }
}

void trimLine(char *psz, int iMode, int *pChg=0)
{
   char *pleft  = psz;
   char *prite  = psz + strlen(psz);
   char *prite2 = prite;
   int   iChg   = 0;

   if (iMode & 1)
   {
      while (*pleft == ' ' || *pleft == '\t') {
         pleft++;
         iChg++;
      }
   }

   if (iMode & 2)
   {
      while (prite > pleft && (prite[-1] == ' ' || prite[-1] == '\t')) {
         prite--;
         iChg++;
      }
   }

   int ilen = prite - pleft;

   if (pleft != psz)
   {
      // move and terminate
      for (int i=0; i<ilen; i++)
         psz[i] = pleft[i];
      psz[ilen] = '\0';
      if (pChg) *pChg = iChg;
   }
   else if (prite != prite2)
   {
      // just terminate
      *prite = '\0';
      if (pChg) *pChg = iChg;
   }
}

char szPrintBufMap[MAX_LINE_LEN+10];

void mystrcatf(char *pOut, int nOutMax, cchar *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';
   char *psz = szPrintBufMap;

   if (nOutMax == 0) nOutMax = MAX_LINE_LEN;

   int nlen1 = strlen(pOut);
   int nrem1 = (nOutMax - nlen1) - 1; // including term.
   int nlen2 = strlen(psz);
   if (nlen2 > nrem1) nlen2 = nrem1;
   if (nlen2 > 0) {
      memcpy(pOut+nlen1, psz, nlen2);
      *(pOut+nlen1+nlen2) = '\0';
   }
}

// without zero termination, only for short fixed-size strings
void mystrplot(char *pOut, int iMaxOut, cchar *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';
   char *psz = szPrintBufMap;

   int iCopy = strlen(psz);
   if (iCopy > iMaxOut)
      iCopy = iMaxOut;
 
   memcpy(pOut, psz, iCopy);
}

char myrchar(char *psz)
{
   int ilen = strlen(psz);
   if (ilen > 0)
      return psz[ilen-1];
   return 0;
}

void printHtml(char *pszText, int iTextLen)
{
   for (int i=0; i<iTextLen; i++) {
      char c = pszText[i];
      switch (c) {
         case '>': printf("&gt;"); break;
         case '<': printf("&lt;"); break;
         case '&': printf("&amp;"); break;
         default : putchar(c); break;
      }
   }
}

int sfkMapAttrToColor(char cAttr)
{
   int d = nGlblDarkColBase;
   int b = nGlblBrightColBase;

   switch (cAttr)
   {
      // sfk internal color codes. when extending this,
      // also adapt color mapping in the "view" command.

      case 'f': return nGlblFileColor ; break;
      case 'l': return nGlblLinkColor ; break;
      case 'h': return nGlblHeadColor ; break;
      case 'i': return nGlblHitColor  ; break;
      case 'a': return nGlblRepColor  ; break;
      case 'x': return nGlblExampColor; break;
      case 'e': return nGlblErrColor  ; break;
      case 'w': return nGlblWarnColor ; break;
      case 't': return nGlblTimeColor ; break;
      case 'p': return nGlblPreColor  ; break;

      // bright base colors
      case 'R': return b+2 ; break;
      case 'G': return b+4 ; break;
      case 'B': return b+8 ; break;
      case 'Y': return b+6 ; break;
      case 'C': return b+12; break;
      case 'M': return b+10; break;
      case 'V': return b+14; break;

      // dark base colors
      case 'r': return d+2 ; break;
      case 'g': return d+4 ; break;
      case 'b': return d+8 ; break;
      case 'y': return d+6 ; break;
      case 'c': return d+12; break;
      case 'm': return d+10; break;
      case 'v': return d+14; break;
   }

   // default:
   return -1;
}

// add to szLineBuf/szAttrBuf. uses szLineBuf2.
// flush line if '\n' is seen.
// consider output chaining.
int addColorText(char ccol, const char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szLineBuf2, MAX_LINE_LEN, pszFormat, argList);
   szLineBuf2[MAX_LINE_LEN] = '\0';

   int iadd = strlen(szLineBuf);
   int nadd = strlen(szLineBuf2);

   if (strlen(szAttrBuf) != iadd) {
      pwarn("invalid attrib buffer content (%d/%d)\n",(int)strlen(szAttrBuf),iadd);
      memset(szAttrBuf, ' ', iadd);
      szAttrBuf[iadd] = '\0';
   }

   if (iadd + nadd + 10 > MAX_LINE_LEN) return 9;

   memcpy(szLineBuf+iadd, szLineBuf2, nadd);
          szLineBuf[iadd+nadd] = '\0';

   memset(szAttrBuf+iadd, ccol, nadd);
          szAttrBuf[iadd+nadd] = '\0';

   // flush to terminal or chain
   char *peol = strchr(szLineBuf, '\n');
   if (peol) {
      iadd = peol - szLineBuf;
      szLineBuf[iadd] = '\0';
      szAttrBuf[iadd] = '\0';
      if (chain.coldata)
         chain.addLine(szLineBuf, szAttrBuf);
      else
         printColorText(szLineBuf, szAttrBuf);
      szLineBuf[0] = '\0';
      szAttrBuf[0] = '\0';
   }

   return 0;
}

void printColorText(char *pszText, char *pszAttrib, bool bWithLF)
{
   // printf("\n\n\n--- pct.text/attr: ---\n%s\n", pszText);
   // printf("%s\n--- output: ---\n", pszAttrib);

   int nTextLen = strlen(pszText);
   int nAttrLen = strlen(pszAttrib);

   // if insufficient attribs provided, use no color
   if (nAttrLen < nTextLen) {
      oprintf("%s%s", pszText, bWithLF ? "\n":"");
      return;
   }

   int i1=0,i2=0;
   while (i1 < nTextLen)
   {
      // identify next phrase of same color
      uchar a1 = pszAttrib[i1];
      for (i2=1; i1+i2<nTextLen; i2++)
         if (pszAttrib[i1+i2] != a1)
            break;

      // dump next phrase with len i2.
      int ncolor = sfkMapAttrToColor(a1);
      setTextColor(ncolor);

      if (bGlblHtml)
         printHtml(pszText+i1, (int)i2);
      else
         oprintf("%.*s", (int)i2, pszText+i1);

      // step forward
      i1 += i2;
   }
   setTextColor(-1);
   if (bWithLF) {
      // putchar('\n');
      oprintf("\n"); // sfk1914
   }
}

char attribFromHumanColor(char *pszCol, char cDefault='i')
{
   // red -> dark red. Red or RED -> bright red.
   if (!mystricmp(pszCol, "red"))     return pszCol[0];
   if (!mystricmp(pszCol, "green"))   return pszCol[0];
   if (!mystricmp(pszCol, "blue"))    return pszCol[0];
   if (!mystricmp(pszCol, "yellow"))  return pszCol[0];
   if (!mystricmp(pszCol, "cyan"))    return pszCol[0];
   if (!mystricmp(pszCol, "magenta")) return pszCol[0];
   if (!mystricmp(pszCol, "def"))     return ' ';
   if (!mystricmp(pszCol, "default")) return ' ';
   if (!mystricmp(pszCol, "white"))   return (pszCol[0] == 'W') ? 'V':'v';

   // since 1.58 also supporting logical colors
   if (!mystricmp(pszCol, "err"))     return 'e';
   if (!mystricmp(pszCol, "warn"))    return 'w';
   if (!mystricmp(pszCol, "head"))    return 'h';
   if (!mystricmp(pszCol, "examp"))   return 'x';
   if (!mystricmp(pszCol, "file"))    return 'f';
   if (!mystricmp(pszCol, "hit"))     return 'i';
   if (!mystricmp(pszCol, "rep"))     return 'a';
   if (!mystricmp(pszCol, "pre"))     return 'p';
   if (!mystricmp(pszCol, "time"))    return 't';

   static bool btold = 0;
   if (!btold)
   {
      btold = 1;
      pwarn("unsupported color name: %s (try \"sfk help color\")\n", pszCol);
   }

   return cDefault;
}

bool bGlblCheckPrintX = 0;
bool bGlblDumpHelpRaw = 0;

char szPrintBuf1[MAX_LINE_LEN+10];
char szPrintBuf2[MAX_LINE_LEN+10];
char szPrintAttr[MAX_LINE_LEN+10];

int printx(const char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);

   if (bGlblCheckPrintX)
      szPrintBuf1[sizeof(szPrintBuf1)-12] = '\xFF';

   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';
 
   if (bGlblCheckPrintX)
      if (szPrintBuf1[sizeof(szPrintBuf1)-12] != '\xFF')
         fprintf(stderr, "printx overflow.1: %.30s ...\n", szPrintBuf1);

   if (bGlblDumpHelpRaw) {
      printf("%s", szPrintBuf1);
      return 0;
   }

   char *pszSrc = szPrintBuf1;
   int  iDst = 0;
   char nAttr = ' ';
   bool bResetOnLF = 0;
   bool bNoCol = 0;
   while (*pszSrc && (iDst < (int)sizeof(szPrintBuf2)-10))
   {
      if (bNoCol) {
         szPrintBuf2[iDst] = *pszSrc;
         szPrintAttr[iDst] = nAttr;
         pszSrc++;
         iDst++;
         continue;
      }
      if (!strncmp(pszSrc, "<nocol>", 7))
         { pszSrc += 7; bNoCol=1; continue; }
      if (pszSrc[0] == '\\' && pszSrc[1] == '<') {
         pszSrc += 2;
         szPrintBuf2[iDst] = '<';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<help>", 6))  { pszSrc += 6; if (cs.usehelpcolor) cs.usecolor = 1; } else
      if (!strncmp(pszSrc, "<file>", 6))  { pszSrc += 6; nAttr = 'f'; } else
      if (!strncmp(pszSrc, "<head>", 6))  { pszSrc += 6; nAttr = 'h'; } else
      if (!strncmp(pszSrc, "<prefix>", 8)){ pszSrc += 8; nAttr = 'p'; } else
      if (!strncmp(pszSrc, "<examp>", 7)) { pszSrc += 7; nAttr = 'x'; } else
      if (!strncmp(pszSrc, "$$"    , 2))  {
         pszSrc += 2;
         szPrintBuf2[iDst] = '$';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "$"     , 1)) { pszSrc += 1; nAttr = 'h'; bResetOnLF = 1; } else
      if (!strncmp(pszSrc, "##"    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = '#';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (pszSrc[0] == '\\' && pszSrc[1] == '*') {
         pszSrc += 2;
         szPrintBuf2[iDst] = '*';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (pszSrc[0] == '\\' && pszSrc[1] == glblWildChar) {
         pszSrc += 2;
         szPrintBuf2[iDst] = glblWildChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "#"     , 1)) { pszSrc += 1; nAttr = 'x'; bResetOnLF = 1; } else
      if (!strncmp(pszSrc, "<hit>" , 5)) { pszSrc += 5; nAttr = 'i'; } else
      if (!strncmp(pszSrc, "<rep>" , 5)) { pszSrc += 5; nAttr = 'a'; } else
      if (!strncmp(pszSrc, "<err>" , 5)) { pszSrc += 5; nAttr = 'e'; } else
      if (!strncmp(pszSrc, "<warn>", 6)) { pszSrc += 6; nAttr = 'w'; } else
      if (!strncmp(pszSrc, "<time>", 6)) { pszSrc += 6; nAttr = 't'; } else
      if (!strncmp(pszSrc, "<def>" , 5)) { pszSrc += 5; nAttr = ' '; } else

      if (!strncmp(pszSrc, "[["    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = '[';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "]]"    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = ']';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      // base colors are bright or dark depending on their first name char
      if (!mystrncmp(pszSrc, "[red]"    , 5)) { nAttr = pszSrc[1]; pszSrc += 5; } else
      if (!mystrncmp(pszSrc, "[green]"  , 7)) { nAttr = pszSrc[1]; pszSrc += 7; } else
      if (!mystrncmp(pszSrc, "[blue]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[yellow]" , 8)) { nAttr = pszSrc[1]; pszSrc += 8; } else
      if (!mystrncmp(pszSrc, "[cyan]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[magenta]", 9)) { nAttr = pszSrc[1]; pszSrc += 9; } else

      if (!strncmp(pszSrc, "[def]"    , 5)) { pszSrc += 5; nAttr = ' '; } else

      if (!strncmp(pszSrc, "[CR]"     , 4)) {
         pszSrc += 4;
         szPrintBuf2[iDst] = '\r';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "[LF]"     , 4)) {
         pszSrc += 4;
         szPrintBuf2[iDst] = '\n';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "<not>"    , 5)) {
         pszSrc += 5;
         szPrintBuf2[iDst] = glblNotChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<run>" , 5)) {
         pszSrc += 5;
         szPrintBuf2[iDst] = glblRunChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<wild>" , 6)) {
         pszSrc += 6;
         szPrintBuf2[iDst] = glblWildChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<sla>" , 5)) {
         pszSrc += 5;
         szPrintBuf2[iDst] = glblPathChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<exp>" , 5)) {
         pszSrc += 5;
         #ifdef _WIN32
         memcpy(szPrintBuf2+iDst, "set", 3);
         memset(szPrintAttr+iDst, nAttr, 3);
         iDst += 3;
         #else
         memcpy(szPrintBuf2+iDst, "export", 6);
         memset(szPrintAttr+iDst, nAttr   , 6);
         iDst += 6;
         #endif
      }
      else
      if (!strncmp(pszSrc, "<shext>" , 7)) {
         pszSrc += 7;
         #ifdef _WIN32
         memcpy(szPrintBuf2+iDst, "bat", 3);
         memset(szPrintAttr+iDst, nAttr, 3);
         iDst += 3;
         #else
         memcpy(szPrintBuf2+iDst, "sh", 2);
         memset(szPrintAttr+iDst, nAttr, 2);
         iDst += 2;
         #endif
      }
      else
      if (!strncmp(pszSrc, "<nofo>" , 6)) {
         pszSrc += 6;
         #ifndef _WIN32
         memcpy(szPrintBuf2+iDst, "-nofo ", 6);
         memset(szPrintAttr+iDst, nAttr   , 6);
         iDst += 6;
         #endif
      }
      else {
         szPrintBuf2[iDst] = *pszSrc;
         szPrintAttr[iDst] = nAttr;
         if (*pszSrc == '\n' && bResetOnLF) {
            nAttr = ' ';
            szPrintAttr[iDst] = nAttr;
            bResetOnLF = 0;
         }
         pszSrc++;
         iDst++;
      }
   }
   szPrintBuf2[iDst] = '\0';

   if (bGlblCheckPrintX)
      if (iDst >= (int)sizeof(szPrintBuf2)-10)
         fprintf(stderr, "printx overflow.2: %.30s ...\n", szPrintBuf2);

   if (iGlblCollectCmd)
   {
      if (iGlblCollectCmd == 1)
      {
         void addHelpCmdLines(char *pszRaw, char *pszForm);
         addHelpCmdLines((char*)pszFormat, szPrintBuf2);
      }
   }
   else if (bGlblCollectHelp)
   {
      int chainAddLine(char *pszText, char *pszAttr, bool bSplitByLF);
      chainAddLine(szPrintBuf2, szPrintAttr, 1);
   }
   else
   {
      printColorText(szPrintBuf2, szPrintAttr, 0);
   }

   return 0;
}

// print whole chapter from main help text
int printHelp(const char *pszFormat, ...)
{
   char *pszBuf  = (char*)abBuf;
   int   iMaxBuf = sizeof(abBuf) - 100;

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(pszBuf, iMaxBuf, pszFormat, argList);
   pszBuf[iMaxBuf] = '\0';

   /*
   file system
      sfk list       - list directory tree contents.
                       list latest, oldest or biggest files.
                       list changed or identical files.
      sfk filefind   - find files by filename
      sfk treesize   - show directory size statistics
   */

   cchar *pszind = "   ";

   char *psz1 = pszBuf;
   char *psz2 = 0;
   int   ilen = 0;
   for (; psz1 && *psz1; psz1=psz2)
   {
      if ((psz2 = strchr(psz1, '\n'))) {
         ilen = psz2 - psz1;
         psz2++; // skip LF
      } else {
         ilen = strlen(psz1);
      }
      char *pszLineEnd = psz1 + ilen;

      // process current line
      if (*psz1 != ' ') {
         // headline
         printx("%s<file>%.*s<def>\n",pszind,ilen,psz1);
         continue;
      }

      // split command entry
      char *pcmd=0, *pcmde=0, *ptext=0;

      pcmd = psz1;
      skipOver(&pcmd, " ");
      if (*pcmd=='\r' || *pcmd=='\n') {
         // no command name, but empty line
         printx("\n");
         continue;
      }
      if (pcmd > psz1+3) {
         // no command name, but continuation line
         printx("%s%.*s\n",pszind,ilen,psz1);
         continue;
      }

      ptext = strstr(pcmd, "- ");
      if (ptext) {
         // found "-" before info text
         pcmde = ptext;
         while (pcmde > pcmd && pcmde[-1] == ' ')
            pcmde--;
         // show name and text in two colors
         int icmdlen = pcmde - pcmd;
         int itxtlen = pszLineEnd - pcmde;
         printx("%s   #%.*s<def>%.*s\n",pszind,icmdlen,pcmd,itxtlen,pcmde);
      } else {
         // command name without info text
         printx("%s$%.*s<def>\n",pszind,ilen,psz1);
         continue;
      }
   }

   return 0;
}

static char szErrBuf[MAX_LINE_LEN+10];
static char szPreErrBuf[MAX_LINE_LEN+10];

cchar *sfkLastError()
{
   if (bErrBufSet)
      return szErrBuf;
   else
      return "";
}

ListEntry::ListEntry( )  { pClNext = pClPrevious = 0; data = 0; }
ListEntry::~ListEntry( ) { pClNext = pClPrevious = 0; data = 0; }

List::List( )  { reset(); }
List::~List( ) { reset(); }

int List::size( )
{
   int icount = 0;
   ListEntry *p = pClFirst;
   while (p) {
      icount++;
      p = p->pClNext;
   }
   return icount;
}

// NOTE: caller MUST FREE all list elements before reset()!
void List::reset( ) {
   pClFirst = pClLast = 0;
}

void List::add(ListEntry* pNew)
{
   if (!pClFirst)
   {
      // yet empty list:
      pClFirst = pClLast = pNew;
      pNew->pClNext = pNew->pClPrevious = 0;
      return;
   }

   // append node at end of list:
   pClLast->pClNext   = pNew;
    pNew->pClPrevious = pClLast;
    pNew->pClNext     = 0;
   pClLast            = pNew;
}

void List::addAsFirst(ListEntry* pNew)
{
   // yet empty list?
   if (!pClFirst)
   {
      pClFirst = pClLast = pNew;
      pNew->pClNext = pNew->pClPrevious = 0;
      return;
   }

   // make node new front of list:
   ListEntry *n2 = pClFirst;
   n2->pClPrevious      = pNew;
    pNew->pClPrevious   = 0;
    pNew->pClNext       = n2;
   pClFirst             = pNew;
}

void List::addAfter(ListEntry *pAfter, ListEntry *pNew)
{
   ListEntry *pNext = pAfter->pClNext;  // might be 0

   pAfter->pClNext   = pNew;
   pNew->pClPrevious = pAfter;
   pNew->pClNext     = pNext;

   if (pNext)
      pNext->pClPrevious = pNew;
   else
      pClLast  = pNew;
}

void List::remove(ListEntry* pRemove)
{
   ListEntry *pPrevious = pRemove->pClPrevious;  // might be 0
   ListEntry *pNext     = pRemove->pClNext;      // might be 0

   pRemove->pClNext = pRemove->pClPrevious = 0;

   if (!pPrevious)   // if 'pRemove' at start of list
   {
      if ((pClFirst = pNext))    // new list start becomes pNext ...
         pNext->pClPrevious = 0; // ... and if pNext exists, adjust it,
      else
         pClLast  = 0;           // else list is empty.
   }
   else
   {
      // at least a 'pClPrevious' is given.
      if ((pPrevious->pClNext = pNext))   // let pPrevious' 'pClNext' ptr bypass 'pRemove' ...
         pNext->pClPrevious = pPrevious;  // ... and if pNext exists, adjust it,
      else
         pClLast  = pPrevious;            // else set new listend.
   }
}

KeyMap::KeyMap( ) {
   mtklog(("keymap ctr %p", this));
   wipe();
}

KeyMap::~KeyMap( ) {
   mtklog(("keymap dtr %p", this));
   reset();
   wipe();
}

void KeyMap::wipe( ) {
   nClArrayAlloc = 0;
   nClArrayUsed = 0;
   apClKey  = 0;
   apClVal  = 0;
   bClCase  = 1;
   bClRev   = 0;
}

void KeyMap::reset( )
{
   for (int i=0; i<nClArrayUsed; i++)
      delete [] apClKey[i];
   if (apClKey) delete [] apClKey;
   if (apClVal) delete [] apClVal;
   wipe();
}

void KeyMap::setcase(bool bYesNo)    { bClCase = bYesNo; }
void KeyMap::setreverse(bool bYesNo) { bClRev = bYesNo;  }

int KeyMap::expand(int nSoMuch)
{__
   // expand the key array
   char **apTmp1 = new char*[nClArrayAlloc+nSoMuch];
   if (!apTmp1) return 9;
   if (apClKey) {
      memcpy(apTmp1, apClKey, nClArrayUsed*sizeof(char*));
      delete [] apClKey;
   }
   apClKey = apTmp1;

   // expand the value array
   void **apTmp2 = new void*[nClArrayAlloc+nSoMuch];
   if (!apTmp2) return 9;
   if (apClVal) {
      memcpy(apTmp2, apClVal, nClArrayUsed*sizeof(void*));
      delete [] apClVal;
   }
   apClVal = apTmp2;

   // set new alloc size
   nClArrayAlloc += nSoMuch;

   return 0;
}

// rc =0:found_and_index_set
// rc <0:insert_before_index
// rc >0:insert_after_index
int KeyMap::bfind(char *pkey, int &rindex)
{
   // binary search for key, or insert position
   uint nbot=0,ndist=0,nhalf=0,imid=0;
   uint ntop=nClArrayUsed; // exclusive
   char  *ptmp=0;
   int    ncmp=-1;   // if empty, insert before index 0

   while (1)
   {
      if (nbot > ntop) // shouldn't happen
         { perr(0, "int. 187281850"); ncmp=-1; break; }

      ndist = ntop - nbot;
      // mtklog(("dist %d bot %d top %d",ndist,nbot,ntop));
      if (ndist == 0) break; // nothing left
      nhalf = ndist >> 1;
      imid  = nbot + nhalf;
      ptmp  = apClKey[imid];
      ncmp  = bClCase ? strcmp(pkey, ptmp) : mystricmp(pkey, ptmp);
      if (bClRev) ncmp = 0 - ncmp;
 
      if (ncmp < 0) {
         // select lower half, if any
         // mtklog((" take lower %lxh %lxh %d",nval,ntmp,imid));
         if (ntop == imid) break; // safety
         ntop = imid;
      }
      else
      if (ncmp > 0) {
         // select upper half, if any
         // mtklog((" take upper %lxh %lxh %d",nval,ntmp,imid));
         if (nbot == imid+1) break; // required
         nbot = imid+1;
      } else {
         // straight match
         mtklog(("%d = indexof(%.30s) used=%u",imid,pkey,nClArrayUsed));
         break; // found
      }
   }

   rindex = imid;
   return ncmp;
}

int KeyMap::put(char *pkey, void *pval)
{
   // assure space for insertion, incl. safety
   if (nClArrayUsed >= nClArrayAlloc-10) {
      if (nClArrayAlloc == 0) {
         if (expand(20)) return 9;
      } else {
         if (expand(nClArrayAlloc)) return 9;
      }
   }

   // search for key or insert position:
   int imid=0;
   int  nrc = bfind(pkey, imid);

   if (nrc)
   {
      // no match, insert new entry:
      // if ncmp <= 0: before imid
      // if ncmp  > 0: after imid
      if (nrc > 0) imid++;
 
      // before imid as it is now
      uint ntomove = nClArrayUsed - imid;
      memmove(&apClKey[imid+1], &apClKey[imid], sizeof(char*) * ntomove);
      memmove(&apClVal[imid+1], &apClVal[imid], sizeof(void*) * ntomove);
      apClKey[imid] = strdup(pkey); // is COPIED.
      nClArrayUsed++;
   }

   // target position is now imid.
   apClVal[imid] = pval;
   // if there was an old pval, it is replaced.

   return 0; // done
}

void *KeyMap::get(char *pkey, int *poutidx)
{
   int imid=0;
   int  nrc = bfind(pkey, imid);
   // even on miss return last comparison index
   // to allow caller to find nearby words.
   if (poutidx) *poutidx = imid;
   if (nrc) return 0;
   if (imid < 0 || imid >= nClArrayUsed)
      {  perr("int. 187281919"); return 0; }
   return apClVal[imid]; // if any
}

bool KeyMap::isset(char *pkey) {
   int imid=0;
   return bfind(pkey, imid) ? 0 : 1;
}

int KeyMap::remove(int imid)
{
   // remove entry at imid
   delete [] apClKey[imid];
   if (imid < nClArrayUsed) {
      uint ntomove = nClArrayUsed - imid - 1;
      if (ntomove > 0) { // fix: 1763: missing check
         memmove(&apClKey[imid+0], &apClKey[imid+1], sizeof(char*) * ntomove);
         memmove(&apClVal[imid+0], &apClVal[imid+1], sizeof(void*) * ntomove);
      }
   }
   nClArrayUsed--;
   return 0;
}

int KeyMap::remove(char *pkey)
{
   int imid=0;
   int  nrc = bfind(pkey, imid);
   if (nrc) return 1; // no such key
   return remove(imid);
}

int KeyMap::size( ) {
   return nClArrayUsed;
}

void *KeyMap::iget(int nindex, char **ppkey)
{
   if (nindex < 0 || nindex >= nClArrayUsed)
      { if (ppkey) *ppkey = 0; return 0; }
   if (ppkey) *ppkey = apClKey[nindex];
   return apClVal[nindex];
}

// - - - keymap access with num keys: - -  -

// so far, the nums are simply converted into
// a hex string, prefixed by a non-printable 0x1.

inline void numToKey(num nkey, char *pbuf) {
   pbuf[0] = '\x01';
   pbuf[1] = '\0';
   numtohex(nkey, 16, pbuf+1);
}

int  KeyMap::put   (num nkey, void *pvalue) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return put(szBuf, pvalue);
}

void *KeyMap::get   (num nkey) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return get(szBuf);
}

bool  KeyMap::isset (num nkey) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return isset(szBuf);
}

int  KeyMap::remove(num nkey) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return remove(szBuf);
}

num hextonum(char *psz)
{
   #ifdef _MSC_VER
   return _strtoui64(psz, 0, 0x10);
   #else
   return strtoull(psz, 0, 0x10);
   #endif
}

void *KeyMap::iget  (int nindex, num *pkey) {
   char *pszkey = 0;
   void *pres = iget(nindex, &pszkey);
   if (pkey) {
      if (*pszkey == '\x01') {
         num nkey = hextonum(pszkey+1);
         *pkey = nkey;
      } else {
         perr("wrong keymap key for index %d", nindex);
         *pkey = 0;
      }
   }
   return pres;
}

// - - - keymap access with num keys end - -  -

StringMap::StringMap( )  {
   mtklog(("strmap ctr %p", this));
}

StringMap::~StringMap( ) {
   mtklog(("strmap dtr %p", this));
   reset();
}

void StringMap::reset( )
{__
   mtklog(("strmap reset %p", this));
   for (int i=0; i<size(); i++)
      if (apClVal[i])
         delete [] (char*)apClVal[i];
   KeyMap::reset();
}

int StringMap::put(char *pkey, char *pvalin)
{
   // COPY the input string, but also accept NULL.
   char *pcopy = pvalin ? strdup(pvalin) : 0;

   mtklog(("strmap put this=%p %p key=%s",this,pcopy,pkey));

   // is the key is stored already?
   int imid=0;
   int  nrc = bfind(pkey, imid);
   if (!nrc)
   {
      // yes: if there is a value, delete it
      if (apClVal[imid])
         delete [] (char*)apClVal[imid];
      // and set new value, also accepting NULL.
      apClVal[imid] = pcopy;
      return 0;
   }

   // else add a copy
   return KeyMap::put(pkey, pcopy);
}

char *StringMap::get(char *pkey, char *pszOptDef)
{
   char *pres = (char*)KeyMap::get(pkey);
   if (!pres && pszOptDef) pres = pszOptDef;
   return pres;
}

int StringMap::remove(char *pkey)
{
   int imid=0;
   int  nrc = bfind(pkey, imid);
   if (!nrc && apClVal[imid])
      delete [] (char*)apClVal[imid];
   return KeyMap::remove(pkey);
}

char *StringMap::iget(int nindex, char **ppkey)
{
   char *pkey = 0;
   char *pval = (char*)KeyMap::iget(nindex, &pkey);
   if (ppkey) *ppkey = pkey;
   return pval;
}

int StringMap::put(num nkey, char *pvalin)
{
   // pvalin is dup'ed in the called put()

   mtklog(("strmap nput this=%p %lxh %p",this,(uint)nkey,pvalin));

   char szBuf[100];
   szBuf[0] = '\0';
   numtohex(nkey, 16, szBuf);

   return StringMap::put(szBuf, pvalin);
}

char *StringMap::get(num nkey)
{
   char szBuf[100];
   szBuf[0] = '\0';
   numtohex(nkey, 16, szBuf);
   return (char*)get(szBuf);
}

char *StringMap::iget(int nindex, num *pkey)
{
   char *pszkey = 0;
   void *pres = iget(nindex, &pszkey);
   if (pkey) {
      num nkey = hextonum(pszkey);
      *pkey = nkey;
   }
   return (char*)pres;
}

int StringMap::remove(num nkey)
{
   char szBuf[100];
   szBuf[0] = '\0';
   numtohex(nkey, 16, szBuf);

   int imid = 0;
   int nrc  = bfind(szBuf, imid);

   if (nrc)
      return 1;

   // cleanup value string
   if (apClVal[imid])
      delete [] (char*)apClVal[imid];

   // cleanup key?
   KeyMap::remove(imid); // FIX: 1763: missing

   return 0;
}

AttribStringMap::AttribStringMap( )  { }
AttribStringMap::~AttribStringMap( ) { }

char *AttribStringMap::mixdup(char *ptext, char *pattr)
{
   int nlen1 = strlen(ptext);
   int nlen2 = strlen(pattr);

   // mixed = TEXT + ZEROTERM + ATTR + ZEROTERM + MAGIC
   int nmix  = nlen1 + 1 + nlen2 + 1 + 1;

   char *pmix = new char[nmix];

   memcpy(pmix, ptext, nlen1);
   pmix[nlen1] = '\0';

   memcpy(pmix+nlen1+1, pattr, nlen2);
   pmix[nlen1+1+nlen2] = '\0';

   // to allow consistency checks:
   pmix[nlen1+1+nlen2+1] = (char)0xFF;

   return pmix;
}

int AttribStringMap::demix(char *pmixed, char **pptext, char **ppattr)
{
   // mixed = TEXT + ZEROTERM + ATTR + ZEROTERM + MAGIC
   char *ptext  = pmixed;
   int nlen1   = strlen(ptext);
   char *pattr  = ptext + nlen1 + 1;
   int nlen2   = strlen(pattr);
   char *pmagic = pattr + nlen2 + 1;
   if (*pmagic != (char)0xFF)
      return 9+perr("color string failure, %p \"%.10s\" \"%.10s\" \"%.10s\"", pmixed, pmixed, ptext, pattr);
   *pptext = ptext;
   *ppattr = pattr;
   return 0;
}

int AttribStringMap::put(char *pkey, char *ptext, char *pattr)
{__
   char *pmix = mixdup(ptext, pattr);
   // mtklog(("asmap::put \"%s\" \"%s\" \"%s\"",pkey,ptext,pattr));
   // the string is dup'ed already,
   // place ptr straight into the keymap:
   return KeyMap::put(pkey, pmix);
}

int AttribStringMap::put(num nkey, char *ptext, char *pattr)
{__
   char *pmix = mixdup(ptext, pattr);
   // mtklog(("asmap::put %d \"%s\" \"%s\"",(int)nkey,ptext,pattr));
   // the string is dup'ed already,
   // place ptr straight into the keymap:
   return KeyMap::put(nkey, pmix);
}

char *AttribStringMap::get(char *pkey, char **ppattr)
{
   char *pmix = StringMap::get(pkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   *ppattr = pattr;
   return ptext;
}

char *AttribStringMap::iget(int nindex, char **ppkey, char **ppattr)
{
   char *pkey = 0;
   char *pmix = StringMap::iget(nindex, &pkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   if (ppkey) *ppkey = pkey;
   *ppattr = pattr;
   return ptext;
}

char *AttribStringMap::get(num nkey, char **ppattr)
{
   char *pmix = StringMap::get(nkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   *ppattr = pattr;
   return ptext;
}

char *AttribStringMap::iget(int nindex, num *pkey, char **ppattr)
{
   num nkey = 0;
   char *pmix = StringMap::iget(nindex, &nkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   if (pkey) *pkey = nkey;
   *ppattr = pattr;
   return ptext;
}

int parseVersion(char *psz, int nmaxlen, StringMap &rmap)
{
   // expect input from a binary block:
   char szBuf[300];
   if (nmaxlen > (int)sizeof(szBuf)-10)
       nmaxlen = (int)sizeof(szBuf)-10;
   memcpy(szBuf, psz, nmaxlen);
   szBuf[nmaxlen] = '\0';

   char szVerID[50];
   sprintf(szVerID, "$%s:", "version");

   // $version:num=1.2.3,id=sfk,name=Swiss File Knife,type=base$\0"
   // 0123456789
   psz = szBuf;
   if (!strBegins(psz, szVerID)) return 9;
   psz += 9;

   char *atmp[10];
   memset(&atmp, 0, sizeof(atmp));

   // split comma separated string
   while (psz)
   {
      // nam=val,
      char *pnam = psz;

      while (*psz && *psz != '=' && *psz != '$') psz++;
      if (*psz != '=') break;
      *psz++ = '\0';

      char *pval = psz;

      while (*psz && *psz != ',' && *psz != '$') psz++;
      if (*psz == ',' || *psz == '$') {
         *psz++ = '\0';
         rmap.put(pnam, pval);
      }
      else break;
   }

   return 0;
}

#ifdef VFILENET
char *flatURLName(char *purl, char *pctype, char *pbuf, int nmaxbuf, uint nmode, bool &rdefault)
{__
   bool bpath2name = (nmode & 1) ? 1 : 0;
   bool bpath2path = (nmode & 2) ? 1 : 0;
   bool bwithdom   = (nmode & 4) ? 1 : 0;
   bool bskippath  = (!bpath2name && !bpath2path);
   // nmode & 8 is reserved
   bool bsynext    = (nmode & 16) ? 1 : 0;

   *pbuf = '\0'; // safety

   char *prel    = purl;
   char *purlmax = purl + strlen(purl);
   char *pCacheDir = getDiskCachePath();

   char szNameBuf[SFK_MAX_PATH+10];

   // only normalize net filenames,
   // or net files from the cache dir.
   if (strBegins(prel, "http://")) prel += strlen("http://");
   else
   if (strBegins(prel, "https://")) prel += strlen("https://");
   else
   if (strBegins(prel, "ftp://"))  prel += strlen("ftp://");
   else
   if (strBegins(prel, pCacheDir))
   {
      prel += strlen(pCacheDir);
      if (*prel == glblPathChar) prel++;

      // rebuild url from cache name format
      char *psrc = prel;
      char *pdst = szNameBuf;
      char *pdstmax = pdst+sizeof(szNameBuf)-10;
      szNameBuf[0] = '\0';

      if (strBegins(psrc, "http/") || strBegins(psrc, "http\\"))
         { psrc += 5; strcat(pdst, "http://"); pdst += 7; }
      else
      if (strBegins(psrc, "ftp/") || strBegins(psrc, "ftp\\"))
         { psrc += 4; strcat(pdst, "ftp://"); pdst += 6; }

      while (*psrc && (pdst < pdstmax))
      {
         if (!strncmp(psrc, "%2F", 3))
            { psrc+=3; *pdst++ = '/'; continue; }
         if (*psrc == '\\')
            { psrc++; *pdst++ = '/'; continue; }
         *pdst++ = *psrc++;
      }
      *pdst = '\0';

      // printf("-> \"%s\"\n", szNameBuf);

      prel = szNameBuf;
   }
   else
      return 0;

   char *pdst = pbuf;
   int  nrem = nmaxbuf - 10;

   if (nrem <= 100) { perr("int. #9529106"); return 0; }

   if (bskippath) {
      // the/sub/doc.zip -> doc.zip
      // http://foo.com/ -> ""
      char *psz2 = strrchr(prel, '/');
      if (psz2) {
         prel = psz2+1;
         if (!*prel) {
            strcpy(pdst, "index.html");
            rdefault = 1;
            return pbuf;
         }
      }
   }
   else
   if (!bwithdom) {
      // foobar.com/path -> path
      char *psz2 = strchr(prel, '/');
      if (psz2) {
         prel = psz2+1;
         if (!*prel) {
            strcpy(pdst, "index.html");
            rdefault = 1;
            return pbuf;
         }
      }
   }

   // convert and add rest of url.
   // http: $-_.+!*'(),
   char *psrc = prel;
   cchar *pext1 = 0;
   char *pext2 = 0;
   char  clast = 0;
   bool  lm    = 0; // last char was minus
   while (*psrc && (nrem > 0))
   {
      char c = *psrc++;
      clast  = c;
      if (isalnum(c)) {
         *pdst++ = c; nrem--; lm=0;
         continue;
      }
      if (!pext2) pext2 = psrc-1;
      switch (c) {
         case '.':
             pext1 = psrc-1; pext2 = 0;
         case '-': case '+': case '_':
            *pdst++ = c; nrem--; lm=0;
            continue;
         case '/':
            if (bpath2path) {
               *pdst++ = glblPathChar; nrem--; lm=0;
               continue;
            }
         default:
            if (!lm) {
               *pdst++ = '-'; nrem--; lm=1;
            }
            continue;
      }
      /*
      sprintf(szBuf, "%%%02X", (unsigned)c);
      *pdst++ = szBuf[0];
      *pdst++ = szBuf[1];
      *pdst++ = szBuf[2];
      nrem -= 3;
      */
   }

   // fix trailing slash
   if (clast == '/' && (nrem >= 12)) {
      strcpy(pdst, "index.html");
      pdst += strlen(pdst);
      pext1 = ".html";
      nrem -= 10;
      rdefault = 1;
   }

   *pdst = '\0';

   if (bsynext)
   {
      // create default extensions for well-known ctypes
      if (!pext1 && pctype) {
         if (strstr(pctype, "text"))   pext1 = ".txt";
         if (strstr(pctype, "html"))   pext1 = ".html";
      }
 
      if (!pext1) pext1 = ".dat";
 
      // if extension is not at end of name, append it again
      if (pext1)
      {
         int nlen   = strlen(pext1);
         bool binurl = (pext1 >= purl && pext1 <= purlmax);
         if (binurl && pext2 && (pext2 > pext1))
            nlen = pext2 - pext1;
         if (nlen > 7) { pext1 = ".dat"; nlen = 4; }
         char *pcmp = pdst - nlen;
         if (pcmp < pbuf) pcmp = pbuf;
         if (nlen <= 7 && nlen < nrem && strncmp(pcmp, pext1, nlen))
         {
            memcpy(pdst, pext1, nlen);
            pdst[nlen] = '\0';
            nrem -= nlen;
         }
      }
   }

   return pbuf;
}
#endif // VFILENET

extern uchar *sfkgetvarexp(char *pname, int *plen);

// - - - - - Coi(Table) begin - - - - -

#define delstring(x) \
   if (x) {          \
      delete [] x;   \
      x = 0;         \
   }

bool Coi::bClDebug = 0;

extern bool endsWithPathChar(char *pszPath, bool bAcceptFWSlash);
extern uchar *getWebDemoData(int &isize);

Coi::Coi(char *pszName, char *pszRootDir)
{
   memset(this, 0, sizeof(*this));

   if (!pszName)
      { perr("int. #21161820"); return; }

   if (!strncmp(pszName, glblDotSlash, 2))
      pszName += 2;

   bool bIsNet = 0;

   #ifdef VFILEBASE
   bool strEnds(char *pszStr, char *pszPat);

   bool bexpdone = 0;

   if (   strBegins(pszName, "http://")
       || strBegins(pszName, "https://")
       || strBegins(pszName, "ftp://")
      )
   {
      // auto-expand http://thehost to http://thehost/
      bIsNet = 1;
      char *psz = strstr(pszName, "//");
      if (psz) {
         psz += 2;
         psz = strchr(psz, '/');
         if (!psz) {
            int nlen = strlen(pszName);
            pszClName = new char[nlen+4];
            strcpy(pszClName, pszName);
            strcat(pszClName, "/");
            bexpdone = 1;
         }
      }
   }

   if (!bexpdone)
   #endif // VFILEBASE

   if (!(pszClName = strdup(pszName))) {
      perr("out of memory: coi.ctr.1");
      return;
   }

   pszClRoot = pszRootDir ? strdup(pszRootDir) : 0;

   mtklog(("coi ctr %p name %s proot %p", this, pszName, pszClRoot));
}

Coi::Coi(int iFromInfo)
{
   memset(this, 0, sizeof(*this));
}

Coi::~Coi( )
{
   mtklog(("coi dtr %p %s\n", this, pszClName));

   if (nClRefs > 0) {
      perr("url has %d refs open, cannot dtr: %s", nClRefs, pszClName);
      return; // avoid instant crash
   }

   if (pdata) {
      // missing cleanup tolerance:
      if (data().pfile) {
         perr("missing close on %s",name());
         fclose(data().pfile);
      }
      // cleanup heavy data:
      delete pdata;
   }

   delstring(pszClName);
   delstring(pszClUName);
   if (pwClName) { delete [] pwClName; pwClName = 0; }

   delstring(pszClRoot);
   delstring(pszClRef);
   delstring(pszClExtStr);

   memset(this, 0, sizeof(*this));
}

bool Coi::hasName( ) { return pszClName ? 1 : 0; }
bool Coi::hasBadName( ) { return bClBadName; }

Coi *Coi::copy( )
{
   Coi *pres = new Coi(name(), pszClRoot ? pszClRoot : 0);
   if (pszClRef) pres->setRef(pszClRef);
   if (pszClExtStr) pres->setExtStr(pszClExtStr);

   pres->nClStatus = nClStatus;
   pres->nClHave   = nClHave;
   pres->nClSize   = nClSize;
   pres->nClMTime  = nClMTime;
   pres->nClCTime  = nClCTime;
   pres->bClRead   = bClRead;
   pres->bClWrite  = bClWrite;
   pres->bClDir    = bClDir;
   pres->bClFSDir  = bClFSDir;
   pres->bClHidden = bClHidden;
   pres->bClLink   = bClLink;
   pres->bClBinary = bClBinary;
   pres->bClArc    = bClArc;
   pres->nClUCS    = nClUCS;
   pres->nClAttr   = nClAttr;
   pres->bClUniName = bClUniName;
   pres->crc       = crc;

   // mtklog(("coi.mtime: %u from copy",(uint)pres->nClMTime));

   return pres;
}

int Coi::incref(cchar *pTraceFrom)  {
   ++nClRefs;
   mtklog(("coi-ref-inc: cnt=%d from %s on %p %s", nClRefs, pTraceFrom, this, name()));
   return nClRefs;
}

int Coi::decref( )  {
   nClRefs--;
   mtklog(("coi-ref-dec: cnt=%d on %p %s", nClRefs, this, name()));
   if (nClRefs < 0)
      pwarn("ref.cnt underflow (%d): %s\n", name());
   return nClRefs;
}

int Coi::refcnt( )  {
   return nClRefs;
}

bool Coi::debug( ) { return cs.debug || bClDebug; }

void Coi::fillFrom(void *pfdatin) // SFKFindData ptr
{
   SFKFindData *pfdat = (SFKFindData *)pfdatin;

   bClDir    = (pfdat->attrib & 0x10) ? 1 : 0; // FILE_ATTRIBUTE_DIRECTORY

   bClHidden = (pfdat->attrib & 0x06) ? 1 : 0;

   #ifdef _WIN32
   // sfk176 identify NTFS links to support -nofo
   bClLink   = (pfdat->attrib & 0x400) ? 1 : 0; // FILE_ATTRIBUTE_REPARSE_POINT
   #else
   bClLink   = pfdat->islink ? 1 : 0;
   #endif

   nClMTime  = pfdat->time_write;
   nClCTime  = pfdat->time_create;
   nClSize   = pfdat->size;

   // mtklog(("coi.mtime: %u from fillFrom",(uint)nClMTime));

   // 0x01 of windows finddata.attrib is readonly
   bClWrite  = (pfdat->attrib & 0x01) ? 0 : 1;

   #ifndef _WIN32
   // linux specific and informal stuff
   rawmode   = pfdat->rawmode;
   rawtype   = pfdat->rawtype;
   rawnlnk   = pfdat->rawnlnk;
   if (pfdat->bhavenode) {
      nClINode  = pfdat->ninode;
      memcpy(&oClStDev, &pfdat->ostdev, sizeof(__dev_t));
      nClHave  |= COI_HAVE_NODE;
   }
   #endif

   // flag the status fields that have been copied
   nClHave  |= COI_HAVE_DIR;
   nClHave  |= COI_HAVE_HIDDEN;
   nClHave  |= COI_HAVE_LINK;
   nClHave  |= COI_HAVE_TIME;
   nClHave  |= COI_HAVE_SIZE;

   mtklog(("coi::fillfrom done dir=%d %s", bClDir, name()));

   // remember we don't need to readStat():
   nClStatus = 1; // meta infos now available
}

int Coi::status( ) {
   return (int)nClStatus;
}

#ifndef _WIN32
bool  Coi::haveNode( )   { return (nClHave & COI_HAVE_NODE) ? 1 : 0; }
num   Coi::getNode( )    { return nClINode; }
bool  Coi::haveFileID( ) { return haveNode(); }

const char *pGlblHexChars = "0123456789ABCDEF";

char *Coi::getFileID( )
{
   if (!haveNode()) return str("");

   // decode binary stdev and inode into a hex string
   uchar *pdst   = (uchar*)szClFileID;
   uchar *pmax   = pdst + sizeof(szClFileID)-4;

   uchar *psrc    = (uchar*)&oClStDev;
   int  nsrcsize = sizeof(oClStDev);
   int  isrc     = 0;

   if (pdst + nsrcsize * 2 >= pmax) return str("");
   for (isrc=0; isrc<nsrcsize; isrc++) {
      *pdst++ = pGlblHexChars[(*psrc >> 4) & 0x0F];
      *pdst++ = pGlblHexChars[(*psrc >> 0) & 0x0F];
      psrc++;
   }

   psrc = (uchar*)&nClINode;
   nsrcsize = sizeof(nClINode);

   if (pdst + nsrcsize * 2 >= pmax) return str("");
   for (isrc=0; isrc<nsrcsize; isrc++) {
      *pdst++ = pGlblHexChars[(*psrc >> 4) & 0x0F];
      *pdst++ = pGlblHexChars[(*psrc >> 0) & 0x0F];
      psrc++;
   }

   *pdst = '\0';

   if (cs.debug) {
      printf("fileid=\"%s\" len=%d for \"%s\"\n",szClFileID,(int)strlen(szClFileID),name());
   }

   return szClFileID;
}
#endif

CoiData::CoiData( ) {
   mtklog(("coidata ctr %p",this));
   memset(this, 0, sizeof(*this));
   #ifdef _WIN32
   otrav = -1;
   #endif
}

CoiData::~CoiData( )
{
   mtklog(("coidata dtr %p", this));

   #ifdef VFILEBASE
   if (pClFtp) {
      mtklog(("coidata dtr autoreleases ftp %p", pClFtp));
      releaseFtp();
      // do NOT delete, is managed by cache.
   }

   if (pClHeaders) {
      mtklog(("coidata dtr autoreleases headers %p", pClHeaders));
      delete pClHeaders;
   }

   if (pClHttp) {
      mtklog(("coidata dtr autoreleases http %p begin", pClHttp));
      releaseHttp();
      // do NOT delete, is managed by cache.
   }

   if (pelements) {
      mtklog(("coidata dtr autoreleases pelements %p", pelements));
      delete pelements;
   }

   if (pClOrgName) {
      mtklog(("coidata dtr autoreleases orgname %p", pClOrgName));
      delete [] pClOrgName;
   }

   #endif // VFILEBASE

   if (src.data) {
      mtklog(("coidata dtr autoreleases src.data %p", src.data));
      delete [] src.data;
   }

   if (rbuf.data) delete [] rbuf.data;

   if (prelsubname) delete [] prelsubname;

   if (bdiropen) perr("missing closeDir() after dir traversal, %p", this);

   if (pdirpat)  delete [] pdirpat;

   memset(this, 0, sizeof(*this));
   #ifdef _WIN32
   otrav = -1;
   #endif
}

#ifdef VFILEBASE
// NOTE: whenever the list is changed,
//       adapt zzfind hashing of extensions.
#endif // VFILEBASE

cchar *officeExtList[] =
{
   // ms office
   ".docx",".dotx",".dotm",".docb",
   ".xlsx",".xlsm",".xltx",".xltm",
   ".pptx",".pptm",".potx",".potm",
   ".ppam",".ppsx",".ppsm",".sldx",".sldm",

   // ODF
   ".odt",".ods",".odp",".odg",".odc",".odf",".odi",".odm",
   ".ott",".ots",".otp",".otg",

   0
};

cchar *arcExtList[] =
{
   ".zip",".jar",".ear",".war",".aar",".xpi",
   ".jmod", // sfk1953

   // ms office sfk193
   ".docx",".dotx",".dotm",".docb",
   ".xlsx",".xlsm",".xltx",".xltm",
   ".pptx",".pptm",".potx",".potm",
   ".ppam",".ppsx",".ppsm",".sldx",".sldm",

   // ODF
   ".odt",".ods",".odp",".odg",".odc",".odf",".odi",".odm",
   ".ott",".ots",".otp",".otg",

   #ifdef VFILEBASE
   #ifndef NO_TAR_SUPPORT
   // CONVENTION:
   //   on ambiguous extensions like .tar <-> .tar.gz,
   //   always list the LONGEST FIRST.
   ".tar.gz", ".tar", ".tgz",
   ".tar.bz2", ".tbz2",
   ".gz", ".bz2",
   // NOTE: .tbz not supported, as it is not clearly bzip2
   #endif
   #endif // VFILEBASE

   // up to 30 user defined ZIP archive extensions are supported:
   0,0,0,0,0, 0,0,0,0,0,
   0,0,0,0,0, 0,0,0,0,0,
   0,0,0,0,0, 0,0,0,0,0,
   0,0,0,0,0  // EOD and some tolerance
};

class StartupEnvGrabber
{
public:
   StartupEnvGrabber();

   char szZipExtBuf[200];
};

StartupEnvGrabber glblEnvGrabber;

StartupEnvGrabber::StartupEnvGrabber()
{
   // set SFK_ZIP_EXT=".foo .bar .myext"
   char *psz1 = getenv("SFK_ZIP_EXT");
   if (psz1)
   {
      // find insertion index in arcExtList
      int iins = 0;
      int imax = (sizeof(arcExtList) / sizeof(char*)) - 3;
      for (; arcExtList[iins] && (iins<imax); iins++);

      // copy and split user extension list
      strcopy(szZipExtBuf, psz1);
      psz1 = szZipExtBuf;
      char *psz2 = 0;
      bool bterminal = 0;
      while (!bterminal && psz1 && *psz1)
      {
         psz1 = strchr(psz1, '.');
         if (!psz1) break;
         psz2 = psz1+1;
         while (*psz2 && isalnum(*psz2))
            psz2++;
         bterminal = *psz2 ? 0 : 1;
         *psz2++ = '\0';
         // still space left?
         if (iins >= imax-1) {
            fprintf(stderr, "Error: too many extensions in SFK_ZIP_EXT\n");
            break;
         }
         // add another extension
         arcExtList[iins++] = psz1;
         // step to next, if !bterminal
         psz1 = psz2;
      }
   }
}

bool endsWithExt(char *pname, char *pszextin)
{
   char *psz = strrchr(pname, '.');
   if (!psz)
      return 0;
 
   if (mystricmp(psz, pszextin))
      return 0;

   return 1;
}

bool endsWithArcExt(char *pname, int iTraceFrom)
{
   // find relevant end of input name:
   // filesys : e.g. .tar.bz2
   // http url: e.g. .tar.bz2?name=val&foo=bar

   // exclusive name end point (on terminator or '?'):
   char *pend = pname + strlen(pname);

   if (   strBegins(pname, "http://")
       || strBegins(pname, "https://")
      )
   {
      char *psz = strrchr(pname, '?');
      if (psz) pend = psz;
   }

   // netto length until end point
   int nnamlen = pend - pname;

   for (int i=0; arcExtList[i]; i++)
   {
      cchar *ppatstr = arcExtList[i];
      int  npatlen  = strlen(ppatstr);
      if (nnamlen < npatlen)
         continue;
      if (!mystrnicmp(pname + nnamlen - npatlen, ppatstr, npatlen)) {
         if (cs.debug)
            printf("arc.byext: %s [%d]\n", pname, iTraceFrom);
         return 1;
      }
   }

   if (cs.debug)
      printf("noarc.byext: %s [%d]\n", pname, iTraceFrom);

   return 0;
}

bool endsWithOfficeExt(char *pname, int iTraceFrom)
{
   // exclusive name end point (on terminator or '?'):
   char *pend = pname + strlen(pname);

   if (   strBegins(pname, "http://")
       || strBegins(pname, "https://")
      )
   {
      char *psz = strrchr(pname, '?');
      if (psz) pend = psz;
   }

   // netto length until end point
   int nnamlen = pend - pname;

   for (int i=0; officeExtList[i]; i++)
   {
      cchar *ppatstr = officeExtList[i];
      int  npatlen  = strlen(ppatstr);
      if (nnamlen < npatlen)
         continue;
      if (!mystrnicmp(pname + nnamlen - npatlen, ppatstr, npatlen)) {
         return 1;
      }
   }

   return 0;
}

// in case of file masks, "!.zip" shall NOT
// implicitely activate archive processing.
bool maskEndsWithArcExt(char *pname, int iTraceFrom)
{
   if (isNotChar(*pname))
      return 0;
 
   return endsWithArcExt(pname, iTraceFrom);
}

bool isArcFile(char *pname)
{
   if (endsWithArcExt(pname, 1))
      return 1;

   #ifdef SFKDEEPZIP
   if (cs.probefiles)
   {
      Coi ocoi(pname, 0);
      ocoi.probeFile();
      if (ocoi.isKnownArc())
         return 1;
   }
   #endif // SFKDEEPZIP

   return 0;
}

bool Coi::isDirOpen( ) {
   return data().bdiropen;
}

bool Coi::hasSize  ( ) {
   return (nClHave & COI_HAVE_SIZE) ? 1 : 0; // fix 1770
}

bool Coi::hasTime  ( ) {
   return (nClHave & COI_HAVE_TIME) ? 1 : 0; // fix 1770
}

void Coi::setSize  (num nSize) {
   nClSize  = nSize;
   nClHave |= COI_HAVE_SIZE;
}

void Coi::setTime(num nMTime, num nCTime)
{
   nClMTime = nMTime;
   nClCTime = nCTime;
   nClHave |= COI_HAVE_TIME;
   // mtklog(("coi.mtime: %u from setTime (%p, %s)",(uint)nClMTime,this,name()));
}

int Coi::remove( )
{
   #ifdef _WIN32
   if (vname()) {
      sfkname oname(name());
      return _wremove((const wchar_t *)oname.wname());
   }
   #endif

   return ::remove(name());
}

int Coi::closeAndRemove( )
{
   if (isFileOpen())
      close();
   return remove();
}

int Coi::setFileTime(num nMTime)
{
   #ifdef _WIN32

   #ifdef WINFULL
   if (vname())
   do
   {
      int irc = 0;

      sfkname oname(name());

      HANDLE hDst = CreateFileW(
         (const wchar_t *)oname.wname(),
         FILE_WRITE_ATTRIBUTES,
         0,    // share
         0,    // security
         OPEN_EXISTING,
         bClDir ? FILE_FLAG_BACKUP_SEMANTICS : FILE_ATTRIBUTE_NORMAL,
         0     // template file
         );
      if (hDst == INVALID_HANDLE_VALUE)
         return 9;

      FILETIME nDstMTime;
      FILETIME *pMTime=0;

      if (makeWinFileTime(nMTime, nDstMTime)) // coi.setFileTime
         irc = 10;
      else
      {
         pMTime = &nDstMTime;
         if (!SetFileTime(hDst, 0, 0, pMTime))
            irc = 11;
      }

      CloseHandle(hDst);

      return irc;
   }
   while (0);
   #endif

   #endif

   return mySetFileTime(name(), nMTime);
}

void Coi::setIsDir (bool bYesNo) {
   bClDir   = bYesNo;
   nClHave |= COI_HAVE_DIR;
}

num Coi::getSize( )
{
   if (nClHave & COI_HAVE_SIZE) return nClSize;
   if (!status()) readStat('s');
   return (status() >= 9) ? -1 : nClSize;
}

num Coi::getTime( )
{
   if (nClHave & COI_HAVE_TIME) {
      if (cs.usectime) return nClCTime;
      return nClMTime;
   }

   if (!status()) readStat('t');
   if (status() >= 9) return -1;

   if (cs.usectime) return nClCTime;
   return nClMTime;
}

uint Coi::getAttr( )
{
   if (nClHave & COI_HAVE_ATTR) return nClAttr;
   if (!status()) readStat('a');
   return (status() >= 9) ? 0 : nClAttr;
}

// RC >= 9: cannot set attributes
int Coi::writeAttr(uint nuxattr, bool bFullPreserve)
{
   int iSubRC = writeAttrRaw(name(), nuxattr, bFullPreserve, 0);

   if (!iSubRC)
      nClAttr = nuxattr;

   return iSubRC;
}

uint lastErrno()
{
   #ifdef _WIN32
   return GetLastError();
   #else
   return errno;
   #endif
}

int Coi::writeAttrRaw(char *pszFile, uint nuxattr, bool bFullPreserve, bool bVerbose)
{
   // valid attr are marked by this bit
   if (!(nuxattr & (1U << 31)))
      return 9; // invalid input

   #ifdef _WIN32

   uint nwinattr = GetFileAttributes(pszFile);
 
   if (nwinattr == INVALID_FILE_ATTRIBUTES)
      return 10;

   uint noldattr = nwinattr;
 
   // under windows, 'r' and 'x' flags are ignored.
   // only if all 'w' flags are cleared it is set readonly.

   if (   (nuxattr & (1U << 1)) // write.everyone
       || (nuxattr & (1U << 4)) // write.group
       || (nuxattr & (1U << 7)) // write.owner
      )
   {
      // disable readonly if set
      nwinattr &= (0xFFFFFFFFUL ^ FILE_ATTRIBUTE_READONLY);
   }
   else
   {
      // set readonly
      nwinattr |= FILE_ATTRIBUTE_READONLY;
   }

   if (noldattr != nwinattr) {
      if (!SetFileAttributes(pszFile, nwinattr)) {
         if (bVerbose)
            pwarn("cannot set file attributes (%d): %s\n", lastErrno(), pszFile);
         return 11;
      }
   }

   return 0;

   #else

   struct stat64 ostat;
   if (stat64(pszFile, &ostat))
      return 10;

   static bool bGotUMask = 0;
   static uint nSysUMask = 0;
   if (!bGotUMask)
   {
      bGotUMask = 1;
      // to read umask, it must be changed temporarily
      nSysUMask = umask(0);
      // change back immediately, as we now have the value
      umask(nSysUMask);
   }

   if (!bFullPreserve)
   {
      // apply umask to input attributes.
      // bits set in umask must be deleted in attributes.
      uint uiReverse = (0xFFFFFFFFUL ^ nSysUMask);
      nuxattr &= uiReverse;
   }

   uint nmode = ostat.st_mode;
   uint noldmode = nmode;

   // allow only changing of the lower 12 bits.
   // also filters out sfk specific bits.
   nmode &= 0xFFFFF000UL;
   nmode |= (nuxattr & 0xFFFUL);

   if (noldmode != nmode)
      if (chmod(pszFile, nmode))
         return 11;

   return 0;

   #endif
}

// RC >= 9: cannot make this writeable
int Coi::forceWriteable(char *pszFile)
{
   #ifdef _WIN32

   uint nwinattr = GetFileAttributes(pszFile);
 
   if (nwinattr == INVALID_FILE_ATTRIBUTES)
      return 1; // nothing to do, does not exist

   if (!(nwinattr & FILE_ATTRIBUTE_READONLY))
      return 2; // nothing to do, is writeable

   nwinattr &= (0xFFFFFFFFUL ^ FILE_ATTRIBUTE_READONLY);

   if (!SetFileAttributes(pszFile, nwinattr))
      return 9; // cannot change

   #else

   struct stat64 ostat;
   if (stat64(pszFile, &ostat))
      return 1; // nothing to do, does not exist

   uint nmode = ostat.st_mode;
 
   if (nmode & (1UL << 7))
      return 2; // nothing to do, is writeable

   nmode |= (1UL << 7);

   if (chmod(pszFile, nmode))
      return 9; // cannot change

   #endif

   return 0; // OK changed
}

int Coi::setExtStr(char *psz) {
   delstring(pszClExtStr);
   if (psz)
      if (!(pszClExtStr = strdup(psz)))
         return 9;
   return 0;
}

char *Coi::getExtStr( ) {
   return pszClExtStr;
}

#ifdef _WIN32
   #ifdef _MSC_VER
      #ifdef SFK_W64
      typedef struct __stat64 sfkstat_t;
      #else
      typedef struct stat sfkstat_t;
      #endif
   #else
      typedef struct stat sfkstat_t;
   #endif
#else
   typedef struct stat64 sfkstat_t;
#endif

int Coi::readStat(char cFromInfo)
{__
   // NOTE: readStat cannot fetch "hidden" and "link" file info.
   //       such info seems to be available only via findFirstFile().

   // if filesystem meta infos already read,
   // or any error already occured, do nothing:
   if (nClStatus > 0)
      return nClStatus;

   #ifdef SFKPACK
   if (isOfficeSubEntry())
   {
      // defensive information gathering:
      // if ANY infos exist, assume that the vfile meta info
      // have already been fetched in a different way,
      // so avoid expensive retrieval operations.
      if (nClHave) {
         nClStatus = 1;
         return 0;
      }

      #if defined(VFILEBASE)
      // no expensive head access.
      if (isHttp()) {
         #ifdef SFKINT
         pwarn("stat: wrong http call sequence (%c).\n", cFromInfo);
         #endif
         nClStatus = 9;
         return 9;
      }
      #endif

      // in any case, block nativeFS access on virtuals:
      nClStatus = 1; // "sorry, we know nothing."
      return 0;
   }
   #endif // SFKPACK

   #ifdef VFILEBASE
   // virtual files MUST be blocked from native FS access
   if (isNet() || isZipSubEntry())
   {
      // defensive information gathering:
      // if ANY infos exist, assume that the vfile meta info
      // have already been fetched in a different way,
      // so avoid expensive retrieval operations.
      if (nClHave) {
         nClStatus = 1;
         return 0;
      }

      // no expensive head access.
      if (isHttp()) {
         #ifdef SFKINT
         pwarn("stat: wrong http call sequence (%c).\n", cFromInfo);
         #endif
         nClStatus = 9;
         return 9;
      }

      // in any case, block nativeFS access on virtuals:
      nClStatus = 1; // "sorry, we know nothing."
      return 0;
   }
   #endif // VFILEBASE

   sfkstat_t ostat;

   int bIsDir    = 0;
   int bCanRead  = 1;
   int bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   num aExtTimes[2];
   memset(aExtTimes, 0, sizeof(aExtTimes));

   #ifdef SFK_W64
   if (vname())
   {
      sfkname oname(name());

      struct __stat64 buf;
      if (_wstat64((const wchar_t *)oname.wname(), &buf)) {
         nClStatus = 9;
         return 9;
      }
      bIsDir = (buf.st_mode & _S_IFDIR ) ? 1 : 0;
      bCanRead     = (buf.st_mode & _S_IREAD ) ? 1 : 0;
      bCanWrite    = (buf.st_mode & _S_IWRITE) ? 1 : 0;
      nFileTime    = buf.st_mtime;
      nFileSize    = buf.st_size;
      aExtTimes[0] = buf.st_ctime;
      aExtTimes[1] = buf.st_atime;
      mclear(ostat);
      ostat.st_mode= buf.st_mode;
   }
   else
   #endif
   if (getFileStat(name(), bIsDir, bCanRead, bCanWrite,
      nFileTime, nFileSize, aExtTimes,
      &ostat, sizeof(ostat)
      ))
   {
      mtklog(("coi.stat failed: %s have=%u from=%c", name(), nClHave, cFromInfo));
      nClStatus = 9;
      return 9;
   }

   nClStatus = 1; // read metadata successfully

   nClSize  =       nFileSize;   nClHave |= COI_HAVE_SIZE;
   nClMTime =       nFileTime;   nClHave |= COI_HAVE_TIME;
   nClCTime =    aExtTimes[0];
   bClRead  = (bool)bCanRead;    nClHave |= COI_HAVE_READ;
   bClWrite = (bool)bCanWrite;   nClHave |= COI_HAVE_WRITE;
   bClDir   = (bool)bIsDir;      nClHave |= COI_HAVE_DIR;

   nClAttr  = ostat.st_mode;     nClHave |= COI_HAVE_ATTR;

   // add sfk flags
   nClAttr |= (1U << 31);  // attribs are valid
   #ifndef _WIN32
   nClAttr |= (1U << 30);  // source is linux
   #endif
 
   // mtklog(("coi.mtime: %u from readStat",(uint)nClMTime));
   mtklog(("coi.stat r=%d w=%d dir=%d %s", bClRead, bClWrite, bClDir, name()));

   return 0;
}

bool Coi::isWriteable( )
{
   #ifdef SFKPACK
   if (isOffice(101)) return 0;
   #endif // SFKPACK
   
   #ifdef VFILEBASE
   // any virtual file?
   if (isNet()) return 0;
   if (isZipSubEntry() > 0) return 0;
   if (isTravelZip(101)) return 0;
   #endif // VFILEBASE

   mtklog(("coi::iswriteable.1 %d %d %s",bClWrite,nClStatus,name()));

   // only physical files are writeable, so far.
   if (!nClStatus) readStat('w');
   if (bClDir) return 0;

   mtklog(("coi::iswriteable.2 %d %d %s",bClWrite,nClStatus,name()));

   return bClWrite;
}

char *Coi::relName( )
{
   char *pszabs = name();

   // native file:
   char *prel = strrchr(pszabs, glblPathChar);
   if (prel) return prel+1;

   #ifdef _WIN32
   // c:thefile.txt
   prel = strrchr(pszabs, ':');
   if (prel) return prel+1;
   #endif

   return pszabs;
}

char *Coi::rootRelName( )
{
   char *relName(char *pszRoot, char *pszAbs);
   if (pszClRoot)
   {
      mtklog(("coi.rootrelname: %s %.10s %.10s", relName(pszClRoot, pszClName), pszClRoot, pszClName));
      if (debug()) printf("coi.rootrelname: %s\n", relName(pszClRoot, pszClName));
      char *prel = relName(pszClRoot, pszClName);
      // special case: theroot.zip\\thesub.txt
      // then now holding: "\thesub.txt"
      if (*prel == glblPathChar) prel++;
      return prel;
   }
   if (debug()) printf("coi.rrname.noroot: %s\n", pszClName);
   return pszClName;
}

bool useOfficeBaseNames( )
{
   #ifdef SFKOFFICE
   if (!cs.office)
      return 0;
   return 1; // office basenames always
   #endif // SFKOFFICE
   return 0;
}

#ifdef SFKPACK
// from    "thefoo.xlsx\\bar.txt"
// returns "bar.txt", or NULL if no zip subname
char *Coi::officeSubName( )
{
   char *pname = name();

   char *purl = strstr(pname, "://");
   if (purl)
         pname = purl + 3;

   char *pxsla = strstr(pname, glblDubPathStr);
   if (!pxsla) return 0; // no pattern hit

   // do NOT accept foo.xlsx\\bar.xlsx\\goo.xml for office.
   // this must be handled by xe zip reading.
   if (strstr(pxsla+2, glblDubPathStr)) return 0;

   long nnamlen = pxsla - pname;

   // accept only office extensions.
   // generic zip is reserved for xe.
   for (long i=0; officeExtList[i]; i++)
   {
      cchar *ppatstr = officeExtList[i];
      long  npatlen  = strlen(ppatstr);
      if (nnamlen < npatlen)
         continue;
      if (striBegins(pxsla - npatlen, ppatstr))
         return pxsla+1;
   }

   return 0;
}
#endif // SFKPACK

void stripOfficeName(char *pname)
{
   char *pxsla = mystrrstr(pname, glblDubPathStr);
   if (!pxsla) return;

   *pxsla = '\0';
}

#ifdef SFKPACK
void Coi::stripOfficeName()
{
   if (!pszClName) return;

   char *pxsla = mystrrstr(pszClName, glblDubPathStr);
   if (!pxsla) return;

   *pxsla = '\0';

   // force re-read of file stats
   nClStatus = 0;
   nClHave = 0;
}

int Coi::isOfficeSubEntry()
{
   #ifdef SFKOFFICE
   char *pzip = officeSubName();
   if (!pzip)    return 0;
   if (!pzip[0]) return 0; // from "thefile.zip//"

   long nlen = strlen(pzip);
   if (nlen > 0 && (pzip[nlen-1] == glblPathChar || pzip[nlen-1] == glblWrongPChar))
      return 2;   // thefile.zip//subdir/

   return 1;   // thefile.zip//subfile.dat
   #endif // SFKOFFICE

   return 0;
}

bool Coi::isOffice(int iTraceFrom, bool bIgnoreOfficeMode)
{
   #ifdef SFKOFFICE

   if (!bIgnoreOfficeMode && !cs.office) return 0;

   if (bClFSDir) return 0; // native file system dir
   if (isOfficeSubEntry()) return 0;
   #ifdef VFILEBASE
   if (isNet()) return 0;
   #endif // VFILEBASE

   #ifdef SFKPACK
   if (endsWithOfficeExt(name(), iTraceFrom))
      return 1;
   #endif // SFKPACK

   #endif // SFKOFFICE

   return 0;
}
#endif // SFKPACK

bool Coi::isAnyDir(int ilevel)
{
   if (bGlblSyntaxTest) {
      // if just simulating, check how the name looks
      if (!strcmp(name(), ".")) return 1;
      return strstr(name(), "dir") ? 1 : 0;
   }

   int n = 0;

   #ifdef SFKDEEPZIP
   if (cs.probefiles)
      probeFile(); // to read isKnownArc() status
   #endif // SFKDEEPZIP

   #ifdef SFKPACK
   if (isOffice(100)) {
      bClDir = 1;
      nClHave |= COI_HAVE_DIR;
      return bClDir;
   }
   #endif // SFKPACK

   #ifdef VFILEBASE
   if (isTravelZip(103)) {
      bClDir = 1;
      mtklog(("%d = isanydir(%s) by trvzip", bClDir, name()));
      nClHave |= COI_HAVE_DIR;
      return bClDir;
   }
   if ((n = isZipSubEntry()))
   {
      switch (n) {
         case 1: bClDir = 0; break; // file within zip
         case 2: bClDir = 1; break; // dir within zip (but not traversable)
      }
      mtklog(("%d = isanydir(%s) by zipsub (%d)", bClDir, name(), n));
      nClHave |= COI_HAVE_DIR;
      return bClDir;
   }
   #endif // VFILEBASE

   if (nClHave & COI_HAVE_DIR) {
      mtklog(("%d = isanydir(%s) as stored", bClDir, name()));
      return bClDir;
   }

   // dir status not yet determined
   bClDir = 0;

   #ifdef VFILEBASE
   if (isHttp()) {
      bClDir = rawIsHttpDir(ilevel);
      mtklog(("%d = isanydir(%s) by httpdir", bClDir, name()));
   }
   else
   if (isFtp()) {
      bClDir = rawIsFtpDir();
      mtklog(("%d = isanydir(%s) by ftpdir", bClDir, name()));
   }
   else
   #endif // VFILEBASE
   {
      bClDir = rawIsDir();
      mtklog(("%d = isanydir(%s) by fs", bClDir, name()));
   }

   // avoid redundant high-effort reads of dir info
   nClHave |= COI_HAVE_DIR;

   return bClDir;
}  // Coi::isAnyDir

bool Coi::isTravelDir(bool bTreatOfficeAsFile)
{
   if (bGlblSyntaxTest) {
      // if just simulating, check how the name looks
      if (!strcmp(name(), ".")) return 1;
      return strstr(name(), "dir") ? 1 : 0;
   }

   // make sure raw status is determined
   bool brawdir = isAnyDir();

   #ifdef SFKPACK
   if (isOffice(102)) {
      if (bTreatOfficeAsFile)
         brawdir = 0;
      else
         brawdir = 1; // per definitionem
      return brawdir;
   }
   #endif // SFKPACK

   #ifdef VFILEBASE
   if (isTravelZip(104))   brawdir = 1;   // per definitionem
   else
   if (isZipSubEntry())    brawdir = 0;   // travel done otherwise
   #endif // VFILEBASE

   mtklog(("%d = istravdir(%s)", brawdir, name()));

   return brawdir;
}

bool Coi::rawIsDir( ) {
   if (!nClStatus)
      readStat('d');
   return bClDir;
}

// used so far only for http redirects
int Coi::setName(char *psz, char *pszOptRoot)
{
   bClBadName = 0;

   #ifdef VFILEBASE
   if (pszClName && hasData() && !data().pClOrgName)
   {
      // do not delete first name,
      // but refunction it as the org name.
      data().pClOrgName = pszClName;
      pszClName = 0;
   }
   #endif // VFILEBASE

   if (pszClName)  { delete [] pszClName;  pszClName = 0; }
   if (pszClUName) { delete [] pszClUName; pszClUName = 0; }
   if (pwClName)   { delete [] pwClName;   pwClName = 0; }

   pszClName = strdup(psz);

   if (pszOptRoot) {
      if (pszClRoot) delete [] pszClRoot;
      pszClRoot = strdup(pszOptRoot);
   }

   return 0;
}

static ushort aEmptyWideName[2] = {0, 0};

char *Coi::name( ) 
{
   return pszClName ? pszClName : str(""); 
}

#ifdef VFILEBASE
char  *Coi::orgName( )
{
   if (hasData() && data().pClOrgName)
      return data().pClOrgName;
   return name();
}

bool Coi::wasRedirected( )
{
   if (hasData() && data().pClOrgName)
      return 1;
   return 0;
}
#endif // VFILEBASE

char  *Coi::root(bool braw) {
   if (braw) return pszClRoot;
   return pszClRoot ? pszClRoot : (char*)"";
}

char  *Coi::ref (bool braw) {
   if (braw) return pszClRef;
   return pszClRef ? pszClRef : (char*)"";
}

int  Coi::setRef(char *pszName) {
   delstring(pszClRef);
   if (pszName)
      if (!(pszClRef = strdup(pszName)))
         return 9;
   return 0;
}

CoiData &Coi::data( )
{
   if (!pdata)
      pdata = new CoiData();
   return *pdata;
}

bool Coi::hasData( )    { return pdata ? 1 : 0; }

#ifdef VFILEBASE
bool Coi::isCached( )   { return bClInCache; }
bool Coi::hasContent( ) { return (pdata && pdata->src.data) ? 1 : 0; }
#endif // VFILEBASE

bool Coi::isFileOpen( ) {
   // the open flag itself is managed via pdata
   if (!pdata) return 0;
   return data().bfileopen;
}

void Coi::setContent(uchar *pdata, num nsize, num ntime)
{__
   mtklog(("coi.setcontent size=%d time=%u (%p, %s)",(int)nsize,(uint)ntime,this,name()));

   num nOldSize = data().src.size;
   num nNewSize = nsize;

   if (data().src.data) {
      delete [] data().src.data;
      mclear(data().src);
   }

   if (pdata) {
 
      data().src.data = pdata;
      data().src.size = nsize;
      data().src.time = ntime;

      // fix: 173: missing meta data update after setContent
      setSize(nsize);
      setTime(ntime, ntime);
   }

   #ifdef VFILEBASE
   // cache checks itself if coi is really cached
   glblVCache.tellByteSizeChange(this, nOldSize, nNewSize);
   #endif // VFILEBASE
}

int Coi::releaseContent( )
{__
   setContent(0,0); // free existing

   if (data().rbuf.data) {
      mtklog(("coi releases rbuf: %s",name()));
      delete [] data().rbuf.data;
      mclear(data().rbuf);
   }

   return 0;
}

bool Coi::existsFile(bool bOrDir, int *pIsDir)
{
   char *pszName = name();

   #ifdef SFKPACK
   if (isOfficeSubEntry()) return 1; // assume it exists
   #endif // SFKPACK

   #ifdef VFILEBASE
   if (isNet())         return 1; // assume it exists
   if (isZipSubEntry()) return 1; // assume it exists
   // .zip file: fall through
   #endif // VFILEBASE

   #ifdef _WIN32

   DWORD nAttrib = 0;
   #ifdef SFK_W64
   if (vname())
   {
      sfkname oname(name());
      nAttrib = GetFileAttributesW((wchar_t *)oname.wname());
   }
   else
   #endif
      nAttrib = GetFileAttributes(pszName);
   if (nAttrib == 0xFFFFFFFF) // "INVALID_FILE_ATTRIBUTES"
      return 0;
   if (nAttrib & FILE_ATTRIBUTE_DIRECTORY) {
      if (!bOrDir)
         return 0; // is a dir, not a file
      if (pIsDir) *pIsDir=1;
   }

   #else

   // linux
   struct stat64 buf;
   if (stat64(pszName, &buf))
      return 0;
   if ((buf.st_mode & _S_IFDIR)) {
      if (!bOrDir)
         return 0; // is a dir, not a file
      if (pIsDir) *pIsDir=1;
   }

   #endif

   // we can get the attribs, and it's not a dir,
   // so expect that it is a file.
   return 1;
}

int Coi::getOpenElapsedTime( )
{
   if (!pdata)
      return 0;
 
   if (!data().nopentime)
      return 0;
 
   return (int)(getCurrentTime() - data().nopentime);
}

int Coi::open(cchar *pmode)
{__
   mtklog(("coi-open %p %s %s",this,name(),pmode));

   // reset per-file statistics
   resetIOStatus();

   #ifdef SFKPACK
   if (isOfficeSubEntry())
      if (loadOfficeSubFile("opn"))
         return 9;
   #endif // SFKPACK

   #ifdef VFILEBASE
   // in case of vfiles, make sure required inputs
   // are loaded, e.g. http://foo.zip//bar.zip//file.txt
   // RECURSION BLOCK: for now, we call provideInput
   // ONLY for zip sub entries. netFiles are expected
   // to be cached otherwise, but not through pinput.
   if (isZipSubEntry())
      if (provideInput("opn"))
         return 9;
   #endif // VFILEBASE

   // (re)init in case that readLine is used:
   if (data().rbuf.data) delete data().rbuf.data;
   memset(&data().rbuf, 0, sizeof(data().rbuf));

   // supported modes: "rb","r+b","wb"
   data().bwrite     = 0;
   data().szmode[0]  = '\0';
   data().ntotalread = 0;
   #ifdef VFILEBASE
   data().bstopread  = 0;
   #endif // VFILEBASE
   data().banyread   = 0;
   data().nopentime  = getCurrentTime();

   if (!strcmp(pmode, "rb"))
      { } // pure read is always ok
   else
   if (!strcmp(pmode, "r")) {
      // read of text: open as binary
      pmode = "rb";
      // but stop as soon as binary is detected.
      data().bstoprdbin = 1;
   }
   else
   if (   !strcmp(pmode, "r+b") || !strcmp(pmode, "wb")
       || !strcmp(pmode, "w") || !strcmp(pmode, "a") // +tofile
      )
   {
      #ifdef VFILEBASE
      if (isVirtual(1)) // WITH root zips
         return 9+perr("write not supported: %s", name());
      #endif // VFILEBASE
      // TODO: not sure if this protects utf16 files in every case,
      //       so far it requires an isBinary() check before.
      if (nClUCS)
         return 9+perr("write to utf-16 file not supported: %s", name());
      // read+write ok
      data().bwrite = 1;
   }
   else
      return 9+perr("unsupported mode \"%s\": %s", pmode, name());

   // remember I/O mode
   strcopy(data().szmode, pmode);

   // take cached data?
   if (data().src.data)
   {
      if (data().bwrite) {
         // re-write of a file: reset cache
         mtklog(("coi-open for write: reset cache"));
         setContent(0,0);
      } else {
         // read: simply reset read index
         mtklog(("coi-open uses CACHED DATA: bytes=%d time=%u (%p)",(int)data().src.size, (uint)nClMTime, this));
         data().src.index = 0;
         return 0;
      }
   }

   #ifdef VFILEBASE
   // this can be reached in READ mode only
   // http://thehost/thefile.txt
   if (isHttp()) return rawOpenHttpSubFile(pmode);
   if (isFtp())  return rawOpenFtpSubFile(pmode);
   #endif // VFILEBASE

   // native file I/O: thefile.dat
   #ifdef WINFULL
   if (vname())
   {
      sfkname omode(pmode);
      sfkname oname(name());
      data().pfile = _wfopen((const wchar_t *)oname.wname(), (const wchar_t *)omode.wname());
      // if (cs.debug)
      //   printf("wfopen: %s / %s / %p\n", name(), dataAsHex((uchar*)oname.wname(),wcslen((wchar_t*)oname.wname())*2), data().pfile);
   }
   else
   #endif
   {
      data().pfile = fopen(name(), pmode);
   }
   if (data().pfile) {
      data().bfileopen = 1;
      return 0;
   }
   return 9;
}

int Coi::renameto(char *pszDst)
{
   #ifdef _WIN32
   if (vname())
   {
      sfkname osrc(name());
      sfkname odst(pszDst);
      return _wrename((const wchar_t *)osrc.wname(), (const wchar_t *)odst.wname());
   }
   else
   #endif
   {
      return rename(name(), pszDst);
   }
}

cchar *Coi::lasterr( ) {
   if (!hasData()) return "";
   return data().szlasterr;
}

#define MY_GETBUF_MAX ((MAX_LINE_LEN+10)*5)

void Coi::setBinaryFile(bool bYesNo) {
   bClBinary = bYesNo;
   nClHave  |= COI_HAVE_BINARY;
}

bool isTextChar(uchar uc) {
   if (uc >= 0x1C) return 1;
   switch (uc) {
   // case 0x04: return 1; // EOT
   // case 0x07: return 1; // BEL
      case 0x08: return 1; // BS
      case 0x09: return 1; // TAB
      case 0x0A: return 1; // LF
      case 0x0C: return 1; // FF
      case 0x0D: return 1; // CR
      case 0x1A: return 1; // EOF
      case 0x1B: return 1; // ESC
   }
   return 0;
}

uchar Coi::isUTF16( ) { return nClUCS; }

bool Coi::isSnapFile( ) { return bClSnap; }

int Coi::iBinaryCheckSize = 4096;

void Coi::probeFile( ) { isBinaryFile(); }

bool Coi::isBinaryFile( )
{__ _p("sf.isbin")

   // if binary status was alread set, return it:
   if (nClHave & COI_HAVE_BINARY)
      return bClBinary;

   #ifdef VFILEBASE
   if (isHttp()) {
      // missing preloadFromWeb
      #ifdef SFKINT
      pwarn("isbinary: wrong http call sequence.\n");
      #endif
      return 1; // safety
   }
   #endif // VFILEBASE

   #ifdef SFKPACK
   if (isOffice(109)) {
      // so far we use only plaintext from office
      bClBinary = 0;
      nClHave  |= COI_HAVE_BINARY;
      return 0;
   }
   #endif // SFKPACK

   if (open("rb"))
      return 0;

   mtklog(("coi isbinary %p", this));
 
   // assure read buffer on demand
   if (!data().rbuf.data) {
      memset(&data().rbuf, 0, sizeof(data().rbuf));
      data().rbuf.data = new uchar[MY_GETBUF_MAX+100];
   }

   bool brc = 0;
 
   do
   {
      int nCheckLen = MY_GETBUF_MAX - 10;
 
      if (nCheckLen > iBinaryCheckSize)
         nCheckLen = iBinaryCheckSize;
 
      int nRead = readRaw(data().rbuf.data, nCheckLen);
 
      // no checks on empty files
      if (nRead <= 0)
         break;
 
      // always assure zero-term'ed memory
      if (nRead <= nCheckLen)
         data().rbuf.data[nRead] = '\0'; // safety
 
      // if (cs.wchardec)
      {
         // ucs-2 heuristic detection
         uint blehead=0,bbehead=0;
         uchar *pdat = data().rbuf.data;
 
         if (nRead>=2 && pdat[0]==0xFF && pdat[1]==0xFE) blehead=1;
         if (nRead>=2 && pdat[0]==0xFE && pdat[1]==0xFF) bbehead=1;
         if (blehead || bbehead) {
            // scan first part of text for double-byte chars.
            // accept only very low code points.
            int nWChars = (nRead - 2) / 2;
            if (nWChars > 10) nWChars = 10;
            int iwc=0;
            for (iwc=0; iwc<nWChars; iwc++) {
               uchar nlo = pdat[2+iwc*2+bbehead];
               uchar nhi = pdat[2+iwc*2+blehead];
               if (!isTextChar(nlo) || isTextChar(nhi))
                  break;
            }
            if (iwc >= nWChars) {
               // count detected ucs-2 files
               gs.utf16found++;
               mtklog(("utf16%s%s, dec=%d: %s\n",blehead?"le":"",bbehead?"be":"",(int)cs.wchardec,name()));
               // but are we allowed to decode?
               if (cs.wchardec) {
                  if (blehead) nClUCS = (uchar)0xFE;
                  if (bbehead) nClUCS = (uchar)0xEF;
                  if (cs.verbose)
                     printf("utf16%s%s: %s\n",blehead?"le":"",bbehead?"be":"",name());
               }
            }
         }
      }
 
 
      if (!brc && !nClUCS) {
         // binary data heuristic detection
         // for (int i=0; i<nRead; i++)
         //    if (data().rbuf.data[i] == 0x00)
         //       { brc=1; break; }
         if (memchr(data().rbuf.data, 0, nRead))
            brc=1;
      }
 
      // sfk snapfile detection
      {
         const char *ppat = ":snapfile sfk,";
         int npatlen = strlen(ppat);
         if ((nRead > npatlen) && strBegins((char*)data().rbuf.data, (char*)ppat))
            bClSnap = 1;

         ppat = ":cluster sfk,";
         npatlen = strlen(ppat);
         if ((nRead > npatlen) && strBegins((char*)data().rbuf.data, (char*)ppat))
            bClSnap = 1;
      }

      #ifdef SFKDEEPZIP
      {
         uchar *p = data().rbuf.data;
         if (nRead >= 24 && p[0]==0x50 && p[1]==0x4B
                         && p[2]==0x03 && p[3]==0x04)
         {
            setArc(1);
         }
      }
      #endif // SFKDEEPZIP
   }
   while (0);
 
   // currently, this frees the rbuf.data!
   close();

   bClBinary = brc;
   nClHave  |= COI_HAVE_BINARY;

   mtklog(("%d = coi::isbinary %s",brc,name()));

   return brc;
}

// TODO: rework rc handling in case of error
int Coi::readLine(char *pszOutBuf, int nOutBufLen)
{_p("sf.readln")

   if (!data().rbuf.data) {
      memset(&data().rbuf, 0, sizeof(data().rbuf));
      data().rbuf.data = new uchar[MY_GETBUF_MAX+100];
   }

   if (data().rbuf.getsize  < 0 || data().rbuf.getsize  > MY_GETBUF_MAX) return 0+perr("int. #62 %d %d\n",(data().rbuf.getsize < 0),(data().rbuf.getsize > MY_GETBUF_MAX));
   if (data().rbuf.getindex < 0 || data().rbuf.getindex > MY_GETBUF_MAX) return 0+perr("int. #63 %d %d\n",(data().rbuf.getindex < 0),(data().rbuf.getindex > MY_GETBUF_MAX));
   if (data().rbuf.geteod > 1) return 0+perr("int. #65\n");

   // if remaining data is less than halve of buffer, read next block
   if (!data().rbuf.geteod && ( data().rbuf.getsize < (MY_GETBUF_MAX/2)-100 ))
   {_p("sf.readl1")
 
      // move remaining cache data to front of buffer
      int nindex  = data().rbuf.getindex;
      int nremain = data().rbuf.getsize;
      if (nindex + nremain < 0) return 0+perr("int. #60\n");
      if (nindex + nremain > MY_GETBUF_MAX) return 0+perr("int. #61\n");
      if (nremain > (MY_GETBUF_MAX/2)) return 0+perr("int. #62\n");
      if (nremain > 0)
      {
         // FIX: 1722: read from zip with sfk x64 produced wrong data
         //      due to memcpy on overlapping buffer
         memmove(data().rbuf.data, &data().rbuf.data[nindex], nremain);
      }

      // now remaining data starts from front of buffer,
      // filling less than the first halve of the buffer.
      data().rbuf.getindex = 0;

      // re-fill remaining buffer space
      int nBufFree = MY_GETBUF_MAX - data().rbuf.getsize;
      uchar *pRead  = data().rbuf.data + data().rbuf.getsize;

      int nRead = 0;
      if ((nRead = read(pRead, nBufFree)) <= 0)
         data().rbuf.geteod = 1;
      else
         data().rbuf.getsize += nRead;
   }

   // anything remaining?
   if (data().rbuf.getsize == 0) {
      data().rbuf.geteod = 2;
      return 0;
   }

   // copy next line from copy index
   uchar *psrc     = data().rbuf.data + data().rbuf.getindex;
   uchar *psrcmax  = psrc + data().rbuf.getsize;
   if (psrcmax > data().rbuf.data + MY_GETBUF_MAX) return 0+perr("int. #63");

   uchar *pdst     = (uchar*)pszOutBuf;
   uchar *pdstmax  = pdst + nOutBufLen - 10;

   bool bBinary    = 0;
   int  nSrcBytes  = 0;
   int  nDstBytes  = 0;

   {_p("sf.readl2")
 
      for (; psrc < psrcmax && pdst < pdstmax;)
      {
         uchar c1 = *psrc++;
         nSrcBytes++;
 
         if (c1 == 0x00 || c1 == 0x1A) {
            if (!c1)
               bBinary = 1;
            c1 = (uchar)'.';
         }
         else
         if (c1 == (uchar)'\r')
            continue;
 
         *pdst++ = (char)c1;
         nDstBytes++;
 
         if (c1 == (uchar)'\n')
            break;
      }
      *pdst = '\0';
 
   }
 
   data().rbuf.getindex += nSrcBytes; // copy next line from there
   data().rbuf.getsize  -= nSrcBytes; // reduce remaining bytes in buf
   data().rbuf.getpos   += nSrcBytes; // absolute source position in file

   if (bBinary && data().bstoprdbin)
      return 0; // "EOD", force end of reading

   return nDstBytes;
}

int Coi::writeLine(char *psz)
{
   int iLen   = strlen(psz);
   int iChars = (int)write((uchar*)psz, strlen(psz));
   if (iChars != iLen)
      return iChars;

   uchar abLF[10];
   abLF[0] = '\n';
   abLF[1] = '\0';

   // depending on mode used with open
   // this writes LF or CRLF
   int iEOL = (int)write(abLF, 1);
   if (iEOL < 1)
      return 0;

   return iChars+iEOL;
}

size_t Coi::read(void *pbufin, size_t nBufSize)
{__ _p("sf.read")

   if (nClUCS && (nBufSize & 0x1UL)) {
      // force even buffer size on ucs-2
      nBufSize ^= (size_t)0x1UL;
      if (!nBufSize)
         return 0+perr("cannot read ucs-2, buffer too small: %s", name());
   }

   bool bfirst = data().banyread ? 0 : 1;

   size_t nraw = readRaw(pbufin, nBufSize);
   size_t nres = nraw; // resulting size

   data().banyread = 1;

   if (nClUCS)
   {
      // transparent ucs-2 decoding.
      // this will return less bytes than nBufSize!
      if (nBufSize & 1) // shouldn't happen due to above alignment
         return 0+perr("cannot read ucs-2, uneven buffer size: %s", name());

      uchar *psrc    = (uchar*)pbufin;
      uchar *psrcmax = (uchar*)pbufin + nraw;
      uchar *pdst    = (uchar*)pbufin;
      uchar *pdstbeg = pdst;
      uchar *pdstmax = (uchar*)pbufin + nBufSize;

      // skip byte order mark?
      if (nClUCS == 0xFE && psrc[0] == 0xFF && psrc[1] == 0xFE)
         psrc += 2;
      else
      if (nClUCS == 0xEF && psrc[0] == 0xFE && psrc[1] == 0xFF)
         psrc += 2;

      // copy loop with zero truncation
      uint nreloff = (nClUCS == 0xFE) ? 0 : 1;
      while (psrc < psrcmax && pdst < pdstmax) {
         *pdst++ = psrc[nreloff];
         psrc += 2;
      }

      // calc new netto size
      nres = pdst - pdstbeg;

      mtklog(("filtered %d ucs-2 chars", (int)nres));

      if (bfirst) gs.utf16read++;
   }

   return nres;
}

size_t Coi::readRaw(void *pbufin, size_t nBufSize)
{__
   // take cached data?
   if (data().src.data)
   {
      int nremain = data().src.size - data().src.index;
      int ntocopy = (int)nBufSize;
      if (ntocopy > nremain) ntocopy = nremain;
      if (ntocopy > 0) {
         memcpy(pbufin, data().src.data + data().src.index, ntocopy);
         data().src.index += ntocopy;
      }
      mtklog(("coi-read copied %d bytes from cache idx %d", ntocopy, (int)data().src.index));
      data().ntotalread += ntocopy;
      return ntocopy;
   }

   #ifdef VFILEBASE
   if (isHttp())  {
      size_t nread = rawReadHttpSubFile(pbufin, nBufSize);
      data().ntotalread += nread;
      return nread;
   }

   if (isFtp())   {
      size_t nread = rawReadFtpSubFile(pbufin, nBufSize);
      data().ntotalread += nread;
      return nread;
   }
   #endif // VFILEBASE

   // native file I/O:
   if (!data().pfile) {
      perr("read on non-open file: %s",name());
      return 0;
   }

   uchar *pBuf = (uchar *)pbufin;

   size_t nOffset = 0;
   size_t nRemain = nBufSize;
   while (nRemain > 0)
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nReadSub = fread(pBuf+nOffset, 1, nBlock, data().pfile); // unsafe.stdin
      if (nReadSub <= 0)
         break;

      nOffset += nReadSub;
      nRemain -= nReadSub;

      // if (nMax > 0)
      //    info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   // if (nOffset > 0 && pmd5 != 0)
   //    pmd5->update(pBuf, nOffset);

   data().ntotalread += nOffset;

   return nOffset;
}

// rc0:ok >=0:failed to seek
int Coi::seek(num nOffset, int nOrigin)
{__
   if (nOrigin != SEEK_SET)
      return 9+perr("internal: seek: supports only SEEK_SET");

   #ifdef VFILEBASE
   if (!data().src.data && isVirtual()) // w/o root zips
   {
      // force caching of virtual files, except root zips
      if (preload("see", 0, 0)) // seek
         return 9+perr("seek failed: %s", name());
   }
   #endif // VFILEBASE

   // take cached data?
   if (data().src.data)
   {
      mtklog(("coi::seek to %d in cache", (int)nOffset));
      if (nOffset < 0 || nOffset > data().src.size)
         return 9+perr("cannot seek to position %s", numtoa(nOffset));
      data().src.index = nOffset;
      return 0;
   }

   #ifdef VFILEBASE
   // virtual file I/O: shouldn't be reached
   if (isHttp())  return 9+perr("cannot seek on http file");
   if (isFtp())   return 9+perr("cannot seek on ftp file");
   if (isZipSubEntry()) return 9+perr("cannot seek on zip entry");
   #endif // VFILEBASE

   // native file I/O:
   if (!data().pfile) {
      perr("seek on non-open file: %s",name());
      return 0;
   }

   FILE *f = data().pfile;

   #ifdef _WIN32
   if (sizeof(num) != sizeof(fpos_t)) return 9+perr("internal: myfseek: wrong fpos_t size, need 64 bits");
   return fsetpos(f, &nOffset);
   #else
   fpos64_t xpos;
   if (fgetpos64(f, &xpos)) // read xpos.__state
      return 9+perr("internal: seek: failed to read position");
    #if defined(MAC_OS_X) || defined(SOLARIS)
     xpos = (fpos_t)nOffset;
    #else
     if (sizeof(xpos.__pos) != sizeof(nOffset)) return 9+perr("internal: myfseek: wrong __pos size, need 64 bits");
     xpos.__pos = nOffset;
    #endif
   return fsetpos64(f, &xpos);
   #endif
}

size_t Coi::write(uchar *pBuf, size_t nBytes)
{__
   if (data().src.data)
      return 9+perr("write: conflict with cached data");

   #ifdef SFKPACK
   if (isOfficeSubEntry()) return 9+perr("cannot write on office entry");
   #endif // SFKPACK

   #ifdef VFILEBASE
   // virtual file I/O:
   if (isHttp())  return 9+perr("cannot write on http file");
   if (isFtp())   return 9+perr("cannot write on ftp file");
   if (isZipSubEntry()) return 9+perr("cannot write on zip entry");
   #endif // VFILEBASE

   // native file I/O:
   if (!data().pfile) {
      perr("write on non-open file: %s",name());
      return 0;
   }

   size_t nOffset = 0;
   size_t nRemain = nBytes;

   while (nRemain > 0)
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nWriteSub = fwrite(pBuf+nOffset, 1, nBlock, data().pfile);
      if (nWriteSub != nBlock)
         return nOffset+nWriteSub; // return no. of bytes actually written

      nOffset += nWriteSub;
      nRemain -= nWriteSub;

      // if (nMax > 0)
      //    info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   // if (nOffset > 0 && pmd5 != 0)
   //    pmd5->update(pBuf, nOffset);

   return nOffset;
}

void Coi::close( )
{__
   mtklog(("coi-close %p %s", this, name()));

   // reset per-file statistics
   resetIOStatus();

   // assuming: close methods below do NOT use rbuf
   if (data().rbuf.data) {
      mtklog(("coi-close deletes rbuf %p size %d", data().rbuf.data, data().rbuf.getsize));
      delete [] data().rbuf.data;
   }
   memset(&data().rbuf, 0, sizeof(data().rbuf));
 
   if (data().src.data) {
      mtklog(("coi-close finished read from cache"));
      data().src.index = 0; // safety
      // return; // chg 1770
   }
 
   #ifdef VFILEBASE
   // http://thehost/thefile.txt
   if (isHttp())  { rawCloseHttpSubFile(); return; }
   if (isFtp())   { rawCloseFtpSubFile(); return; }
   #endif // VFILEBASE
 
 
   // in any case, reset the flag:
   data().bfileopen = 0;

   // native file I/O:
   if (!data().pfile) {
      mtklog(("close.file already done: %s",name()));
      return;
   }

   fclose(data().pfile);
   data().pfile = 0;
 
   // keeptime is applied only after data was written.
   // this may also happen later after a second open/close
   // on the same Coi to overwrite the input file.
   if (bClSetWriteCloseTime)
   {
      if (data().bwrite) {
         if (cs.debug)
            printf("applying -keeptime after write close: %s\n", name());
         int iSubRC = applyWriteCloseTime();
         if (iSubRC)
            pwarn("cannot set file time (rc=%d) for: %s\n",iSubRC,name());
      } else {
         if (cs.debug)
            printf("skipping -keeptime after non write close: %s\n", name());
      }
   }
}

int Coi::setKeepTime(Coi *pSrc)
{__
   // pSrc can also be == this

   // make sure filestat is read on src
   if (pSrc->getTime() <= 0)
      return 5; // does not apply

   // then copy whatever is set
   nClMTime = pSrc->nClMTime;
   nClCTime = pSrc->nClCTime;

   // mtklog(("coi.mtime: %u from setKeepTime",(uint)nClMTime));
 
   // and remember to apply this on write close
   bClSetWriteCloseTime = 1;

   return 0;
}

int Coi::applyWriteCloseTime( )
{__
   bClSetWriteCloseTime = 0;

   if (!data().bwrite)
      return 5; // ignored, file was not written

   #ifdef _WIN32

   HANDLE hDst = CreateFile(
      name(),
      FILE_WRITE_ATTRIBUTES,
      0,    // share
      0,    // security
      OPEN_EXISTING,
      bClDir ? FILE_FLAG_BACKUP_SEMANTICS : FILE_ATTRIBUTE_NORMAL,
      0     // template file
      );
   if (hDst == INVALID_HANDLE_VALUE)
      return 10;

   int nrc = 0;

   FILETIME nDstMTime, nDstCTime;
   FILETIME *pMTime=0, *pCTime=0;

   if (nClMTime > 0)
   {
      if (!makeWinFileTime(nClMTime, nDstMTime)) // coi.applyWriteCloseTime
         pMTime = &nDstMTime;
      else
         nrc = 11;
   }

   if (nClCTime > 0)
   {
      if (!makeWinFileTime(nClCTime, nDstCTime)) // coi.applyWriteCloseTime
         pCTime = &nDstCTime;
      else
         nrc = 12;
   }

   #ifdef WINFULL
   if (!nrc && (pMTime || pCTime)) {
      if (!SetFileTime(hDst, pCTime, 0, pMTime)) {
         perr("cannot set file time (rc=%u): %s\n", (uint)GetLastError(), name());
         nrc = 13;
      }
   }
   #endif
 
   CloseHandle(hDst);

   return nrc;

   #else

   // linux generic: set only mtime

   if (nClMTime <= 0)
      return 1; // nothing to set

   struct utimbuf otimes;
   mclear(otimes);

   otimes.modtime = nClMTime;

   int iRC = utime(name(), &otimes);
   if (iRC) return 9+perr("failed to set file times (rc=%d): %s\n",iRC,name());

   return 0;

   #endif
}

int Coi::openDir(int ilevel)
{__
   mtklog(("coi::opendir %p", this));

   #ifdef SFKPACK
   if (isOffice(105)) {
      int nrc = rawLoadDir(ilevel);
      if (nrc >= 5) return nrc; // failed
      data().bdiropen = 1;
      return 0;
   }
   #endif // SFKPACK

   #ifdef VFILEBASE
   if (isTravelZip(105) || isNet()) {
      int nrc = rawLoadDir(ilevel);
      if (nrc >= 5) return nrc; // failed
      data().bdiropen = 1;
      return 0;
   }
   #endif // VFILEBASE

   if (rawIsDir())
      return rawOpenDir();

   perr("no filesystem directory, cannot open: %s", name());
   return 9;
}

// caller MUST RELEASE COI after use!
Coi *Coi::nextEntry( )
{__
   mtklog(("coi::nextentry %p", this));

   // additional filter loop: block any kind of endless
   // link looping, i.e. dir links within a dir to itself.
   while (1)
   {
      Coi *psub = nextEntryRaw();
      if (!psub) return 0;
      if (psub == this) {
         mtklog(("coi.nextentry: skip sub == top for %p", psub));
         // psub is OWNED BY US, so release it first.
         if (!psub->decref())
            perr("int. #1310281137"); // should NOT happen
         // do NOT delete! it was a double ref onto THIS.
         continue;
      }
      if (!strcmp(psub->name(), name())) {
         mtklog(("coi.nextentry: skip equal sub %p, top %p for name %s", psub, this, psub->name()));
         // psub is OWNED BY US, so release it first.
         if (!psub->decref())
            delete psub; // no refs remaining, not cached
         continue;
      }
      // is different, return entry.
      return psub;
   }
   return 0; // not reached
}

// caller MUST RELEASE COI after use!
Coi *Coi::nextEntryRaw( )
{__
   #ifdef VFILEBASE
   if (isFtp())   return rawNextFtpEntry();
   #endif // VFILEBASE

   #ifdef SFKPACK
   if (isOffice(106)) return rawNextOfficeEntry();
   #endif // SFKPACK

   if (rawIsDir()) return rawNextEntry();

   perr("no directory, cannot read: %s", name());
   return 0;
}

void Coi::closeDir( )
{__
   mtklog(("coi::closedir %p", this));

   #ifdef VFILEBASE
   if (isFtp())   return rawCloseFtpDir();
   #endif // VFILEBASE

   #ifdef SFKPACK
   if (isOffice(107)) return rawCloseOfficeDir();
   #endif // SFKPACK

   if (rawIsDir())
      return rawCloseDir();

   perr("no directory, cannot close: %s", name());
}

int Coi::rawOpenDir( )
{
   // prepare traversal pattern, or simply
   // the directory name stripped from possible slash

   int nsize1 = strlen(name());
   if (data().pdirpat) delete [] data().pdirpat;
   data().pdirpat = new char[nsize1+12];
   #ifdef _WIN32
   joinPath(data().pdirpat, nsize1+8, name(), (char*)"*");
   #else
   joinPath(data().pdirpat, nsize1+8, name(), (char*)"");
   #endif
 
   #ifdef _WIN32

   // delay real actions until first nextEntry()

   #else

   // linux:
   if (!(data().ptrav = opendir(data().pdirpat)))
      return 1; // no such dir

   #endif

   data().bdiropen = 1;

   return 0;
}

bool isAbsolutePath(char *psz1)
{
   if (isHttpURL(psz1)) return 1; // 1770
   #ifdef _WIN32
   if (strlen(psz1) >= 2) {
      // try for C:\thedir
      char c1 = tolower(*psz1);
      if (c1 >= 'a' && c1 <= 'z' && *(psz1+1) == ':') // && *(psz1+2) == '\\')
         return 1;
   }
   #endif
   // e.g. /tmp
   // e.g. \\machine\path
   if (psz1[0] == glblPathChar) return 1;
   if (psz1[0] == '/') return 1; // sfk185 always
   return 0;
}

char *getAbsPathStart(char *pszin) // sfk1934
{
   static char szroot[SFK_MAX_PATH+10];

   strcopy(szroot,pszin);

   char *p = szroot;

   if (stribeg(p,"http:") || stribeg(p,"https://") || stribeg(p,"ftp:"))
   {
      // http://thehost.com:port/path
      char *psz=strstr(szroot,"://");
      if (!psz) return szroot;
      psz+=3;
      while (*psz!=0 && *psz!='/') psz++;
      if (!*psz) return szroot;
      // return: http://thehost.com:port/
      psz++; *psz='\0'; return szroot;
   }

   #ifdef _WIN32
   if (strlen(p) >= 2) {
      char c1 = tolower(*p);
      if (c1 >= 'a' && c1 <= 'z' && p[1] == ':') {
         // handle C:foo C:\foo
         p += 2; while (isUniPathChar(*p)) p++;
         // return: C: or "C:\"
         *p='\0'; return szroot;
      }
   }
   #endif

   // \foo.txt  ->  \   foo.txt
   // \\foo.txt ->  \\  foo.txt
   // foo.txt   ->      foo.txt
   while (isUniPathChar(*p)) p++;
   *p='\0';
   return szroot;
}

int joinPath(char *pszDst, int nMaxDst, char *pszSrc1, char *pszSrc2, int *pFlexible)
{
   mystrcopy(pszDst, pszSrc1, nMaxDst-4); // colon, terminator, 2 buffer.

   if (pFlexible)
   {
      // join c:\tvraw\ and ..\subdir\outfile.mts to c:\subdir\outfile.mts
      // join c:\tvraw\ and \tvedit\outfile.mts   to c:\tvedit\outfile.mts
      char szup[10];
      sprintf(szup, "..%c", glblPathChar);

      int iskipped=0;

      bool babs=(pszSrc2[0]==glblPathChar)?1:0;

      if (babs)
      {
         *pszDst = '\0';
         pszSrc2++;
         iskipped=1;

         #ifdef _WIN32
         if (pszSrc1[0]!=0 && pszSrc1[1]==':') {
            pszDst[0] = pszSrc1[0];
            pszDst[1] = pszSrc1[1];
            pszDst[2] = '\0';
         }
         #endif

         strcat(pszDst, glblPathStr);
      }

      int idstlen=strlen(pszDst);
 
      if (!babs)
      while (idstlen>0 && !strncmp(pszSrc2, szup, 3))
      {
         // c:\tvraw\ -> c:\tvraw
         // c:\ -> c:
         if (pszDst[idstlen]==glblPathChar)
            idstlen--;
         // c:\tvraw -> "c:\"
         while (idstlen>0 && pszDst[idstlen-1]!=glblPathChar
                #ifdef _WIN32
                && pszDst[idstlen-1]!=':'
                #endif
               )
               idstlen--;
         pszDst[idstlen]='\0';
         // ..\subdir\outfile.mts -> subdir\outfile.mts
         pszSrc2 += 3;
         iskipped += 3;
      }

      *pFlexible = iskipped;
   }

   int nlen = strlen(pszDst);
   if (nlen > 0) {
      char clast = pszDst[nlen-1];
      #ifdef _WIN32
      if (clast != ':') // AND below
      #endif
      if (clast != glblPathChar) {
         strcat(pszDst, glblPathStr);
         nlen++;
      }
   }
   if (nlen < nMaxDst)
      mystrcopy(pszDst+nlen, pszSrc2, nMaxDst-nlen);
   // printf("JOIN \"%s\" \"%s\" => \"%s\"\n",pszSrc1,pszSrc2,pszDst);
   return 0;
}

int joinShadowPath(char *pszDst, int nMaxDst, char *pszSrc1, char *pszSrc2)
{
   mystrcopy(pszDst, pszSrc1, nMaxDst-4); // colon, terminator, 2 buffer.
   int nlen = strlen(pszDst);
   if (nlen > 0) {
      char clast = pszDst[nlen-1];
      #ifdef _WIN32
      if (clast != ':') // AND below
      #endif
      if (clast != glblPathChar) {
         strcat(pszDst, glblPathStr);
         nlen++;
      }
   }
   mystrcopy(pszDst+nlen, "zz-shadow-01", (nMaxDst-2)-nlen);
   strcat(pszDst, glblPathStr);
   nlen = strlen(pszDst);
   mystrcopy(pszDst+nlen, pszSrc2, nMaxDst-nlen);
   // printf("JOIN \"%s\" \"%s\" => \"%s\"\n",pszSrc1,pszSrc2,pszDst);
   return 0;
}

#ifdef SFK_W64
intptr_t myfindfirst64(char *pszMask, SFKFindData *pout, int *pBadConv)
{
   if (!vname())
      return _findfirst64(pszMask, pout);

   sfkname oname1(pszMask);
   ushort *amask = oname1.wname();

   sfkfinddata64_t odata;
   mclear(odata);

   intptr_t pres = _wfindfirst64((const wchar_t *)amask, &odata);

   memset(pout, 0, sizeof(SFKFindData));

   sfkname oname2((ushort*)odata.name);
   strcopy(pout->name, oname2.vname()); // pout->name is an array
   if (pBadConv)
      *pBadConv = oname2.bbadconv;

   pout->attrib      = odata.attrib;
   pout->time_write  = odata.time_write;
   pout->time_create = odata.time_create;
   pout->size        = odata.size;

   return pres;
}

int myfindnext64(intptr_t phandle, SFKFindData *pout, int *pBadConv)
{
   if (!vname())
      return _findnext64(phandle, pout);

   sfkfinddata64_t odata;

   int ires = _wfindnext64(phandle, &odata);

   memset(pout, 0, sizeof(SFKFindData));

   sfkname oname((ushort*)odata.name);
   strcopy(pout->name, oname.vname()); // pout->name is an array
   if (pBadConv)
      *pBadConv = oname.bbadconv;

   // printf("VNAME.1: %s\n", dataAsTrace(odata.name,wcslen((wchar_t*)odata.name)*2));
   // printf("VNAME.2: %s\n", pout->name);

   pout->attrib      = odata.attrib;
   pout->time_write  = odata.time_write;
   pout->time_create = odata.time_create;
   pout->size        = odata.size;

   return ires;
}
#endif

// caller MUST RELEASE COI after use!
Coi *Coi::rawNextEntry( )
{
   if (!data().bdiropen) {
      perr("nextEntry() called without openDir()");
      return 0;
   }

   SFKFindData myfdat;

   char   szAbsName[SFK_MAX_PATH+10];

   int bBadConv = 0;

   // loop to skip ".", ".." and invalid files:
   while (1)
   {
      memset(&myfdat, 0, sizeof(myfdat));
      szAbsName[0] = 0;
      bBadConv = 0;
 
      #ifdef _WIN32

      // windows:
      if (!data().bdir1stdone) {
         data().bdir1stdone = 1;
         // first call:
         #ifdef SFK_W64
         data().otrav = myfindfirst64(data().pdirpat, &myfdat, &bBadConv);
         #else
          #ifndef _INTPTR_T_DEFINED
           typedef int intptr_t;
          #endif
         data().otrav = _findfirst(data().pdirpat, &myfdat);
         #endif
         if (data().otrav == -1)
            return 0; // probably empty dir
      } else {
         // subsequent calls
         #ifdef SFK_W64
         int nrc = myfindnext64(data().otrav, &myfdat, &bBadConv);
         #else
         int nrc = _findnext(data().otrav, &myfdat);
         #endif
         if (nrc) return 0; // no further entries
      }

      // printf("# rawnextentry attr %lxh %s\n", (uint)myfdat.attrib, myfdat.name);
 
      #else
 
      // linux:
      struct dirent *e = readdir(data().ptrav);
      if (e == NULL)
         return 0; // no further entries
 
      myfdat.name    = e->d_name;
      myfdat.attrib  = 0;

      #ifdef SOLARIS
      myfdat.rawtype = 0;
      #else
      myfdat.rawtype = (uint)e->d_type;
      #endif

      // dirent symbolic links have their own inode,
      // and are of no use to detect repeated content listings.
      //   myfdat.ninode  = (num)e->d_ino;
      //   myfdat.bhavenode = 1;
      // the actual inode is fetched below through stat64.
 
      #endif

      // always skip "." and ".."
      if (   !strcmp(myfdat.name, ".")
          || !strcmp(myfdat.name, ".."))
         continue;

      // construct absolute name of entry now,
      // although we may decide to skip the file.
      int nRootLen = strlen(name());
      int nSubLen  = strlen(myfdat.name);
 
      // create tmp absname, taking care of ":" and slash
      int nMixLen  = nRootLen+nSubLen;
      joinPath(szAbsName, SFK_MAX_PATH, name(), myfdat.name);

      // identify further file attributes:
      // symbolic link directory under linux?
 
      #ifndef _WIN32

      // get further dir/file statistics. no 32 bit compat here -
      // getting the latest g++ for linux shouldn't be too difficult.
      struct stat64 hStat1;
      if (stat64(szAbsName, &hStat1)) {
         if (cs.verbose) printf("nostat: %s (non-regular file)\n", szAbsName);
         cs.noFiles++;
         continue;
      }

      myfdat.rawmode = (uint)hStat1.st_mode;
      myfdat.rawnlnk = (uint)hStat1.st_nlink;

      // get the "true" (dereferenced) inode,
      // allowing dup content listing detection:
      myfdat.ninode  = (num)hStat1.st_ino;
      memcpy(&myfdat.ostdev, &hStat1.st_dev, sizeof(__dev_t));
      myfdat.bhavenode = 1;

      #ifdef SOLARIS
      myfdat.islink = 0; // set by hStat1 below
      myfdat.attrib = 0; // set by hStat1 below
      #else
      // DT_LNK: not available on older Linux versions
      if (e->d_type == DT_LNK)
         myfdat.islink = 1; // cannot tell here if dir or file link
      else
      if (e->d_type == DT_DIR)
         myfdat.attrib = 0x10; // dir
      else
      if (e->d_type == DT_REG)
         myfdat.attrib = 0x00; // regular file
      // else probably DT_UNKNOWN
      #endif
 
      // general linux, including older variants
      #ifdef S_IFLNK
      if ((hStat1.st_mode & S_IFLNK) == S_IFLNK)
         myfdat.islink = 1;
      #endif
      // no else here.
      if ((hStat1.st_mode & S_IFDIR) == S_IFDIR)
         myfdat.attrib = 0x10; // dir
      else
      if ((hStat1.st_mode & S_IFREG) == S_IFREG)
         myfdat.attrib = 0x00; // regular file
      else {
         if (cs.verbose) printf("nofile: %s (non-regular file)\n", myfdat.name);
         cs.noFiles++;
         continue;
      }
 
      /*
         NOTE: these are OCTAL VALUES, NOT hexadecimal.
         __S_IFDIR   0040000  // Directory.
         __S_IFCHR   0020000  // Character device.
         __S_IFBLK   0060000  // Block device.
         __S_IFREG   0100000  // Regular file.
         __S_IFIFO   0010000  // FIFO.
         __S_IFLNK   0120000  // Symbolic link.
         __S_IFSOCK  0140000  // Socket.
      */

      // skip of dirlinks should be done by caller
      // if (myfdat.islink && ((hStat1.st_mode & _S_IFDIR) == _S_IFDIR)) {
      //    // symbolic directory link:
      //    bIsDirLink = 1;
      //    if (cs.skipLinks && (nGlblFunc != eFunc_FileStat)) {
      //       continue;
      //    }
      // }
 
      // may also set 0x02 here for hidden files.
      // may also set 0x04 here for system files.
 
      myfdat.time_write  = hStat1.st_mtime;
      myfdat.time_create = hStat1.st_ctime;
      myfdat.size        = hStat1.st_size;
 
      #endif

      // entry valid, not skipped: take it
      break;

   }  // endwhile (1)

   // expect that we (the parent of psub) have a root
   // copied through from higher levels. if not,
   // set ourselves as the root.
   Coi *psub = new Coi(szAbsName, pszClRoot ? pszClRoot : name());
   psub->fillFrom(&myfdat);
   // time, size, hidden, link
   psub->bClBadName = bBadConv;

   #ifdef SFKDEEPZIP
   if (cs.probefiles)
      psub->probeFile();
   #endif // SFKDEEPZIP

   // verified file system directory:
   if (myfdat.attrib & 0x10)
      psub->bClFSDir = 1;

   psub->incref("rne");

   // read metadata successfully:
   psub->nClStatus = 1;

   return psub; // managed by caller
}

bool Coi::isHidden( ) {
   // TODO: so far, readStat can NOT determine the hidden status,
   //       therefore the call doesn't help unless this changes.
   if (!nClStatus) readStat('h');
   mtklog(("%d = coi::ishidden %s",bClHidden,name()));
   return bClHidden;
}

bool Coi::isLink   ( ) {
   // TODO: so far, readStat can NOT determine the link status,
   //       therefore the call doesn't help unless this changes.
   if (!nClStatus) readStat('l');
   return bClLink;
}

bool Coi::isDirLink( ) {
   // TODO: so far, readStat can NOT determine the link status,
   //       therefore the call doesn't help unless this changes.
   if (!nClStatus) readStat('l');
   return bClDir && bClLink;
}

void Coi::rawCloseDir( )
{
   if (!data().bdiropen)
      pwarn("closeDir() called on non-open dir");

   #ifdef _WIN32

   if (data().otrav != -1) {
      _findclose(data().otrav);
      data().otrav = -1;
   }

   #else

   if (data().ptrav) {
      closedir(data().ptrav);
      data().ptrav = 0;
   }

   #endif

   if (data().pdirpat) {
      delete [] data().pdirpat;
      data().pdirpat = 0;
   }

   data().bdiropen = 0;
}

CoiTable::CoiTable() {
   mtklog(("coitab ctr %p",this));
   nClArraySize = 0;
   nClArrayUsed = 0;
   apClArray    = 0;
}

CoiTable::~CoiTable() {
   mtklog(("coitab dtr %p",this));
   resetEntries();
}

void CoiTable::resetEntries()
{
   if (apClArray)
   {
      for (int i=0; i<nClArrayUsed; i++)
      {
         if (apClArray[i])
         {
            if (apClArray[i]->refcnt() > 0) {
               // should not occur as CoiTable adds copies of coi.
               perr("cannot cleanup used file object: %d %s\n", apClArray[i]->refcnt(), apClArray[i]->name());
            } else {
               delete apClArray[i];
            }
         }
         apClArray[i] = 0;
      }
   }
   nClArrayUsed = 0;
   if (apClArray)
      delete [] apClArray;
   apClArray = 0;
   nClArraySize = 0;
}

int CoiTable::numberOfEntries() { return nClArrayUsed; }

bool CoiTable::isSet(int iIndex) {
   if (iIndex < 0) { pwarn("illegal index: %d\n", iIndex); return 0; }
   return (iIndex < nClArrayUsed) ? 1 : 0;
}

int CoiTable::expand(int nSoMuch) {
   Coi **apTmp = new Coi*[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (apClArray) {
      memcpy(apTmp, apClArray, nClArraySize*sizeof(Coi*));
      delete [] apClArray;
   }
   apClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

int CoiTable::hasEntry(char *pszFilename) {
   for (int i=0; i<nClArrayUsed; i++) {
      Coi *p = apClArray[i];
      if (p!=0 && strcmp(pszFilename, p->name())==0)
         return 1;
   }
   return 0;
}

// add a COPY of the supplied coi
int CoiTable::addEntry(Coi &ocoi, int nAtPos) {
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (int i=nClArrayUsed; i>nAtPos; i--)
         apClArray[i] = apClArray[i-1];
      apClArray[nAtPos] = ocoi.copy();
      nClArrayUsed++;
   } else {
      apClArray[nClArrayUsed++] = ocoi.copy();
   }
   return 0;
}

int CoiTable::addSorted(Coi &ocoi, char cSortedBy, bool bUseCase)
{
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }

   Coi *padd = &ocoi;

   int nInsPos = -1;
   int nCnt = numberOfEntries();

   #if 1 // sfk1963: binary sort with sfk big, sfk late etc.

   int nbot  = 0;
   int ntop  = nCnt;
   int ndist = ntop - nbot;
   int nmid  = 0;
   Coi *pown = 0;

   // printf("addsorted %u %c cnt=%d\n",(int)padd->getSize(),cSortedBy,nCnt);

   while (ndist > 0)
   {
      int nhalf = ndist / 2;
      nmid = nbot + nhalf;
      // printf("from %02u to %02u mid %02u for %u\n",nbot,ntop,nmid,(int)padd->getSize());
      num ncmp  = 0;
      pown = apClArray[nmid];
      switch (cSortedBy)
      {
         case 'T': ncmp = padd->getTime() - pown->getTime(); break;
         case 't': ncmp = pown->getTime() - padd->getTime(); break;
         case 'S': ncmp = padd->getSize() - pown->getSize(); break;
         case 's': ncmp = pown->getSize() - padd->getSize(); break;
         case 'N': {
            ncmp = bUseCase ?   strcmp(padd->name(), pown->name())
                              : mystricmp(padd->name(), pown->name());
            break;
         }
         case 'n': {
            ncmp = bUseCase ?   strcmp(padd->name(), pown->name())
                              : mystricmp(padd->name(), pown->name());
            break;
         }
         default: return 9+perr("internal #141272257\n");
      }
      if (ncmp > 0) {
         nmid++;
         if (nbot == nmid) break;
         nbot = nmid; // printf("   set bot %u\n", nbot);
      }
      if (ncmp < 0) { 
         if (ntop == nmid) break;
         ntop = nmid; // printf("   set top %u\n", ntop); 
      }
      if (ncmp == 0) {
         nmid++;
         // printf("match\n");
         break; 
      }
      ndist = ntop - nbot;
   }
   // printf("   have nmid %u\n", nmid);
   if (nmid > 0 && nmid <= nCnt)
      nInsPos = nmid;
   else
      nInsPos = 0;

   #else

   int i=0; bool bbail=0;
   for (i=0; i<nCnt; i++)
   {
      Coi *pown = apClArray[i];
      switch (cSortedBy) {
         case 'T': bbail = (pown->getTime() > padd->getTime()); break;
         case 't': bbail = (pown->getTime() < padd->getTime()); break;
         case 'S': bbail = (pown->getSize() > padd->getSize()); break;
         case 's': bbail = (pown->getSize() < padd->getSize()); break;
         case 'N': {
            int ncmp = bUseCase ?      strcmp(pown->name(), padd->name())
                                   : mystricmp(pown->name(), padd->name());
            bbail = (ncmp > 0);
            break;
         }
         case 'n': {
            int ncmp = bUseCase ?      strcmp(pown->name(), padd->name())
                                   : mystricmp(pown->name(), padd->name());
            bbail = (ncmp < 0);
            break;
         }
         default: return 9+perr("internal #141272256\n");
      }
      if (bbail) break;
   }
   if (i < nCnt) nInsPos = i;

   #endif

   // printf("   addEntry at %u\n",(int)nInsPos);

   int irc = addEntry(ocoi, nInsPos);

   // nCnt = numberOfEntries();
   // for (int i=0; i<nCnt; i++) printf("   %d\n",(int)apClArray[i]->getSize());

   return irc;
}

int CoiTable::removeEntry(int nAtPos) {
   if (nAtPos < 0 || nAtPos >= nClArrayUsed)
      return 9;
   if (apClArray[nAtPos]) delete apClArray[nAtPos];
   for (int i=nAtPos; i<nClArrayUsed-1; i++)
      apClArray[i] = apClArray[i+1];
   apClArray[nClArrayUsed-1] = 0; // just in case
   nClArrayUsed--;
   return 0;
}

int CoiTable::setEntry(int nIndex, Coi *pcoi) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("illegal set index: %d\n", nIndex);
   if (apClArray[nIndex])
      delete apClArray[nIndex];
   apClArray[nIndex] = pcoi ? pcoi->copy() : 0;
   return 0;
}

Coi *CoiTable::getEntry(int nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return apClArray[nIndex];
   perr("illegal CoiTable index: %d tline %d\n", nIndex, nTraceLine);
   return 0;
}

// - - - - - CoiTable end - - - - -

ProgressInfo info;

void initConsole()
{
   // manually set or override console width:
   char *psz2 = getenv("SFK_CONFIG"); // console
   if (psz2) {
      psz2 = strstr(psz2, "columns:");
      if (psz2) {
         int ncols = atol(psz2+8);
         if (ncols >= 40) {
            nGlblConsColumns = ncols;
            bGlblConsColumnsSet = 2; // change forbidden
            info.setWidth(nGlblConsColumns);
         }
      }
   }

   // need this also for html help
   char *pszColEnv = getenv("SFK_COLORS");
   if (pszColEnv)
      setColorScheme(pszColEnv);

   #ifdef WINFULL

   hGlblConsole = GetStdHandle(STD_OUTPUT_HANDLE);
   hGlblStdIn   = GetStdHandle(STD_INPUT_HANDLE);

   // TODO: vc10 with GetConsoleScreenBufferInfoEx
   CONSOLE_SCREEN_BUFFER_INFO oConInf;
   if (!GetConsoleScreenBufferInfo(hGlblConsole, &oConInf)) {
      // not in interactive mode, e.g. output redirected to file:
      gs.usecolor = gs.usehelpcolor = 0;
      cs.usecolor = cs.usehelpcolor = 0;
      return;
   }
   bGlblHaveInteractiveConsole = 1;
   if (oConInf.dwCursorPosition.X==0 && oConInf.dwCursorPosition.Y==0)
      bGlblStartedInEmptyConsole = 1;
   nGlblConsAttrib = oConInf.wAttributes;
 
   /*
   printf("CONSATTRIB DEFAULTS %lxh:\n",nGlblConsAttrib);
   printf("   %u  BACKGROUND_BLUE\n" , nGlblConsAttrib & BACKGROUND_BLUE);
   printf("   %u  BACKGROUND_GREEN\n", nGlblConsAttrib & BACKGROUND_GREEN);
   printf("   %u  BACKGROUND_RED\n"  , nGlblConsAttrib & BACKGROUND_RED);
   */

   int nConCol = oConInf.srWindow.Right - oConInf.srWindow.Left + 1;
   int nConRow = oConInf.srWindow.Bottom - oConInf.srWindow.Top + 1;

   if (!bGlblConsColumnsSet && (oConInf.dwSize.X >= 60)) {
      nGlblConsColumns = oConInf.dwSize.X;
      bGlblConsColumnsSet = 1;
      info.setWidth(nGlblConsColumns);
   }
   if (!bGlblConsRowsSet && (nConRow >= 10)) {
      nGlblConsRows = nConRow;
      bGlblConsRowsSet = 1;
   }

   if (!pszColEnv)
   {
      // if we autodetect a black background shell
      uint nBackMask = BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE;
      if ((nGlblConsAttrib & (nBackMask)) == 0) {
         // auto-select color theme:black
         setColorScheme("theme:black");
      }
      if ((nGlblConsAttrib & (nBackMask)) == nBackMask) {
         // optimize colors for white background
         setColorScheme("theme:white");
      }
   }
   #endif

   #ifdef _WIN32

   #ifdef WINFULL
   if (gs.usecolor || cs.usecolor)
      SetConsoleCtrlHandler(ctrlcHandler, 1);
   #endif

   #else

   signal(SIGINT, ctrlcHandler);

   #endif
}

// sfk1972 console auto width: this called 2/sec with
// commands showing a long operation status, like copy
void updateConsole()
{
   #ifdef WINFULL

   if (hGlblConsole == 0
       || bGlblHaveInteractiveConsole == 0)
      return;

   if (bGlblConsColumnsSet == 0     // access didnt work
       || bGlblConsColumnsSet == 2) // change forbidden
         return;

   CONSOLE_SCREEN_BUFFER_INFO oConInf;
   if (!GetConsoleScreenBufferInfo(hGlblConsole, &oConInf))
      return;

   if (oConInf.dwSize.X >= 60) {
      nGlblConsColumns = oConInf.dwSize.X;
      info.setWidth(nGlblConsColumns);
   }

   #endif
}

int autoCalcWrapColumns()
{
   int ncols = 80;
   if (bGlblConsColumnsSet)
   {
      if (cs.verbose >= 2) printf("ConsoleColumns=%d\n",nGlblConsColumns);
      return nGlblConsColumns-2;
   }
   #ifdef _WIN32
   HWND hDeskWin = GetDesktopWindow();
   if (hDeskWin) {
      HDC hdcDesk = GetWindowDC(hDeskWin);
      if (hdcDesk != NULL) {
         int ndeskw = GetDeviceCaps(hdcDesk, HORZRES); // gdi32.lib
         int ncols2 = ndeskw / 10; // default char width: 10 pixels
         if (ncols2 > 80)
            ncols = ncols2;
         if (cs.verbose >= 2) printf("wdesk %d col.calc %d used %d\n",ndeskw,ncols2,ncols);
         ReleaseDC(hDeskWin, hdcDesk);
      }
   }
   #else
   // identify number of linux shell columns
   #endif
   return ncols-2;
}

ProgressInfo::ProgressInfo()
{
   memset(this, 0, sizeof(ProgressInfo));
   setWidth(80);
   nLastDumpTime = getCurrentTime();
   bAddInfoPrio  = 1;
}

void ProgressInfo::setWidth(int nColumns) {
   nMaxChars      = nColumns  -  3;
   nMaxSubChars   = nMaxChars - 20;
   // sfk1972 console auto width
   if (nMaxChars > (nAddInfoCols+10) + 30)
      nMaxSubChars = nMaxChars - (nAddInfoCols+10);
}

void ProgressInfo::setAddInfoWidth(int nAddCols) {
   nAddInfoCols = nAddCols;
   // vrfy  58% [filename]......... addinfo
   // 1234567890                    addcols
   nAddCols += 10; // add left side columns
   if (nMaxChars > nAddCols + 30)
      nMaxSubChars = nMaxChars - nAddCols;
}

void ProgressInfo::fixAddInfoWidth() {
   if ((int)strlen(szAddInfo) > nAddInfoCols) {
      nAddInfoCols = (int)strlen(szAddInfo);
      int nAddCols = nAddInfoCols + 10;
      if (nMaxChars > nAddCols + 30)
         nMaxSubChars = nMaxChars - nAddCols;
   }
}

void ProgressInfo::setStatus(cchar *pverb, cchar *psubj, cchar *pszAddInfo, int nKeepFlags)
{
   strcopy(szVerb, pverb);
   strcopy(szSubject, psubj);
   if (nKeepFlags & eKeepProg)  // keep progress
      szPerc[0] = '\0';
   if (pszAddInfo) {
      if (!strcmp(pszAddInfo, "00")) {
         strcpy(szPerc, "... ");
         strcopy(szAddInfo, pszAddInfo+2);
      } else
         strcopy(szAddInfo, pszAddInfo);
   }
   else
   if (!(nKeepFlags & eKeepAdd)) { // keep addinfo
      szAddInfo[0] = '\0';
   }

   fixAddInfoWidth();

   if (nKeepFlags & eSlowCycle)
      nLastDumpTime = getCurrentTime();

   if (!(nKeepFlags & eNoCycle))
      cycle();
}

void ProgressInfo::setStatProg(cchar *pverb, cchar *psubj, num nMax, num nCur, cchar *pszUnit) {
   strcopy(szVerb, pverb);
   strcopy(szSubject, psubj);
   szAddInfo[0] = '\0';
   setProgress(nMax, nCur, pszUnit);
}

void ProgressInfo::setProgress(num nMax, num nCur, cchar *pszUnit, bool btriple) 
{
   if (nMax <= 0) nMax = 1; // safe division
   int nPerc = (int)(nCur * 100 / nMax);
   if (nPerc > 0 && nPerc <= 100) {
      if (btriple)
         sprintf(szPerc, "%03d%% ", nPerc);
      else
         sprintf(szPerc, "%02d%% ", nPerc);
   }
   else
   if (nPerc > 100) {
      sprintf(szPerc, "100%% ");
      if (cs.debug) printf("[progress: cur=%d max=%d perc=%d]\n", (int)nCur, (int)nMax, (int)nPerc);
   } else {
      if (btriple)
         sprintf(szPerc, ".... ");
      else
         sprintf(szPerc, "... ");
      if (cs.debug) printf("[progress: cur=%d max=%d perc=%d]\n", (int)nCur, (int)nMax, (int)nPerc);
   }
   cycle();
}

void ProgressInfo::clearProgress( )
{
   szPerc[0] = '\0';
}

void ProgressInfo::cycle() {
   #ifdef _WIN32
   // windows: if output is redirected, info display makes no sense.
   if (!bGlblHaveInteractiveConsole)
      return;
   #endif
   if (cs.quiet || cs.noprog)
      return;
   if (getCurrentTime() >= (nLastDumpTime + 500)) {
      updateConsole();  // sfk1972 internal
      dumpTermStatus();
  }
}

void ProgressInfo::setAction(cchar *pverb, cchar *psubj, cchar *pszAddInfo, int nKeepFlags) {
   setStatus(pverb, psubj, pszAddInfo, nKeepFlags);
   if (!(nKeepFlags & eNoPrint))
      print();
}

void ProgressInfo::print() {
   if (cs.quiet || cs.noprog)
      return;
   dumpTermStatus();
}

void ProgressInfo::printLine(int nFilter) {
   if (cs.quiet || cs.noprog)
      return;
   if (nFilter & (1<<1)) {
      // print only subject, but with unlimited length
      clearTermStatus();
      oprintf("%s\n", szSubject);
   } else {
      if (nFilter & (1<<2))
         strcpy(szPerc, " ");
      dumpTermStatus(); // may clear previous status output
      printf("\n");
   }
   nDumped = 0;
}

int ProgressInfo::print(const char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf, sizeof(szPrintBuf)-10, pszFormat, argList);
   szPrintBuf[sizeof(szPrintBuf)-10] = '\0';
   clear();
   printf("%s", szPrintBuf);
   return 0;
}

void ProgressInfo::setAddInfo(const char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szAddInfo, sizeof(szAddInfo)-10, pszFormat, argList);
   szAddInfo[sizeof(szAddInfo)-10] = '\0';
   fixAddInfoWidth();
}

void ProgressInfo::clear()
{
   clearTermStatus();
   szVerb[0]      = '\0';
   szSubject[0]   = '\0';
   szAddInfo[0]   = '\0';
   szPerc[0]      = '\0';
   // nLastDumpTime  = getCurrentTime();
}

void ProgressInfo::clearTermStatus()
{
   if (nDumped > 0 && nDumped < sizeof(szTermBuf)-4)
   {
      mtklog(("info::clearterm"));
      memset(szTermBuf, ' ', nDumped);
      szTermBuf[nDumped] = '\0';
      printf("%s\r",szTermBuf);
      fflush(stdout);
      nDumped = 0;
   }
   // do NOT reset szVerb etc. here
}

void ProgressInfo::dumpTermStatus()
{__
   if (cs.quiet || cs.noprog)
      return;

   if (!szSubject[0])
   {
      if (nDumped)
         clearTermStatus();
      return;  // nothing to dump
   }

   int nToClear = nDumped;

   int nMaxMiddle = nMaxSubChars;
   if (!szPerc[0])
      nMaxMiddle += 2; // no percentage: have more chars to use

   // if there is few space, and low addinfo prio
   bool bWithAdd = 1;
   if ((int)strlen(szSubject) > nMaxMiddle) {
      if (!bAddInfoPrio) {
         bWithAdd = 0;
         nMaxMiddle += nAddInfoReserve; // add space to center
      }
   }

   if ((int)strlen(szSubject) > nMaxMiddle) {
      int nlen  = strlen(szSubject);
      int nmax2 = nMaxMiddle - 3;
      if (nmax2 < 0) nmax2 = 0;
      char *psz1 = &szSubject[nlen-nmax2];
      snprintf(szTermBuf, sizeof(szTermBuf)-10, "...%s", psz1);
   } else {
      snprintf(szTermBuf, sizeof(szTermBuf)-10, "%-*.*s", (int)nMaxMiddle, (int)nMaxMiddle, szSubject);
   }

   nDumped = 0;

   char cTurn = (nTurn & 1) ? '.':' ';
   nTurn++;

   if (szVerb[0]) {
      int nvlen = strlen(szVerb);
      if (nvlen > 5) nvlen = 5;
      while (nvlen > 3 && szVerb[nvlen-1] == ' ')
         nvlen--;
      if (szPerc[0]) {
         cchar *pszPerc2 = szPerc;
         if (!strcmp(szPerc, " "))
            pszPerc2 = ""; // ignore, is just a dummy
         printx("<head>%-*.*s %s<def>", nvlen,nvlen, szVerb, pszPerc2);
         nDumped += 6 + strlen(szPerc);
      } else {
         printx("<head>%-*.*s <time>%c<def> ", nvlen,nvlen, szVerb, cTurn);
         nDumped += 6 + 2;
      }
   }

   mtklog(("info::dump \"%s\"", szTermBuf));
   printf("%s ",szTermBuf);
   nDumped += strlen(szTermBuf) + 1;

   if (bWithAdd && strlen(szAddInfo)) {
      setTextColor(nGlblTimeColor);
      printf("%s", szAddInfo);
      setTextColor(-1);
      nDumped += strlen(szAddInfo);
   }
 
   // need to add a blank area to clear old output?
   int nDelta = nToClear - nDumped;
   if (nDelta > 0 && nDelta < sizeof(szTermBuf)-4)
   {
      memset(szTermBuf, ' ', nDelta);
      szTermBuf[nDelta] = '\0';
      printf("%s",szTermBuf);
   }

   printf("\r");
   fflush(stdout);
   nLastDumpTime = getCurrentTime();
}

// FIX for Windows 60 MB I/O Bug: Windows XP fails to read blocks
// larger than 60 MByte, therefore use myfread instead of fread:

// large block read incl. optional info update and checksum building
size_t myfread(uchar *pBuf, size_t nBufSize, FILE *fin, num nMax, num nCur, SFKMD5 *pmd5)
{
   size_t nOffset  = 0;
   size_t nRemain  = nBufSize;
   size_t nReadSub = 0;
 
   while ((nRemain > 0) && !bGlblEscape)
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      #ifdef _WIN32
      // sfk1972 fix Visual 2015 stdin fread causes random joined lines.
      if (fin != stdin)
         nReadSub = fread(pBuf+nOffset, 1, nBlock, fin); // safe
      else
      if (!ReadFile(hGlblStdIn, pBuf+nOffset, nBlock, &nGlblStdRead, 0))
         { nReadSub = 0; } else { nReadSub = (size_t)nGlblStdRead; }
      #else
      nReadSub = fread(pBuf+nOffset, 1, nBlock, fin); // safe
      #endif

      if (nReadSub <= 0)
         break;

      nOffset += nReadSub;
      nRemain -= nReadSub;

      if (nMax > 0)
         info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   if (nOffset > 0 && pmd5 != 0)
      pmd5->update(pBuf, nOffset);
 
   return nOffset;
}

// large block write incl. optional info update and checksum building
size_t myfwrite(uchar *pBuf, size_t nBytes, FILE *fout, num nMax, num nCur, SFKMD5 *pmd5)
{
   size_t nOffset = 0;
   size_t nRemain = nBytes;

   while ((nRemain > 0) && !bGlblEscape)
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nWriteSub = fwrite(pBuf+nOffset, 1, nBlock, fout);

      // mtklog(("myfwrite: %d = fwrite(%d)",(int)nWriteSub,(int)nBlock));

      if (nWriteSub != nBlock)
         return nOffset+nWriteSub; // return no. of bytes actually written

      nOffset += nWriteSub;
      nRemain -= nWriteSub;

      if (nMax > 0)
         info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   if (nOffset > 0 && pmd5 != 0)
      pmd5->update(pBuf, nOffset);

   return nOffset;
}

#ifdef _WIN32
void timetToFileTime(num ntimet, FILETIME *pft) // sfk1933 full 64 bits
{
   #if 1

   ntimet *= 10000000LL;
   ntimet += 116444736000000000LL;

   LONGLONG ll = (LONGLONG)ntimet;

   pft->dwLowDateTime  = (DWORD)ll;
   pft->dwHighDateTime = (DWORD)(ll>>32);

   #else

   time_t t = (time_t)ntimet; // time32 deactivated with sfk1933

   LONGLONG ll = Int32x32To64(t, 10000000) + 116444736000000000LL;

   pft->dwLowDateTime  = (DWORD)ll;
   pft->dwHighDateTime = (DWORD)(ll>>32);

   #endif
}

num fileTimeToTimeT(num nwft)
{
   nwft -= 116444736000000000LL;
   nwft /= 10000000;
   // sfk197: never return negative times
   if (nwft < 0) nwft = 0;
   return nwft;
}

num fileTimeToTimeT(FILETIME *pft)
{
   num nwft =     (((num)pft->dwHighDateTime) << 32)
               |  (((num)pft->dwLowDateTime));
   nwft -= 116444736000000000LL;
   nwft /= 10000000;
   // sfk197: never return negative times
   if (nwft < 0) nwft = 0;
   return nwft;
}
#endif

size_t safefread(void *pBuf, size_t nBlockSize, size_t nBufSize, FILE *fin)
   { return myfread((uchar*)pBuf, nBufSize, fin); }

size_t safefwrite(const void *pBuf, size_t nBlockSize, size_t nBufSize, FILE *fin)
   { return myfwrite((uchar*)pBuf, nBufSize, fin); }

// FROM HERE ON, ALL fread() and fwrite() calls are MAPPED to SAFE versions
// to work around Windows runtime bugs (60 MB I/O bug, stdin joined lines etc.)

#define fread  safefread
#define fwrite safefwrite

// optional reroute of error messages
int (*pGlblSFKStatusCallBack)(int nMsgType, char *pmsg) = 0;

int errPauseOrEcho( )
{
   if (cs.echoonerr) {
      if (cs.argc > 0 && cs.argv != 0) {
         fprintf(stderr, "[cmd]: ");
         for (int i=0; i<cs.argc; i++)
            fprintf(stderr, "%s ", cs.argv[i]);
         fprintf(stderr, "\n");
      }
      else {
         printf("cmd  : [none]\n");
      }
   }

   if (bGlblPauseOnError) {
      printf("Press ENTER to continue.\n");
      while (getchar() != '\n');
   }
 
   return 0;
}

int perr(const char *pszFormat, ...)
{
   if (cs.noerr) return 0;

   static bool bWithinPErr = 0;

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   szErrBuf[sizeof(szErrBuf)-10] = '\0';

   if (cs.errtotext && !bWithinPErr) {
      bWithinPErr = 1;
      removeCRLF(szErrBuf);
      chain.print('e', 0, "error: %s\n", szErrBuf);
      bWithinPErr = 0;
      // error is "catched" so allow no pause etc.
      return 0;
   }
   else
   if (pGlblSFKStatusCallBack) {
      // output to callback
      removeCRLF(szErrBuf);
      pGlblSFKStatusCallBack(1, szErrBuf);
   } else {
      // output to terminal
      if (!strchr(szErrBuf, '\n'))
         strcat(szErrBuf, "\n");
      // sfk197 prefix error by current command
      info.clear();
      setTextColor(nGlblErrColor, 1); // on stderr
      fprintf(stderr, "error: sfk %s: %s", cs.curcmd, szErrBuf);
      setTextColor(-1, 1);
   }

   mtkerr(("%s", szErrBuf));

   bErrBufSet = 1;
   nGlblErrors++;

   errPauseOrEcho();

   return 0;
}

// file not found unified error with filename check
int pferr(const char *pszFile, const char *pszFormat, ...)
{
   char szBuf[SFK_MAX_PATH+100];
   char aCode[256];

   if (cs.noerr) return 0;

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPreErrBuf, sizeof(szPreErrBuf)-10, pszFormat, argList);
   szPreErrBuf[sizeof(szPreErrBuf)-10] = '\0';

   if (strBegins(szPreErrBuf, "[warn] "))
      pwarn("%s", szPreErrBuf+7);
   else
      perr("%s", szPreErrBuf);

   memset(aCode, 0, sizeof(aCode));
   bool bvalid=1;
   for (uchar *p=(uchar*)pszFile; *p; p++) {
      aCode[*p]=1;
      if (*p < 0x20)
         bvalid=0;
   }
   if (aCode['\r'] || aCode['\n']) {
      pinf("filename contains CR or LF line end characters:\n");
      pinf("  %s\n", dataAsTrace((void*)pszFile, strlen(pszFile), szBuf, sizeof(szBuf)));
      pinf("  use echo -pure or +xed \"/[eol]//\" in previous commands.\n");
   } else if (!bvalid) {
      pinf("filename contains invalid characters. look for {nn} codes in the following dump:\n");
      pinf("  %s\n", dataAsTrace((void*)pszFile, strlen(pszFile), szBuf, sizeof(szBuf)));
   }

   return 0;
}

int pbad(char *pszCmd, char *pszParm)
{
   return perr("unexpected parameter \"%s\". (sfk %s)\n", pszParm, pszCmd);
}

int pcon(char *pszCmd, char *pszParm)
{
   perr("conflicting input from previous command and parameter: %s", pszParm);
   pinf("use \"+then %s\" to ignore command chain input text.\n", pszCmd);
   return 0;
}

int pwarn(const char *pszFormat, ...)
{
   if (cs.nowarn) return 0;
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   szErrBuf[sizeof(szErrBuf)-10] = '\0';

   if (pGlblSFKStatusCallBack) {
      // output to callback
      removeCRLF(szErrBuf);
      char *pbuf = szErrBuf;
      if (!strncmp(pbuf, "[nopre] ", 8))
         pbuf += 8;
      pGlblSFKStatusCallBack(2, pbuf);
   } else {
      // output to terminal
      if (!strchr(szErrBuf, '\n'))
         strcat(szErrBuf, "\n");
      info.clear();
      setTextColor(nGlblWarnColor, 1);
      char *psz = szErrBuf;
      // sfk197 prefix warn by current command
      if (!strncmp(psz, "[nopre] ", 8))
         fprintf(stderr, "sfk %s: %s", cs.curcmd, psz+8);
      else
         fprintf(stderr, "warn : sfk %s: %s", cs.curcmd, psz);
      setTextColor(-1, 1);
   }

   mtkwarn(("%s", szErrBuf));
   nGlblWarnings++;

   return 0;
}

int pinf(const char *pszFormat, ...)
{
   if (cs.nonotes) return 0;

   // does NOT use szErrBuf to allow access to last
   // error message through sfkLastError().

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';

   if (pGlblSFKStatusCallBack) {
      // output to callback
      removeCRLF(szPrintBuf1);
      pGlblSFKStatusCallBack(3, szPrintBuf1);
   } else {
      // output to terminal
      info.clear();
      setTextColor(nGlblTimeColor, 1);
      char *psz = szPrintBuf1;
      if (!strncmp(psz, "[nopre] ", 8))
         fprintf(stderr, "%s", psz+8);
      else
         fprintf(stderr, "note : %s", psz);
      setTextColor(-1, 1);
   }

   mtklog(("note: %s", szPrintBuf1));

   return 0;
}

int tellCannotWriteBatchFile(char *pszName)
{
   perr("cannot write batch file: %s\n", szRefNameBuf);
   #ifndef _WIN32
   pinf("batch files are put into the same folder as the sfk binary.\n");
   pinf("try placing sfk in a writeable folder listed first in the PATH,\n");
   pinf("for example: mkdir ~/bin; cp sfk ~/bin; export PATH=~/bin:$PATH\n");
   pinf("or try sudo, if you are the only user of this machine.\n");
   #endif
   return 0;
}

char *mystrerr(int iOptCode=-1)
{
   static char szBuf[100];
 
   szBuf[0] = '\0';

   #ifdef _WIN32

   DWORD nerr = (iOptCode >= 0) ? iOptCode : GetLastError();

   LPVOID lpMsgBuf = 0;

   FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, nerr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        // MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        (LPTSTR)&lpMsgBuf,
        0, NULL );

   if (lpMsgBuf) {
      removeCRLF((char*)lpMsgBuf);
      snprintf(szBuf, sizeof(szBuf)-10, "%d,%s", nerr, (char*)lpMsgBuf);
   }

   LocalFree(lpMsgBuf);

   #else

   int nerr = (iOptCode >= 0) ? iOptCode : errno;

   char *psz = strerror(nerr);
   snprintf(szBuf, sizeof(szBuf)-10, "%d,%s", nerr, psz);

   #endif
 
   return szBuf;
}

void perrinfo(const char *pszContext)
{
   // general reasons first
   if (!strcmp(pszContext, "fwrite")) {
      pinf("the target volume may have no space left on the device.\n");
      pinf("if the target is a network drive, a file size limit may apply.\n");
   }

   // then dump system infos, if any
   #ifdef _WIN32

   #ifdef WINFULL
   #ifdef USE_SFK_BASE
   int  nerr1 = 0;
   #else
   int  nerr1 = errno;
   #endif
   DWORD nerr2 = GetLastError();
   LPVOID lpMsgBuf = 0;
   FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, nerr2,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &lpMsgBuf,
        0, NULL );
   if (lpMsgBuf) removeCRLF((char*)lpMsgBuf);
   info.clear(); // in case no perr was done
   setTextColor(nGlblWarnColor);
   printf("cerno: %d,%s\n", nerr1, strerror(nerr1));
   printf("werno: %u,%s\n", nerr2, lpMsgBuf ? lpMsgBuf : "");
   setTextColor(-1);
   LocalFree(lpMsgBuf);
   #endif

   #else

   int  nerr1 = errno;
   info.clear(); // in case no perr was done
   setTextColor(nGlblWarnColor);
   printf("cerno: %d,%s\n", nerr1, strerror(nerr1));
   setTextColor(-1);

   #endif
}

bool bGlblSysErrOccured = 0;

int esys(const char *pszContext, const char *pszFormat, ...)
{
   bGlblSysErrOccured = 1;

   // just like perr:
   if (cs.noerr) return 0;
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   szErrBuf[sizeof(szErrBuf)-10] = '\0';
   if (!strchr(szErrBuf, '\n'))
      strcat(szErrBuf, "\n");
   info.clear();
   setTextColor(nGlblErrColor, 1); // on stderr
   fprintf(stderr, "error: %s", szErrBuf);
   setTextColor(-1, 1);
   mtkerr(("%s", szErrBuf));
   bErrBufSet = 1;
   nGlblErrors++;

   // optionally extend output by runtime info:
   if (bGlblSysErrDetail)
      perrinfo(pszContext);

   errPauseOrEcho();

   return 0;
}

bool cmpchr(char c1, char cmsk, bool bcase, bool besc)
{
   if (!besc && cmsk == '?') return 1;
   if (!bcase) c1   = sfktolower(c1);
   if (!bcase) cmsk = sfktolower(cmsk);
   if (c1 == cmsk) return 1;
   return 0;
}

enum eMatchStr {
   eMatchCase     = 1,
   eMatchLiteral  = 2,
   eMatchHead     = 4,
   eMatchTail     = 8
};

char peekpatchr(char *p, int &rEscaped)
{
   rEscaped = 0;
   char c  = *p++;
   if (!cs.spat || c != '\\') // spat.3 peek 2
      return c;
   char c2 = *p;
   switch (c2) {
      case 't' : rEscaped=1; c='\t'; break;
      case 'q' : rEscaped=1; c='"'; break;
      case '\\':
      case '*' :
      case '?' : rEscaped=1; c=c2;   break;
      case 'x' :
         if (p[1] && p[2]) {
            rEscaped=3;
            c = (char)getTwoDigitHex(p+1);
         }
         break;
   }
   return c;
}

bool mystrhit(char *pszStr, char *pszPat, bool bCase, int *pOutHitIndex)
{
   if (bCase) {
      char *psz = strstr(pszStr, pszPat);
      if (psz) {
         if (pOutHitIndex) *pOutHitIndex = (int)(psz-pszStr);
         return true;
      } else {
         if (pOutHitIndex) *pOutHitIndex = -1;
         return false;
      }
   } else {
      if (mystrstrip(pszStr, pszPat, pOutHitIndex))
         return true;
      else
         return false;
   }
}

bool matchstr(char *pszHay, char *pszPat, int nFlags, int &rfirsthit, int &rhitlen)
{
   if (cs.debug)
      printf("match: enter matchstr \"%s\" \"%s\" flags %u\n",pszHay,pszPat,nFlags);

   bool bCase = ( nFlags & 1) ? 1 : 0;
   bool bHead = ( nFlags & 4) ? 1 : 0;
   bool bTail = ( nFlags & 8) ? 1 : 0;

   int nhaylen = strlen(pszHay);
   int ibase   = 0;
   int ifirst  = -1;     // pos'n of first matching char
   int ilast   = -1;     // pos'n of last matching char
   bool bmatch  = 0;
   int nesc    = 0;      // escapes not (0), or 1 or 3 chars

   if (!cs.wpat) {
      // no wildcard interpretation
      int npatlen = strlen(pszPat);
      if (bTail) {
         // check for end-of-line match
         if (nhaylen < npatlen) return 0;
         char *pend = pszHay+nhaylen-npatlen;
         if (!mystrncmp(pend,pszPat,npatlen,bCase)) {
            if (cs.debug)
               printf("match:  direct at %d len %d\n",nhaylen-npatlen,npatlen);
            rfirsthit = nhaylen-npatlen;
            rhitlen   = npatlen;
            return 1;
         }
         return 0;
      } else {
         // check for anywhere or start-of-line match
         int ihit = 0;
         bool brc = mystrhit(pszHay, pszPat, bCase, &ihit);
         if (!brc) return 0;
         if (bHead && ihit != 0) return 0;
         rfirsthit = ihit;
         rhitlen   = npatlen;
         if (cs.debug)
            printf("match:  direct at %d len %d\n",ihit,npatlen);
         rfirsthit = ihit;
         rhitlen   = npatlen;
         return 1;
      }
   }

   do
   {
      char *ppat = pszPat;       // pattern read cursor
      char *phay = pszHay+ibase; // haystack read cursor
 
      bool biskip = !bHead; // initial skip, add * at start
      ifirst = -1;     // pos'n of first matching char
      ilast  = -1;     // pos'n of last matching char
 
      bmatch=0;
      while (true)
      {
         if (!*ppat) {
            bmatch = 1;
            break;
         }

         char cpat  = 0;
         char cpat2 = 0;
         bool bdowc = cs.wpat; // do the wild char, or not
 
         if (biskip) {
            biskip = 0;
            cpat   = '*';
            if (cs.debug)
               printf("match:  process %c index %d \"%s\"\n", cpat, ppat-pszPat, ppat);
         } else {
            cpat  = *ppat++;
            cpat2 = *ppat;
            if (cs.debug)
               printf("match:  process %c index %d \"%s\"\n", cpat, ppat-pszPat-1, ppat-1);
         }
 
         // remapping of \\ \n \t \* \?
         if (cs.spat && cpat == '\\')  // spat.4 matchstr 22
         {
            switch (cpat2) {
               case '\\': ppat++; break;
               case 't' : ppat++; cpat = '\t'; break;
               case 'q' : ppat++; cpat = '"';  break;
               case '*' : ppat++; cpat = '*'; bdowc = 0; break;
               case '?' : ppat++; cpat = '?'; bdowc = 0; break;
               case 'x' :
                  if (ppat[1] && ppat[2]) {
                     cpat = (char)getTwoDigitHex(ppat+1);
                     ppat += 3;
                     bdowc = 0;
                  }
                  break;
            }
         }
 
         if (bdowc && cpat == '*')
         {
            // seek forward over *
            char cnext = peekpatchr(ppat, nesc);
            bool enext = (nesc > 0) ? 1 : 0;
            if (!cnext) { bmatch=1; break; }
            // **?
            if (!nesc && cnext == '*') continue;
            // isolate next non-* part
            int isrc=0,idst=0;
            while (idst<MAX_MATCH_BUF) {
               char csub = peekpatchr(ppat+isrc, nesc);
               if (nesc)
                  isrc += 1+nesc; // fetched \* or \xnn
               else {
                  if (!csub || csub == '*') break; // NO isrc increment on *
                  isrc++;
               }
               szMatchBuf[idst  ] = csub;
               szMatchEsc[idst++] = (bool)nesc;
            }
            szMatchBuf[idst] = '\0';
            szMatchEsc[idst] = '\0';
            ppat += isrc;
            if (cs.debug)
               printf("match:   check part \"%s\" cnext \"%c\" with hay at \"%.10s\"\n",szMatchBuf,cnext,phay);
            // find next occurrence of non-* part
            bool bsubmatch=0;
            while (*phay) {
               while (*phay && !cmpchr(*phay,cnext,bCase,enext)) phay++;
               if (!*phay) break;
               if (cs.debug)
                  printf("match:   from %.10s\n",phay);
               // matched first char, compare rest
               int isub=0;
               char *ppat2=szMatchBuf;
               bool *epat2=szMatchEsc;
               for (; phay[isub] && ppat2[isub]; isub++)
                  if (!cmpchr(phay[isub], ppat2[isub], bCase, epat2[isub]))
                     break;
               if (!ppat2[isub]) {
                  // rest matched: adapt hit positions
                  bsubmatch=1;
                  if (ifirst < 0)
                     ifirst = phay - pszHay;
                  ilast = phay - pszHay + isub - 1;
                  // jump past non-* part
                  if (cs.debug)
                     printf("match:   submatched \"%s\"\n",szMatchBuf);
                  phay += isub;
                  break;
               }
               // else retry from next position
               if (cs.debug)
                  printf("match:   submiss\n");
               phay++;
            }
            // synced past *
            if (!*ppat){
               if (bsubmatch) {
                  if (cs.debug)
                     printf("match:   full inner match, %d %d\n",ifirst,ilast);
                  bmatch=1;
               } else {
                  if (cs.debug)
                     printf("match:   full inner miss\n");
               }
               break; // match or miss
            }
            if (!*phay) break; // miss
            if (cs.debug)
               printf("match:   cont hay \"%.10s\" pat \"%.10s\"\n",phay,ppat);
            continue;
         }
         else
         {
            // compare single char, adapt match positions
            if (!cmpchr(*phay, cpat, bCase, 0)) {
               if (cs.debug)
                  printf("match:   miss at haychr \"%c\" msk %c position %d\n",*phay,cpat,phay-pszHay);
               break; // miss
            }
            if (ifirst < 0)
               ifirst = phay - pszHay;
            ilast  = phay - pszHay;
            phay++;
            // and continue
         }
      }  // end inner search loop
 
      if (cs.debug)
         printf("match:  1) ifirst %d ilast %d bmatch %d\n",ifirst,ilast,bmatch);

      if (bmatch) {
         // full hit somewhere, do we accept?
         if (!bTail) break;
         if (nhaylen > 0 && ilast == nhaylen-1) break;
         if (cs.debug)
            printf("match:  c) no line-end hit, %d != %d\n",ilast,nhaylen-1);
         // tail, and no hit at end: continue searching
      }
 
      if (ifirst < 0) break; // full miss
 
      ibase = ifirst+1; // try again
   }
   while (ibase < nhaylen);
 
   if (cs.debug)
      printf("match:  2) ifirst %d ilast %d bmatch %d for hay \"%s\" pat \"%s\"\n",ifirst,ilast,bmatch,pszHay,pszPat);

   if (bmatch && ifirst >= 0) {
      rfirsthit  = ifirst;
      if (ilast >= ifirst)
         rhitlen = (ilast-ifirst)+1;
      return 1;
   }

   return 0;
}

int indent(char *pszin) {
   char *psz = pszin;
   bool bempty = 1;
   for (; *psz; psz++)
      if (*psz != ' ' && *psz != '\t')
         { bempty = 0; break; }
   if (bempty) return -1;
   return psz-pszin;
}

// uses szLineBuf:
num getOldDirTime(char *pszName)
{
   // printf("gdt %s\n",pszName);
   if (!pszGlblDirTimes)
      return 0;
   // direct search of entry in text file
   sprintf(szLineBuf, " %s\r", pszName);
   char *psz1 = strstr(pszGlblDirTimes, szLineBuf);
   if (!psz1)
      return 0;
   // step back to start of line, with timestamp
   while ((psz1 > pszGlblDirTimes) && (*psz1 != '\n'))
      psz1--;
   // skip LF, if not in very first line
   if (psz1 > pszGlblDirTimes)
      psz1++;
   num nTime = atonum(psz1);
   // printf("-> TIME %u\n",nTime);
   return nTime;
}

bool equalFileName(char *psz1, char *psz2) {
   #ifdef _WIN32
   // Windows: expect case-insensitive filenames
   return (!_stricmp(psz1, psz2)) ? 1 : 0;
   #else
   // Unix: expect case-sensitive filenames
   return (!strcmp(psz1, psz2)) ? 1 : 0;
   #endif
}

bool strBegins(char *pszStr, cchar *pszPat) {
   if (!strncmp(pszStr, pszPat, strlen(pszPat)))
      return 1;
   return 0;
}

bool strbeg(char *pszStr, cchar *pszPat) {
   if (!strncmp(pszStr, pszPat, strlen(pszPat)))
      return 1;
   return 0;
}

bool striBegins(char *pszStr, cchar *pszPat) {
   if (!mystrnicmp(pszStr, pszPat, strlen(pszPat)))
      return 1;
   return 0;
}

bool strcase(char *pszStr, cchar *pszPat) {
   return strcmp(pszStr, pszPat) ? 0 : 1;
}

bool strEnds(char *pszStr, cchar *pszPat) {
   int nlenhay = strlen(pszStr);
   int nlenpat = strlen(pszPat);
   if (nlenhay < nlenpat) return 0;
   return !strcmp(pszStr+nlenhay-nlenpat, pszPat) ? 1 : 0;
}

bool striEnds(char *pszStr, cchar *pszPat) {
   int nlenhay = strlen(pszStr);
   int nlenpat = strlen(pszPat);
   if (nlenhay < nlenpat) return 0;
   return !mystricmp(pszStr+nlenhay-nlenpat, pszPat) ? 1 : 0;
}

bool startsLikeSnapFile(char *psz) {
   return strBegins(psz, ":snapfile sfk,") || strBegins(psz, ":cluster sfk,");
}

bool startsLikeActFile(char *psz) {
   return strBegins(psz, "<interleaved-attributes-text version=\"1.0\" prefix=\"\">");
}

class InfoCounter {
public:
   InfoCounter    ( );
   uint count    ( );  // RC > 0 says print the counter now
   bool  checkTime( );  // RC > 0 says print the counter now
   bool  countSkip(char *pszFile);
   uint value    ( );
   uint skipped  ( );
   char  *skipInfo( );
   void  reset    ( );
private:
   void  copyAll  ( );

   uint nClUnits;
   uint nClSkipped;
   num   nClTime;

   uint nClTellSteps;
   uint nClLastTold;
   uint nClTellSteps2;
   uint nClLastTold2;
   num   nClLastTimeTold;
   int  nClTimeInertia; // to avoid calling getCurrentTime() too often

   char  aClSkipInfo[100];
   int  nClSkipIdx;
};

InfoCounter::InfoCounter() { reset(); }

void InfoCounter::reset()
{
   nClUnits      = 0;
   nClSkipped    = 0;
   nClTime       = 0;

   nClLastTold   = 0;
   nClTellSteps  = 1;
   nClLastTold2  = 0;
   nClTellSteps2 = 1;
   nClLastTimeTold = 0;
   nClTimeInertia = 10;

   memset(aClSkipInfo, 0, sizeof(aClSkipInfo));
   // memset(aClSkipInfo, ' ', 5 * 3);
   nClSkipIdx = 2; // force switch to 0 on first add
}

void InfoCounter::copyAll() {
   nClLastTimeTold = nClTime;
   nClLastTold     = nClUnits;
   nClLastTold2    = nClSkipped;
   nClTimeInertia  = 10;
}

uint InfoCounter::value()    { return nClUnits; }
uint InfoCounter::skipped()  { return nClSkipped; }
char *InfoCounter::skipInfo() { return aClSkipInfo; }

uint InfoCounter::count() {
   nClUnits++;
   if (nClUnits >= (nClLastTold+nClTellSteps)) {
      nClTellSteps++;
      copyAll();
      return 1;
   }
   return checkTime();
}

bool InfoCounter::countSkip(char *pszFile)
{
   nClSkipped++;

   // mtklog(("countskip %s", pszFile));

   // update list of skipped file extensions
   char *pszInfo = pszFile;
   char *pszExt  = strrchr(pszInfo, '.');
   if (pszExt) pszInfo = pszExt;
   int nInfoLen = strlen(pszInfo);
   if (nInfoLen > 4) pszInfo = pszInfo + nInfoLen - 4;
   char *pszCur = &aClSkipInfo[5*nClSkipIdx];
   nInfoLen = strlen(pszInfo);
   if (   strncmp(&aClSkipInfo[ 0], pszInfo, nInfoLen)
       && strncmp(&aClSkipInfo[ 5], pszInfo, nInfoLen)
       && strncmp(&aClSkipInfo[10], pszInfo, nInfoLen)
      )
   {
      // there is a change, so step and write
      nClSkipIdx = (nClSkipIdx + 1) % 3;
      pszCur = &aClSkipInfo[5*nClSkipIdx];
      memset(pszCur, ' ', 5);
      strncpy(pszCur, pszInfo, nInfoLen);
      if (nClSkipIdx == 2)
         pszCur[4] = '\0';
   }

   // mtklog(("countskip info %s", aClSkipInfo));

   if (nClSkipped >= (nClLastTold2+nClTellSteps2)) {
      nClTellSteps2++;
      copyAll();
      return 1;
   }
   return checkTime();
}

bool InfoCounter::checkTime() {
   if (nClTimeInertia-- > 0)
      return 0;
   nClTimeInertia = 10;
   nClTime = getCurrentTime();
   if (nClTime > nClLastTimeTold + 1000) {
      copyAll();
      return 1;
   }
   return 0;
}

InfoCounter glblFileCount;

void resetFileCounter()   { glblFileCount.reset(); cs.lines = 0; }
bool fileCountCheckTime() { return glblFileCount.checkTime(); }

// --- sfk190 nocase with variable table ---

/*
   middle europe: 852 1250
   cyrillic     : 866 1251
   west.  europe: 850 1252
*/

// :middle europe
unsigned short glblCodePage1250[] = {
   0x80,0x20ac, 0x82,0x201a, 0x84,0x201e, 0x85,0x2026, 0x86,0x2020, 0x87,0x2021, 0x89,0x2030, 0x8a,0x0160,
   0x8b,0x2039, 0x8c,0x015a, 0x8d,0x0164, 0x8e,0x017d, 0x8f,0x0179, 0x91,0x2018, 0x92,0x2019, 0x93,0x201c,
   0x94,0x201d, 0x95,0x2022, 0x96,0x2013, 0x97,0x2014, 0x99,0x2122, 0x9a,0x0161, 0x9b,0x203a, 0x9c,0x015b,
   0x9d,0x0165, 0x9e,0x017e, 0x9f,0x017a, 0xa1,0x02c7, 0xa2,0x02d8, 0xa3,0x0141, 0xa5,0x0104, 0xaa,0x015e,
   0xaf,0x017b, 0xb2,0x02db, 0xb3,0x0142, 0xb9,0x0105, 0xba,0x015f, 0xbc,0x013d, 0xbd,0x02dd, 0xbe,0x013e,
   0xbf,0x017c, 0xc0,0x0154, 0xc3,0x0102, 0xc5,0x0139, 0xc6,0x0106, 0xc8,0x010c, 0xca,0x0118, 0xcc,0x011a,
   0xcf,0x010e, 0xd0,0x0110, 0xd1,0x0143, 0xd2,0x0147, 0xd5,0x0150, 0xd8,0x0158, 0xd9,0x016e, 0xdb,0x0170,
   0xde,0x0162, 0xe0,0x0155, 0xe3,0x0103, 0xe5,0x013a, 0xe6,0x0107, 0xe8,0x010d, 0xea,0x0119, 0xec,0x011b,
   0xef,0x010f, 0xf0,0x0111, 0xf1,0x0144, 0xf2,0x0148, 0xf5,0x0151, 0xf8,0x0159, 0xf9,0x016f, 0xfb,0x0171,
   0xfe,0x0163, 0xff,0x02d9,
   0,0
};

unsigned short glblCodePage852[] = {
   0x80,0x00c7, 0x81,0x00fc, 0x82,0x00e9, 0x83,0x00e2, 0x84,0x00e4, 0x85,0x016f, 0x86,0x0107, 0x87,0x00e7,
   0x88,0x0142, 0x89,0x00eb, 0x8a,0x0150, 0x8b,0x0151, 0x8c,0x00ee, 0x8d,0x0179, 0x8e,0x00c4, 0x8f,0x0106,
   0x90,0x00c9, 0x91,0x0139, 0x92,0x013a, 0x93,0x00f4, 0x94,0x00f6, 0x95,0x013d, 0x96,0x013e, 0x97,0x015a,
   0x98,0x015b, 0x99,0x00d6, 0x9a,0x00dc, 0x9b,0x0164, 0x9c,0x0165, 0x9d,0x0141, 0x9e,0x00d7, 0x9f,0x010d,
   0xa0,0x00e1, 0xa1,0x00ed, 0xa2,0x00f3, 0xa3,0x00fa, 0xa4,0x0104, 0xa5,0x0105, 0xa6,0x017d, 0xa7,0x017e,
   0xa8,0x0118, 0xa9,0x0119, 0xaa,0x00ac, 0xab,0x017a, 0xac,0x010c, 0xad,0x015f, 0xae,0x00ab, 0xaf,0x00bb,
   0xb0,0x2591, 0xb1,0x2592, 0xb2,0x2593, 0xb3,0x2502, 0xb4,0x2524, 0xb5,0x00c1, 0xb6,0x00c2, 0xb7,0x011a,
   0xb8,0x015e, 0xb9,0x2563, 0xba,0x2551, 0xbb,0x2557, 0xbc,0x255d, 0xbd,0x017b, 0xbe,0x017c, 0xbf,0x2510,
   0xc0,0x2514, 0xc1,0x2534, 0xc2,0x252c, 0xc3,0x251c, 0xc4,0x2500, 0xc5,0x253c, 0xc6,0x0102, 0xc7,0x0103,
   0xc8,0x255a, 0xc9,0x2554, 0xca,0x2569, 0xcb,0x2566, 0xcc,0x2560, 0xcd,0x2550, 0xce,0x256c, 0xcf,0x00a4,
   0xd0,0x0111, 0xd1,0x0110, 0xd2,0x010e, 0xd3,0x00cb, 0xd4,0x010f, 0xd5,0x0147, 0xd6,0x00cd, 0xd7,0x00ce,
   0xd8,0x011b, 0xd9,0x2518, 0xda,0x250c, 0xdb,0x2588, 0xdc,0x2584, 0xdd,0x0162, 0xde,0x016e, 0xdf,0x2580,
   0xe0,0x00d3, 0xe1,0x00df, 0xe2,0x00d4, 0xe3,0x0143, 0xe4,0x0144, 0xe5,0x0148, 0xe6,0x0160, 0xe7,0x0161,
   0xe8,0x0154, 0xe9,0x00da, 0xea,0x0155, 0xeb,0x0170, 0xec,0x00fd, 0xed,0x00dd, 0xee,0x0163, 0xef,0x00b4,
   0xf0,0x00ad, 0xf1,0x02dd, 0xf2,0x02db, 0xf3,0x02c7, 0xf4,0x02d8, 0xf5,0x00a7, 0xf6,0x00f7, 0xf7,0x00b8,
   0xf8,0x00b0, 0xf9,0x00a8, 0xfa,0x02d9, 0xfb,0x0171, 0xfc,0x0158, 0xfd,0x0159, 0xfe,0x25a0, 0xff,0x00a0,
   0,0
};

// :cyrillic
unsigned short glblCodePage1251[] = {
   0x80,0x0402, 0x81,0x0403, 0x82,0x201a, 0x83,0x0453, 0x84,0x201e, 0x85,0x2026, 0x86,0x2020, 0x87,0x2021,
   0x88,0x20ac, 0x89,0x2030, 0x8a,0x0409, 0x8b,0x2039, 0x8c,0x040a, 0x8d,0x040c, 0x8e,0x040b, 0x8f,0x040f,
   0x90,0x0452, 0x91,0x2018, 0x92,0x2019, 0x93,0x201c, 0x94,0x201d, 0x95,0x2022, 0x96,0x2013, 0x97,0x2014,
   0x99,0x2122, 0x9a,0x0459, 0x9b,0x203a, 0x9c,0x045a, 0x9d,0x045c, 0x9e,0x045b, 0x9f,0x045f, 0xa1,0x040e,
   0xa2,0x045e, 0xa3,0x0408, 0xa5,0x0490, 0xa8,0x0401, 0xaa,0x0404, 0xaf,0x0407, 0xb2,0x0406, 0xb3,0x0456,
   0xb4,0x0491, 0xb8,0x0451, 0xb9,0x2116, 0xba,0x0454, 0xbc,0x0458, 0xbd,0x0405, 0xbe,0x0455, 0xbf,0x0457,
   0xc0,0x0410, 0xc1,0x0411, 0xc2,0x0412, 0xc3,0x0413, 0xc4,0x0414, 0xc5,0x0415, 0xc6,0x0416, 0xc7,0x0417,
   0xc8,0x0418, 0xc9,0x0419, 0xca,0x041a, 0xcb,0x041b, 0xcc,0x041c, 0xcd,0x041d, 0xce,0x041e, 0xcf,0x041f,
   0xd0,0x0420, 0xd1,0x0421, 0xd2,0x0422, 0xd3,0x0423, 0xd4,0x0424, 0xd5,0x0425, 0xd6,0x0426, 0xd7,0x0427,
   0xd8,0x0428, 0xd9,0x0429, 0xda,0x042a, 0xdb,0x042b, 0xdc,0x042c, 0xdd,0x042d, 0xde,0x042e, 0xdf,0x042f,
   0xe0,0x0430, 0xe1,0x0431, 0xe2,0x0432, 0xe3,0x0433, 0xe4,0x0434, 0xe5,0x0435, 0xe6,0x0436, 0xe7,0x0437,
   0xe8,0x0438, 0xe9,0x0439, 0xea,0x043a, 0xeb,0x043b, 0xec,0x043c, 0xed,0x043d, 0xee,0x043e, 0xef,0x043f,
   0xf0,0x0440, 0xf1,0x0441, 0xf2,0x0442, 0xf3,0x0443, 0xf4,0x0444, 0xf5,0x0445, 0xf6,0x0446, 0xf7,0x0447,
   0xf8,0x0448, 0xf9,0x0449, 0xfa,0x044a, 0xfb,0x044b, 0xfc,0x044c, 0xfd,0x044d, 0xfe,0x044e, 0xff,0x044f,
   0,0
};

unsigned short glblCodePage866[] = {
   0x80,0x0410, 0x81,0x0411, 0x82,0x0412, 0x83,0x0413, 0x84,0x0414, 0x85,0x0415, 0x86,0x0416, 0x87,0x0417,
   0x88,0x0418, 0x89,0x0419, 0x8a,0x041a, 0x8b,0x041b, 0x8c,0x041c, 0x8d,0x041d, 0x8e,0x041e, 0x8f,0x041f,
   0x90,0x0420, 0x91,0x0421, 0x92,0x0422, 0x93,0x0423, 0x94,0x0424, 0x95,0x0425, 0x96,0x0426, 0x97,0x0427,
   0x98,0x0428, 0x99,0x0429, 0x9a,0x042a, 0x9b,0x042b, 0x9c,0x042c, 0x9d,0x042d, 0x9e,0x042e, 0x9f,0x042f,
   0xa0,0x0430, 0xa1,0x0431, 0xa2,0x0432, 0xa3,0x0433, 0xa4,0x0434, 0xa5,0x0435, 0xa6,0x0436, 0xa7,0x0437,
   0xa8,0x0438, 0xa9,0x0439, 0xaa,0x043a, 0xab,0x043b, 0xac,0x043c, 0xad,0x043d, 0xae,0x043e, 0xaf,0x043f,
   0xb0,0x2591, 0xb1,0x2592, 0xb2,0x2593, 0xb3,0x2502, 0xb4,0x2524, 0xb5,0x2561, 0xb6,0x2562, 0xb7,0x2556,
   0xb8,0x2555, 0xb9,0x2563, 0xba,0x2551, 0xbb,0x2557, 0xbc,0x255d, 0xbd,0x255c, 0xbe,0x255b, 0xbf,0x2510,
   0xc0,0x2514, 0xc1,0x2534, 0xc2,0x252c, 0xc3,0x251c, 0xc4,0x2500, 0xc5,0x253c, 0xc6,0x255e, 0xc7,0x255f,
   0xc8,0x255a, 0xc9,0x2554, 0xca,0x2569, 0xcb,0x2566, 0xcc,0x2560, 0xcd,0x2550, 0xce,0x256c, 0xcf,0x2567,
   0xd0,0x2568, 0xd1,0x2564, 0xd2,0x2565, 0xd3,0x2559, 0xd4,0x2558, 0xd5,0x2552, 0xd6,0x2553, 0xd7,0x256b,
   0xd8,0x256a, 0xd9,0x2518, 0xda,0x250c, 0xdb,0x2588, 0xdc,0x2584, 0xdd,0x258c, 0xde,0x2590, 0xdf,0x2580,
   0xe0,0x0440, 0xe1,0x0441, 0xe2,0x0442, 0xe3,0x0443, 0xe4,0x0444, 0xe5,0x0445, 0xe6,0x0446, 0xe7,0x0447,
   0xe8,0x0448, 0xe9,0x0449, 0xea,0x044a, 0xeb,0x044b, 0xec,0x044c, 0xed,0x044d, 0xee,0x044e, 0xef,0x044f,
   0xf0,0x0401, 0xf1,0x0451, 0xf2,0x0404, 0xf3,0x0454, 0xf4,0x0407, 0xf5,0x0457, 0xf6,0x040e, 0xf7,0x045e,
   0xf8,0x00b0, 0xf9,0x2219, 0xfa,0x00b7, 0xfb,0x221a, 0xfc,0x2116, 0xfd,0x00a4, 0xfe,0x25a0, 0xff,0x00a0,
   0,0
};

// :western
unsigned short glblCodePage1252[] = {
   0x80,0x20ac, 0x82,0x201a, 0x83,0x0192, 0x84,0x201e, 0x85,0x2026, 0x86,0x2020, 0x87,0x2021, 0x88,0x02c6,
   0x89,0x2030, 0x8a,0x0160, 0x8b,0x2039, 0x8c,0x0152, 0x8e,0x017d, 0x91,0x2018, 0x92,0x2019, 0x93,0x201c,
   0x94,0x201d, 0x95,0x2022, 0x96,0x2013, 0x97,0x2014, 0x98,0x02dc, 0x99,0x2122, 0x9a,0x0161, 0x9b,0x203a,
   0x9c,0x0153, 0x9e,0x017e, 0x9f,0x0178,
   0,0
};

unsigned short glblCodePage850[] = {
   0x80,0x00c7, 0x81,0x00fc, 0x82,0x00e9, 0x83,0x00e2, 0x84,0x00e4, 0x85,0x00e0, 0x86,0x00e5, 0x87,0x00e7,
   0x88,0x00ea, 0x89,0x00eb, 0x8a,0x00e8, 0x8b,0x00ef, 0x8c,0x00ee, 0x8d,0x00ec, 0x8e,0x00c4, 0x8f,0x00c5,
   0x90,0x00c9, 0x91,0x00e6, 0x92,0x00c6, 0x93,0x00f4, 0x94,0x00f6, 0x95,0x00f2, 0x96,0x00fb, 0x97,0x00f9,
   0x98,0x00ff, 0x99,0x00d6, 0x9a,0x00dc, 0x9b,0x00f8, 0x9c,0x00a3, 0x9d,0x00d8, 0x9e,0x00d7, 0x9f,0x0192,
   0xa0,0x00e1, 0xa1,0x00ed, 0xa2,0x00f3, 0xa3,0x00fa, 0xa4,0x00f1, 0xa5,0x00d1, 0xa6,0x00aa, 0xa7,0x00ba,
   0xa8,0x00bf, 0xa9,0x00ae, 0xaa,0x00ac, 0xab,0x00bd, 0xac,0x00bc, 0xad,0x00a1, 0xae,0x00ab, 0xaf,0x00bb,
   0xb0,0x2591, 0xb1,0x2592, 0xb2,0x2593, 0xb3,0x2502, 0xb4,0x2524, 0xb5,0x00c1, 0xb6,0x00c2, 0xb7,0x00c0,
   0xb8,0x00a9, 0xb9,0x2563, 0xba,0x2551, 0xbb,0x2557, 0xbc,0x255d, 0xbd,0x00a2, 0xbe,0x00a5, 0xbf,0x2510,
   0xc0,0x2514, 0xc1,0x2534, 0xc2,0x252c, 0xc3,0x251c, 0xc4,0x2500, 0xc5,0x253c, 0xc6,0x00e3, 0xc7,0x00c3,
   0xc8,0x255a, 0xc9,0x2554, 0xca,0x2569, 0xcb,0x2566, 0xcc,0x2560, 0xcd,0x2550, 0xce,0x256c, 0xcf,0x00a4,
   0xd0,0x00f0, 0xd1,0x00d0, 0xd2,0x00ca, 0xd3,0x00cb, 0xd4,0x00c8, 0xd5,0x0131, 0xd6,0x00cd, 0xd7,0x00ce,
   0xd8,0x00cf, 0xd9,0x2518, 0xda,0x250c, 0xdb,0x2588, 0xdc,0x2584, 0xdd,0x00a6, 0xde,0x00cc, 0xdf,0x2580,
   0xe0,0x00d3, 0xe1,0x00df, 0xe2,0x00d4, 0xe3,0x00d2, 0xe4,0x00f5, 0xe5,0x00d5, 0xe6,0x00b5, 0xe7,0x00fe,
   0xe8,0x00de, 0xe9,0x00da, 0xea,0x00db, 0xeb,0x00d9, 0xec,0x00fd, 0xed,0x00dd, 0xee,0x00af, 0xef,0x00b4,
   0xf0,0x00ad, 0xf1,0x00b1, 0xf2,0x2017, 0xf3,0x00be, 0xf4,0x00b6, 0xf5,0x00a7, 0xf6,0x00f7, 0xf7,0x00b8,
   0xf8,0x00b0, 0xf9,0x00a8, 0xfa,0x00b7, 0xfb,0x00b9, 0xfc,0x00b3, 0xfd,0x00b2, 0xfe,0x25a0, 0xff,0x00a0,
   0,0
};

SFKChars sfkchars;

SFKChars::SFKChars( )
{
   memset(this, 0, sizeof(*this));

   #ifndef _WIN32
   iclocp = 850;  // linux/mac default
   iclacp = 1252; // linux/mac default
   #endif
}

/*
   even if the system has codepage 1252 the fixed glblCodePage1252
   is used internally, assuring the same behaviour on all computers
   in case that -isochars is used.
*/
ushort SFKChars::ibytetouni(uchar c, ushort icp)
{
   ushort *pfixedcp=0;
   bool bdos=0;

   switch (icp)
   {
      case 1250: pfixedcp = glblCodePage1250; break;
      case  852: pfixedcp = glblCodePage852;  bdos=1; break;
      case 1251: pfixedcp = glblCodePage1251; break;
      case  866: pfixedcp = glblCodePage866;  bdos=1; break;
      case 1252: pfixedcp = glblCodePage1252; break;
      case  850: pfixedcp = glblCodePage850;  bdos=1; break;
   }
   if (pfixedcp) {
      for (int i=0; pfixedcp[i]; i+=2)
         if (pfixedcp[i+0]==c)
            return pfixedcp[i+1];
      // Ansi: everything else maps 1:1
      // Dos : everything else >= 0x80 does not exist
      return c;
   }

   #ifdef _WIN32

   sztmp[0] = c;
   sztmp[1] = 0;

   awtmp[0] = 0;

   MultiByteToWideChar( // win.varcp
      icp, 0, sztmp, 1,
      (wchar_t*)awtmp, 10
      );

   ushort ntmp = awtmp[0];

   if (ntmp)
      return ntmp;

   #endif

   return 0;
}

int SFKChars::setocp(ushort i)
{
   switch (i) 
   {
      // support for unzip -fromcode:
      case 1250: case 1251: case 1252:
         if (!banycp)
            return 9;
         // else fall through
      #ifdef _WIN32
      default:
      #endif
      case 852: case 866: case 850:
         iclocp=i;
         bsysocp=0;
         bclinited=0;
         return 0;
   }
   return 9;
}

int SFKChars::setacp(ushort i)
{
   switch (i) 
   {
      #ifdef _WIN32
      default:
      #endif
      case 1250: case 1251: case 1252:
         iclacp=i;
         bsysacp=0;
         bclinited=0;
         return 0;
   }
   return 9;
}

ushort SFKChars::getocp( )
   { init(); return iclocp; }

ushort SFKChars::getacp( )
   { init(); return iclacp; }

int SFKChars::init( )
{
   if (bclinited)
      return 0;

   ushort n1=iclocp;
   ushort n2=iclacp;
    memset(this, 0, sizeof(*this));
   iclocp=n1;
   iclacp=n2;
   bclinited = 1;

   #ifdef _WIN32

   if (iclocp==0) {
      iclocp = GetOEMCP();
      bsysocp = 1;
   }

   if (iclacp==0) {
      iclacp = GetACP();
      bsysacp = 1;
   }

   #endif

   ushort coem=0,cans=0,cuni=0;
   ushort noemmaps=0,nansmaps=0;

   // build byte to uni mapping
   for (ushort i=0; i<256; i++)
   {
      coem = i;
      cuni = ibytetouni(coem, iclocp);
      amap1[coem] = cuni;
      amap2[cuni] = coem;
      if (i >= 0x80 && cuni != 0)
         noemmaps++;

      cans = i;
      cuni = ibytetouni(cans, iclacp);
      amap3[cans] = cuni;
      amap4[cuni] = cans;
      if (i >= 0x80 && cuni != 0)
         nansmaps++;
   }

   if (noemmaps < 1) return 10;
   if (nansmaps < 1) return 11;

   // build byte crossmapping
   for (ushort i=0; i<256; i++)
   {
      coem = i;
      cuni = oemtouni(coem);
      cans = unitoansi(cuni);
      amap5[coem] = cans ? cans : '?';
      if (!cans)
         amap5err[coem] = 1;

      cans = i;
      cuni = ansitouni(cans);
      coem = unitooem(cuni);
      amap6[cans] = coem ? coem : '?';
      if (!coem)
         amap6err[cans] = 1;
   }

   return 0;
}

ushort SFKChars::ansitouni(uchar  c)
   { init(); return amap3[c]; }

ushort SFKChars::oemtouni(uchar  c)
   { init(); return amap1[c]; }

uchar SFKChars::unitoansi(ushort n)
   { init(); return amap4[n]; }

uchar SFKChars::unitooem(ushort n)
   { init(); return amap2[n]; }

uchar SFKChars::oemtoansi(uchar  c)
   { init(); return amap5[c]; }

uchar SFKChars::ansitooem(uchar  c)
   { init(); return amap6[c]; }

int SFKChars::stroemtoansi(char *psz, int *pChg, bool bNoDefault)
{
   int ifailed=0;
   init();
   for (; *psz; psz++)
   {
      if (amap5err[(uchar)*psz]) {
         ifailed++;
         if (bNoDefault)
            continue;
      }
      char c = amap5[(uchar)*psz];
      if (pChg!=0 && *psz!=c)
         *pChg++;
      *psz = c;
   }
   return ifailed;
}

int SFKChars::stransitooem(char *psz, int *pChg, bool bNoDefault)
{
   int ifailed=0;
   init();
   for (; *psz; psz++)
   {
      if (amap6err[(uchar)*psz]) {
         ifailed++;
         if (bNoDefault)
            continue;
      }
      char c = (char)amap6[(uchar)*psz];
      if (pChg!=0 && *psz!=c)
         *pChg++;
      *psz = c;
   }
   return ifailed;
}

int SFKChars::strunitoansi(ushort *puni, int iunilen,
   char *pansi, int imaxansi)
{
   if (imaxansi < 1)
      return 10;

   init();

   int irc = 0;

   ushort *punicur = puni;
   ushort *punimax = puni+iunilen;
   uchar  *panscur = (uchar*)pansi;
   uchar  *pansmax = panscur+imaxansi;

   while (punicur<punimax && panscur+4<pansmax)
   {
      ushort nuni = *punicur++;
      uchar  cans = unitoansi(nuni);
      if (!cans)
         { cans = '?'; irc = 9; }
      *panscur++ = cans;
   }

   *panscur = '\0';

   return irc;
}

int SFKChars::wlen(ushort *puni)
{
   ushort *pcur=puni;
   while (*pcur) pcur++;
   return (int)(pcur - puni);
}

num getAnsiToUTFSize(char *psrc)
{
   char szTmp[100];

   num nout = 0;

   while (*psrc!=0)
   {
      uchar cans  = *psrc++;
      ushort nuni = sfkchars.ansitouni(cans);
      nout += UTF8Codec::toutf8((char*)szTmp, 10, nuni);
   }

   return nout;
}

int ansiToUTF(char *pdst, int imaxdst, char *psrc)
{
   char *pdstcur=pdst;
   char *pdstmax=pdst+imaxdst;
   while (*psrc!=0 && pdstcur+10<pdstmax)
   {
      uchar cans  = *psrc++;
      ushort nuni = sfkchars.ansitouni(cans);
      int iwrite  = UTF8Codec::toutf8((char*)pdstcur, 10, nuni);
      pdstcur += iwrite;
   }
   *pdstcur = '\0';
   return 0;
}

void utfToAnsi(char *pdst, int imaxdst, char *psrc)
{
   UTF8Codec utf(psrc);

   char *pdstcur = pdst;
   char *pdstmax = pdst+imaxdst;

   while (pdstcur+10<pdstmax)
   {
      ushort nuni = utf.nextChar();
      if (nuni == 0)
         break;
      uchar cans = sfkchars.unitoansi(nuni);
      *pdstcur++ = cans ? cans : '?';
   }
   *pdstcur = '\0';
}

char *ansiToUTF(char *psrc) {
   static char aaBuf[3][MAX_LINE_LEN+10];
   static int  iaBuf=0;
   iaBuf = (iaBuf+1)%3;
   ansiToUTF(aaBuf[iaBuf],MAX_LINE_LEN,psrc);
   return aaBuf[iaBuf];
}
char *utfToAnsi(char *psrc) {
   static char aaBuf[3][MAX_LINE_LEN+10];
   static int  iaBuf=0;
   iaBuf = (iaBuf+1)%3;
   utfToAnsi(aaBuf[iaBuf],MAX_LINE_LEN,psrc);
   return aaBuf[iaBuf];
}

/*
   -  so far windows dependent,
      linux maps only basic latin chars

   -  unicode mapping of many special chars
*/

extern unsigned short atol1to1[];
extern unsigned short atolfuzz[];

SFKNoCase sfknocasesharp(0);
SFKNoCase sfknocasefuzz(1);

SFKNoCase::SFKNoCase(bool bfuzz)
{
   memset(this,0,sizeof(*this));

   bclfuzz = bfuzz;
}

void SFKNoCase::tellPage( )
{
   if (bcltoldcp)
      return;
   bcltoldcp = 1;
   sfkchars.init();
   printf("[nocase : using %s Ansi page %u for mapping, %s OEM page %u for display]\n",
      sfkchars.bsysacp ? "system":"fixed", sfkchars.iclacp,
      sfkchars.bsysocp ? "system":"fixed", sfkchars.iclocp
      );
}

#ifndef SWINST

uchar SFKNoCase::map1to1(uchar c, uchar btolower, ushort auni[])
{
   auni[0] = 0;
   auni[1] = 0;

   ushort ntmp = sfkchars.ansitouni(c);

   if (!ntmp)
      return c;

   int i1 = btolower ? 0 : 1;
   int i2 = btolower ? 1 : 0;

   ushort *pmap = bclfuzz ? atolfuzz : atol1to1;
 
   ushort nout = 0;
   for (int i=0; pmap[i]; i+=2)
   {
      if (pmap[i+i1] == ntmp)
      {
         nout = pmap[i+i2];
         auni[0] = ntmp;
         auni[1] = nout;
         break;
      }
      if (pmap[i+i2] == ntmp)
      {
         // found ourselves as output.
         // for information fill in the code.
         auni[0] = pmap[i+i2];
         auni[1] = pmap[i+i1];
      }
   }

   if (!nout)
      return c;

   uchar cres = sfkchars.unitoansi(nout);

   if (!cres)
      return c;

   return cres;
}

#endif

char *getuniname(ushort ncode);

#ifndef SWINST
void listcodes(bool ball, bool bfull, bool btrace)
{
   ushort auni[2];

   // abbuf has at least 64 k for our marker table
   memset(abBuf, 0, MAX_ABBUF_SIZE);
   uchar *adone = abBuf;

   sfkchars.init();
   printf("List of character mappings in %s codepage %u.\n",
      sfkchars.bsysacp ? "system":"fixed",
      sfkchars.iclacp);
   if (cs.fuzz)
   printf("Using accent insensitive mappings by option -deacc.\n");
   printf("---------------------------------------------------\n");

   char szTrace[100];
   szTrace[0]='\0';
   uchar nlo=0, nhi=0;

   // Ansi and Unicodes
   for (uint n=32; n<256; n++)
   {
      if (btrace)
         sprintf(szTrace, "isa=%d/%d isp=%d/%d ", 
            sfkisalpha(n), isalpha(n),
            sfkisprint(n), isprint(n)
            );

      if (cs.fuzz) {
         nlo = sfknocasefuzz.map1to1((uchar)n, 1, auni);
         nhi = sfknocasefuzz.map1to1((uchar)n, 0, auni);
      } else {
         nlo = sfknocasesharp.map1to1((uchar)n, 1, auni);
         nhi = sfknocasesharp.map1to1((uchar)n, 0, auni);
      }

      char *pname1 = getuniname(auni[0]);
      char *pname2 = getuniname(auni[1]);

      if (nlo != n) {
         oprintf("%c 0x%02x U+%04X -> %c 0x%02x U+%04X %s%s\n", 
            (char)n, n, auni[0],
            (char)nlo, nlo, auni[1], szTrace, pname1
            );
         adone[auni[0]] = 1;
         adone[auni[1]] = 1;
       } else if (nhi != n) {
         oprintf("%c 0x%02x U+%04X -> %c 0x%02x U+%04X %s%s\n",
            (char)n, n, auni[0],
            (char)nhi, nhi, auni[1], szTrace, pname1
            );
         adone[auni[0]] = 1;
         adone[auni[1]] = 1;
      } else if (bfull) {
         auni[0] = sfkchars.ansitouni((uchar)n);
         pname1 = getuniname(auni[0]);
         oprintf("%c 0x%02x U+%04X -> - ---- ------ %s%s\n",
            (char)n, n, auni[0],
            szTrace, pname1
            );
         adone[auni[0]] = 1;
      }
   }

   if (!ball)
      return;

   printf("\n");
   printf("List of character mappings not supported on your system:\n");
   printf("--------------------------------------------------------\n");

   // just Unicodes
   bool btolower = 1;
   int i1 = btolower ? 0 : 1;
   int i2 = btolower ? 1 : 0;
   ushort *pmap = atol1to1;
   for (uint n=32; n<65536; n++)
   {
      if (adone[n])
         continue;
      ushort nout = 0;
      for (int i=0; pmap[i]; i+=2)
      {
         // tolower mapping?
         if (pmap[i+0] == n)
         {
            nout = pmap[i+1];
            char *pname1 = getuniname(n);
            oprintf("U+%04X -> U+%04X %s\n", n, nout, pname1);
            break;
         }
         // toupper mapping?
         if (pmap[i+1] == n)
         {
            nout = pmap[i+0];
            char *pname1 = getuniname(n);
            oprintf("U+%04X -> U+%04X %s\n", n, nout, pname1);
            break;
         }
      }
   }
}
#endif

uchar SFKNoCase::itolower(uchar c)
{
   #ifdef SWINST

   return tolower(c);

   #else

   #ifdef _WIN32

   if (cs.nocasemin)
      return tolower(c);

   ushort auni[2];

   if (atolower[c])
      return atolower[c];

   atolower[c] = map1to1(c, 1, auni);

   if (atolower[c] != c)
      aisalpha[c] = 1;
   else if (auni[0] != 0 && auni[0] == auni[1])
      aisalpha[c] = 1; // e.g. 01A6;LATIN LETTER YR

   if (cs.tracecase) 
   {
      tellPage();
      char *pname1 = getuniname(auni[0]);
      char *pname2 = getuniname(auni[1]);
      if (atolower[c] != c)
         oprintf("[tolower: Ansi %c 0x%02x U+%04x -> %c 0x%02x U+%04x - %s]\n",
            c, c, auni[0], 
            atolower[c], atolower[c], auni[1], pname1);
      else if (cs.tracecase > 1)
         oprintf("[tolower: Ansi %c 0x%02x U+%04x -- no lo mapping - %s]\n",
            c, c, auni[0], pname1);
   }

   return atolower[c];

   #else

   return tolower(c);

   #endif

   #endif
}

uchar SFKNoCase::itoupper(uchar c)
{
   #ifdef SWINST

   return toupper(c);

   #else

   #ifdef _WIN32

   if (cs.nocasemin)
      return toupper(c);

   ushort auni[2];

   if (atoupper[c])
      return atoupper[c];

   atoupper[c] = map1to1(c, 0, auni);

   if (atoupper[c] != c)
      aisalpha[c] = 1;
   else if (auni[0] != 0 && auni[0] == auni[1])
      aisalpha[c] = 1; // e.g. 01A6;LATIN LETTER YR

   if (cs.tracecase)
   {
      tellPage();
      char *pname1 = getuniname(auni[0]);
      char *pname2 = getuniname(auni[1]);
      if (atoupper[c] != c)
         oprintf("[toupper: Ansi %c 0x%02x U+%04x -> %c 0x%02x U+%04x - %s]\n",
            c, c, auni[0],
            atoupper[c], atoupper[c], auni[1], pname1);
      else if (cs.tracecase > 1)
         oprintf("[toupper: Ansi %c 0x%02x U+%04x -- no up mapping - %s]\n",
            c, c, auni[0], pname1);
   }

   return atoupper[c];

   #else

   return toupper(c); // FIX sfk193 linux case insensitivity

   #endif

   #endif
}

void SFKNoCase::isetStringToLower(char *psz)
{
   for (int i=0; psz[i]; i++)
   {
      psz[i] = itolower((uchar)psz[i]);
   }
}

bool SFKNoCase::iisalpha(uchar c)
{
   if (aisalpha[c] == 0) // not yet checked
   {
      if (isalpha(c))
         aisalpha[c] = 1;
      else {
         if (itolower(c) != c)
            aisalpha[c] = 1;
         else
         if (itoupper(c) != c)
            aisalpha[c] = 1;
         else
            aisalpha[c] = 2;
      }
   }
   if (aisalpha[c] == 1)
      return 1;
   return 0;
}

bool SFKNoCase::iisalnum(uchar c)
{
   if (iisalpha(c))
      return 1;
   if (isdigit(c))
      return 1;
   return 0;
}

bool SFKNoCase::iisprint(uchar uc)
{
   if (iisalpha(uc))
      return 1;
   if (isdigit(uc))
      return 1;
   // linux: isprint(':') returns 16384
   // so never return the value directly.
   if (isprint((char)uc))
      return 1;
   return 0;
}

int sfktolower(int c) 
{
   // nocase search uses tolower for matching,
   // so -deacc is applied.
   if (cs.fuzz)
      return sfknocasefuzz.itolower(c);
   else
      return sfknocasesharp.itolower(c);
}

void sfkSetStringToLower(char *psz)
{
   if (cs.fuzz)
      return sfknocasefuzz.isetStringToLower(psz);
   else
      return sfknocasesharp.isetStringToLower(psz);
}

uchar sfkMapChar(char ch, uchar bCase)
{
   if (cs.fuzz)
      return sfknocasefuzz.mapChar(ch, bCase);
   else
      return sfknocasesharp.mapChar(ch, bCase);
}

uchar sfkLowerUChar(uchar c)
{
   if (cs.fuzz)
      return sfknocasefuzz.lowerUChar(c);
   else
      return sfknocasesharp.lowerUChar(c);
}

uchar sfkUpperUChar(uchar c)
{
   return sfknocasesharp.lowerUChar(c);
}

// set all possible matches for this character
void sfkSetHeadMatch(uchar ucFirst, uchar aHeadMatch[])
{
   if (cs.fuzz == 0)
   {
      // normally there is a 1:1 mapping of lower- and upper char.
      aHeadMatch[sfktoupper(ucFirst)&0xFF] = 1;
      aHeadMatch[sfktolower(ucFirst)&0xFF] = 1;
      return;
   }

   // with -deacc many codes may map to a single char.
   // user types a, it can match a A a_accent A_accent etc.
   ucFirst = sfktolower(ucFirst);
   aHeadMatch[ucFirst] = 1;
   for (ushort n=1; n<256; n++)
   {
      if (sfktolower(n) == ucFirst) aHeadMatch[n] = 1;
      // if (sfktoupper(n) == ucFirst) aHeadMatch[n] = 1;
   }
}

int sfktoupper(int c) 
{
   // toupper is never used in nocase comparisons,
   // so -deacc does not apply.
   return sfknocasesharp.itoupper(c);
}

bool sfkisalpha(uchar uc)
{
   if (cs.nocasemin)
      return isalpha((char)uc) ? 1 : 0;
      // converts int value eg. 16384 to bool!

   return sfknocasesharp.iisalpha(uc); 
}

bool sfkisalnum(uchar uc)
{ 
   if (cs.nocasemin)
      return isalnum((char)uc) ? 1 : 0;
      // converts int value eg. 16384 to bool!

   return sfknocasesharp.iisalnum(uc); 
}

bool sfkisprint(uchar uc)
{
   if (cs.nocasemin)
      return isprint((char)uc) ? 1 : 0;
      // converts int value eg. 16384 to bool!

   return sfknocasesharp.iisprint(uc); 
}

// void sfkSetAccentSupport(bool b) // sfk190 deprecated
// {
//    gs.noaccent = cs.noaccent = b ? 0 : 1;
// }

// --- nocase derived functions ---

#ifdef WITH_CASE_XNN
// RC : 0 == match, <> 0 == no match.
// Not suitable for sorting algorithms.
int sfkmemcmp2(uchar *psrc1, uchar *psrc2, num nlen, bool bGlobalCase, uchar *pFlags)
{
   if (bGlobalCase)
      return memcmp(psrc1, psrc2, nlen);

   int idiff=0;

   // optim: compare last character first.
   // requires at least a 2-char phrase.
   if (nlen > 1)
   {
      uchar bCase = pFlags ? sfkGetBit(pFlags,nlen-1) : 0;
      idiff =     sfkMapChar(psrc1[nlen-1],bCase)
               -  sfkMapChar(psrc2[nlen-1],bCase);
      if (idiff)
         return idiff;
   }

   uchar bCase;

   for (int i=0; i<nlen; i++)
   {
      bCase = pFlags ? sfkGetBit(pFlags,i) : 0;
      idiff =     sfkMapChar(psrc1[i],bCase)
               -  sfkMapChar(psrc2[i],bCase);
      if (idiff)
         break;
   }

   return idiff;
}
#endif

// RC : 0 == match, <> 0 == no match.
// Not suitable for sorting algorithms.
int sfkmemcmp3(uchar *psrc, uchar *ppat, num nlen, bool bGlobalCase, uchar *pPatFlags, int iPatOff)
{
   ppat += iPatOff;

   if (bGlobalCase)
      return memcmp(psrc, ppat, nlen);

   int idiff=0;

   // optim: compare last character first.
   // requires at least a 2-char phrase.
   if (nlen > 1)
   {
      uchar bCase = pPatFlags ? sfkGetBit(pPatFlags,nlen+iPatOff-1) : 0;
      idiff =     sfkMapChar(psrc[nlen-1],bCase)
               -  sfkMapChar(ppat[nlen-1],bCase);
      if (idiff)
         return idiff;
   }

   uchar bCase;

   for (int i=0; i<nlen; i++)
   {
      bCase = pPatFlags ? sfkGetBit(pPatFlags,iPatOff+i) : 0;
      idiff =     sfkMapChar(psrc[i],bCase)
               -  sfkMapChar(ppat[i],bCase);
      if (idiff)
         break;
   }

   return idiff;
}

// RC : 0 == match, <> 0 == no match.
// Not suitable for sorting algorithms.
int sfkmemcmp(uchar *psrc1, uchar *psrc2, num nlen, bool bcase)
{
   if (bcase)
      return memcmp(psrc1, psrc2, nlen);

   num i=0, idiff=0;

   // optim: compare last character first.
   // requires at least a 2-char phrase.
   if (nlen > 1)
   {
      idiff =     sfkLowerUChar(psrc1[nlen-1])
               -  sfkLowerUChar(psrc2[nlen-1]);
      if (idiff)
         return idiff;
   }

   for (; i<nlen; i++)
   {
      idiff =     sfkLowerUChar(psrc1[i])
               -  sfkLowerUChar(psrc2[i]);

      if (idiff)
         break;
   }

   return idiff;
}

#ifdef WITH_CASE_XNN
uchar *memIFind(uchar *pNeedle, num nNeedleSize, uchar *pHayStack, num nHaySize, uchar *pFlags)
{
   uchar *pCur = pHayStack;
   uchar *pMax = pHayStack + nHaySize - nNeedleSize; // inclusive
   uchar bCase = pFlags ? sfkGetBit(pFlags,0) : 0;
   uchar c1    = sfkMapChar(*pNeedle,bCase);
   while (pCur <= pMax)
   {
      uchar *p1 = pCur;
      // seek to next potential start
      while ((p1 <= pMax) && (sfkMapChar(*p1,bCase) != c1))
         p1++;
      if (!p1 || (p1 > pMax))
         return 0;
      // compare from p1, case-insensitive
      // pMax assures that from p1, there are at least nNeedleSize
      // bytes available for actual compare, so we don't check
      // p1 against pMax again here.
      num i=0;
      for (; i<nNeedleSize; i++) {
         bCase = pFlags ? sfkGetBit(pFlags,i) : 0;
         if (sfkMapChar(pNeedle[i],bCase) != sfkMapChar(p1[i],bCase))
            break;
      }
      if (i >= nNeedleSize)
         return p1;  // hit
      // no hit, proceed
      pCur = p1+1;
   }
   return 0;
}
#else
uchar *memIFind(uchar *pNeedle, num nNeedleSize, uchar *pHayStack, num nHaySize)
{
   uchar *pCur = pHayStack;
   uchar *pMax = pHayStack + nHaySize - nNeedleSize; // inclusive
   uchar c1    = sfkLowerUChar(*pNeedle);
   while (pCur <= pMax)
   {
      uchar *p1 = pCur;
      // seek to next potential start
      while ((p1 <= pMax) && (sfkLowerUChar(*p1) != c1))
         p1++;
      if (!p1 || (p1 > pMax))
         return 0;
      // compare from p1, case-insensitive
      // pMax assures that from p1, there are at least nNeedleSize
      // bytes available for actual compare, so we don't check
      // p1 against pMax again here.
      num i=0;
      for (; i<nNeedleSize; i++)
         if (sfkLowerUChar(pNeedle[i]) != sfkLowerUChar(p1[i]))
            break;
      if (i >= nNeedleSize)
         return p1;  // hit
      // no hit, proceed
      pCur = p1+1;
   }
   return 0;
}
#endif

char *dataAsHex(void *pAnyData, int iDataSize, char *pszBuf, int iMaxBuf, bool bLowerCase)
{
   static char szBuf[300];

   if (!pszBuf)
   {
      pszBuf = szBuf;
      iMaxBuf = sizeof(szBuf);
   }
 
   uchar *pSrcCur = (uchar *)pAnyData;
   uchar *pSrcMax = pSrcCur + iDataSize;
 
   char *pszDstCur = pszBuf;
   char *pszDstMax = pszBuf + iMaxBuf - 20;
 
   while (pSrcCur < pSrcMax && pszDstCur < pszDstMax)
   {
      uchar uc = *pSrcCur++;
      if (bLowerCase)
         sprintf(pszDstCur, "%02x", uc);
      else
         sprintf(pszDstCur, "%02X", uc);
      pszDstCur += 2;
   }
 
   *pszDstCur = '\0';
 
   return pszBuf;
}

char *dataAsTrace(void *pAnyData, int iDataSize, char *pszBuf, int iMaxBuf)
{
   static char szBuf[300];

   if (iDataSize == -1)
       iDataSize = strlen((char*)pAnyData);

   if (!pszBuf)
   {
      pszBuf = szBuf;
      iMaxBuf = sizeof(szBuf);
   }
 
   uchar *pSrcCur = (uchar *)pAnyData;
   uchar *pSrcMax = pSrcCur + iDataSize;
 
   char *pszDstCur = pszBuf;
   char *pszDstMax = pszBuf + iMaxBuf - 20;
 
   while (pSrcCur < pSrcMax && pszDstCur < pszDstMax)
   {
      uchar uc = *pSrcCur++;
 
      if (isprint((char)uc))
      {
         *pszDstCur++ = (char)uc;
         continue;
      }

      // convert binary to {hex}
      sprintf(pszDstCur, "{%02X}", uc);
      pszDstCur += 4;
   }
 
   *pszDstCur = '\0';
 
   return pszBuf;
}

char *dataAsTraceW(ushort *pAnyData)
{
   static char szBuf[300];

   char *pszBuf = szBuf;
   int  iMaxBuf = sizeof(szBuf);
 
   ushort *pSrcCur = (ushort *)pAnyData;
 
   char *pszDstCur = pszBuf;
   char *pszDstMax = pszBuf + iMaxBuf - 20;
 
   int i=0;
   for (; pSrcCur[i] != 0 && pszDstCur < pszDstMax; i++)
   {
      ushort uc = pSrcCur[i];
 
      if (uc < 0x100U && isprint((char)uc))
      {
         *pszDstCur++ = (char)uc;
         continue;
      }

      // convert binary to {hex}
      sprintf(pszDstCur, "{%04X}", uc);
      pszDstCur += 6;
   }
 
   *pszDstCur = '\0';
 
   return pszBuf;
}

class FileInfo
{
public:
      FileInfo    (bool bWriteOnly=false);
     ~FileInfo    ( );
int   init        (char *pszFileName, int nShortNameLen=60, num nFileSize=0);
bool  fileValid   ( );
bool  timeToTell  ( );
int   percentage  (num nPosition);
cchar *prefix     ( );
cchar *shortName  ( );
num   fileSize    ( ) { return nClFileSize; }
void  printBlankLine (int nChars);
private:
bool  bClWriteOnly;
char  *pszClName;
int   nClNameLen;
int   nClShortNameLen;
num   nClStartTime;
num   nClNextTell;
num   nClFileSize;
};

FileInfo::FileInfo(bool bWriteOnly) {
   bClWriteOnly   = bWriteOnly;
   pszClName      = 0;
   nClNameLen     = 0;
   nClStartTime   = 0;
   nClNextTell    = 0;
   nClFileSize    = 0;
}

int FileInfo::init(char *pszName, int nShortNameLen, num nFileSize)
{
   pszClName = strdup(pszName);
   if (!pszClName) return 9+perr("out of memory: finfo\n");
   nClNameLen = strlen(pszClName);
   nClShortNameLen = nShortNameLen;
   nClStartTime = getCurrentTime();
   nClNextTell = nClStartTime + 1000;
   nClFileSize = nFileSize;
   return 0;
}

bool FileInfo::fileValid() {
   return (nClFileSize >= 0);
}

FileInfo::~FileInfo() {
   if (pszClName) delete [] pszClName;
}

bool FileInfo::timeToTell() {
   if (getCurrentTime() >= nClNextTell) {
      nClNextTell = getCurrentTime() + 1000;
      return true;
   }
   return false;
}

int FileInfo::percentage(num nPosition) {
   if (!nClFileSize) return 100;
   return (int)(nPosition * 100 / nClFileSize);
}

cchar *FileInfo::prefix() {
   int nLimit = nClShortNameLen;
   if (nClNameLen > nLimit)
      return "...";
   return "";
}

cchar *FileInfo::shortName() {
   int nLimit = nClShortNameLen;
   if (!pszClName) return "";
   int noff = 0;
   if (nClNameLen > nLimit)
        noff = nClNameLen - nLimit;
   return pszClName+noff;
}

void FileInfo::printBlankLine(int nChars) {
   for (int i=0; i<nChars; i++)
      putchar(' ');
   printf("\r");
}

FileSet  glblFileSet;   // int format -dir and -file set
CoiTable glblSFL;       // short format specific file list

int glblSFLNumberOfEntries() { return glblSFL.numberOfEntries(); }

int StringPipe::setEntry(int iIndex, char *psz, char *pAttr)
{
   if (clAttr.setEntry(iIndex, pAttr)) return 9;
   return clText.setEntry(iIndex, psz);
}

int StringPipe::addEntry(char *psz, char *pAttr)
{
   if (clAttr.addEntry(pAttr)) return 9;
   return clText.addEntry(psz);
}

void StringPipe::resetEntries()
{
   clText.resetEntries();
   clAttr.resetEntries();
}

char *StringPipe::getEntry(int nIndex, int nLine, char **ppAttr)
{
   char *ptext = clText.getEntry(nIndex, nLine);
   char *pattr = clAttr.getEntry(nIndex, nLine);
   if (ppAttr) *ppAttr = pattr;
   return ptext;
}

void StringPipe::resetPipe()
{
   resetEntries();
   nReadIndex = 0;
}

void StringPipe::dump(cchar *pszTitle)
{
   printf("[pipe %s contents (%d lines):]\n",pszTitle,numberOfEntries());
   for (int i=0; i<numberOfEntries(); i++)
      printf("[   \"%s\"]\n",getEntry(i,__LINE__));
}

bool strEndsWith(char *psz, char c)
{
   int ilen=strlen(psz);
   if (ilen>0 && psz[ilen-1]==c)
      return 1;
   return 0;
}

// .
void stepMore()
{
   if (!cs.nmore)
      return;

   if (cs.imore+1 >= cs.nmore)
   {
      cs.morepage++;
      setTextColor(nGlblTimeColor, 1);
      printf("--- %03u [enter/c/x] ---\r", cs.morepage); fflush(stdout);
      int c = getchar();
      setTextColor(-1);
      cs.imore = 0;
      if (c == 'c')
         cs.nmore = 0;
      if (c == 'x' || c == 'q')
         bGlblEscape = 1;
   }
}

void oprintf(cchar *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';

   #ifdef _WIN32
   char *psz = szPrintBufMap;
   // windows only: if output is NOT directed to file, map it to DOS charset,
   // to have filenames listed with correct umlauts etc.
   if (cs.outcconv && (cs.forcecconv || bGlblHaveInteractiveConsole))
   {
      sfkchars.stransitooem(psz);
   }
   #endif

   printf("%s", szPrintBufMap);
   fflush(stdout);

   if (cs.nmore) {
      for (int i=0; szPrintBufMap[i]; i++)
         if (szPrintBufMap[i]=='\n')
            cs.imore++;
      if (strEndsWith(szPrintBufMap, '\n'))
         stepMore();
   }
}

void oprintf(StringPipe *pOutData, cchar *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';

   char *psz = szPrintBufMap;

   if (pOutData) {
      // auto-strip LF if given. oprintf adds full records only.
      // do NOT convert text, as it is passed to further chain commands.
      int nlen = strlen(psz);
      if (nlen > 0 && psz[nlen-1] == '\n')
         psz[nlen-1] = '\0';
      pOutData->addEntry(psz, str(""));
   } else {
      #ifdef _WIN32
      // windows only: if output is NOT directed to file, map it to DOS charset,
      // to have filenames listed with correct umlauts etc.
      if (cs.outcconv && (cs.forcecconv || bGlblHaveInteractiveConsole))
      {
         sfkchars.stransitooem(psz);
      }
      #endif
      printf("%s", szPrintBufMap);
      fflush(stdout);
      if (cs.nmore) {
         for (int i=0; szPrintBufMap[i]; i++)
            if (szPrintBufMap[i]=='\n')
               cs.imore++;
         if (strEndsWith(szPrintBufMap, '\n'))
            stepMore();
      }
   }
}

CommandChaining chain;

// sfk cmd support
#define MAX_HELPCMD_TEXT 1000
char szGlblHelpCmdPat[50]; // e.g. [1234]
char szGlblHelpCmdText[MAX_HELPCMD_TEXT+100];
int  iGlblHelpCmd = 0;
int  iGlblHelpCmdCollectState = 0;
int  iGlblHelpCmdIndent = 0;

void addHelpCmdLine(char *pszRawIn, char *pszForm)
{
   /*
      raw
         "      #sfk xex in.csv "_[lstart]*\t*\t*_<row>\n <artist>[part2]{LF}"
         ...
         "         then reformat this to xml data. [123] \n"

      form
         sfk xex in.csv "_[lstart]*\t*\t*_<row>\n <artist>[part2]
         ...
         then reformat this to xml data. [123]{CR/LF}
   */

   // is it the searched reference?
   char *psz = pszForm + strlen(pszForm);
   while (psz > pszForm && (psz[-1]=='\r' || psz[-1]=='\n'))
      psz--;
   if (psz > pszForm && psz[-1] == ']' && strstr(pszForm, szGlblHelpCmdPat))
   {
      // yes, stop further collection
      iGlblCollectCmd = 2;
      return;
   }

   // collect example text
   bool bexamp=0;
   char *pszRaw = pszRawIn;
   while (*pszRaw == ' ')
      pszRaw++;
   if (*pszRaw == '#') {
      int iCurIndent = (int)(pszRaw - pszRawIn);
      if (!strncmp(pszRaw, "#sfk", 4)) {
         iGlblHelpCmdIndent = iCurIndent;
         bexamp = 1;
      } else {
         if (iCurIndent==iGlblHelpCmdIndent || iCurIndent==iGlblHelpCmdIndent+1)
            bexamp = 1;
      }
   }

   switch (iGlblHelpCmdCollectState)
   {
      case 0:  // seeking for next example start
         if (bexamp) {
            iGlblHelpCmdCollectState=1;
            break;
         }
         // any text
         iGlblHelpCmdCollectState=2;
         return;
 
      case 1:  // within example text lines
         if (bexamp)
            break;
         // any text
         iGlblHelpCmdCollectState=2;
         return;

      case 2:  // seeking for reference, or next example start
         if (bexamp) {
            szGlblHelpCmdText[0] = '\0';
            iGlblHelpCmdCollectState=1;
            break;
         }
         // any text
         return;
   }

   // append another example line

   int iquotes = 0;
   for (char *psz2 = szGlblHelpCmdText; *psz2; psz2++)
      if (*psz2 == '\"')
         iquotes++;
   if (szGlblHelpCmdText[0] != 0 && (iquotes & 1) == 0)
      strcat(szGlblHelpCmdText, " ");

   char *pSrcCur = pszForm;
   char *pSrcMax = pszForm + strlen(pszForm);
   while (*pSrcCur == ' ')
      pSrcCur++;
   while (pSrcMax > pszForm && (pSrcMax[-1]=='\r' || pSrcMax[-1]=='\n'))
      pSrcMax--;

   int iDstLen = strlen(szGlblHelpCmdText);
   int iDstRem = MAX_HELPCMD_TEXT - iDstLen;
   int iSrcLen = pSrcMax - pSrcCur;
   if (iSrcLen < 1 || iSrcLen+10 > iDstRem) {
      printf("example overflow: %s\n", pszForm);
      return;
   }

   memcpy(szGlblHelpCmdText+iDstLen, pSrcCur, iSrcLen);
   szGlblHelpCmdText[iDstLen+iSrcLen] = '\0';
}

void addHelpCmdLines(char *pszRaw, char *pszForm)
{
   char szBuf1[1100],szBuf2[1100];

   while (*pszRaw && *pszForm)
   {
      char *pszRaw2 = strchr(pszRaw, '\n');
      if (!pszRaw2)
            pszRaw2 = pszRaw + strlen(pszRaw);
      int iLenRaw = pszRaw2 - pszRaw;
      if (iLenRaw > 1000) {
         printf("help.overflow.1 %s\n", pszRaw);
         return;
      }

      char *pszForm2 = strchr(pszForm, '\n');
      if (!pszForm2)
            pszForm2 = pszForm + strlen(pszForm);
      int iLenForm = pszForm2 - pszForm;
      if (iLenForm > 1000) {
         printf("help.overflow.2 %s\n", pszForm);
         return;
      }

      memcpy(szBuf1, pszRaw, iLenRaw);
      szBuf1[iLenRaw] = '\0';

      memcpy(szBuf2, pszForm, iLenForm);
      szBuf2[iLenForm] = '\0';

      addHelpCmdLine(szBuf1, szBuf2);

      if (iGlblCollectCmd == 2)
         break;

      pszRaw = pszRaw2;
      if (*pszRaw)
         pszRaw++;

      pszForm = pszForm2;
      if (*pszForm)
         pszForm++;
   }
}

int chainAddLine(char *pszText, char *pszAttr, bool bSplitByLF)
{
   // mtklog(("chain-add: \"%.50s\"", pszText));
   return chain.addLine(pszText, pszAttr, bSplitByLF);
}

int CommandChaining::hasFile(char *psz) {
   return outfiles->hasEntry(psz);
}

int CommandChaining::addFile(Coi &ocoi) {
   return outfiles->addEntry(ocoi);
}

Coi *CommandChaining::getFile(int nIndex) {
   return infiles->getEntry(nIndex, __LINE__);
}

void CommandChaining::dumpContents()
{__
   if (usedata) {
      printf("[indata]\n");
      for (int i=0; i<chain.indata->numberOfEntries(); i++) {
         char *pattr = str("");
         char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
         if (ptext)
            printColorText(ptext, pattr, 1); // with lf
      }
   }

   if (usefiles) {
      printf("[infiles]\n");
      for (int i=0; i<chain.numberOfInFiles(); i++) {
         Coi *pcoi = chain.getFile(i);
         if (pcoi) {
            oprintf("%s\n", pcoi->name());
         }
      }
   }
}

// uses print buffers from printx
int CommandChaining::print(char cattrib, int nflags, cchar *pszFormat, ...)
{__
   va_list argList;
   va_start(argList, pszFormat);

   #ifdef SFKPRINTREDIR
   bool bcollect = colany();
   #else
   bool bcollect = coldata;
   #endif

   bool bWithPostLF = (nflags & 1) ? 1 : 0;
   bool bWithPreLF  = (nflags & 2) ? 1 : 0;
   bool bMultiLine  = (nflags & 4) ? 1 : 0;

   // prepare text
   ::vsnprintf(szClPreBuf, sizeof(szClPreBuf)-10, pszFormat, argList);
   szClPreBuf[sizeof(szClPreBuf)-10] = '\0';

   if (bMultiLine)
   {
      // full flexible line split
      if (!bcollect && !cs.outfile)
         info.clear();
 
      char *psz1 = szClPreBuf;
      while (psz1 && *psz1)
      {
         char *psz2 = strchr(psz1, '\n');
         if (psz2) {
            // intermediate record
            int n = psz2-psz1;
            if (n > MAX_LINE_LEN) n = MAX_LINE_LEN;
            memcpy(szPrintBuf2, psz1, n);
            szPrintBuf2[n] = '\0';
            trimCR(szPrintBuf2);
            psz2++;
         } else {
            // last record
            strcopy(szPrintBuf2, psz1);
         }
 
         int nlen = strlen(szPrintBuf2);
         memset(szClPreAttr, cattrib, nlen);
         szClPreAttr[nlen] = '\0';
 
         if (bcollect)
            addLine(szPrintBuf2, szClPreAttr);
         else
         if (cs.outfile)
            fprintf(cs.outfile, "%s\n", szPrintBuf2);
         else
            printColorText(szPrintBuf2, szClPreAttr, 1);
 
         psz1 = psz2;
      }
   }
   else
   {
      // single line print

      // prepare mono color
      int nlen = strlen(szClPreBuf);
      memset(szClPreAttr, cattrib, nlen);
      szClPreAttr[nlen] = '\0';
 
      if (bcollect) {
         if (bWithPreLF)
            addLine(str(""), str(""));
         if (bWithPostLF) {
            return addLine(szClPreBuf, szClPreAttr);
         } else {
            return addToCurLine(szClPreBuf, szClPreAttr, bWithPreLF);
         }
      } else {
         info.clear();
         if (bWithPreLF)
            printf("\n");
         printColorText(szClPreBuf, szClPreAttr, bWithPostLF);
      }
   }

   return 0;
}

// uses print buffers from printx
int CommandChaining::printFile(cchar *pszOutFile, bool bWriteFile, cchar *pszFormat, ...)
{__
   int nrc = 0;

   #ifdef SFKPRINTREDIR
   bool bcollect = colany();
   #else
   bool bcollect = coldata;
   #endif

   // there should be no redirect file open
   if (cs.outfile) return 9+perr("redirect file already open");

   if (bWriteFile) {
      // isolate path, create all directories
      strcopy(szPrintBuf2, pszOutFile);
      char *psz1 = strrchr(szPrintBuf2, glblPathChar);
      if (psz1) {
         *psz1 = '\0';
         if ((nrc = createSubDirTree(szPrintBuf2, str(""), 0)))
            return nrc+perr("cannot create dir: %s\n", szPrintBuf2);
      }
 
      // init redirect outfile
      if (!(cs.outfile = fopen(pszOutFile, "w")))
         return 9+perr("cannot write: %s\n", pszOutFile);
   } else {
      // just simulate the file writing:
      printf("\n:file:\n%s\n", pszOutFile);
   }

   // NO RETURN WITHOUT CONDITIONAL FILE CLOSE BEGIN

   va_list argList;
   va_start(argList, pszFormat);

   // prepare text
   ::vsnprintf(szClPreBuf, sizeof(szClPreBuf)-10, pszFormat, argList);
   szClPreBuf[sizeof(szClPreBuf)-10] = '\0';

   if (!bcollect && !cs.outfile)
      info.clear();

   char *psz1 = szClPreBuf;
   while (psz1 && *psz1)
   {
      char *psz2 = strchr(psz1, '\n');
      if (psz2) {
         // intermediate record
         int n = psz2-psz1;
         if (n > MAX_LINE_LEN) n = MAX_LINE_LEN;
         memcpy(szPrintBuf2, psz1, n);
         szPrintBuf2[n] = '\0';
         psz2++;
      } else {
         // last record
         strcopy(szPrintBuf2, psz1);
      }

      int nlen = strlen(szPrintBuf2);
      memset(szClPreAttr, ' ', nlen);
      szClPreAttr[nlen] = '\0';

      if (bcollect)
         addLine(szPrintBuf2, szClPreAttr);
      else
      if (cs.outfile)
         fprintf(cs.outfile, "%s\n", szPrintBuf2);
      else
         printColorText(szPrintBuf2, szClPreAttr, 1);

      psz1 = psz2;
   }

   // NO RETURN WITHOUT FILE CLOSE END

   if (bWriteFile && cs.outfile) {
      fclose(cs.outfile);
      cs.outfile = 0;
      printf("written: %s\n", pszOutFile);
   }

   return nrc;
}

// raw printf like method. no colors, no special options,
// but it splits multiline text into many records.
// one-line text SHOULD be terminated with LF.
int CommandChaining::print(cchar *pszFormat, ...)
{__
   va_list argList;
   va_start(argList, pszFormat);

   #ifdef SFKPRINTREDIR
   bool bcollect = colany();
   #else
   bool bcollect = coldata;
   #endif

   // prepare text
   ::vsnprintf(szClPreBuf, sizeof(szClPreBuf)-10, pszFormat, argList);
   szClPreBuf[sizeof(szClPreBuf)-10] = '\0';

   if (!bcollect && !cs.outfile)
      info.clear();

   char *psz1 = szClPreBuf;
   while (psz1 && *psz1)
   {
      char *psz2 = strchr(psz1, '\n');
      if (psz2) {
         // intermediate record
         int n = psz2-psz1;
         if (n > MAX_LINE_LEN) n = MAX_LINE_LEN;
         memcpy(szPrintBuf2, psz1, n);
         szPrintBuf2[n] = '\0';
         psz2++;
      } else {
         // last record
         strcopy(szPrintBuf2, psz1);
      }

      int nlen = strlen(szPrintBuf2);
      memset(szClPreAttr, ' ', nlen);
      szClPreAttr[nlen] = '\0';

      if (bcollect)
         addLine(szPrintBuf2, szClPreAttr);
      else
      if (cs.outfile)
         fprintf(cs.outfile, "%s\n", szPrintBuf2);
      else
         printColorText(szPrintBuf2, szClPreAttr, 1);

      psz1 = psz2;
   }

   return 0;
}

int CommandChaining::openOverallOutputFile(cchar *pszMode)
{
   if (!cs.tomask)
      return 0;
   if (!cs.tomaskfile)
      return 9+perr("use -tofile but not -to.");
   if (chain.colany())
      return 9+perr("-tofile excludes any further chain processing.");
   if (!(cs.outfile = fopen(cs.tomask, pszMode)))
      return 9+perr("cannot open for writing: %s", cs.tomask);
   cs.overallOutFilename = cs.tomask;
   cs.tomask = 0; // avoid per infile handling by execSingleFile
   return 0;
}

void CommandChaining::closeOverallOutputFile(int iDoneFiles)
{
   if (cs.outfile == 0)
      return;
   fclose(cs.outfile);
   cs.outfile = 0;

   if (!cs.quiet && cs.overallOutFilename) {
      num nbytes = getFileSize(cs.overallOutFilename);
      cchar *punit = "bytes";
      num   ndiv   = 1;
      if (nbytes > 1000000)
         {  ndiv   = 1000000; punit = "mb"; }
      else
      if (nbytes > 1000)
         {  ndiv   = 1000; punit = "kb"; }
      if (iDoneFiles)
         info.print("wrote %d files to %s (%s %s).\n",
            iDoneFiles, cs.overallOutFilename,
            numtoa(nbytes/ndiv),punit);
      else
         info.print("wrote %s with %s %s.\n",
            cs.overallOutFilename,
            numtoa(nbytes/ndiv),punit);
   }
}

int CommandChaining::convInDataToInFiles()
{__
   // user wants to convert text to filename list
   for (int i=0; i<indata->numberOfEntries(); i++) 
   {
      char *psz1 = indata->getEntry(i, __LINE__);
      // strip LFs (if any) from indata. we will drop
      // all indata records below, therefore edit directly:
      int nlen = strlen(psz1);
      if (nlen > 0 && psz1[nlen-1] == '\n')
          psz1[nlen-1] = '\0';
      // sfk1934: guess filename root on text data
      char *pszroot = getAbsPathStart(psz1);
      // printf("root %s for %s\n",pszroot,psz1);
      Coi ocoi(psz1, pszroot); // sfk1934 fromclip +copy support
      infiles->addEntry(ocoi); // is copied
   }
   indata->resetEntries();
   if (cs.tracechain)
      printf("[chain converts text data to filename list]\n");
   usefiles = 1;
   usedata  = 0;
   return 0;
}

int CommandChaining::addBinary(uchar *pData, int iSize)
{
   int iRemain   = iSize;
   int iRecChars = (sizeof(szClBinBuf)-100);
   int iRecBytes = iRecChars/2;
 
   const char *ptohex = "0123456789ABCDEF";

   int iSrcOff = 0;
   int iDstOff = iClBinBufUsed;

   while (iRemain > 0)
   {
      int iPart = mymin(iRemain, iRecBytes);

      for (int iByte=0; iByte<iPart; iByte++)
      {
         if (iDstOff+2 >= iRecChars)
         {
            szClBinBuf[iDstOff] = '\0';
            iDstOff = iClBinBufUsed = 0;
            if (outdata->addEntry(szClBinBuf, str("")))
               return 9;
         }

         uchar u = pData[iSrcOff+iByte];
         szClBinBuf[iDstOff+0] = ptohex[(u>>4)&0xF];
         szClBinBuf[iDstOff+1] = ptohex[(u   )&0xF];
         nClOutCheckSum = ((nClOutCheckSum << 1) ^ (nClOutCheckSum >> 31)) ^ u;

         iDstOff += 2;
      }

      iSrcOff += iPart;
      iRemain -= iPart;
      nClOutBinarySize += iPart;
   }

   iClBinBufUsed = iDstOff;
 
   return 0;
}

uchar twoHexToUChar(char *psz, bool &rError)
{
   uchar u = 0;
   switch (psz[0])
   {
      case '0': u=0x00; break; case '1': u=0x10; break; case '2': u=0x20; break;
      case '3': u=0x30; break; case '4': u=0x40; break; case '5': u=0x50; break;
      case '6': u=0x60; break; case '7': u=0x70; break; case '8': u=0x80; break;
      case '9': u=0x90; break; case 'A': u=0xA0; break; case 'B': u=0xB0; break;
      case 'C': u=0xC0; break; case 'D': u=0xD0; break; case 'E': u=0xE0; break;
      case 'F': u=0xF0; break;
      default:
         rError=1;
         return 0;
   }
   switch (psz[1])
   {
      case '0': u|=0x00; break; case '1': u|=0x01; break; case '2': u|=0x02; break;
      case '3': u|=0x03; break; case '4': u|=0x04; break; case '5': u|=0x05; break;
      case '6': u|=0x06; break; case '7': u|=0x07; break; case '8': u|=0x08; break;
      case '9': u|=0x09; break; case 'A': u|=0x0A; break; case 'B': u|=0x0B; break;
      case 'C': u|=0x0C; break; case 'D': u|=0x0D; break; case 'E': u|=0x0E; break;
      case 'F': u|=0x0F; break;
      default:
         rError=1;
         return 0;
   }
   return u;
}

// guarantees zero termination with 100 bytes tolerance
uchar *CommandChaining::loadBinary(num &rSize)
{
   if (nClInBinarySize < 1)
      return 0;

   uchar *pData = new uchar[nClInBinarySize+100];
   if (!pData)
      { perr("out of memory while collecting binary chain data (%s)", numtoa(nClInBinarySize)); return 0; }
   memset(pData, 0, nClInBinarySize+100);

   uchar *pDstCur = pData;
   uchar *pDstMax = pData + nClInBinarySize;

   bool bError = 0;

   num nBytes = 0;
 
   uint nTmpSum = 0;

   for (int i=0; i<chain.indata->numberOfEntries(); i++)
   {
      char *pattr = str("");
      char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
      if (!ptext)
         break;

      while (ptext[0] && ptext[1])
      {
         uchar u = twoHexToUChar(ptext, bError);
         if (bError) {
            delete [] pData;
            perr("invalid chain binary data format: %s", ptext);
            pinf("a previous command may have sent two conflicting data.\n");
            return 0;
         }
         if (pDstCur >= pDstMax) {
            // should not occur
            delete [] pData;
            perr("output overflow while collecting chain binary data");
            return 0;
         }
         nTmpSum = ((nTmpSum << 1) ^ (nTmpSum >> 31)) ^ u;
         *pDstCur++ = u;
         nBytes++;
         ptext += 2;
      }
   }

   if (nBytes != nClInBinarySize) {
      delete [] pData;
      perr("data size mismatch while collecting chain binary data (%d/%d)",(int)nBytes,(int)nClInBinarySize);
      return 0;
   }
   if (nTmpSum != nClInCheckSum) {
      delete [] pData;
      perr("checksum mismatch while collecting chain binary data (%X/%X)",nTmpSum,nClInCheckSum);
      return 0;
   }

   rSize = nBytes;

   return pData;
}

int CommandChaining::addBlockAsLines(char *pData, int iData)
{
   int isubrc=0;
   if ((isubrc = addStreamAsLines(1,0,0)))
      return isubrc;
   if ((isubrc = addStreamAsLines(2,pData,iData)))
      return isubrc;
   if ((isubrc = addStreamAsLines(3,0,0)))
      return isubrc;
   return 0;
}

int CommandChaining::addStreamAsLines(int iCmd, char *pData, int iData)
{
   static char aCache[MAX_LINE_LEN+100];
   static int  iCache=0;

   if (iCmd==1) { // init
      iCache=0;
      return 0;
   }

   if (iCmd==2) { // add
      char *pSrcCur=pData;
      char *pSrcMax=pData+iData;
      while (pSrcCur<pSrcMax) {
         char c=*pSrcCur++;
         if (c=='\n') {
            // regular line end
            aCache[iCache]='\0';
            removeCRLF(aCache); // fix sfk1912
            addLine(aCache,str(""),0);
            iCache=0;
            continue;
         }
         aCache[iCache++]=c;
         if (iCache >= MAX_LINE_LEN) {
            // hard wrap
            aCache[iCache]='\0';
            addLine(aCache,str(""),0);
            iCache=0;
            continue;
         }
      }
   }

   if (iCmd==3) { // flush, close
      if (iCache>0) {
         aCache[iCache]='\0';
         addLine(aCache,str(""),0);
         iCache=0;
      }
   }

   return 0;
}

int CommandChaining::addLine(char *pszText, char *pszAttr, bool bSplitByLF)
{
   mtklog(("addl.text: %d %04d \"%s\"", bSplitByLF, strlen(pszText), pszText));
   mtklog(("addl.attr: %d %04d \"%s\"", bSplitByLF, strlen(pszAttr), pszAttr));

   if (pszText[0] && bSplitByLF)
   {
      // detect if the line contains multiple linefeeds.
      // if so, create multiple records.
      bool btermlf = 0;
      char *psz  = pszText;
      int nalen = strlen(pszAttr);
      while (*psz)
      {
         char *psz2 = psz;
         while (*psz2 && *psz2 != '\n')
            psz2++;
         int nlen = psz2-psz;
         if (nlen > MAX_LINE_LEN) nlen = MAX_LINE_LEN;

         // isolate text part
         memcpy(szClBuf, psz, nlen);
         szClBuf[nlen] = '\0';
         removeCRLF(szClBuf); // just in case

         // isolate attribute part
         int noff = psz-pszText;
         if (noff < nalen) {
            strncpy(szClAttr, pszAttr+noff, nlen);
            szClAttr[nlen] = '\0';
         } else {
            szClAttr[0] = '\0';
         }

         // then store both parts
         outdata->addEntry(szClBuf, szClAttr);

         if (*psz2) {
            psz2++; // skip lf
            if (!*psz2) btermlf = 1;
         }
         psz = psz2;
      }
      if (btermlf && (bSplitByLF > 1)) {
         // the text was ended by a LF. this should produce
         // an empty line only if SplitByLF == 2.
         outdata->addEntry(str(""), str(""));
      }
   } else {
      // used also for empty strings, to add empty line
      outdata->addEntry(pszText, pszAttr);
   }
   return 0;
}

int CommandChaining::addToCurLine(char *pszWords, char *pszAttr, bool bNewLine)
{
   mtklog(("addc.text: %d %04d \"%s\"", bNewLine, strlen(pszWords), pszWords));
   mtklog(("addc.attr: %d %04d \"%s\"", bNewLine, strlen(pszAttr ), pszAttr ));

   if (!outdata->numberOfEntries() || bNewLine)
       if (outdata->addEntry(str(""), str("")))
         return 9;

   // append actual text
   {
      int nidx = outdata->numberOfEntries()-1;
      if (nidx < 0) return 9+perr("internal 200706102039");

      char *pAttr  = 0;
      char *pszCur = outdata->getEntry(nidx, __LINE__, &pAttr);
      strcopy(szClBuf, pszCur);
      if (pAttr) strcopy(szClAttr, pAttr);
      else szClAttr[0] = '\0';

      int icurlen = strlen(szClBuf);
      int nremain = MAX_LINE_LEN - icurlen - 1;

      // append text
      int naddlen = strlen(pszWords);
      if (naddlen > nremain) {
         if (!btold1) {
            btold1 = 1;
            perr("line buffer overflow: cannot join \"%s\" and following\n", pszWords);
            pinf("buffered lines may have %d characters max.\n", MAX_LINE_LEN-10);
         }
         return 1;
      }

      // and attributes as well, length limited by text
      int nattlen = strlen(pszAttr);
      if (nattlen > naddlen) nattlen = naddlen;

      strncpy(szClBuf+icurlen, pszWords, naddlen);
      szClBuf[icurlen+naddlen] = '\0';

      strncpy(szClAttr+icurlen, pszAttr, nattlen);
      szClAttr[icurlen+nattlen] = '\0';

      outdata->setEntry(nidx, szClBuf, szClAttr);
   }

   return 0;
}

int CommandChaining::moveOutToIn(char *pszCmd)
{__
   // flush final part of binary add
   if (chain.coldata && iClBinBufUsed)
   {
      if (cs.tracechain)
         printf("[chain flushes %d binary data]\n", iClBinBufUsed/2);
      szClBinBuf[iClBinBufUsed] = '\0';
      iClBinBufUsed = 0;
      if (outdata->addEntry(szClBinBuf, str("")))
         return 9;
   }

   CoiTable *p1 = infiles;
   infiles      = outfiles;
   outfiles     = p1;
   outfiles->resetEntries();

   usefiles = colfiles;

   StringPipe *p3 = indata;
   indata   = outdata;
   outdata  = p3;
   outdata->resetPipe();

   usedata  = coldata;

   colfiles = 0;
   coldata  = 0;
   colbinary= 0;

   if (usefiles && usedata)
   {
      // chain command with ANY input:
      // can work only if one stream has data AND other is empty
      if (numberOfInFiles() && indata->numberOfEntries()) {
         perr("command chaining: cannot use text data AND filename list in parallel.\n");
         exit(9);
      }

      // reduce mode selection, following given data
      if (indata->numberOfEntries()) usefiles = 0;
      if (numberOfInFiles()) usedata = 0;
   }

   if (cs.tracechain)
      printf("[chain swaps out and in, text2files=%d files2text=%d]\n",text2files,files2text);

   bool bt2f = text2files;
   bool bf2t = files2text;

   text2files = 0;
   files2text = 0;

   if (bt2f && bf2t)
      return 9+perr("command chaining stopped: cannot execute text2files AND files2text\n");

   if (usedata && !usefiles && !indata->numberOfEntries()) {
      if (cs.tracechain)
         printf("[chain autoselects ftt from %d filenames.]\n",numberOfInFiles());
      bf2t = 1;
   }

   if (usefiles && !usedata && !numberOfInFiles()) {
      if (cs.tracechain)
         printf("[chain autoselects ttf from %d text lines.]\n",indata->numberOfEntries());
      bt2f = 1;
   }

   if (bf2t)
   {
      // autoconvert filename list to text, even on empty list.
      int nrec = numberOfInFiles();
      for (int i=0; i<nrec; i++) {
         Coi *pcoi = getFile(i);
         if (pcoi) indata->addEntry(pcoi->name(), str(""));
      }
      infiles->resetEntries();
      if (cs.tracechain)
         printf("[chain converts filename list to text data, %d records]\n", nrec);
      usefiles = 0;
      usedata  = 1;
   }
   else
   if (bt2f)
   {
      if (indata->numberOfEntries()) {
         // user wants to convert text to filename list
         convInDataToInFiles();
      } else if (!cs.keepchain) {
         // out of chain filenames
         if (!cs.nonotes) { // sfk1933: active by default. ignores -quiet.
            #if 1
            pinf("[nopre] no files, stopping at %s. 'sfk help chain' for options.\n",pszCmd);
            #else
            pinf("chaining stops before %s: no more filenames.\n",pszCmd);
            pinf("[nopre] ... try '+then %s', -keepchain or -nonote.\n",pszCmd);
            #endif
         }
         return 1;
      }
   }

   if (cs.tracechain) {
      if (usefiles)
         printf("[chain passes %d files to %s]\n",numberOfInFiles(),pszCmd);
      if (usedata)
         printf("[chain passes %d %s to %s]\n",
            indata->numberOfEntries(),
            nClOutBinarySize ? "records":"text lines",
            pszCmd);
   }

   nClInCheckSum = nClOutCheckSum;
   nClOutCheckSum = 0;

   if ((nClInBinarySize = nClOutBinarySize)) {
      nClOutBinarySize = 0;
      if (cs.tracechain)
         printf("[chain passes %s bytes of binary]\n", numtoa(nClInBinarySize));
   }

   return 0;
}

CommandChaining::CommandChaining()
{
   colfiles   = 0;
   usefiles   = 0;
   coldata    = 0;
   usedata    = 0;
   colbinary  = 0;

   infiles    = 0;
   outfiles   = 0;

   indata     = 0;
   outdata    = 0;
   storedata  = 0;
   perlinein  = 0;
   perlineout = 0;

   text2files = 0;
   files2text = 0;
   btold1     = 0;

   nClOutBinarySize = 0;
   nClInBinarySize = 0;
   nClOutCheckSum = 0;
   nClInCheckSum = 0;
   iClBinBufUsed = 0;
}

int CommandChaining::init()
{
   infiles  = new CoiTable();
   outfiles = new CoiTable();

   indata   = new StringPipe();
   outdata  = new StringPipe();
   storedata= new StringPipe();

   justNamesFilter = new KeyMap(); // sfk193

   // perline... stays NULL until +forline

   memset(szClPreBuf, 0, sizeof(szClPreBuf));
   memset(szClPreAttr, 0, sizeof(szClPreAttr));
   memset(szClBuf, 0, sizeof(szClBuf));
   memset(szClAttr, 0, sizeof(szClAttr));
   memset(szClBinBuf, 0, sizeof(szClBinBuf));

   nClOutBinarySize = 0;
   nClInBinarySize = 0;
   nClOutCheckSum = 0;
   nClInCheckSum = 0;
   iClBinBufUsed = 0;

   return 0;
}

void CommandChaining::reset()
{
   colfiles   = 0;
   usefiles   = 0;
   coldata    = 0;
   usedata    = 0;
   text2files = 0;
   files2text = 0;
   btold1     = 0;
   colbinary  = 0;

   infiles->resetEntries();
   outfiles->resetEntries();

   indata->resetEntries();
   outdata->resetEntries();
 
   if (justNamesFilter)
      justNamesFilter->reset(); // sfk193

   nClOutBinarySize = 0;
   nClInBinarySize = 0;
   nClOutCheckSum = 0;
   nClInCheckSum = 0;
   iClBinBufUsed = 0;
}

void CommandChaining::shutdown()
{
   if (infiles) {
      infiles->resetEntries();
      delete infiles;
   }
   if (outfiles) {
      outfiles->resetEntries();
      delete outfiles;
   }

   if (indata) {
      indata->resetEntries();
      delete indata;
   }
   if (outdata) {
      outdata->resetEntries();
      delete outdata;
   }

   if (storedata) {
      storedata->resetEntries();
      delete storedata;
   }

   if (perlinein) {
      perlinein->resetEntries();
      delete perlinein;
   }
   if (perlineout) {
      perlineout->resetEntries();
      delete perlineout;
   }

   if (justNamesFilter) { // sfk193
      justNamesFilter->reset();
      delete justNamesFilter;
   }
}

int printEcho(uint nflags, const char *pszFormat, ...)
{__
   #ifdef SFKPRINTREDIR
   bool bcollect = chain.colany();
   #else
   bool bcollect = chain.coldata;
   #endif

   bool bAddToCurLine = (nflags & 1) ? 1 : 0;
   bool bTell         = (nflags & 2) ? 1 : 0;
   bool bEcho         = bTell ? 0 : 1;
   bool bToTerm       = (nflags & 4) ? 1 : 0;

   if (bToTerm)
      bcollect = 0;

   va_list argList;
   va_start(argList, pszFormat);

   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';

   char *pszSrc = szPrintBuf1;
   int iDst = 0;
   char nAttr = ' ';
   bool bResetOnLF = 0;
   while (*pszSrc && (iDst < (int)sizeof(szPrintBuf2)-10))
   {
      if (!strncmp(pszSrc, "[["    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = '[';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "]]"    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = ']';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      // base colors are bright or dark depending on their first name char
      if (!mystrncmp(pszSrc, "[red]"    , 5)) { nAttr = pszSrc[1]; pszSrc += 5; } else
      if (!mystrncmp(pszSrc, "[green]"  , 7)) { nAttr = pszSrc[1]; pszSrc += 7; } else
      if (!mystrncmp(pszSrc, "[blue]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[yellow]" , 8)) { nAttr = pszSrc[1]; pszSrc += 8; } else
      if (!mystrncmp(pszSrc, "[cyan]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[magenta]", 9)) { nAttr = pszSrc[1]; pszSrc += 9; } else
      // inofficial: does not work with a white background under Windows
      if (!mystrncmp(pszSrc, "[white]"  , 7)) { nAttr = 'v';       pszSrc += 7; } else

      if (!strncmp(pszSrc, "[def]"    , 5)) { pszSrc += 5; nAttr = ' '; }

      else
      {
         szPrintBuf2[iDst] = *pszSrc;
         szPrintAttr[iDst] = nAttr;
         if (*pszSrc == '\n' && bResetOnLF) {
            nAttr = ' ';
            szPrintAttr[iDst] = nAttr;
            bResetOnLF = 0;
         }
         pszSrc++;
         iDst++;
      }
   }
   szPrintBuf2[iDst] = '\0';
   if (bEcho && bcollect) {
      if (bAddToCurLine) {
         chain.addToCurLine(szPrintBuf2, szPrintAttr, 0);
      } else {
         // mode 2: if echo text ends with "\n", add an empty line.
         chain.addLine(szPrintBuf2, szPrintAttr, 2);
      }
   } else {
      printColorText(szPrintBuf2, szPrintAttr, 0);
      if (!bAddToCurLine) printf("\n");
      fflush(stdout);
   }
   return 0;
}

// sfk1944: bGlblInSpecificProcessing -> inFileList
void setUsingFileList(int bYesNo)
{
   cs.infilelist = bYesNo;
}

Array glblGrepPat("grep");
Array glblUnzipMask("unzip");
Array glblIncBin("incbin");

StringTable::StringTable() {
   nClArraySize = 0;
   nClArrayUsed = 0;
   apClArray    = 0;
}

StringTable::~StringTable() {
   resetEntries();
}

void StringTable::dump(int nIndent) {
   printf("] %.*sstringtable %p, %d entries:\n",nIndent,pszGlblBlank,this,nClArrayUsed);
   for (int i=0; i<nClArrayUsed; i++) {
      printf("]   %.*s%s\n", nIndent,pszGlblBlank,apClArray[i] ? apClArray[i] : "<null>");
   }
}

void StringTable::resetEntries() {
   if (apClArray) {
      for (int i=0; i<nClArrayUsed; i++) {
         if (apClArray[i]) delete [] apClArray[i];
         apClArray[i] = 0;
      }
   }
   nClArrayUsed = 0;
   if (apClArray)
      delete [] apClArray;
   apClArray = 0;
   nClArraySize = 0;
}

int StringTable::numberOfEntries() {
   return nClArrayUsed;
}

bool StringTable::isSet(int iIndex) {
   if (iIndex < 0)
      { pwarn("illegal index: %d\n", iIndex); return 0; }
   return (iIndex < nClArrayUsed) ? 1 : 0;
}

int StringTable::expand(int nSoMuch) {
   char **apTmp = new char*[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (apClArray) {
      memcpy(apTmp, apClArray, nClArraySize*sizeof(char*));
      delete [] apClArray;
   }
   apClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

int StringTable::addEntry(char *psz, int nAtPos, char **ppCopy)
{
   char *pCopy = 0;
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (int i=nClArrayUsed; i>nAtPos; i--)
         apClArray[i] = apClArray[i-1];
      pCopy = psz ? strdup(psz) : 0;
      apClArray[nAtPos] = pCopy;
      nClArrayUsed++;
   } else {
      pCopy = psz ? strdup(psz) : 0;
      apClArray[nClArrayUsed++] = pCopy;
   }
   if (ppCopy) *ppCopy = pCopy;
   return 0;
}

int StringTable::removeEntry(int nAtPos) {
   if (nAtPos < 0 || nAtPos >= nClArrayUsed)
      return 9;
   if (apClArray[nAtPos]) delete [] apClArray[nAtPos];
   for (int i=nAtPos; i<nClArrayUsed-1; i++)
      apClArray[i] = apClArray[i+1];
   apClArray[nClArrayUsed-1] = 0; // just in case
   nClArrayUsed--;
   return 0;
}

int StringTable::addEntryPrefixed(char *psz, char cPrefix) {
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   // create extended copy with prefix at beginning
   int nLen = strlen(psz);
   char *pszCopy = new char[nLen+2];
   pszCopy[0] = cPrefix;
   strcpy(pszCopy+1, psz);
   // add this copy
   apClArray[nClArrayUsed++] = pszCopy;
   if (cs.debug) printf("]  stringtable %p added %s, have %d\n",this,pszCopy,nClArrayUsed);
   return 0;
}

int StringTable::setEntry(int nIndex, char *psz) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("illegal set index: %d\n", nIndex);
   if (apClArray[nIndex])
      delete [] apClArray[nIndex];
   apClArray[nIndex] = strdup(psz);
   return 0;
}

int StringTable::setEntryPrefixed(int nIndex, char *psz, char cPrefix) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("illegal set index: %d\n", nIndex);
   // create extended copy with prefix at beginning
   int nLen = strlen(psz);
   char *pszCopy = new char[nLen+2];
   pszCopy[0] = cPrefix;
   strcpy(pszCopy+1, psz);
   // delete old entry, if any
   if (apClArray[nIndex])
      delete [] apClArray[nIndex];
   // set new copy
   apClArray[nIndex] = pszCopy;
   if (cs.debug) printf("]  stringtable %p set %s, have %d\n",this,pszCopy,nClArrayUsed);
   return 0;
}

char *StringTable::getEntry(int nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return apClArray[nIndex];
   perr("illegal StringTable index: %d tline=%d used=%d\n", nIndex, nTraceLine, nClArrayUsed);
   return 0;
}

int StringTable::find(char *psz) {
   for (int i=0; i<nClArrayUsed; i++)
      if (apClArray[i] && !strcmp(apClArray[i], psz))
         return i;
   return -1;
}

StringTable glblErrorLog;
StringTable glblStaleLog;

StringPipe::StringPipe()
{
   nReadIndex = 0;
}

bool StringPipe::eod()
{
   return (nReadIndex >= numberOfEntries());
}

char *StringPipe::read(char **ppAttr)
{
   if (nReadIndex < numberOfEntries()) {
      char *psz   = clText.getEntry(nReadIndex, __LINE__);
      char *pattr = clAttr.getEntry(nReadIndex, __LINE__);
      // printf("PIPE.READ %d = %s\n",nReadIndex,psz);
      nReadIndex++;
      if (ppAttr)
         *ppAttr = pattr;
      return psz;
   }
   return 0; // EOD
}

void logError(const char *format, ...)
{
   va_list arg_ptr;
   va_start(arg_ptr, format);

   char szTmpBuf[4096];
   vsprintf(szTmpBuf, format, arg_ptr);

   glblErrorLog.addEntry(szTmpBuf);
   printf("%s\n", szTmpBuf);
}

char *skipDotSlash(char *psz) {
   if (!strncmp(psz, glblDotSlash, 2))
      psz += 2;
   return psz;
}

void trackStaleZip(char *pszFileName)
{
   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   int nEntries = glblStaleLog.numberOfEntries();
   for (int i=0; i<nEntries; i++)
   {
      char *psz = glblStaleLog.getEntry(i, __LINE__);
      if (!strcmp(psz, pszFileName))
         return; // is already registered
   }

   // add zip containing stale files to stale list
   glblStaleLog.addEntry(pszFileName);
}

bool endsWithPathChar(char *pszPath, bool bAcceptFWSlash=0) {
   int nLen = strlen(pszPath);
   if (nLen>0) {
      if (pszPath[nLen-1] == glblPathChar)
         return 1;
      if (bAcceptFWSlash && pszPath[nLen-1] == '/')
         return 1;
   }
   return 0;
}

bool endsWithColon(char *pszPath) {
   #ifdef _WIN32
   int nLen = strlen(pszPath);
   if (nLen>0 && pszPath[nLen-1] == ':')
      return 1;
   #endif
   return 0;
}

// ============================================================

Array::Array(const char *pszID) {
   nClRowsSize = 0;
   nClRowsUsed = 0;
   apClRows    = 0;
   nClCurRow   = 0;
   pszClID     = pszID;
}

Array::~Array() {
   reset();
}

void Array::dump() {
   printf("] array %s dump:\n",pszClID);
   for (int iRow=0; iRow<nClRowsUsed; iRow++) {
      StringTable *pRow = apClRows[iRow];
      printf("]   row %p:\n",pRow);
      pRow->dump(5);
   }
}

int Array::expand(int nSoMuch) {
   StringTable **apTmp = new StringTable*[nClRowsSize+nSoMuch];
   if (!apTmp) return 9;
   if (apClRows) {
      memcpy(apTmp, apClRows, nClRowsSize*sizeof(StringTable*));
      delete [] apClRows;
   }
   apClRows = apTmp;
   nClRowsSize += nSoMuch;
   return 0;
}

// make sure at least one row exists
int Array::ensureBase( ) {
   if (!nClRowsSize) {
      // if (cs.debug) printf("] array %p crt initial\n",this);
      // create initial row, for one-dimensional mode
      if (expand(1)) return 9;
      StringTable *pFirst = new StringTable();
      if (!pFirst) return 9;
      apClRows[nClRowsUsed++] = pFirst;
   }
   return 0;
}

// public: remove everything
void Array::reset() {
   // if (cs.debug) printf("] array %p RESET\n",this);
   for (int i=0; i<nClRowsUsed; i++) {
      delete apClRows[i];
      apClRows[i] = 0;
   }
   nClRowsUsed = 0;
   if (apClRows) {
      delete [] apClRows;
      apClRows = 0;
   }
   nClRowsSize = 0;
   nClCurRow = 0; // [22261] FIX sfk196: missing, crash on chaining
}

// public: return number of columns in current row
int Array::numberOfEntries() {
   if (ensureBase()) return 0;
   return apClRows[nClCurRow]->numberOfEntries();
}

int Array::numberOfEntries(int lRow) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   return apClRows[lRow]->numberOfEntries();
}

// public: add string object to current row
int Array::addString(char *psz) {
   if (ensureBase()) return 0;
   if (cs.debug) printf("] array %s: add to row %d entry %s. [%d rows total]\n",pszClID,nClCurRow,psz,nClRowsUsed);
   int lRC = apClRows[nClCurRow]->addEntryPrefixed(psz, 's');
   return lRC;
}

int Array::addString(int lRow, char *psz) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   if (cs.debug) printf("] array %s: add to row %d entry %s. [%d rows total]\n",pszClID,lRow,psz,nClRowsUsed);
   int lRC = apClRows[lRow]->addEntryPrefixed(psz, 's');
   return lRC;
}

int Array::addNull(int lRow) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   if (cs.debug) printf("] array %s: add NULL to row %d. [%d rows total]\n",pszClID,lRow,nClRowsUsed);
   int lRC = apClRows[lRow]->addEntry(0);
   return lRC;
}

int Array::setString(int lRow, int nIndex, char *psz) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   if (cs.debug) printf("] array %s: set row %d:%d entry %s. [%d rows total]\n",pszClID,lRow,nIndex,psz,nClRowsUsed);
   int lRC = apClRows[lRow]->setEntryPrefixed(nIndex, psz, 's');
   return lRC;
}

// public: get string object from current row
char *Array::getString(int nIndex) {
   if (ensureBase()) return 0;
   char *pszRaw = apClRows[nClCurRow]->getEntry(nIndex, __LINE__);
   if (!pszRaw)
      return 0; // NULL entry
   if (pszRaw[0] != 's') { perr("%s: no string entry type at %u %u\n", pszClID, nClCurRow, nIndex); return 0; }
   return pszRaw+1;
}

char *Array::getString(int lRow, int nIndex) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   char *pszRaw = apClRows[lRow]->getEntry(nIndex, __LINE__);
   if (!pszRaw)
      return 0; // NULL entry
   if (pszRaw[0] != 's') { perr("%s: no string entry type at %u %u\n", pszClID, lRow, nIndex); return 0; }
   return pszRaw+1;
}

// public: add integer to current row, internally encoded as string
int Array::addLong(int nValue, int nTraceLine) {
   if (ensureBase()) return 0;
   if (cs.debug) printf("] array %s: add to row %d entry %d [tline %d]\n",pszClID,nClCurRow,nValue,nTraceLine);
   char szBuf[100];
   uint uValue = (uint)nValue;
   // char *_ultoa( unsigned int value, char *string, int radix );
   #ifdef _WIN32
   _ultoa(uValue, szBuf, 16);
   #else
   sprintf(szBuf, "%x", uValue);
   #endif
   return apClRows[nClCurRow]->addEntryPrefixed(szBuf, 'i');
}

int Array::addLong(int lRow, int nValue, int nTraceLine) {
   if (ensureBase()) return 0;
   if (cs.debug) printf("] array %s: add to row %d entry %d [tline %d]\n",pszClID,lRow,nValue,nTraceLine);
   if (lRow < 0 || lRow > nClRowsUsed) return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   char szBuf[100];
   uint uValue = (uint)nValue;
   #ifdef _WIN32
   _ultoa(uValue, szBuf, 16);
   #else
   sprintf(szBuf, "%x", uValue);
   #endif
   return apClRows[lRow]->addEntryPrefixed(szBuf, 'i');
}

int Array::getLong(int nIndex) {
   if (ensureBase()) return 0;
   char *pszRaw = apClRows[nClCurRow]->getEntry(nIndex, __LINE__);
   if (!pszRaw)
      return 0;
   if (pszRaw[0] != 'i') { perr("no long entry type at row %u col %u\n", nClCurRow, nIndex); return 0; }
   // unsigned int strtoul( const char *nptr, char **endptr, int base );
   uint uValue = strtoul(pszRaw+1, 0, 16);
   return (int)uValue;
}

int Array::getLong(int lRow, int nIndex, int nTraceLine) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   char *pszRaw = apClRows[lRow]->getEntry(nIndex, nTraceLine);
   if (!pszRaw)
      return 0;
   if (pszRaw[0] != 'i') { perr("no long entry type at row %u col %u\n", lRow, nIndex); return 0; }
   // unsigned int strtoul( const char *nptr, char **endptr, int base );
   uint uValue = strtoul(pszRaw+1, 0, 16);
   return (int)uValue;
}

int Array::setLong(int lRow, int nIndex, int nValue, int nTraceLine) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   char szBuf[100];
   uint uValue = (uint)nValue;
   // char *_ultoa( unsigned int value, char *string, int radix );
   #ifdef _WIN32
   _ultoa(uValue, szBuf, 16);
   #else
   sprintf(szBuf, "%x", uValue);
   #endif
   return apClRows[lRow]->setEntryPrefixed(nIndex, szBuf, 'i');
}

// public: create new row. shouldn't be called for first row.
int Array::addRow(int nTraceLine) {
   int nOldRows = nClRowsSize;
   if (ensureBase()) return 0;
   // if anyone calls this before adding first data, accept it.
   if (!nOldRows)
      return 0;
   // for all further rows, check if row table is full.
   // if so, expand in exponential steps.
   if (nClRowsUsed == nClRowsSize) {
      if (expand(nClRowsSize)) return 9;
   }
   // finally, add new row object
   StringTable *pFirst = new StringTable();
   if (!pFirst) return 9;
   apClRows[nClRowsUsed++] = pFirst;
   nClCurRow = nClRowsUsed-1;
   if (cs.debug) printf("array %s extended to %d rows [tln %d]\n",pszClID,nClRowsUsed,nTraceLine);
   return 0;
}

// public: select current row
int Array::setRow(int iCurRow, int nTraceLine) {
   if (ensureBase()) return 9;
   if (iCurRow < 0 || iCurRow >= nClRowsUsed)
      return 9+perr("%s: illegal row index: %d on setRow, tline %d\n",pszClID,iCurRow,nTraceLine);
   nClCurRow = iCurRow;
   if (cs.debug) printf("array %s setrow %d\n",pszClID,nClCurRow);
   return 0;
}

// public: tell if index in current row is set, used for loops
bool Array::isSet(int iIndex) {
   if (ensureBase()) return 0;
   return apClRows[nClCurRow]->isSet(iIndex);
}

// public: tell if index in current row is set with a string
bool Array::isStringSet(int iIndex) {
   if (ensureBase()) return 0;
   if (!apClRows[nClCurRow]->isSet(iIndex)) {
      // if (cs.debug) printf("] %s: no string set at %d:%d\n",pszClID,nClCurRow,iIndex);
      return 0;
   }
   char *pszRaw = apClRows[nClCurRow]->getEntry(iIndex, __LINE__);
   // printf("xxx %s:%d:%d %s\n",pszClID,nClCurRow,iIndex,pszRaw);
   if (!pszRaw) {
      if (cs.debug) {
         printf("error: no entry at index %d, table %p, within array %p\n",iIndex,apClRows[nClCurRow],this);
         apClRows[nClCurRow]->dump();
      }
      return 0;
   }
   if (pszRaw[0] != 's') {
      perr("no string type at %s:%d:%d\n",pszClID,nClCurRow,iIndex);
      return 0;
   }
   return 1;
}

bool Array::isStringSet(int lRow, int iIndex) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   if (!apClRows[lRow]->isSet(iIndex))
      return 0;
   char *pszRaw = apClRows[lRow]->getEntry(iIndex, __LINE__);
   if (!pszRaw) {
      if (cs.debug) {
         printf("error: no entry at index %d, table %p, within array %p\n",iIndex,apClRows[lRow],this);
         apClRows[lRow]->dump();
      }
      return 0;
   }
   return (pszRaw[0] == 's') ? 1 : 0;
}

// public: tell if index in current row is set with a int
bool Array::isLongSet(int lRow, int iIndex) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   if (!apClRows[lRow]->isSet(iIndex))
      return 0;
   char *pszRaw = apClRows[lRow]->getEntry(iIndex, __LINE__);
   if (!pszRaw)
      return 0;
   return (pszRaw[0] == 'i') ? 1 : 0;
}

// public: tell if row exists
bool Array::hasRow(int iRow) {
   if (ensureBase()) return 0;
   if (iRow < 0) {  perr("%s: illegal row index: %d on hasRow\n",pszClID,iRow); return 0; }
   return (iRow < nClRowsUsed) ? 1 : 0;
}

// ============================================================

LongTable::LongTable() {
   nClArraySize = 0;
   nClArrayUsed = 0;
   pClArray     = 0;
}

LongTable::~LongTable() {
   resetEntries();
}

void LongTable::resetEntries() {
   nClArrayUsed = 0;
   if (pClArray)
      delete [] pClArray;
   pClArray = 0;
   nClArraySize = 0;
}

int LongTable::numberOfEntries() {
   return nClArrayUsed;
}

int LongTable::expand(int nSoMuch) {
   int *apTmp = new int[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (pClArray) {
      memcpy(apTmp, pClArray, nClArraySize*sizeof(int));
      delete [] pClArray;
   }
   pClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

int LongTable::addEntry(int nValue, int nAtPos)
{
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (int i=nClArrayUsed; i>nAtPos; i--)
         pClArray[i] = pClArray[i-1];
      pClArray[nAtPos] = nValue;
      nClArrayUsed++;
   } else {
      pClArray[nClArrayUsed++] = nValue;
   }
   return 0;
}

int LongTable::updateEntry(int nValue, int nIndex) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("wrong index for updateEntry: %d\n", nIndex);
   pClArray[nIndex] = nValue;
   return 0;
}

int LongTable::getEntry(int nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return pClArray[nIndex];
   perr("illegal LongTable index: %d %d tline %d\n", nIndex, nClArrayUsed, nTraceLine);
   return -1;
}

// ======================================================

NumTable::NumTable() {
   nClArraySize = 0;
   nClArrayUsed = 0;
   pClArray     = 0;
}

NumTable::~NumTable() {
   resetEntries();
}

void NumTable::resetEntries() {
   nClArrayUsed = 0;
   if (pClArray)
      delete [] pClArray;
   pClArray = 0;
   nClArraySize = 0;
}

int NumTable::numberOfEntries() {
   return nClArrayUsed;
}

int NumTable::expand(int nSoMuch) {
   num *apTmp = new num[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (pClArray) {
      memcpy(apTmp, pClArray, nClArraySize*sizeof(num));
      delete [] pClArray;
   }
   pClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

int NumTable::addEntry(num nValue, int nAtPos) {
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (int i=nClArrayUsed; i>nAtPos; i--)
         pClArray[i] = pClArray[i-1];
      pClArray[nAtPos] = nValue;
      nClArrayUsed++;
   } else {
      pClArray[nClArrayUsed++] = nValue;
   }
   return 0;
}

int NumTable::updateEntry(num nValue, int nAtPos) {
   if (nAtPos >= nClArrayUsed)
      return 9+perr("illegal index for updateEntry: %d\n", nAtPos);
   pClArray[nAtPos] = nValue;
   return 0;
}

num NumTable::getEntry(int nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return pClArray[nIndex];
   perr("illegal NumTable index: %d %d tline %d\n", nIndex, nClArrayUsed, nTraceLine);
   return -1;
}

// ==========================================================

SFKMD5::SFKMD5() { reset(); }

void SFKMD5::reset()
{
   bClDigDone  = 0;

   nClDigLen   = 16;
   nClBufLen   = 64;
   pClBuf      = aClBuf;
   pClDig      = aClDig;

   nClCntHigh  = nClCntLow = nClBufCnt = 0;

   alClSta[0] = 0x67452301;
   alClSta[1] = 0xefcdab89;
   alClSta[2] = 0x98badcfe;
   alClSta[3] = 0x10325476;

   nClCRC = 0;
}

SFKMD5::~SFKMD5() { }

uint sfkPackSum(uchar *buf, uint len, uint crc);

void SFKMD5::update(uchar *pData, uint32_t nLen)
{
   #ifdef SFKPACK
   if (cs.crcmd5) {
      nClCRC = sfkPackSum(pData, nLen, nClCRC);
      return;
   }
   #endif // SFKPACK

   if (bGlblOldMD5)
   {
      for (uint32_t i=0; i<nLen; i++)
         update(pData[i]);
   }
   else
   {
      int nCnt = 0;
 
      if (nClBufCnt != 0)
      {
         int nAvail = nClBufLen - nClBufCnt;
         int nMax = nAvail < (int)nLen ? nAvail : (int)nLen;
 
         for (; nCnt < nMax; nCnt++)
            update(pData[nCnt]);
      }
 
      int nBlocks = (nLen - nCnt) / nClBufLen;
 
      unsigned int ulNumChars = nBlocks * nClBufLen;
 
      nClCntLow += ulNumChars;
 
      if (nClCntLow < ulNumChars)
         nClCntHigh++;
 
      for (int i = 0; i < nBlocks; i++)
      {
         memcpy(pClBuf, pData + nCnt, nClBufLen);
         transform();
         nCnt += nClBufLen;
      }
 
      for (; nCnt < (int)nLen; nCnt++)
         update(pData[nCnt]);
   }
}

void SFKMD5::update(uchar c)
{
   pClBuf[nClBufCnt++] = c;
   if (nClBufCnt == nClBufLen)
   {
      transform();
      nClBufCnt = 0;
   }
   if (++nClCntLow == 0)
      nClCntHigh++;
}

void SFKMD5::transform()
{
   #define MD5XOR0(x, y, z) (z ^ (x & (y ^ z)))
   #define MD5XOR1(x, y, z) (y ^ (z & (x ^ y)))
   #define MD5XOR2(x, y, z) (x ^ y ^ z)
   #define MD5XOR3(x, y, z) (y  ^  (x | ~z))
   #define MD5ROT(a, n) a = (a << n) | (a >> (32 - n))
   #define MD5PR0(a, b, c, d, k, s, t) { a += k + t + MD5XOR0(b, c, d); MD5ROT(a, s); a += b; }
   #define MD5PR1(a, b, c, d, k, s, t) { a += k + t + MD5XOR1(b, c, d); MD5ROT(a, s); a += b; }
   #define MD5PR2(a, b, c, d, k, s, t) { a += k + t + MD5XOR2(b, c, d); MD5ROT(a, s); a += b; }
   #define MD5PR3(a, b, c, d, k, s, t) { a += k + t + MD5XOR3(b, c, d); MD5ROT(a, s); a += b; }

   uchar *pBuf = pClBuf;
   for (uint32_t i = 0; i < 16; i++)
   {
      uint32_t ul;
      ul = pBuf[0];
      ul |= pBuf[1] << 8;
      ul |= pBuf[2] << 16;
      ul |= pBuf[3] << 24;
      pBuf += 4;
      alClBuf[i] = ul;
   }

   uint32_t a = alClSta[0];
   uint32_t b = alClSta[1];
   uint32_t c = alClSta[2];
   uint32_t d = alClSta[3];

   MD5PR0(a, b, c, d, alClBuf[ 0],  7, 0xd76aa478);
   MD5PR0(d, a, b, c, alClBuf[ 1], 12, 0xe8c7b756);
   MD5PR0(c, d, a, b, alClBuf[ 2], 17, 0x242070db);
   MD5PR0(b, c, d, a, alClBuf[ 3], 22, 0xc1bdceee);
   MD5PR0(a, b, c, d, alClBuf[ 4],  7, 0xf57c0faf);
   MD5PR0(d, a, b, c, alClBuf[ 5], 12, 0x4787c62a);
   MD5PR0(c, d, a, b, alClBuf[ 6], 17, 0xa8304613);
   MD5PR0(b, c, d, a, alClBuf[ 7], 22, 0xfd469501);
   MD5PR0(a, b, c, d, alClBuf[ 8],  7, 0x698098d8);
   MD5PR0(d, a, b, c, alClBuf[ 9], 12, 0x8b44f7af);
   MD5PR0(c, d, a, b, alClBuf[10], 17, 0xffff5bb1);
   MD5PR0(b, c, d, a, alClBuf[11], 22, 0x895cd7be);
   MD5PR0(a, b, c, d, alClBuf[12],  7, 0x6b901122);
   MD5PR0(d, a, b, c, alClBuf[13], 12, 0xfd987193);
   MD5PR0(c, d, a, b, alClBuf[14], 17, 0xa679438e);
   MD5PR0(b, c, d, a, alClBuf[15], 22, 0x49b40821);

   MD5PR1(a, b, c, d, alClBuf[ 1],  5, 0xf61e2562);
   MD5PR1(d, a, b, c, alClBuf[ 6],  9, 0xc040b340);
   MD5PR1(c, d, a, b, alClBuf[11], 14, 0x265e5a51);
   MD5PR1(b, c, d, a, alClBuf[ 0], 20, 0xe9b6c7aa);
   MD5PR1(a, b, c, d, alClBuf[ 5],  5, 0xd62f105d);
   MD5PR1(d, a, b, c, alClBuf[10],  9, 0x02441453);
   MD5PR1(c, d, a, b, alClBuf[15], 14, 0xd8a1e681);
   MD5PR1(b, c, d, a, alClBuf[ 4], 20, 0xe7d3fbc8);
   MD5PR1(a, b, c, d, alClBuf[ 9],  5, 0x21e1cde6);
   MD5PR1(d, a, b, c, alClBuf[14],  9, 0xc33707d6);
   MD5PR1(c, d, a, b, alClBuf[ 3], 14, 0xf4d50d87);
   MD5PR1(b, c, d, a, alClBuf[ 8], 20, 0x455a14ed);
   MD5PR1(a, b, c, d, alClBuf[13],  5, 0xa9e3e905);
   MD5PR1(d, a, b, c, alClBuf[ 2],  9, 0xfcefa3f8);
   MD5PR1(c, d, a, b, alClBuf[ 7], 14, 0x676f02d9);
   MD5PR1(b, c, d, a, alClBuf[12], 20, 0x8d2a4c8a);

   MD5PR2(a, b, c, d, alClBuf[ 5],  4, 0xfffa3942);
   MD5PR2(d, a, b, c, alClBuf[ 8], 11, 0x8771f681);
   MD5PR2(c, d, a, b, alClBuf[11], 16, 0x6d9d6122);
   MD5PR2(b, c, d, a, alClBuf[14], 23, 0xfde5380c);
   MD5PR2(a, b, c, d, alClBuf[ 1],  4, 0xa4beea44);
   MD5PR2(d, a, b, c, alClBuf[ 4], 11, 0x4bdecfa9);
   MD5PR2(c, d, a, b, alClBuf[ 7], 16, 0xf6bb4b60);
   MD5PR2(b, c, d, a, alClBuf[10], 23, 0xbebfbc70);
   MD5PR2(a, b, c, d, alClBuf[13],  4, 0x289b7ec6);
   MD5PR2(d, a, b, c, alClBuf[ 0], 11, 0xeaa127fa);
   MD5PR2(c, d, a, b, alClBuf[ 3], 16, 0xd4ef3085);
   MD5PR2(b, c, d, a, alClBuf[ 6], 23, 0x04881d05);
   MD5PR2(a, b, c, d, alClBuf[ 9],  4, 0xd9d4d039);
   MD5PR2(d, a, b, c, alClBuf[12], 11, 0xe6db99e5);
   MD5PR2(c, d, a, b, alClBuf[15], 16, 0x1fa27cf8);
   MD5PR2(b, c, d, a, alClBuf[ 2], 23, 0xc4ac5665);

   MD5PR3(a, b, c, d, alClBuf[ 0],  6, 0xf4292244);
   MD5PR3(d, a, b, c, alClBuf[ 7], 10, 0x432aff97);
   MD5PR3(c, d, a, b, alClBuf[14], 15, 0xab9423a7);
   MD5PR3(b, c, d, a, alClBuf[ 5], 21, 0xfc93a039);
   MD5PR3(a, b, c, d, alClBuf[12],  6, 0x655b59c3);
   MD5PR3(d, a, b, c, alClBuf[ 3], 10, 0x8f0ccc92);
   MD5PR3(c, d, a, b, alClBuf[10], 15, 0xffeff47d);
   MD5PR3(b, c, d, a, alClBuf[ 1], 21, 0x85845dd1);
   MD5PR3(a, b, c, d, alClBuf[ 8],  6, 0x6fa87e4f);
   MD5PR3(d, a, b, c, alClBuf[15], 10, 0xfe2ce6e0);
   MD5PR3(c, d, a, b, alClBuf[ 6], 15, 0xa3014314);
   MD5PR3(b, c, d, a, alClBuf[13], 21, 0x4e0811a1);
   MD5PR3(a, b, c, d, alClBuf[ 4],  6, 0xf7537e82);
   MD5PR3(d, a, b, c, alClBuf[11], 10, 0xbd3af235);
   MD5PR3(c, d, a, b, alClBuf[ 2], 15, 0x2ad7d2bb);
   MD5PR3(b, c, d, a, alClBuf[ 9], 21, 0xeb86d391);

   alClSta[0] += a;
   alClSta[1] += b;
   alClSta[2] += c;
   alClSta[3] += d;
}

uchar *SFKMD5::digest()
{
   #ifdef SFKPACK
   if (cs.crcmd5) {
      memset(aClDig, 0, 16);
      aClDig[0] = ((nClCRC >> 24) & 0xFFU);
      aClDig[1] = ((nClCRC >> 16) & 0xFFU);
      aClDig[2] = ((nClCRC >>  8) & 0xFFU);
      aClDig[3] = ((nClCRC >>  0) & 0xFFU);
      return pClDig;
   }
   #endif // SFKPACK

   if (bClDigDone)
      return pClDig;

   uint32_t lLow  = nClCntLow << 3;
   uint32_t lHigh = (nClCntLow >> 29) | (nClCntHigh << 3);

   update(128);

   while ((nClCntLow & 63) != 56)
      update(0);

   update((uchar)lLow);
   update((uchar)(lLow >> 8));
   update((uchar)(lLow >> 16));
   update((uchar)(lLow >> 24));

   update((uchar)lHigh);
   update((uchar)(lHigh >> 8));
   update((uchar)(lHigh >> 16));
   update((uchar)(lHigh >> 24));

   // above code should ensure that last update() lead to empty buffer.
   if (nClBufCnt != 0) { fprintf(stderr, "ERROR: SFKMD5 internal #1\n"); }

   uchar *pDigest = pClDig;
   for (uint32_t i = 0; i < 4; i++)
   {
      uint32_t ul = alClSta[i];
      pDigest[0] = (uchar)ul; ul >>= 8;
      pDigest[1] = (uchar)ul; ul >>= 8;
      pDigest[2] = (uchar)ul; ul >>= 8;
      pDigest[3] = (uchar)ul;
      pDigest += 4;
   }

   bClDigDone = 1;
   return pClDig;
}

// ==========================================================

FileList::FileList()  { }
FileList::~FileList() { }

void FileList::reset()
{
   clNames.resetEntries();
   clRoots.resetEntries();
   clTimes.resetEntries();
   clSizes.resetEntries();
}

int FileList::addFile(char *pszAbsName, char *pszRoot, num nTimeStamp, num nSize, char cSortedBy)
{__ _p("sf.addfile")

   // IF filename starts with ".\\", skip this part
   if (!strncmp(pszAbsName, glblDotSlash, strlen(glblDotSlash)))
      pszAbsName += strlen(glblDotSlash);

   // insert sorted by (1)name, (2)time, (3)size?
   int nInsPos = -1;

   if (cSortedBy == 'T' || cSortedBy == 't') {
      // find insert by time position
      int nCnt = clTimes.numberOfEntries();
      int i=0;
      for (i=0; i<nCnt; i++)
         if (cSortedBy=='T' && (clTimes.getEntry(i, __LINE__) > nTimeStamp))
            break;
         else
         if (cSortedBy=='t' && (clTimes.getEntry(i, __LINE__) < nTimeStamp))
            break;
      if (i < nCnt)
         nInsPos = i;
   }

   if (cSortedBy == 'S' || cSortedBy == 's') {
      // find insert by size position
      int nCnt = clSizes.numberOfEntries();
      int i=0;
      for (i=0; i<nCnt; i++)
         if (cSortedBy=='S' && (clSizes.getEntry(i, __LINE__) > nSize))
            break;
         else
         if (cSortedBy=='s' && (clSizes.getEntry(i, __LINE__) < nSize))
            break;
      if (i < nCnt)
         nInsPos = i;
   }

   if (cSortedBy == 'N' || cSortedBy == 'n') {
      // find insert by name position
      int nCnt = clNames.numberOfEntries();
      int i=0;
      for (i=0; i<nCnt; i++) {
         char *psz1 = clNames.getEntry(i, __LINE__);
         char *psz2 = pszAbsName;
         // both psz1 and psz2 point to a mixed string with a prefix.
         // need to find the actual filename first:
         int npre1 = atol(psz1)+6; if (npre1 < (int)strlen(psz1)) psz1 += npre1;
         int npre2 = atol(psz2)+6; if (npre2 < (int)strlen(psz2)) psz2 += npre2;
         int ncmp  = cs.usecase ? strcmp(psz1,psz2) : mystricmp(psz1, psz2);
         if (cSortedBy=='N' && ncmp > 0)
            break;
         else
         if (cSortedBy=='n' && ncmp < 0)
            break;
      }
      if (i < nCnt)
         nInsPos = i;
   }

   if (clNames.addEntry(pszAbsName, nInsPos)) return 9;
   if (clRoots.addEntry(pszRoot   , nInsPos)) return 9;
   if (clTimes.addEntry(nTimeStamp, nInsPos)) return 9;
   if (clSizes.addEntry(nSize     , nInsPos)) return 9;

   return 0;
}

// checkAndMark checks the filename and size,
// but NOT the rather complicated timestamps.
int FileList::checkAndMark(char *pszName, num nSize) {
   int nEntries = clNames.numberOfEntries();
   for (int i=0; i<nEntries; i++) {
      char *psz = clNames.getEntry(i, __LINE__);
      if ((psz[0] != 0) && !strcmp(psz, pszName)) {
         num nSize2 = clSizes.getEntry(i, __LINE__);
         if (nSize != nSize2)
            return 2; // on size mismatch, do NOT mark as done.
         psz[0] = '\0';
         return 0;
      }
   }
   return 1;
}

// ====================================================

#ifndef USE_SFK_BASE

class DupScanner
{
public:
   DupScanner     ( );
   int  addFile   (Coi *pcoi);      // copies just name, size
   int  analyze   (bool blistorg);
   void reset     ( );
   num  getHash   (Coi *pcoi);

public:
   int   analyzeBlock   (int ilo, int ihi, bool blistorg);
   int   bfind          (num nKeySize, int &rindex);

   NumTable    clSizes;
   NumTable    clTimes;
   StringTable clNames; // if name==null, was already processed
   StringTable clRoots;
   NumTable    clSumHi;
   NumTable    clSumLo;
   int   clNumOrgs;
   int   clNumDups;
   int   clSkipMatch;   // with syncnames
   num   clOrgBytes;
   num   clDupBytes;
   bool  clDiffDirs;    // list only dups from different dirs
   bool  clSyncNames;
   bool  clByName;
   bool  clByTime;
   bool  clUnsafe;
   char  *pszClSrcRoot; // with syncnames
   char  *pszClDstRoot; // with syncnames
   char  *pszClLog;
   FILE  *pClLog;
   char  clLocDupPath[SFK_MAX_PATH+10];
   char  clLocDupRoot[SFK_MAX_PATH+10];
   char  clLocTarget[SFK_MAX_PATH+10];
};

DupScanner::DupScanner() { reset(); }

void DupScanner::reset()
{
   clSizes.resetEntries();
   clTimes.resetEntries();
   clNames.resetEntries();
   clRoots.resetEntries();
   clSumHi.resetEntries();
   clSumLo.resetEntries();
   clNumOrgs  = 0;
   clNumDups  = 0;
   clOrgBytes = 0;
   clDupBytes = 0;
   clDiffDirs = 0;
   clSyncNames = 0;
   clByName   = 0;
   clByTime   = 0;
   clUnsafe   = 0;
   pszClLog   = 0;
   pClLog     = 0;
   clSkipMatch  = 0;
   pszClSrcRoot = 0;
   pszClDstRoot = 0;
}

// rc =0:found_and_index_set
// rc <0:insert_before_index
// rc >0:insert_after_index
int DupScanner::bfind(num nKeySize, int &rindex)
{
   // binary search for insert index by keysize
   uint nbot=0,ndist=0,nhalf=0,imid=0;
   uint ntop=clSizes.numberOfEntries(); // exclusive
   num  ntmp=0;
   int  ncmp=-1;   // if empty, insert before index 0

   while (1)
   {
      if (nbot > ntop) // shouldn't happen
         { perr(0, "int. 187281850"); ncmp=-1; break; }

      ndist = ntop - nbot;
      if (ndist == 0) break; // nothing left
 
      nhalf = ndist >> 1;
      imid  = nbot + nhalf;
      ntmp  = clSizes.getEntry(imid, __LINE__);
      ncmp  = nKeySize - ntmp;

      if (ncmp < 0) {
         // select lower half, if any
         // mtklog((" take lower %lxh %lxh %d",nval,ntmp,imid));
         if (ntop == imid) break; // safety
         ntop = imid;
      }
      else
      if (ncmp > 0) {
         // select upper half, if any
         // mtklog((" take upper %lxh %lxh %d",nval,ntmp,imid));
         if (nbot == imid+1) break; // required
         nbot = imid+1;
      } else {
         // straight match
         // mtklog(("%d = indexof(%.20s) used=%u",imid,pkey,clSizes.numberOfEntries()));
         break; // found
      }
   }

   rindex = imid;
   return ncmp;
}

num DupScanner::getHash(Coi *pcoi)
{
   num nSize = pcoi->getSize();

   if (nSize <= 0)
      return nSize;

   if (clByName == 0 && clByTime == 0)
      return nSize;

   SFKMD5 md5;

   if (clByName) {
      char *prelname = pcoi->relName();
      md5.update((uchar*)prelname, strlen(prelname));
   }
   if (clByTime) {
      num nTime = pcoi->getTime();
      md5.update((uchar*)&nTime, sizeof(nTime));
   }

   md5.update((uchar*)&nSize, sizeof(nSize));

   uchar *pdig = md5.digest();

   num nResult = 0;

   // use only 6 bytes of digest to keep positive values
   for (int i=0; i<6; i++)
   {
      nResult = (nResult << 8) | (num)(pdig[0]);
   }

   return nResult;
}

int DupScanner::addFile(Coi *pcoi)
{__
   char *pszFile = pcoi->name();

   num nSize = getHash(pcoi); // sfk1944 i/o getSize();

   if (nSize <= 0)
      return 1;

   num nTime = pcoi->getTime();
 
   // filter by size selection
   if (cs.selMinSize > 0 && nSize < cs.selMinSize)
      return 0;

   // find insert position
   int ipos = 0;
   if (cs.fast) // experimental
   {
      int isubrc = bfind(nSize, ipos);
      // continue with linear stepping
      for (; ipos<clSizes.numberOfEntries(); ipos++)
         if (nSize < clSizes.getEntry(ipos, __LINE__))
            break;
      if (ipos >= clSizes.numberOfEntries())
         ipos = -1;
   }
   else
   {
      for (; ipos<clSizes.numberOfEntries(); ipos++)
         if (nSize < clSizes.getEntry(ipos, __LINE__))
            break;
      if (ipos >= clSizes.numberOfEntries())
         ipos = -1;
   }
 
   int irc = 0;
   do
   {
      if (irc = clSizes.addEntry(nSize  , ipos))   break;
      if (irc = clTimes.addEntry(nTime  , ipos))   break;
      if (irc = clNames.addEntry(pszFile, ipos))   break;
      if (irc = clRoots.addEntry(glblFileSet.root(), ipos)) break;
      num nDummy = 0;
      if (irc = clSumHi.addEntry(nDummy , ipos))   break;
      if (irc = clSumLo.addEntry(nDummy , ipos))   break;
   }
   while (0);
 
   if (irc)
   {
      perr("Out of memory. Please select smaller folders to scan.\n");
      return 99; // enforce stop of file tree processing
   }

   return 0;
}

int DupScanner::analyze(bool blistorg)
{__
   char szAddInfo[200];

   int nTotal = clSizes.numberOfEntries();
 
   if (cs.fast != 0 && nTotal > 0)
   {
      // verify that all sizes are ascending or equal
      num nLastSize = clSizes.getEntry(0, __LINE__);
      num nCurSize  = nLastSize;
      for (int i=0; i<nTotal; i++) {
         nCurSize = clSizes.getEntry(i, __LINE__);
         if (nCurSize < nLastSize) {
            perr("data integrity error, disable -fast option");
            return 99;
         }
         nLastSize = nCurSize;
      }
   }

   #ifdef WITH_TRACING
   mtklog(("] scanned file sizes:"));
   for (int idump=0; idump<nTotal; idump++)
   {
      num nref  = clSizes.getEntry(idump, __LINE__);
      char *psz = clNames.getEntry(idump, __LINE__);
      mtklog(("%s %s",numtoa(nref),psz));
   }
   #endif

   num  nCurSize = -1;
   for (int iouter=0; iouter<nTotal && !userInterrupt();)
   {
      num nref = clSizes.getEntry(iouter, __LINE__);
      if (nref == nCurSize)
         return 9+perr("internal 279122205");

      // found start of new size block.
      nCurSize = nref;
      int iblocklo = iouter + 0;
      int iblockhi = iouter + 1;
      for (; iblockhi<nTotal && clSizes.getEntry(iblockhi, __LINE__) == nCurSize;)
         iblockhi++;

      // size block ranges from iblocklo to iblockhi-1
      if (iblockhi-iblocklo < 2)
      {
         // this block has just one entry.
         // if "list just orgs" mode selected
         if (blistorg) {
            char *pszOrg     = clNames.getEntry(iouter, __LINE__);
            char *pszOrgRoot = clRoots.getEntry(iouter, __LINE__);
            if (!pszOrg[0]) return 9+perr("internal 279122206");
            if (chain.colfiles) {
               // collect ORG names for next cmd
               Coi ocoi(pszOrg, pszOrgRoot);
               if (chain.addFile(ocoi)) // is copied
                  return 99+perr("out of memory: dsa.1");
            } else {
               chain.print(' ', 1, "%s", pszOrg);
            }
            clNumOrgs++;
            clOrgBytes += nCurSize;
         }
         iouter = iblockhi;
         continue;
      }

      // have at least two entries in this block.
      // build content md5sums.
      int nBlockFiles   = iblockhi-iblocklo;
      num  nCurFileSize = clSizes.getEntry(iblocklo, __LINE__);
      num  nCurFileTime = clTimes.getEntry(iblocklo, __LINE__); // -bytime only
      if (clByName || clByTime)
      {
         // 'size' is just a hash. must re-read exact data.
         char *pszFile = clNames.getEntry(iblocklo, __LINE__);
         nCurFileSize  = getFileSize(pszFile);
         if (nCurFileSize < 0)
            return 9+perr("invalid state, cannot read: %s", pszFile);
      }
      for (int icur=iblocklo; icur<iblockhi; icur++)
      {__
         char *pszFile = clNames.getEntry(icur, __LINE__);
         nCurFileTime  = clTimes.getEntry(icur, __LINE__);

         info.setProgress(nBlockFiles, icur-iblocklo, "files");
         sprintf(szAddInfo, "%d files of size %s", nBlockFiles, numtoa(nCurFileSize));
         info.setStatus("scan", pszFile, szAddInfo, (icur==iblocklo) ? eSlowCycle : 0);

         SFKMD5 md5;
         uchar abDummy[16];
         unsigned char *pmd5 = abDummy;

         if (clUnsafe)
         {
            // fast and unsafe comparison
            do
            {
               char *prel = strrchr(pszFile, glblPathChar);
               if (!prel) return 19+perr("int. #2195193");
               prel++;
               if (strlen(prel) < 1) return 19+perr("int. #2195194");

               if (clByName)
                  md5.update((uchar*)prel,strlen(prel));

               if (clByTime)
                  md5.update((uchar*)&nCurFileTime,sizeof(nCurFileTime));

               // safety: re-read filesize
               nCurFileSize = getFileSize(pszFile);
               if (nCurFileSize < 0)
                  break;

               // abBuf has 100k total
               int nprobe = 16384;

               // on small files use just head
               if (nCurFileSize <= nprobe*2)
                   nprobe = nprobe*2;

               memset(abBuf, 0, nprobe);

               FILE *fin = fopen(pszFile, "rb");
               if (!fin) break;

               // 2. by first 8k of file
               int iread = fread(abBuf, 1, nprobe, fin);
               if (iread > 0)
               {
                  md5.update(abBuf, iread);
                  if (nCurFileSize >= nprobe*2)
                  {
                     // 3. by last 8k of file
                     myfseek(fin, nCurFileSize-nprobe, SEEK_SET);
                     iread = fread(abBuf, 1, nprobe, fin);
                     if (iread > 0)
                        md5.update(abBuf, iread);
                  }
               }

               fclose(fin);

               pmd5 = md5.digest();

            } while (0);
         }
         else
         if (!getFileMD5(pszFile, md5, 0, 1))
            pmd5 = md5.digest();

         if (pmd5 == abDummy)
         {
            // cannot read file: create random digest,
            // to make sure no wrong duplicates are listed.
            for (int i=0; i<sizeof(abDummy); i++)
               abDummy[i] = (uchar)rand();
            // furthermore remove filename to block any post processing.
            clNames.setEntry(icur, str(""));
         }
         num nsumlo=0, nsumhi=0;
         for (int i=0,b=64-8; i<8; i++) {
            nsumhi = nsumhi | (((num)pmd5[0+i]&0xFF) << b);
            nsumlo = nsumlo | (((num)pmd5[8+i]&0xFF) << b);
            b -= 8;
         }
         clSumHi.updateEntry(nsumhi, icur);
         clSumLo.updateEntry(nsumlo, icur);
      }
 
      // all prepared for this block, list results:
      if (analyzeBlock(iblocklo, iblockhi, blistorg) >= 99)
         return 99; // out of memory, or internal error

      // proceed to next size block
      iouter = iblockhi;
   }

   return 0;
}

#define checkPtr(ptr,id) do { if (!ptr) return 99+perr("int. #211618" #id); } while (0)

int moveFile(char *pszSrc, char *pszDst);

int DupScanner::analyzeBlock(int ilo, int ihi, bool blistorg)
{__
   for (int iorg=ilo; iorg<ihi; iorg++)
   {__
      char *pszOrg     = clNames.getEntry(iorg, __LINE__);  checkPtr(pszOrg, 1);
      if (!pszOrg[0]) continue; // already processed
      char *pszOrgRoot = clRoots.getEntry(iorg, __LINE__);  checkPtr(pszOrgRoot, 2);

      // get current potential org data
      num nsumhi = clSumHi.getEntry(iorg, __LINE__);
      num nsumlo = clSumLo.getEntry(iorg, __LINE__);

      // see if any dups are present for this
      bool btoldorg=0;
      int  ilocdups=0;      // no. of local dups
      clLocDupPath[0]='\0'; // name of last local dup
      clLocDupRoot[0]='\0'; // root of last local dup
      for (int idup=iorg+1; idup<ihi; idup++)
      {__
         char *pszDup     = clNames.getEntry(idup, __LINE__);  checkPtr(pszDup, 3);
         if (!pszDup[0]) continue; // already processed
         char *pszDupRoot = clRoots.getEntry(idup, __LINE__);  checkPtr(pszDupRoot, 4);

         if (clDiffDirs && !strcmp(pszOrgRoot, pszDupRoot))
            continue; // skip, both files have same root dir

         num nduphi = clSumHi.getEntry(idup, __LINE__);
         num nduplo = clSumLo.getEntry(idup, __LINE__);
         if (nduphi == nsumhi && nduplo == nsumlo)
         {__
            // found a dup for iorg.
            if (!clSyncNames && !blistorg) {
               if (chain.colfiles) {
                  // collect dup names for next cmd
                  Coi ocoi(pszDup, pszDupRoot);
                  if (chain.addFile(ocoi)) // is copied
                     return 99+perr("out of memory: dsab.1");
               } else {
                  if (!btoldorg) {
                     btoldorg = 1;
                     chain.print('f', 1, "%s", pszOrg);
                  }
                  chain.print(' ', 1, "   %s", pszDup);
               }
            }

            ilocdups++;
            strcopy(clLocDupPath, pszDup);
            strcopy(clLocDupRoot, pszDupRoot);

            clNumDups++;
            if (!clByName && !clByTime)
               clDupBytes += clSizes.getEntry(idup, __LINE__);

            // mark dup as processed
            clNames.setEntry(idup, str(""));
         }
      }  // endfor potential dups

      // if "list just orgs" mode selected
      if (!clSyncNames && blistorg)
      {__
         if (chain.colfiles) {
            // collect ORG names for next cmd
            Coi ocoi(pszOrg, pszOrgRoot);
            if (chain.addFile(ocoi)) // is copied
               return 99+perr("out of memory: dsab.2");
         } else {
            chain.print(' ', 1, "%s", pszOrg);
         }
         clNumOrgs++;
         clOrgBytes += clSizes.getEntry(iorg, __LINE__);
      }

      int isubrc = 0;

      // sfk1944: unique dup?
      if (ilocdups == 1 && clSyncNames == 1)
      do
      {__
         if (cs.debug) printf("sync.org : %s in %s\n", pszOrg, pszOrgRoot);
         if (cs.debug) printf("sync.dup : %s in %s\n", clLocDupPath, clLocDupRoot);
         // safety checks
         if (!strbeg(pszOrg, pszOrgRoot))        return 9+perr("int. #2195191");
         if (!strbeg(clLocDupPath, clLocDupRoot))  return 9+perr("int. #2195192");
         if (!strcmp(pszOrgRoot, clLocDupRoot)) {
            perr("source/target dir must differ");
            pinf("src: %s\n", pszOrgRoot);
            pinf("dst: %s\n", clLocDupRoot);
            return 9;
         }
         // relativize names
         char *pszOrgRel = pszOrg+strlen(pszOrgRoot);
         if (ispathchr(*pszOrgRel)) pszOrgRel++;
         char *pszDstRel = clLocDupPath+strlen(clLocDupRoot);
         if (ispathchr(*pszDstRel)) pszDstRel++;
         // synthesize destination path
         joinPath(clLocTarget, SFK_MAX_PATH, clLocDupRoot, pszOrgRel);
         // if dst exists is was already moved
         if (!strcmp(pszOrgRel, pszDstRel) || fileExists(clLocTarget)) {
            if (cs.debug) printf("         > target exists (already moved)\n");
            break;
         }
         if (cs.yes)
            createOutDirTree(clLocTarget);
         isubrc = execFileMoveSub(clLocDupPath, clLocTarget);
         if (!isubrc) {
            cs.filesMoved++;
            if (pClLog) {
               num ntime = time(0);
               fprintf(pClLog, "%.8s\t%s\t%s\n", timeAsString(ntime,1), clLocDupPath, clLocTarget);
            }
         }
      }
      while (0);

      // mark org as processed
      clNames.setEntry(iorg, str(""));

      // safety on fatal errors like unwriteable output
      if (isubrc >= cs.treeStopRC)
         return isubrc;

   }  // endfor orgs
 
   return 0;
}

DupScanner glblDupScan;

#endif // USE_SFK_BASE

enum eDirCommands {
   eCmd_CopyDir      = 1,
   eCmd_FreezeDir    = 2,
   eCmd_Undefined    = 0xFF
};

FileSet::FileSet()
 : clRootDirs("RootDirs"),
   clDirMasks("DirMasks"),
   clFileMasks("FileMasks")
{
   nClCurDir   =  0;
   nClCurLayer = -1;
   pClLineBuf  = new char[MAX_LINE_LEN+10];
   resetAddFlags();
}

FileSet::~FileSet() {
   shutdown();
}

void FileSet::resetAddFlags() {
   bClGotAllMask = 0;
   bClGotPosFile = 0;
   bClGotNegFile = 0;
}

void FileSet::reset()
{
   nClCurDir   =  0;
   nClCurLayer = -1;
   resetAddFlags();
   clRootDirs.reset();
   clDirMasks.reset();
   clFileMasks.reset();
}

void FileSet::shutdown() {
   reset();
   delete [] pClLineBuf;
   pClLineBuf = 0;
}

char* FileSet::firstFileMask() {
   Array &rMasks = fileMasks();
   if (!rMasks.isStringSet(0)) return str("*");
   return rMasks.getString(0);
}

int FileSet::getDirCommand() {
   return clRootDirs.getLong(1, nClCurDir, __LINE__);
}

/*
   A "layer" is a set of dir and file masks, which may be
   referenced by one or many root directories.
*/

void FileSet::dump()
{__
   printf("=== fileset begin ===\n");

   for (int i1=0; clRootDirs.isStringSet(0,i1); i1++)
   {
      int nLayer = clRootDirs.getLong(2,i1, __LINE__);
      int nCmd   = 0;
      if (clRootDirs.isLongSet(1,i1))
           nCmd   = clRootDirs.getLong(1,i1, __LINE__);
      printf("] ROOT \"%s\" -> layer %d, cmd %d\n",
         clRootDirs.getString(0,i1),
         nLayer,
         nCmd
         );
   }

   for (int iLayer=0; clDirMasks.hasRow(iLayer); iLayer++)
   {
      printf("] layer %d:\n", iLayer);

      printf("]  dmsk:\n");
      for (int i5=0; clDirMasks.isStringSet(iLayer, i5); i5++)
         printf("]   %s\n",clDirMasks.getString(iLayer, i5));

      printf("]  fmsk:\n]   ");
      for (int i6=0; clFileMasks.isStringSet(iLayer, i6); i6++)
         printf("%s, ",clFileMasks.getString(iLayer, i6));
      printf("\n");
   }

   printf("=== fileset end ===\n");
}

char *FileSet::currentInfoLine(int iLine)
{
   pClLineBuf[0] = '\0';
 
   // required:
   //  nClCurDir   is set
   //  nClCurLayer is set
   if (!hasRoot(nClCurDir))
      return str("");
   if (nClCurLayer < 0)
      return str("");

   int iLayer = nClCurLayer;
   char *pszUnit = 0;

   switch (iLine)
   {
      case 1: // current root dir
         return getCurrentRoot();
 
      case 2: // current layer's dir mask set
      {
         for (int i=0; clDirMasks.isStringSet(iLayer, i); i++) {
            pszUnit = clDirMasks.getString(iLayer, i);
            if (!strcmp(pszUnit, "*"))
               continue;
            if (strlen(pClLineBuf) > MAX_LINE_LEN-100)
               break;
            mystrcatf(pClLineBuf, MAX_LINE_LEN-100, "%s ", pszUnit);
         }
         break;
      }

      case 3: // current layer's file mask set
      {
         for (int i=0; clFileMasks.isStringSet(iLayer, i); i++) {
            pszUnit = clFileMasks.getString(iLayer, i);
            if (!strcmp(pszUnit, "*"))
               continue;
            if (strlen(pClLineBuf) > MAX_LINE_LEN-100)
               break;
            mystrcatf(pClLineBuf, MAX_LINE_LEN-100, "%s ", pszUnit);
         }
         break;
      }
   }
 
   return pClLineBuf;
}

// like dump, but easier representation, using pinf
void FileSet::info(void (*pout)(int nrectype, char *pline))
{
   char *psml = szLineBuf;
   char *pbig = (char*)abBuf;

   for (int i1=0; clRootDirs.isStringSet(0,i1); i1++)
   {
      int nLayer = clRootDirs.getLong(2,i1, __LINE__);
      int nCmd   = 0;
      if (clRootDirs.isLongSet(1,i1))
           nCmd   = clRootDirs.getLong(1,i1, __LINE__);

      sprintf(pbig, "directory tree %d:", i1+1);
      pout(1, pbig);

      pout(2, clRootDirs.getString(0,i1));

      // list masks used by that tree, possibly redundant
      int iLayer = nLayer;

      pbig[0] = '\0';
      int i5=0;
      for (; clDirMasks.isStringSet(iLayer, i5); i5++) {
         strcat(pbig, clDirMasks.getString(iLayer, i5));
         strcat(pbig, " ");
      }
      if (i5) {
         sprintf(psml, "... uses %d dir masks:", i5);
         pout(3, psml);
         pout(4, pbig);
      } else {
         pout(3, str("... uses no dir masks."));
      }

      pbig[0] = '\0';
      int i6=0;
      for (; clFileMasks.isStringSet(iLayer, i6); i6++) {
         strcat(pbig, clFileMasks.getString(iLayer, i6));
         strcat(pbig, " ");
      }
      if (i6) {
         sprintf(psml, "... uses %d file masks:", i6);
         pout(5, psml);
         pout(6, pbig);
      } else {
         pout(5, str("... uses no file masks."));
      }
   }
}

int FileSet::checkConsistency()
{__
   int nLayers = 0;
   for (int i0=0; clDirMasks.hasRow(i0); i0++)
      nLayers++;

   mtklog(("check consistency of %d layers", nLayers));

   int lRC = 0;

   int *pRefCnt = new int[nLayers+10];
   memset(pRefCnt, 0, (nLayers+10)*sizeof(int));
   // NO RETURN FROM HERE

   // count for each layer how often it's referenced
   for (int i1=0; clRootDirs.isStringSet(0,i1); i1++)
   {
      int iLayer = clRootDirs.getLong(2,i1, __LINE__);
      if (iLayer < 0 || iLayer >= nLayers) {
         perr("internal #60 %d\n", iLayer);
         lRC = 9;
         break;
      }
      mtklog(("root %d references layer %d", i1, iLayer));
      pRefCnt[iLayer]++;
   }

   // find unreferenced layers
   for (int i2=0; i2<nLayers; i2++) {
      if (!pRefCnt[i2]) {
         // if -any is specified, the first layer is used implicitely
         // to list important file extensions.
         if ((i2 == 0) && cs.anyused)
            continue;
         perr("wrong -dir and -file sequence (%d)\n", i2);
         pinf("specify -dir ... before -file\n");
         pinf("or type a single filename as first parameter.\n");
         lRC = 9;
      }
   }

   // NO RETURN UNTIL HERE
   delete [] pRefCnt;

   return lRC;
}

bool FileSet::anyRootAdded() {
   return (clRootDirs.numberOfEntries() > 0) ? 1 : 0;
}

// does the current root have any non-"*" file masks set?
bool FileSet::anyFileMasks()
{
   if (clFileMasks.numberOfEntries() <= 0)
      return false;

   // check if there is any non-"*" file mask
   for (int i=0; clFileMasks.isStringSet(i); i++)
   {
      char *pszMask = clFileMasks.getString(i);
      if (strcmp(pszMask, "*"))
         return true;
   }

   // if not, say no mask is set.
   return false;
}

bool FileSet::hasRoot(int iIndex) {
   bool bRC = clRootDirs.isStringSet(iIndex);
   // if (cs.debug) printf("] %d = hasRoot(%d)\n", bRC, iIndex);
   return bRC;
}

char* FileSet::setCurrentRoot(int iIndex)
{
   if (cs.debug) printf("] select root %d\n",iIndex);
   mtklog(("FileSet::setCurrentRoot(%d)", iIndex));
   nClCurDir = iIndex;
   // the root dir no. iIndex selects a specific layer.
   nClCurLayer = clRootDirs.getLong(2, iIndex, __LINE__);
   clRootDirs.setRow(0, __LINE__);
   // fully switch to current layer
   if (cs.debug) printf("]  select layer %d\n",nClCurLayer);
   mtklog(("   select layer %d",nClCurLayer));
   clDirMasks.setRow(nClCurLayer, __LINE__);
   clFileMasks.setRow(nClCurLayer, __LINE__);
   return getCurrentRoot();
}

// return current root or simply "" if none:
char *FileSet::root(bool braw) {
   if (!hasRoot(nClCurDir)) return braw ? 0 : (char*)"";
   return getCurrentRoot();
}

char* FileSet::getCurrentRoot()
{
   char *pszDirName = clRootDirs.getString(0, nClCurDir);
   // prefix by preroot, if any
   if (pszGlblPreRoot) {
      // printf("PRE %s ADD %s\n",pszGlblPreRoot,pszDirName);
      strcopy(szGlblMixRoot, pszGlblPreRoot);
      // avoid to append "./" as dir name
      if (!strncmp(pszDirName, glblDotSlash, 2))
         pszDirName += 2;
      // avoid to append "." as dir name
      if (!strcmp(pszDirName, "."))
         pszDirName++;
      // any local dir remaining to append?
      if (strlen(pszDirName)) {
         if (!endsWithPathChar(szGlblMixRoot) && !endsWithColon(szGlblMixRoot))
            strcat(szGlblMixRoot, glblPathStr);
         strcat(szGlblMixRoot, pszDirName);
      }
      pszDirName = szGlblMixRoot;
   }
   return pszDirName;
}

// just for webserv
int FileSet::changeSingleRoot(char *pszNew)
{
   if (clRootDirs.numberOfEntries(0) != 1)
      return 9+perr("cannot changeSingleRoot (%d/1)",clRootDirs.numberOfEntries(0));
   return clRootDirs.setString(0, 0, pszNew);
}

int FileSet::numberOfRootDirs() {
   return clRootDirs.numberOfEntries(0);
}

int FileSet::ensureBase(int nTraceLine) {
   mtklog(("fs: ensureBase %d", nTraceLine));
   // clRootDirs must have 3 rows
   while (!clRootDirs.hasRow(2)) {
      mtklog(("fs: ... add another row"));
      if (clRootDirs.addRow(nTraceLine))
         return 9;
   }
   return 0;
}

// a layer is one set of dir masks and file masks.
// - dir masks is a row in clDirMasks.
// - file masks is a row in clFileMasks.
// - command is 1:1 per directory root,
//   therefore cmd is stored in clRootDirs.
// - clRootDirs row 0 is the directory name.
// - clRootDirs row 1 is the directory command (zip, copy).
// - a directory tree references a layer.

int FileSet::beginLayer(bool bWithEmptyCommand, int nTraceLine)
{
   mtklog(("fs: beginlayer %d", nTraceLine));

   // reset state of add sequence controlling
   resetAddFlags();

   // ensure clRootDirs has two columns
   if (ensureBase(__LINE__)) return 9;
   // make space for new layer
   clDirMasks.addRow(__LINE__);
   clFileMasks.addRow(__LINE__);
   // count new layer
   nClCurLayer++;
   // printf("] BEGINLAYER: new current=%d [\n",nClCurLayer);

   // a "command" is "-copy" or "-zip", used only with freezeto.
   // all other commands will just fill the command column with dummys.
   if (bWithEmptyCommand) {
      // set dummy command "0" in row 1 of clRootDirs
      clRootDirs.addLong(1, 0, __LINE__);
   }
   return 0;
}

int FileSet::addRootDir(char *pszRoot, int nTraceLine,
   bool bNoCmdFillup, bool bAutoUseArc)
{
   mtklog(("fs: addRootDir %s from %d", pszRoot, nTraceLine));

   if (cs.debug) printf("] add root dir: %s, referencing layer: %d [tline %d]\n", pszRoot, nClCurLayer, nTraceLine);

   // prefix root: if -root is given.
   // purify root: no patch char appended.
   if (cs.rootdir[0]) {
      if (strcmp(pszRoot, ".")) // avoid mydir\.\first.txt
         joinPath(pClLineBuf, MAX_LINE_LEN, cs.rootdir, pszRoot);
      else
         strncpy(pClLineBuf, cs.rootdir, MAX_LINE_LEN);
      pClLineBuf[MAX_LINE_LEN] = '\0';
      if (cs.debug) printf("]  use prefixed: %s\n", pClLineBuf);
   } else {
      strncpy(pClLineBuf, pszRoot, MAX_LINE_LEN);
      pClLineBuf[MAX_LINE_LEN] = '\0';
   }

   pszRoot = pClLineBuf;

   if (endsWithPathChar(pszRoot)) {
      #ifdef _WIN32
      if (strlen(pszRoot) == 3 && pszRoot[1] == ':')
         { } // do not strip / from c:/
      else
      #endif
      if (strlen(pszRoot) > 1)
         pszRoot[strlen(pszRoot)-1] = '\0';
   }

   if (ensureBase(__LINE__)) return 9;
   if (nClCurLayer == -1) {
      if (cs.debug) printf("] impl. create first fileset layer\n");
      beginLayer(true, __LINE__);
   }
   // complete the current column
   int nMax = clRootDirs.numberOfEntries(0);
   if (!bNoCmdFillup)
      if (clRootDirs.numberOfEntries(1) < nMax)
          clRootDirs.addLong(1, 0, __LINE__); // add empty command
   if (clRootDirs.numberOfEntries(2) < nMax)
      return 9+perr("internal #20\n");

   // add another root dir, forward-referencing
   // the current layer in which masks will follow.
   clRootDirs.addString(0,pszRoot);
   clRootDirs.addLong(2,nClCurLayer, __LINE__);

   #ifdef VFILEBASE
   // implicite activation of zip travel by root dir:
   if (bAutoUseArc && endsWithArcExt(pszRoot, 2)) {
      cs.xelike     = 1;
      cs.travelzips = 1;
   }
   #endif // VFILEBASE

   return 0;
}  // FileSet::addRootDir

int FileSet::addDirCommand(int lCmd)
{
   if (ensureBase(__LINE__)) return 9;
   // one single -cmd may map to several root dirs.
   // example: -dir a1 a2 a3 -copy
   // therefore fill up until root dir names number reached.
   int nMax = clRootDirs.numberOfEntries(0);
   while (clRootDirs.numberOfEntries(1) < nMax)
      clRootDirs.addLong(1, lCmd, __LINE__);
   return 0;
}

int FileSet::addDirMask(char *pszMask)
{
   if (ensureBase(__LINE__)) return 9;
 
   // per definitionem,  ".ext" means ".ext/"
   // per definitionem, "!.ext" means "!.ext/"
   // per definitionem, "*.ext" means "*.ext/"
 
   int iMaskLen = strlen(pszMask);
   if (pszMask[0] == '.' && pszMask[iMaskLen-1] != glblPathChar)
   {
      snprintf(pClLineBuf, MAX_LINE_LEN-10, "%s%c", pszMask, glblPathChar);
      pszMask = pClLineBuf;
   }
   else
   if (   isNotChar(pszMask[0]) != 0
       && pszMask[1] == '.'
       && pszMask[iMaskLen-1] != glblPathChar)
   {
      snprintf(pClLineBuf, MAX_LINE_LEN-10, "%s%c", pszMask, glblPathChar);
      pszMask = pClLineBuf;
   }
   else
   if (   pszMask[0] == glblWildChar
       && pszMask[1] == '.'
       && pszMask[iMaskLen-1] != glblPathChar)
   {
      snprintf(pClLineBuf, MAX_LINE_LEN-10, "%s%c", pszMask, glblPathChar);
      pszMask = pClLineBuf;
   }
 
   clDirMasks.addString(pszMask);
 
   return 0;
}

int FileSet::addFileMask(char *pszMask)
{
   // if (cs.debug) printf("] addFileMask %s\n", pszMask);
   if (ensureBase(__LINE__)) return 9;

   // per definitionem,  ".ext" means ".ext/"
   // per definitionem, "!.ext" means "!.ext/"
 
   int iMaskLen = strlen(pszMask);
   if (pszMask[0] == '.' && pszMask[iMaskLen-1] != glblPathChar)
   {
      snprintf(pClLineBuf, MAX_LINE_LEN-10, "%s%c", pszMask, glblPathChar);
      pszMask = pClLineBuf;
   }
   else
   if (   isNotChar(pszMask[0]) != 0
       && pszMask[1] == '.'
       && pszMask[iMaskLen-1] != glblPathChar)
   {
      snprintf(pClLineBuf, MAX_LINE_LEN-10, "%s%c", pszMask, glblPathChar);
      pszMask = pClLineBuf;
   }

   #ifdef VFILEBASE
   if (!cs.shallowzips && cs.xelike && cs.travelzips && maskEndsWithArcExt(pszMask, 3))
   {
      pinf("file mask \"%s\" may produce no results, because\n",pszMask);
      char *pext = strrchr(pszMask, '.');
      if (!pext) pext = pszMask;
      pinf("option -arc is set, treating %s files as directories.\n",pext);
      pinf("say -dir ... %c%s -file ... instead to use %s as a path mask.\n",glblWildChar,pext,pszMask);
   }
   #endif // VFILEBASE

   if (!strcmp(pszMask, "-all") || isWildStr(pszMask)) {
      if (bClGotAllMask)
         return 9+perr("-all or %c supplied multiple times.\n", glblWildChar);
      if (bClGotPosFile) {
         if (bGlblAllowAllPlusPosFile)
            pwarn("wrong sequence: positive file pattern already given, specify \"%s\" before this.\n", pszMask);
         else
            pwarn("positive file pattern already given, \"%s\" is unexpected.\n", pszMask);
      }
      if (bClGotNegFile)
         return 9+perr("wrong sequence: negative file pattern already given, specify \"%s\" before this.\n", pszMask);
      // map to * internally:
      pszMask = str("*");    // no wildstr, using real * internally
      bClGotAllMask = 1;
   }
   else
   if (isNotChar(pszMask[0])) {
      // negative file pattern: if it is the very first pattern
      if (!bClGotAllMask && !bClGotPosFile && !bClGotNegFile)
         clFileMasks.addString(str("*")); // IMPLICITELY. no wildstr.
      bClGotNegFile = 1;
   }
   else {
      // positive file pattern:
      if (bClGotAllMask && !bGlblAllowAllPlusPosFile)
         pwarn("-all or * already given, \"%s\" has no effect.\n", pszMask);
      if (bClGotNegFile)
         return 9+perr("wrong sequence: negative file pattern already given, specify \"%s\" before this.\n", pszMask);
      bClGotPosFile = 1;
   }

   clFileMasks.addString(pszMask);
   return 0;
}

int FileSet::autoCompleteFileMasks(int nWhat)
{
   if (cs.debug) printf("] autocomplete %d:\n", nWhat);

   if (nWhat & 1)
   for (int irow=0; clFileMasks.hasRow(irow); irow++) {
      if (clFileMasks.setRow(irow, __LINE__)) return 9;
      if (clFileMasks.numberOfEntries() == 0) {
         if (cs.debug) printf("]  yes, at layer %d\n",irow);
         if (clFileMasks.addString(str("*"))) return 9;   // no wildstr
      }
   }

   if (nWhat & 2)
   if (clRootDirs.numberOfEntries() == 0) {
      if (cs.debug) printf("] adding dir .\n");
      addRootDir(str("."), __LINE__, false);
   }

   return 0;
}

void FileSet::setBaseLayer()
{
   clRootDirs.setRow(0, __LINE__);
   clDirMasks.setRow(0, __LINE__);
   clFileMasks.setRow(0, __LINE__);
}

BinTexter::BinTexter(Coi *pcoi)
{
   memset(this, 0, sizeof(*this));
   pClCoi = pcoi;
}

BinTexter::~BinTexter()
{
   memset(this, 0, sizeof(*this));
}

// uses szLineBuf. Result in szLineBuf2.
int BinTexter::process(int nDoWhat)
{
   int icol   = 0;
   int istate = 0;
   int iword  = 0;  // index in short word target buffer
   int nword  = 0;  // to count non-binary word length
   int ihi    = 0;
   bool bflush = 0;
   bool bisws  = 0;
   bool bwasws = 0;
   bool bisbin = 0;
   bool bishi  = 0;
   bool bispunct = 0;
   bool bhardwrap = 0;
   bool babineol = 0; // helper flag, add blank if not at end of line
   char c = 0;
   unsigned char uc = 0;
   int nLine = 0;
   int nMinWord = 1; // min word length adapted dynamically below
   int lRC = 0;

   szClOutBuf[0] = '\0';

   num  nTellTime = getCurrentTime();
   int nTellLines = 0;

   bool bbail = 0;
   while (!bbail)
   {
      int nRead = pClCoi->read(szLineBuf, sizeof(szLineBuf)-10);

      if (nRead <= 0) {
         bbail = 1;
         nRead = 1;
      }
 
      if (nTellLines++ > 1000) {
         nTellLines = 0;
         if (getCurrentTime() > nTellTime + 1000) {
            // working on the same file for 1000 msec: show status
            nTellTime = getCurrentTime();
            if (!cs.quiet && pClCoi->name()) {
               info.setAddInfo("%u files, %u dirs", cs.filesScanned, cs.dirsScanned);
               info.setStatus("scan", pClCoi->name(), 0, eKeepAdd);
            }
         }
      }

      // .
      for (int i=0; i<nRead; i++)
      {
         if (bbail) {
            c  = 0x00;
            uc = (unsigned char)c;
            bflush = 1;
         } else {
            c  = szLineBuf[i];
            uc = (unsigned char)c;
            bflush = 0;
         }

         if (c=='\n') {
            nLine++;
            bflush = 1;
            bhardwrap = 1;
         }

         if (cs.rewrap) {
            // reformatting plain text
            bisbin = (uc == 0) ? 1 : 0; // just in case
         } else {
            // reformatting binary
            bisbin = (uc < 0x20) ? 1 : 0;
            if (uc >= 0x80 && cs.binallchars == 0) // sfk190
               bisbin = 1;
            // if (cs.binallchars == 0)
            //    bishi = (uc >= 0xC0);
         }

         if (!bisbin && !bishi)
            nword++;

         if (sfkisprint(c) && !bisbin)
         {
            // printable char
            if (istate == 1) {
               // start collecting next word
               istate = 0;
               iword = 0;
               ihi   = 0;
            }
            // continue collecting current word,
            // reduce multi-whitespace sequences.
            bisws    = (c==' ' || c=='\t');
            bispunct = 0;
            if (cs.delim && strchr(cs.delim, c)) // CHG: 1703: instead of (c=='.' || c==',' || c==';');
               bispunct = 1;
            if (!(bisws && bwasws)) {
               szLineBuf2[iword++] = c;
               if (bishi)
                  ihi++;
            }
            // hard or soft word break?
            if (iword >= cs.wrapbincol)
               bflush = 1;
            else
            if ((iword >= 20) && (bisws || bispunct))
               bflush = 1;
         } else {
            // non-printable (binary) char
            if (istate == 0)  // if collecting a word
               bflush = 1;    // then flush the word
            // start skipping non-word data (binary etc.)
            istate = 1;
            bwasws = 0;
            bisws  = 0;
            bispunct = 0;
            // increment min word length needed to add to buffer.
            nMinWord = 3;
         }

         // dump current word?
         if (bflush)
         {
            bflush = 0;
            if ((iword >= nMinWord || nword >= nMinWord) || c == '\n' || bbail)
            {
               // reset "add blank if not at end of line"
               babineol = 0;

               szLineBuf2[iword] = '\0';

               // do not add blank after whitespace, punct, or End Of Data.
               // add blank after a linefeed, if not in grep mode.
               if (bisws || bispunct || bbail || c == '\n') {
                  if (nDoWhat != eBT_Grep && c == '\n')
                     if (iword > 0 || nword > 0)
                        babineol = 1;
               } else {
                  // all other cases including '\r':
                  // add blank between isolated expressions
                  babineol = 1; // if not at end of line
               }

               if (strlen(szClOutBuf) + strlen(szLineBuf2) < sizeof(szClOutBuf)-10)
                  strcat(szClOutBuf, szLineBuf2);
               // else
               //    pwarn("buffer overflow (%d/%d/%d)\n",
               //       (int)strlen(szClOutBuf), (int)strlen(szLineBuf2), (int)sizeof(szClOutBuf)-10);

               icol += (iword+1);

               // strings and jamfile: create floating text.
               // in case of grep, keep hard line breaks.
               if (nDoWhat != eBT_Grep && c == '\n')
                  c = ' '; // binary to text: wrap floating text

               if (icol >= cs.wrapbincol || c == '\n' || bbail)
               {
                  // line flush.
                  if ((lRC = processLine(szClOutBuf, nDoWhat, nLine, bhardwrap)))
                     return lRC;
                  // sfk181: option -maxlines with find
                  if (cs.maxlines>0 && nLine>cs.maxlines)
                     { bbail=1; break; }
                  bhardwrap = 0;
                  icol = 0;
                  szClOutBuf[0] = '\0';
                  nword = 0;
                  nMinWord = 1;
               }
               else
               if (babineol)
               {
                  // no line flush, further stuff will be added,
                  // and remembered to insert a blank before that.
                  strcat(szClOutBuf, " ");
               }
            }
            iword  = 0;
            ihi    = 0;
            bwasws = 0;
         }
         else
            bwasws = bisws;

         // "sane" word count reset on any binary or non-printable
         if (bisbin || bishi || (c < 0x20))
            nword  = 0;
      }
   }

   return 0;
}

// snapto optional callback functions
int (*pGlblJamCheckCallBack)(char *pszFilename) = 0;
int (*pGlblJamFileCallBack)(char *pszFilename, num &rLines, num &rBytes) = 0;
int (*pGlblJamLineCallBack)(char *pszLine, int nLineLen, bool bAddLF) = 0;
int (*pGlblJamStatCallBack)(Coi *pCoiOrNull, uint nFiles, uint nLines, uint nMBytes, uint nSkipped, char *pszSkipInfo) = 0;
int (*pGlblShowDataCallBack)(char *pszLine, int nLineLen) = 0;

int BinTexter::processLine(char *pszBuf, int nDoWhat, int nLine, bool bHardWrap)
{
   int iRC = 0;

   info.cycle();

   if (nDoWhat == eBT_Print) {
      if (chain.coldata) {
         setattr(szAttrBuf3, 'f', strlen(szClOutBuf)+2, MAX_LINE_LEN);
         chain.addLine(szClOutBuf, szAttrBuf3);
      } else {
         info.print("%s\n", szClOutBuf);
      }
   }
   else
   if (nDoWhat == eBT_JamFile)
   {
      int dumpJamLine(char *pszLine, int nLineLen, bool bAddLF); // len 0: zero-terminated

      // strip empty lines from binary text:
      if (!strlen(szClOutBuf) || szClOutBuf[0] == '\n')
         return 0;

      int lRC = dumpJamLine(szClOutBuf, 0, 1);

      cs.totalbytes += strlen(szClOutBuf);
      cs.lines++;

      // only for callback: check per line if stat update is required.
      // it doesn't matter that nLines is actually counted past call to dumpJamLine.
      if (pGlblJamStatCallBack && glblFileCount.checkTime())
      {
         lRC |= pGlblJamStatCallBack(pClCoi, glblFileCount.value(), cs.lines, (uint)(cs.totalbytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
         // NO printf output here! BinTexter is also used by grep, strings.
      }

      return lRC;
   }
   else
   if (nDoWhat == eBT_Grep)
   {
      // 1. count no. of hits across current AND last line
      int nMatchCur = 0;
      int nMatchPre = 0;
      int nGrepPat  = glblGrepPat.numberOfEntries();
      int iHitOff   = 0;
      for (int i=0; ((nMatchCur+nMatchPre) < nGrepPat) && (i<nGrepPat); i++)
      {
         if (mystrhit((char*)pszBuf, glblGrepPat.getString(i), cs.usecase, &iHitOff)) {
            // FIX: 1703: accept hit in current line only if in front halve,
            // otherwise truncation costs are too high. hits in rear halve
            // are moved to previous record.
            if (cs.joinlines == 0 || iHitOff < cs.wrapbincol/2) {
               nMatchCur++;
               continue;
            }
            // else fall through and check previous record
         }
         if (szClLastLine[0] && mystrhit(szClLastLine, glblGrepPat.getString(i), cs.usecase, 0))
            nMatchPre++;
      }

      // 2. if ALL pattern parts have a match somewhere, list both lines
      if ((nMatchCur+nMatchPre) == nGrepPat)
      {
         // found a matching file
         cs.anymatches = 1;

         if (chain.colfiles) {
            // filenames only, as filename chain
            // TODO: set root as glblFileSet.root()?
            chain.addFile(*pClCoi); // is copied
            return 1; // end read loop above
         }

         if (cs.useJustNames || cs.useNotNames) {
            // filenames only, as text data, NOT prefixing
            // further text data, therefore NOT including ":file "
            if (chain.coldata) {
               sprintf(szLineBuf3, "%s", pClCoi->name());
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf3, 'f', strlen(szLineBuf3)+2, MAX_LINE_LEN);
               chain.addLine(szLineBuf3, szAttrBuf3);
            } else {
               info.print("%s\n", pClCoi->name());
            }
            return 1; // end read loop above
         }

         // actually dump the content:

         // list filename first
         if (!bClDumpedFileName && !cs.nonames && !cs.pure) {
            bClDumpedFileName = 1;
            if (chain.coldata) {
               sprintf(szLineBuf3, ":file %s", pClCoi->name());
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf3, 'f', strlen(szLineBuf3)+2, MAX_LINE_LEN);
               chain.addLine(szLineBuf3, szAttrBuf3);
            } else {
               setTextColor(nGlblFileColor);
               info.print("%s :\n", pClCoi->name());
               setTextColor(-1);
            }
         }

         // create coloured display of hits of PREVIOUS line
         bool bskipcur = 0;
         if (!cs.justrc && nMatchPre)
         {
            // 1703: auto join of split result
            if (cs.joinlines)
            {
               int icur = strlen(szClLastLine);
               int irem = ((int)sizeof(szClLastLine)) - icur;
               int iadd = strlen(pszBuf);
               if (iadd < irem)
               {
                  memcpy(szClLastLine+icur, pszBuf, iadd);
                  szClLastLine[icur+iadd] = '\0';
                  bskipcur = 1;
               }
            }

            char *pszTmp = szClLastLine;
            bool bPrefixed = 0;

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            char csla = cs.joinlines ? ' ' : '/';
            char asla = cs.joinlines ? ' ' : 'p';
            if (bGlblGrepLineNum)
               sprintf(szClPreBuf, " %c %04u ", csla, (nLine > 0) ? (nLine-1) : nLine);
            else
               sprintf(szClPreBuf, " %c ", csla);
            szClAttBuf[1] = asla;
 
            int iMargin = 1;
            if (!cs.pure && !cs.noind) {
               if (chain.coldata) {
                  // FIX: 163: create new record here
                  chain.addLine(szClPreBuf, szClAttBuf);
                  bPrefixed = 1;
               } else {
                  printColorText(szClPreBuf, szClAttBuf, 0); // w/o LF
               }
               iMargin += strlen(szClPreBuf);
            }

            int iMinHitOff = -1;
            int iMaxHitOff = -1;

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            for (int k=0; k<nGrepPat; k++)
            {
               char *pszPat = glblGrepPat.getString(k);
               int nPatLen = strlen(pszPat);
               int nTmpLen = strlen(pszTmp);
               int nCur = 0, nRel = 0;
               while (mystrhit(pszTmp+nCur, pszPat, cs.usecase, &nRel))
               {
                  if (iMinHitOff < 0 || nRel < iMinHitOff)
                     iMinHitOff = nRel;
                  int iMaxOff = nRel+nPatLen;
                  if (iMaxHitOff < 0 || iMaxOff > iMaxHitOff)
                     iMaxHitOff = iMaxOff;
                  if (nCur+nRel+nPatLen < (int)sizeof(szClAttBuf)-10)
                     memset(&szClAttBuf[nCur+nRel], 'i', nPatLen);
                  nCur += nRel+nPatLen;
                  if (nCur >= nTmpLen-1)
                     break;
               }
            }
            if (iMinHitOff < 0 || cs.joinlines == 0)
               iMinHitOff = 0;
            if (cs.rtrim) {
               // trim line to result range
               int itrim = cs.rtrim-1;
               if (iMaxHitOff + itrim > BINTEXT_RECSIZE)
                   itrim = 0;
               pszTmp[iMaxHitOff+itrim] = '\0';
               szClAttBuf[iMaxHitOff+itrim] = '\0';
            } else {
               // trim joined line to normal wrap width
               int iMaxHitLen = iMaxHitOff - iMinHitOff;
               int iPrintLen  = strlen(pszTmp) - iMinHitOff;
               int iBestLen   = cs.wrapbincol/2-iMargin;
               if (   iPrintLen > 0
                   && iMinHitOff+iPrintLen < BINTEXT_RECSIZE
                   && iPrintLen > iBestLen
                   && iMaxHitLen < iBestLen
                   )
               {
                  iPrintLen = iBestLen;
                  pszTmp[iMinHitOff+iPrintLen] = '\0';
                  szClAttBuf[iMinHitOff+iPrintLen] = '\0';
               }
            }
            if (chain.coldata) {
               // FIX: 163: if prefix, append after that
               if (bPrefixed)
                  chain.addToCurLine(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff, 0);
               else
                  chain.addLine(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff);
            } else {
               printColorText(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff);
            }
         }
 
         // create coloured display of hits of CURRENT line
         if (!cs.justrc && !bskipcur && nMatchCur)
         {
            char *pszTmp = pszBuf;
            bool bPrefixed = 0;

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            if (bGlblGrepLineNum)
               sprintf(szClPreBuf, "   %04u ", nLine);
            else
               sprintf(szClPreBuf, "   ");
            if (nMatchPre) {
               szClPreBuf[1] = '\\';
               szClAttBuf[1] = 'p';
            }

            int iMargin = 1;
            if (!cs.pure && !cs.noind) {
               if (chain.coldata) {
                  // FIX: 163: create new record here
                  chain.addLine(szClPreBuf, szClAttBuf, 0);
                  bPrefixed = 1;
               } else {
                   printColorText(szClPreBuf, szClAttBuf, 0); // w/o LF
               }
               iMargin += strlen(szClPreBuf);
            }

            int iMinHitOff = -1;
            int iMaxHitOff = -1;

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            for (int k=0; k<nGrepPat; k++)
            {
               char *pszPat = glblGrepPat.getString(k);
               int nPatLen = strlen(pszPat);
               int nTmpLen = strlen(pszTmp);
               int nCur = 0, nRel = 0;
               while (mystrhit(pszTmp+nCur, pszPat, cs.usecase, &nRel))
               {
                  if (iMinHitOff < 0 || nRel < iMinHitOff)
                     iMinHitOff = nRel;
                  int iMaxOff = nRel+nPatLen;
                  if (iMaxHitOff < 0 || iMaxOff > iMaxHitOff)
                     iMaxHitOff = iMaxOff;
                  if (nCur+nRel+nPatLen < (int)sizeof(szClAttBuf)-10)
                     memset(&szClAttBuf[nCur+nRel], 'i', nPatLen);
                  nCur += nRel+nPatLen;
                  if (nCur >= nTmpLen-1)
                     break;
               }
            }
            if (iMinHitOff < 0 || cs.joinlines == 0)
               iMinHitOff = 0;
            if (cs.rtrim) {
               // trim line to result range
               int itrim = cs.rtrim-1;
               if (iMaxHitOff + itrim > BINTEXT_RECSIZE)
                   itrim = 0;
               pszTmp[iMaxHitOff+itrim] = '\0';
               szClAttBuf[iMaxHitOff+itrim] = '\0';
            } else {
               // trim current line to normal wrap width
               int iMaxHitLen = iMaxHitOff - iMinHitOff;
               int iPrintLen  = strlen(pszTmp) - iMinHitOff;
               int iBestLen   = cs.wrapbincol/2-iMargin;
               if (   iPrintLen > 0
                   && iMinHitOff+iPrintLen < BINTEXT_RECSIZE
                   && iPrintLen > iBestLen
                   && iMaxHitLen < iBestLen
                   )
               {
                  iPrintLen = iBestLen;
                  pszTmp[iMinHitOff+iPrintLen] = '\0';
                  szClAttBuf[iMinHitOff+iPrintLen] = '\0';
               }
            }
            if (chain.coldata) {
               // FIX: 163: if prefix, append after that
               if (bPrefixed)
                  chain.addToCurLine(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff, 0);
               else
                  chain.addLine(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff);
            } else {
               printColorText(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff);
            }
         }

         // line was listed, do NOT remember
         szClLastLine[0] = '\0';
 
         if (cs.useFirstHitOnly)
            iRC = 1;
      }
      else
      {
         // line was NOT listed
         szClLastLine[0] = '\0';
         // FIX: 1703: ALWAYS take over current line to lastline no matter if hardwrap
         // if (!bHardWrap)
         {
            int nCurLen = strlen(pszBuf);
            int nCopyIndex = 0;
            if (nCurLen > BINTEXT_RECSIZE) {
               nCopyIndex = nCurLen - BINTEXT_RECSIZE;
               nCurLen    = BINTEXT_RECSIZE;
            }
            // mystrcopy guarantees a zero terminator if nCurLen > 0.
            mystrcopy(szClLastLine, pszBuf+nCopyIndex, nCurLen+1);
         }
      }
   }

   return iRC;
}

// only for processDirParms and walkAllTrees:
int nGlblError = 0; // flag from walkAllTrees
StringTable *pGlblFileParms = 0;
char **apGlblFileParms = 0;
int  nGlblFileParms    = 0;
bool bGlblHaveMixedDirFileList = 0;

void skipSpaceRem(char **pszInOut, bool bUseUsingRemarks)
{
   static bool btold=0;

   char *psz1 = *pszInOut;

   // skip all whitespaces and remark lines
   while (*psz1)
   {
      if (*psz1==' ' || *psz1=='\t' || *psz1=='\r' || *psz1=='\n')
         { psz1++; continue; }

      if (bUseUsingRemarks)
      {
         // -using remarks start '//' only
         if (!strncmp(psz1, "//", 2) && isspace(psz1[2]))
         {
            while (*psz1 && *psz1 != '\n') psz1++;
            if (*psz1) psz1++; // skip LF
            continue;
         }
      }
      else 
      {
         // -fileset remarks start '#'
         if (*psz1=='#' 
             || *psz1==';' // sfk197 deprecated, undocumented
             )
         {
            if (*psz1==';' && btold==0) {
               btold=1;
               pwarn("fileset remarks starting ';' are deprecated, use '#': %.32s\n", dataAsTrace(psz1));
            }
            while (*psz1 && *psz1!='\n') psz1++;
            if (*psz1) psz1++; // skip LF
            continue;
         }
      }

      break;
   }

   *pszInOut = psz1;
}

uint currentProcessID()
{
   #ifdef _WIN32
   return (uint)GetCurrentProcessId();
   #else
   return (uint)getpid();
   #endif
}

SFKHome sfkhome;

SFKHome::SFKHome( )
{
   mclear(szClDir);
   bClTold = 0;

   #ifdef _WIN32

   char *psz = getenv("SFK_HOME");
   if (psz) {
      strcopy(szClDir, psz);
      return;
   }

   psz = getenv("LOCALAPPDATA");
   if (psz) {
      snprintf(szClDir, sizeof(szClDir)-10, "%s\\.sfkhome", psz);
      return;
   }

   // strcpy(szClDir, "\\.sfkhome");

   #else

   // FIX: 174: wrong sfkhome under linux
   // sprintf(szClDir, "~/.sfkhome");

   char *psz = getenv("SFK_HOME");
   if (psz) {
      strcopy(szClDir, psz);
      return;
   }

   psz = getenv("HOME");
   if (psz) {
      snprintf(szClDir, sizeof(szClDir)-10, "%s/.sfkhome", psz);
      return;
   }

   do
   {
      struct passwd *ppw = getpwuid(getuid());
      if (!ppw)
         break;
      const char *pszhome = ppw->pw_dir;
      if (!pszhome)
         break;
      snprintf(szClDir, sizeof(szClDir)-10, "%s/.sfkhome", pszhome);
      return;
   }
   while (0);

   // strcpy(szClDir, "/.sfkhome");

   #endif
}

bool SFKHome::noHomeDir()
{
   if (szClDir[0])
      return 0;

   if (!bClTold)
   {
      bClTold = 1;

      pwarn("no SFK Home Dir exists to store or read data.");
 
      #ifdef _WIN32
      pinf("you may SET \"SFK_HOME=anyfolder\" to define it directly.\n");
      pinf("you may SET \"LOCALAPPDATA=anyfolder\" to define it's parent folder.\n");
      #endif
   }

   return 1;
}

char *SFKHome::makePath(char *pszRelPath, bool bReadOnly)
{
   if (noHomeDir())
      return 0;

   snprintf(szClPathBuf, sizeof(szClPathBuf)-10,
      "%s%c%s", szClDir, glblPathChar, pszRelPath);

   if (!bReadOnly && createOutDirTree(szClPathBuf))
      return 0;

   return szClPathBuf;
}

char *SFKHome::getPath(char *pszRelPath)
{
   return makePath(pszRelPath, 1);
}

int SFTmpFile::ncnt = 1;
char *SFTmpFile::pszTmpDir = 0;

SFTmpFile::SFTmpFile(const char *pszExt, bool bNoAutoDelete, uint nTmpFileNum)
{
   strcopy(szClExt, pszExt);
   bClAutoDel = !bNoAutoDelete;
   nClNum     = nTmpFileNum;
   pszClName  = 0;
}

SFTmpFile::~SFTmpFile()
{
   if (pszClName != 0) {
      if (bClAutoDel && fileExists(pszClName))
         remove(pszClName);
      delete [] pszClName;
      pszClName = 0;
   }
}

void SFTmpFile::setTmpDir(char *pszDir)
{
   pszTmpDir = pszDir;
}

bool SFTmpFile::tmpDirWasSet( )
{
   return pszTmpDir ? 1 : 0;
}

// uses szLineBuf
char *SFTmpFile::name()
{
   if (!pszClName) {
      char *psz = pszTmpDir;
      if (!psz) psz = getenv("TEMP");
      if (!psz) psz = getenv("TMP");
      #ifndef _WIN32
      if (!psz) psz = str("/tmp");
      #endif
      if (!psz)
         { perr("cannot create temporary file: no TEMP or TMP environment variable found.\n"); return 0; }
      pszClName = new char[MAX_LINE_LEN+10];
      if (joinPath(pszClName, MAX_LINE_LEN-20, psz, str("zz-tmp-sfk-")))
         { perr("cannot create temporary file.\n"); return 0; }
      int nlen = strlen(pszClName);
      uint uprocid = currentProcessID();
      if (nClNum > 0)
         sprintf(pszClName+nlen, "%03u%s", nClNum, szClExt);
      else
         sprintf(pszClName+nlen, "%03u%s", uprocid, szClExt);
      ncnt = (ncnt+1) % 3;
   }
   if (cperm.showtmp) {
       info.clear();
       setTextColor(nGlblTimeColor);
       oprintf("using temporary file: %s\n", pszClName);
       setTextColor(-1);
   }
   return pszClName;
}

bool isDirParm(char *psz)
{
   if (!strcmp(psz, "-root"))       return true;   // sfk197
   if (!strcmp(psz, "-dir"))        return true;
   if (!strcmp(psz, "-file"))       return true;
   if (!strcmp(psz, "-fileset"))    return true;
   if (!strcmp(psz, "-using"))      return true;   // sfk1963 added
   // if (!strncmp(psz, "-from=", 6))  return true;   // sfk1963 deleted
   // if (!strcmp(psz, "-view"))       return true;   // sfk1963 deleted
   return false;
}

#ifdef SFK_LINUX_FULL
// experimental: change thread priority
void setPriority(int nprio)
{
   // supported values are -2 to +2
   #ifdef _WIN32
   SetThreadPriority(GetCurrentThread(), nprio);
   #else
   sched_param oschedparm;
   int nNativePrio = 0;
   switch (nprio) {
      case -2 : nNativePrio =   1; break;
      case -1 : nNativePrio =  25; break;
      case  0 : nNativePrio =  50; break;
      case  1 : nNativePrio =  75; break;
      case  2 : nNativePrio = 100; break;
   }
   if (nprio < -2) nNativePrio =   1;
   if (nprio >  2) nNativePrio = 100;
   oschedparm.sched_priority = nNativePrio;
   pthread_setschedparam(pthread_self(), SCHED_OTHER, &oschedparm);
   #endif
}
#endif

#ifdef VFILEBASE
extern "C" void setUzpMemLimit(num nlimit);
#endif // VFILEBASE

void setMemoryLimit(int nMBytes)
{
   num nbytes = (num)nMBytes * 1048576; // fix sfk1892 64 bits
   // no not accept limits below 10 MB:
   if (nbytes < (num)10 * 1000000) {
      perr("ignoring memlimit, illegal value: %d", nMBytes);
   } else {
      nGlblMemLimit = nbytes;
      bGlblMemLimitWasSet = 1;
   }
}

// sfkmatch.mod
#define SFKMATCH_IMPORTED
#include "sfkmatch.hpp"

bool sfkisopt(char *psz)
{
   // sfk197: accept empty parms as -noop
   if (psz[0] == '\0') return 1;

   return strncmp(psz, "-", 1) ? 0 : 1;
}

// process -opt=value AND -opt value
bool haveParmOption(char *argv[], int argc, int &iDir, cchar *pszOptBase, char **pszOutParm)
{
   *pszOutParm = 0;  // if this stays NULL it tells ERROR status.

   // check if format -opt=value is given
   char szEqBuf[100];
   sprintf(szEqBuf, "%s=", pszOptBase);
   char *pszOpt = argv[iDir];
   if (*pszOpt == '+') pszOpt++; // e.g. +md5gento=
   if (!strncmp(pszOpt, szEqBuf, strlen(szEqBuf))) {
      *pszOutParm = pszOpt+strlen(szEqBuf);
      return 1;
   }

   // check if format "-opt value" is given
   if (!strcmp(pszOpt, pszOptBase)) {
      if (iDir >= argc-1) {
         perr("missing parameter after option %s\n", pszOptBase);
         return 0;
      }
      iDir++;  // IDIR INCREMENT IS WRITTEN BACK!
      *pszOutParm = argv[iDir];
      return 1;
   }

   return 0;
}

bool setGeneralOption(char *argv[], int argc, int &iOpt, bool bGlobal=0, bool bJustCheck=0)
{
   struct CommandStats *pcs = (bGlobal ? &gs : &cs);
   if (bJustCheck)      pcs = &dummyCommandStats;

   bool bsim = bJustCheck;

   char *psz1 = argv[iOpt];
   char *pszParm = 0;

   // sfk197: accept empty parms as general option -noop.
   if (psz1[0] == '\0') return true;

   if (!strcmp(psz1, "-stest"))     { bGlblSyntaxTest = 1; return true; }
   if (!strcmp(psz1, "-debug"))     { pcs->debug = 1; pcs->memcheck = 1; return true; }
   if (!strcmp(psz1, "-debug=2"))   { pcs->debug = 2; pcs->memcheck = 1; return true; }
   if (!strncmp(psz1, "-coi", 4))   { Coi::bClDebug = 1; return true; }
   if (!strcmp(psz1, "-noop"))      { return true; }
   if (!strcmp(psz1, "-quiet"))     { pcs->quiet = 1; return true; }
   if (!strcmp(psz1, "-quiet=2"))   { pcs->quiet = 2; return true; }
   if (!strcmp(psz1, "-stat"))      { pcs->dostat = 1; return true; } // sfk1892
   if (!strcmp(psz1, "-nostat"))    { pcs->dostat = 0; pcs->nostat=1; return true; } // sfk1892
   if (!strcmp(psz1, "-nohead"))    { pcs->nohead = 1; return true; }
   if (!strcmp(psz1, "-nocheck"))   { pcs->nocheck = 1; return true; }
   if (!strncmp(psz1, "-noinf", 6)) { pcs->noinfo = 1; return true; }
   if (!strncmp(psz1, "-nofile", 7)){ pcs->nonames = 1; return true; }
   if (!strncmp(psz1, "-noname", 7)){ pcs->nonames = 1; return true; }
   if (!strcmp(psz1,  "-subnames")) { pcs->subnames = 1; return true; }
   if (!strncmp(psz1, "-noind", 6)) { pcs->noind = 1; return true; }
   if (!strcmp(psz1, "-sim"))       { pcs->sim = 1; return true; }
   if (!strcmp(psz1, "-norec"))     { pcs->subdirs = 0; return true; }
   if (!strcmp(psz1, "-nosub2"))    { pcs->subdirs = 0; pcs->hidesubdirs = 1; return true; } // sfk1912
   if (!strncmp(psz1, "-nosub", 6)) { pcs->subdirs = 0; return true; }
   if (!strcmp(psz1, "-withsub"))   { pcs->subdirs = 1; return true; }
   if (!strcmp(psz1, "-i"))         { bGlblStdInAny = 1; return true; }
   if (!strcmp(psz1, "-verbose"))   { pcs->verbose = 1; return true; }
   if (!strcmp(psz1, "-verbose=0")) { pcs->verbose = 0; return true; }
   if (!strcmp(psz1, "-verbose=2")) { pcs->verbose = 2; return true; }
   if (!strcmp(psz1, "-verbose=3")) { pcs->verbose = 3; return true; }
   if (!strcmp(psz1, "-verbose=4")) { pcs->verbose = 4; return true; }
   if (!strcmp(psz1, "-iotrace"))   { pcs->iotrace = 1; return true; }
   if (!strcmp(psz1, "-showip"))    { pcs->showip = 1; return true; }
   if (!strcmp(psz1, "-justrc"))    { pcs->justrc = 1; return true; }
   if (strBegins(psz1, "-hid"))     { pcs->hidden = 1; return true; }
   if (strBegins(psz1, "-nohid"))   { pcs->hidden = 0; return true; }
   if (!strcmp(psz1, "-yes"))       { pcs->yes = 1; return true; }
   if (!strcmp(psz1, "-clog"))      { if (bsim) return 1; gs.logcmd = cs.logcmd = 1; return true; }
   if (!strcmp(psz1, "-yes+"))      { if (bsim) return 1; pcs->yes = 1; gs.logcmd = cs.logcmd = 1; return true; }
   if (!strcmp(psz1, "-binallchars"))  { pcs->binallchars = 1; return true; }
   if (!strcmp(psz1, "-umlauts"))   { // deprecated with sfk190
      // cs.noaccent = 0; 
      return true; 
   }
   if (!strcmp(psz1, "-nocasemin")) { // sfk190
      pcs->nocasemin = 1;
      return true;
   }
   if (!strcmp(psz1, "-noumlauts") || strBegins(psz1, "-noacc")) { // undocumented since sfk190
      pcs->nocasemin = 1;    // sfk190: pcs not just cs
      return true;
   }
   if (strBegins(psz1, "-utf"))     { pcs->wchardec = 1; return true; } // deprecated
   if (strBegins(psz1, "-noutf"))   { pcs->wchardec = 0; return true; } // deprecated
   if (strBegins(psz1, "-wchar"))   { pcs->wchardec = 1; return true; }
   if (strBegins(psz1, "-nowchar")) { pcs->wchardec = 0; return true; }
   if (!strcmp(psz1, "-nocol"))     { pcs->usecolor = pcs->usehelpcolor = 0; return true; }
   if (!strcmp(psz1, "-col"))       { pcs->usecolor = 1; return true; }
   if (!strcmp(psz1, "-case"))      { pcs->usecase = 1; return true; }
   if (!strcmp(psz1, "-nocase"))    { pcs->usecase = 0; pcs->nocase = 1; return true; }
   if (!strcmp(psz1, "-withdirs"))  { pcs->withdirs = 1; return true; }
   if (!strncmp(psz1, "-wdir", 5))  { pcs->withdirs = 1; return true; }
   if (!strcmp(psz1, "-justdirs"))  { pcs->justdirs = 1; return true; }
   if (!strcmp(psz1, "-names"))     { pcs->useJustNames = 1; return true; }
   if (!strcmp(psz1, "-names2"))    { pcs->useJustNames = 2; return true; }
   if (!strcmp(psz1, "-notnames"))  { pcs->useNotNames = 1; return true; }
   if (!strncmp(psz1, "-rel", 4))   { pcs->rootrelname = 1; return true; }
   if (!strncmp(psz1, "-absname", 8)) { pcs->rootabsname = 1; return true; }
   if (!strncmp(psz1, "-quot", 5))  { bGlblQuoted = 1; return true; }
   if (!strcmp(psz1, "-nocconv"))   { pcs->outcconv = 0; return true; }
   if (!strcmp(psz1, "-cconv"))     { pcs->forcecconv = 1; return true; }
   if (!strcmp(psz1, "-incref"))    { bGlblSinceDirIncRef = 1; return true; }
   if (!strcmp(psz1, "-force"))     { pcs->force = 1; return true; }
   if (!strcmp(psz1, "-force=2"))   { pcs->force = 2; return true; }
   if (!strncmp(psz1, "-lit", 4))   { pcs->spat = 0; pcs->wpat = 0; return true; }
   if (!strcmp(psz1, "-spats"))     { pcs->spat = 2; return true; }
   if (!strncmp(psz1, "-spat", 5))  { pcs->spat = 1; return true; }
   if (!strncmp(psz1, "-nospat", 7)){ pcs->spat = 0; return true; }
   #ifndef USE_SFK_BASE // sfk180
   if (!strncmp(psz1, "-xpat", 5))  { pcs->xpat = 1; return true; }
   if (strBegins(psz1, "-xmaxlen=")) {
      if (bsim) return 1;
      SFKMatchDefaultMaxLen = (int)numFromSizeStr(psz1+9, psz1);
      if (SFKMatchDefaultMaxLen < 1)
         { perr("invalid -xmaxlen"); exit(9); }
      return true;
   }
   #endif // USE_SFK_BASE
   if (!strcmp(psz1, "-bright"))    { nGlblDarkColBase = 1; return true; }
   if (!strcmp(psz1, "-dark"))      { nGlblDarkColBase = 0; return true; }
   if (!strcmp(psz1, "-nochain"))   { pcs->nochain = 1; return true; }
   if (!strcmp(psz1, "-showrc"))    { if (bsim) return 1; gs.showrc = 1; return true; }
   if (!strcmp(psz1, "-exectime"))  { if (bsim) return 1; gs.tellExecTime = 1; return true; }
   if (!strncmp(psz1, "-nowarn", 7)) { pcs->nowarn = 1; return true; }
   if (!strncmp(psz1, "-noerr",  6)) { pcs->noerr = 1; return true; }
   if (!strncmp(psz1, "-errtotext", 6)) { pcs->errtotext = 1; return true; }
   if (!strncmp(psz1, "-nonote", 7)) { pcs->nonotes = 1; return true; }
   if (!strncmp(psz1, "-nofo", 5))   { pcs->skipLinks = 1; return true; }
   if (!strncmp(psz1, "-rawflags", 5)) { pcs->traceFileFlags = 1; return true; }
   if (!strncmp(psz1, "-ltarg", 6))  { pcs->listTargets = 1; return true; }
   if (!strncmp(psz1, "-stoponerr", 10))  { pcs->treeStopRC = 9; return true; }
   if (!strncmp(psz1, "-echoonerr", 11)) { pcs->echoonerr = 1; return true; }
   if (!strncmp(psz1, "-rcfromerr", 10))  { pcs->rcFromError = 9; return true; }
   if (!strncmp(psz1, "-waitonerr", 10))  { bGlblPauseOnError = 1; return true; }
   else
   if (!strncmp(psz1, "-wait", 5))  { bGlblPauseOnEnd = 1; return true; }
   if (!strncmp(psz1, "-exterr", 7)){ bGlblSysErrDetail = 1; return true; }
   if (!strncmp(psz1, "-detail", 7)){ bGlblSysErrDetail = 1; return true; }
   if (!strcmp(psz1, "-showskip"))  { pcs->showdupdirs = 1; return true; }
   if (strBegins(psz1, "-allowdup")) { pcs->usecirclemap = 0; return true; }
   if (!strcmp(psz1, "-fast"))      { pcs->fast = 1; return true; }
   if (strBegins(psz1, "-nover"))   { pcs->verify = 0; return true; }
   if (strBegins(psz1, "-verify"))  { pcs->verify = 1; return true; }
   if (!strcmp(psz1, "-noprog"))    { pcs->noprog = 1; return true; }
   if (!strcmp(psz1, "-test"))      { pcs->test = 1; return true; }
   if (!strcmp(psz1, "-oldmd5"))    { bGlblOldMD5 = 1; return true; }
   if (strBegins(psz1, "-withbin"))    { pcs->textfiles = 0; pcs->binaryfiles = 0; return true; }
   if (strBegins(psz1, "-textandbin")) { pcs->textfiles = 0; pcs->binaryfiles = 0; return true; }
   if (strBegins(psz1, "-text"))       { pcs->textfiles = 1; return true; }
   if (strBegins(psz1, "-textfile"))   { pcs->textfiles = 1; return true; }
   if (strBegins(psz1, "-nobin"))      { pcs->textfiles = 1; return true; }
   if (strBegins(psz1, "-bin"))        { pcs->binaryfiles = 1; return true; }
   if (strBegins(psz1, "-binfile"))    { pcs->binaryfiles = 1; return true; }
   if (strBegins(psz1, "-binaryfile")) { pcs->binaryfiles = 1; return true; }
   if (!strcmp(psz1, "-keepdate"))  { pcs->keeptime = 1; return true; }
   if (!strcmp(psz1, "-keeptime"))  { pcs->keeptime = 1; return true; }
   if (!strcmp(psz1, "-noesckey"))  { bGlblDisableEscape = 1; return true; }
   if (!strcmp(psz1, "-snap"))      { pcs->usesnap = 1; return true; }
   if (!strncmp(psz1, "-snapw", 6)) { // snapwithnames
      pcs->usesnap = 1;
      pcs->usesnapfiltname = 1;
      return true;
   }
   if (!strcmp(psz1, "-upat")) {
      setLinuxSyntax(1); // -upat
      return true;
   }
   if (!strcmp(psz1, "-upat2")) {
      setLinuxSyntax(2); // -upat2
      return true;
   }
   if (!strcmp(psz1, "-upath")) { pcs->upath = 1; return true; }
   #ifdef VFILEBASE
   if (!strcmp(psz1, "-qarc") || !strcmp(psz1, "-qxarc")) {
      pcs->travelzips  = 1;
      pcs->probefiles  = (strcmp(psz1, "-qxarc") ? 0 : 1);
      pcs->xelike      = 1;
      pcs->shallowzips = 1;  // toplevel only
      return true;
   }
   else
   #endif // VFILEBASE
   if (!strcmp(psz1, "-qarc") || !strcmp(psz1, "-qxarc")) {
      pcs->travelzips  = 1;
      pcs->probefiles  = (strcmp(psz1, "-qxarc") ? 0 : 1);
      return true;
   }
   if (!strcmp(psz1, "-zip") || !strcmp(psz1, "-arc") || !strcmp(psz1, "-xarc")) {
      if (!strcmp(psz1, "-zip"))
         pwarn("option -zip is deprecated, use -arc instead."); // sfk 175
      pcs->travelzips  = 1;
      pcs->probefiles  = (strcmp(psz1, "-xarc") ? 0 : 1);
      #ifdef VFILEBASE
      pcs->xelike     = 1;  // process zips as deep as possible
       #ifdef USE_SFK_BASE
       pcs->precachezip = 1; // dv load: always force precache
       #endif // USE_SFK_BASE
      #endif // VFILEBASE
      return true;
   }
   if (!strcmp(psz1, "-nozip") || !strcmp(psz1, "-noarc"))
      { pcs->travelzips = 0; return true; }

   #ifdef VFILEBASE
   if (!strcmp(psz1, "-extdom"))    { pcs->extdomref = 1; return true; }
   if (!strcmp(psz1, "-xd"))        { pcs->xelike    = 1; return true; }
   if (!strcmp(psz1, "-cacheall"))  { pcs->cacheall  = 1; return true; }
   if (!strcmp(psz1, "-cachestat")) { if (bsim) return 1; gs.cachestat = 1; return true; }
   if (!strcmp(psz1, "-nocache"))   { setDiskCacheActive(0); return true; }
   #endif // VFILEBASE

   if (strBegins(psz1, "-noipex"))  { pcs->noipexpand = 1; return true; }
   if (strBegins(psz1, "-crashtest"))  { pcs->crashtest = 1; return true; }

   // -pure is often a local option, but some commands allow general use:
   if (bGlblAllowGeneralPure && !strcmp(psz1, "-pure"))
      { pcs->pure = 1; return true; }

   if (!strcmp(psz1, "-allbin") || !strcmp(psz1, "-include-all-binaries"))
      { pcs->incbin = 1; return true; }

   if (!strcmp(psz1, "-xbin") || !strcmp(psz1, "-wlbin")) // sfk1944 internal
      { pcs->incwlbin = 1; return true; }

   if (!strcmp(psz1,"-wrap") || !strcmp(psz1,"-rewrap"))
   {
      if (!strcmp(psz1,"-rewrap")) pcs->rewrap = 1;
      // wrap with auto-calculated number of columns
      int nCols = autoCalcWrapColumns();
      if (nCols) {
         pcs->wrapcol = nCols;
         if (pcs->wrapbincol == 80) // if on default
            pcs->wrapbincol = nCols;
      }
      mtklog(("opt: done %s, wrapcol=%d, wrapbincol=%d",psz1,pcs->wrapcol,pcs->wrapbincol));
      return true;
   }
   if (strBegins(psz1,"-wrap=") || strBegins(psz1,"-rewrap="))
   {
      int nCols = 0;
      if (strBegins(psz1,"-rewrap=")) {
         pcs->rewrap = 1;
         nCols = atol(psz1+8);
      } else {
         nCols = atol(psz1+6);
      }
      // wrap with fixed (user-defined) number of columns
      if (nCols) {
         pcs->wrapcol = nCols;
         if (pcs->wrapbincol == 80) // if on default
            pcs->wrapbincol = nCols;
      }
      mtklog(("opt: done %s, wrapcol=%d, wrapbincol=%d",psz1,pcs->wrapcol,pcs->wrapbincol));
      return true;
   }
   if (!strncmp(psz1,"-wrapbin",8)) {
      // wrap for text extracted from binary files
      int nCols = 0;
      if (!strncmp(psz1,"-wrapbin=",9))
         nCols = atol(psz1+9);
      else
         nCols = autoCalcWrapColumns();
      if (nCols) {
         pcs->wrapbincol = nCols;
      }
      return true;
   }
   if (!strcmp(psz1, "-memcheck"))  { pcs->memcheck = 1; return true; }
   #ifdef SFK_MEMTRACE
   if (!strcmp(psz1, "-nomemcheck")) {
      bGlblNoMemCheck = 1;
      sfkmem_nocheck();
      return true;
   }
   #endif // SFK_MEMTRACE
   if (strBegins(psz1, "-memlimit=")) {
      int nMBytes = atol(psz1+10);
      setMemoryLimit(nMBytes);
      return true;
   }
   if (strBegins(psz1, "-weblimit=")) {
      int nMBytes = atol(psz1+10);
      pcs->maxwebsize = nMBytes * 1000000;
      return true;
   }
   if (!strncmp(psz1,"-keepstale=",strlen("-keepstale="))) {
      nGlblActiveFileAgeLimit = atol(psz1+strlen("-keepstale="));
      return true;
   }
   if (!strncmp(psz1, "-html", 5)) {
      bGlblHtml = 1;
      if (!getenv("SFK_COLORS"))
         setColorScheme("file:1,head:4,examp:8");
      if (!strcmp(psz1, "-htmlpage"))
         printf("<font face=\"courier\" size=\"2\"><pre>\n");
      return true;
   }
   if (   !strcmp(psz1, "-sincedir") || !strcmp(psz1, "-sd")
       || !strcmp(psz1, "-sinceadd") || !strncmp(psz1, "-sincedif", 9)
       || !strncmp(psz1, "-sincech", 8) || !strcmp(psz1, "-sc")
      )
   {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (bsim) return 1; 
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *psz2 = argv[iOpt];
      if (*psz2 == '-') { perr("need directory name, no option allowed after %s\n", psz1); exit(9); }
      pszGlblSinceDir = strdup(psz2);
      if (!bGlblSyntaxTest && !isDir(pszGlblSinceDir))
         { perr("no such directory: %s\n", pszGlblSinceDir); exit(9); }
      if (!strcmp(psz1, "-sinceadd"))
         nGlblSinceMode |= 1;
      else
      if (!strncmp(psz1, "-sincedif", 9))
         nGlblSinceMode |= 2;
      else
      if (!strncmp(psz1, "-sincech", 8) || !strcmp(psz1, "-sc"))
         nGlblSinceMode |= 1+2;  // only add and dif, no time diff
      else
         nGlblSinceMode = 1+2+4; // default: list all differences
      return true;
   }
   if (!strncmp(psz1, "-ignoretime", 11)) {
      bGlblIgnoreTime = 1;
      return true;
   }
   if (!strcmp(psz1, "-ignore3600")) {
      bGlblIgnore3600 = 1;
      return true;
   }
   if (!strcmp(psz1, "-noignore3600")) {
      bGlblIgnore3600 = 0;
      return true;
   }
   if (!strncmp(psz1, "-tracesel", 9)) {
      nGlblTraceSel |= 3;
      return true;
   }
   if (!strncmp(psz1, "-tracedir", 9)) {
      nGlblTraceSel |= 1;
      return true;
   }
   if (!strncmp(psz1, "-tracefile", 10)) {
      nGlblTraceSel |= 2;
      return true;
   }
   if (!strcmp(psz1, "-tracechain"))
      { pcs->tracechain = 1; return true; }
   if (!strcmp(psz1, "-usectime")) {
      pcs->usectime = 1;
      return true;
   }
   if (!strcmp(psz1, "-utc") || !strcmp(psz1, "-gmt")) {
      pcs->useutc = 1;
      return true;
   }
   #ifdef VFILENET
   if (!strcmp(psz1, "-proxy")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (bsim) return 1; 
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char szBuf[200];
      char *pproxy = argv[iOpt];
      strcopy(szBuf, pproxy);
      char *psz1 = szBuf;
      while (*psz1 && *psz1 != ':') psz1++;
      if (*psz1) *psz1++ = '\0';
      int nport = atol(psz1);
      if (!nport) nport = 80;
      TCPCore::setProxy(szBuf, nport); // -proxy option
      return true;
   }
   #endif // VFILENET
   if (strBegins(psz1, "-minsize=")) {
      pcs->minsize = numFromSizeStr(psz1+9, psz1);
      if (pcs->minsize < 0) exit(9);
      return true;
   }
   if (strBegins(psz1, "-maxsize=")) {
      pcs->maxsize = numFromSizeStr(psz1+9, psz1);
      if (pcs->maxsize < 0) exit(9);
      return true;
   }
   if (!strcmp(psz1, "-since")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (bsim) return 1; 
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *psz2 = argv[iOpt];
      if (tryGetRelTime(psz2, pcs->sincetime))
      { }
      else
      if (timeFromString(psz2, pcs->sincetime)) // local option -since
         exit(9);
      if (pcs->untiltime && pcs->untiltime <= pcs->sincetime)
         {  perr("-before lower or equal than -since was specified.\n"); exit(9); }
      return true;
   }
   if (!strcmp(psz1, "-before")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (bsim) return 1; 
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *psz2 = argv[iOpt];
      if (tryGetRelTime(psz2, pcs->untiltime))
      { }
      else
      if (timeFromString(psz2, pcs->untiltime)) // local option -before
         exit(9);
      if (pcs->sincetime && pcs->sincetime >= pcs->untiltime)
         {  perr("-since greater or equal than -before was specified.\n"); exit(9); }
      return true;
   }
   if (!strcmp(psz1, "-to")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (bsim) return 1; 
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      cs.tomask = argv[iOpt];
      cs.tomaskfile = 0;
      return true;
   }
   if (!strcmp(psz1, "-tofile")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (bsim) return 1; 
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      cs.tomask = argv[iOpt];
      cs.tomaskfile = 1;
      return true;
   }
   if (!strcmp(psz1, "-tomake")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (bsim) return 1; 
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      bGlblGotToMake = 1;
      char *pszMask = argv[iOpt];
      // auto extend .mp4 as $path\$base.mp4
      if (!strchr(pszMask, glblRunChar) && !isalnum(pszMask[0])
          && !strchr(pszMask, glblPathChar)) {
         snprintf(cs.tomake,sizeof(cs.tomake)-10,
            "%cpath%c%cbase%s",
            glblRunChar, glblPathChar, glblRunChar, pszMask);
         if (cs.verbose)
            printf("[extended -tomake as %s]\n", cs.tomake);
      } else {
         strcopy(cs.tomake, pszMask);
      }
      return true;
   }
   if (!strcmp(psz1, "-tmpdir")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (bsim) return 1; 
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      SFTmpFile::setTmpDir(argv[iOpt]);
      return true;
   }
   if (!strcmp(psz1, "-keeptmp")) {
      cperm.keeptmp = 1;
      return true;
   }
   if (!strcmp(psz1, "-showtmp")) {
      cperm.showtmp = 1;
      return true;
   }
   if (!strcmp(psz1, "-today")) {
      tryGetRelTime("today", pcs->sincetime);
      return true;
   }
   if (!strcmp(psz1, "-flist") || !strcmp(psz1, "-fl"))
   {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (bsim) return 1; 
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *pszFile = argv[iOpt];

      // read list of filenames from a file.
      Coi ocoi(pszFile, 0);
      if (ocoi.open("rb"))
         { perr("cannot read filename list file: %s\n", pszFile); exit(9); }
      while (ocoi.readLine(szLineBuf, sizeof(szLineBuf)-10) > 0)
      {
         szLineBuf[sizeof(szLineBuf)-10] = '\0';
         removeCRLF(szLineBuf);
         if (cs.debug) printf("] add2flist.1: %s\n", szLineBuf);
         Coi ocoisub(szLineBuf, 0);
         glblSFL.addEntry(ocoisub); // is copied
      }
      ocoi.close();

      cs.usingflist = 1;

      // if no further dir parms follow, do not autocomplete.
      cs.blockAutoComplete = 1;

      return true;
   }
   #ifdef SFK_LINUX_FULL
   if (!strncmp(psz1,"-prio=", 6)) {
      setPriority(atol(psz1+6));
      return true;
   }
   #endif
   if (!strncmp(psz1,"-dirdelay=",strlen("-dirdelay="))) {
      pcs->walkDirDelay = atol(psz1+strlen("-dirdelay="));
      return true;
   }
   if (!strncmp(psz1,"-filedelay=",strlen("-filedelay="))) {
      pcs->walkFileDelay = atol(psz1+strlen("-filedelay="));
      return true;
   }
   if (!strcmp(psz1,"-slow=3"))   {
      pcs->walkDirDelay  = 10;
      pcs->walkFileDelay = 10;
      return true;
   }
   if (!strcmp(psz1,"-slow=2"))   {
      pcs->walkDirDelay  = 100;
      return true;
   }
   if (!strcmp(psz1,"-slow")) { // sfk1952
      #ifdef _WIN32
      SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS);
      #endif
      #ifdef SFK_LINUX_FULL
      setPriority(-1);
      #endif
      return true;
   }
   if (!strcmp(psz1,"-broad"))      {  pcs->incFNameInPath = 1; return true; }   // sfk187 global support
   if (!strcmp(psz1,"-firsthit"))   {  pcs->useFirstHitOnly = 1; return true; }  // sfk187 global support
   if (!strcmp(psz1,"-xchars"))     {  pcs->xchars = 1; return true; }
   if (!strcmp(psz1,"-perf"))       {  pcs->perf = 1; return true; }
   if (!strcmp(psz1,"-crlf"))       {  strcpy(pcs->szeol, "\r\n"); return true; }
   if (!strcmp(psz1,"-lf"))         {  strcpy(pcs->szeol, "\n"); return true; }
   if (strBegins(psz1,"-toiso="))   {  pcs->toiso = 1; pcs->toisodef = psz1[strlen("-toiso=")]; return true; }
   if (!strcmp(psz1,"-toiso"))      {  pcs->toiso = 1; return true; }
   if (!strcmp(psz1,"-iso"))        {  pcs->toiso = 1; return true; }
   if (!strcmp(psz1,"-toutf"))      {  pcs->toutf = 1; return true; }
   if (!strcmp(psz1,"-toutfsafe"))  {  pcs->toutf = 2; return true; }
   if (!strcmp(psz1,"-uname"))      {
      pcs->uname = 1; pcs->outcconv = 0;
      return true; 
   }
   #ifdef SFK_UNAME
   if (!strcmp(psz1,"-tname"))      {  
      pcs->tname = 1; pcs->outcconv = 0; 
      return true; 
   }
   #endif // SFK_UNAME
   // TODO: -utf name conflict with experimental utf16 decode
   #ifdef VFILEBASE
   if (strBegins(psz1,"-useragent="))
   {
      setHTTPUserAgent(psz1+strlen("-useragent="));
      return true;
   }
   #endif // VFILEBASE
   if (!strcmp(psz1, "-rawhelp")) {
      bGlblDumpHelpRaw=1;
      return true;
   }
   if (!strncmp(psz1,"-webtimeout=",12)) {
      pcs->maxwebwait = atol(psz1+12);
      return true;
   }
   if (!strcmp(psz1,"-webnoclose")) {  // sfk198 internal
      pcs->webnoclose = 1;
      return true;
   }
   if (!strncmp(psz1,"-ftptimeout=",12)) {
      pcs->maxftpwait = atol(psz1+12);
      return true;
   }
   // --- user/pw generic options begin ---
   if (haveParmOption(argv, argc, iOpt, "-user", &pszParm)) {
      if (!pszParm) return 9;
      pcs->puser = pszParm;
      return true;
   }
   if (haveParmOption(argv, argc, iOpt, "-pw", &pszParm)) {
      if (!pszParm) return 9;
      pcs->ppass = pszParm;
      return true;
   }
   // global option e.g. for filter http://
   if (haveParmOption(argv, argc, iOpt, "-webuser", &pszParm)) {
      if (!pszParm) return 9;
      pcs->pwebuser = pszParm;
      return true;
   }
   if (haveParmOption(argv, argc, iOpt, "-webpw", &pszParm)) {
      if (!pszParm) return 9;
      pcs->pwebpass = pszParm;
      return true;
   }
   // --- user/pw generic options end ---
   if (!strcmp(psz1, "-qraw"))    { pcs->mlquotes = 'r'; return true; }
   if (!strcmp(psz1, "-qtrim"))   { pcs->mlquotes = 'f'; return true; }
   if (!strcmp(psz1, "-headers")) { pcs->showhdr  = 255; return true; }
   if (!strcmp(psz1, "-header") || !strcmp(psz1, "-head")) { // sfk1972
      ++iOpt;
      if (bsim) return 1;
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *ptoadd = argv[iOpt];
      int   nadd = (int)strlen(ptoadd);
      if (pcs->headers == 0) {
         pcs->headers = new char[nadd+20];
         if (!pcs->headers) { perr("outofmem"); return false; }
         snprintf(pcs->headers, nadd+10, "\n%s\r\n", ptoadd);
      } else {
         char *pold = pcs->headers;
         int   nold = (int)strlen(pold);
         pcs->headers = new char[nold+nadd+20];
         if (!pcs->headers) { perr("outofmem"); return false; }
         memcpy(pcs->headers, pold, nold);
         memcpy(pcs->headers+nold, ptoadd, nadd+1);
         strcpy(pcs->headers+nold+nadd, "\r\n");
      }
      return true;
   }
   if (!strcmp(psz1, "-showreq")) { pcs->showreq  =   1; return true; }
   // for global setting. also interpreted in SFKMapArgs.
   if (!strcmp(psz1, "-novar"))   { pcs->usevars  = 0; return true; }
   if (!strcmp(psz1, "-var"))     { pcs->usevars  = 1; return true; }
   if (!strcmp(psz1, "-strict"))    { pcs->strict = 1; return true; }
   if (!strcmp(psz1, "-nostrict"))  { pcs->strict = 0; return true; }
   if (!strcmp(psz1, "-nopass"))    { pcs->nopass = 1; return true; }

   // sfk187
   if (!strcmp(psz1, "-chainweb") || !strcmp(psz1, "-cweb"))    
      { if (bsim) return 1; gs.cweb = 1; return true; }
   if (!strcmp(psz1, "-nochainweb") || !strcmp(psz1, "-nocweb"))  
      { if (bsim) return 1; gs.cweb = 0; return true; }

   if (!strcmp(psz1, "-deacc"))      { pcs->fuzz = 1; return true; }
   if (!strcmp(psz1, "-tracecase"))  { pcs->tracecase = 1; return true; }
   if (!strcmp(psz1, "-tracecase2")) { pcs->tracecase = 2; return true; }
   if (!strcmp(psz1, "-isochars") || !strcmp(psz1, "-isoc"))   {
      sfkchars.setacp(1252);
      sfkchars.setocp(850);
      return true;
   }
   if (!strncmp(psz1,"-codepage=",10)) {
      char *psz=psz1+10;
      int iacp = atoi(psz);
      if (sfkchars.setacp(iacp)) {
         perr("unsupported ansi codepage: %d\n", iacp);
         return false;
      }
      int iocp = 0;
      while (*psz!=0 && isdigit(*psz)!=0) psz++;
      if (*psz=='-') psz++;
      if (isdigit(*psz)) {
         iocp = atoi(psz);
         if (sfkchars.setocp(iocp)) {
            perr("unsupported OEM codepage: %d\n", iocp);
            return false;
         }
      }
      if (gs.tracecase || cs.tracecase) {
         sfkchars.init();
         printf("[using Ansi codepage %u, OEM codepage %u]\n",
            sfkchars.iclacp, sfkchars.iclocp);
      }
      return true;
   }
   if (!strcmp(psz1, "-more"))
      { pcs->nmore = nGlblConsRows; return true; }
   if (strBegins(psz1, "-more") && isdigit(psz1[5])!=0)
      { pcs->nmore = atoi(psz1+5); return true; }
   #ifdef SFKOFFICE
   // if (!strcmp(psz1, "-office2")) { pcs->office = 2; return true; }
   // if (!strcmp(psz1, "-office"))  { pcs->office = 1; return true; }
   // sfk1944: -notext was an undocumented, unused option.
   if (!strcmp(psz1, "-notext"))     { return true; }
   // sfk1944 limit just to office files with some commands.
   if (!strcmp(psz1, "-justoffice") || !strcmp(psz1, "-justdoc"))
      { pcs->justoffice = 1; return true; }
   if (!strcmp(psz1, "-crcmd5")) // internal, LOCAL only
      { cs.crcmd5 = 1; return true; }
   if (!strncmp(psz1, "-crc=", 5)) {
      cs.bjustcrc = 1;
      cs.njustcrc = strtoul(psz1+5, 0, 0x10);
      return true;
   }
   #endif // SFKOFFICE
   if (!strcmp(psz1, "-keepdata"))   { pcs->keepdata = 1; return true; }
   if (!strcmp(psz1, "-keepchain"))  { pcs->keepchain = 1; return true; }
   if (!strncmp(psz1, "-every=", 7)) { pcs->justevery = atoi(psz1+7); return true; }
   if (!strncmp(psz1, "-cliptries=", 11)) { pcs->cliptries = atoi(psz1+11); return true; }
   /*
   if (!strcmp(psz1, "-root")) { // done in pdp
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (bsim) return 1;
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      strcopy(cs.rootdir, argv[iOpt]);
      return true;
   }
   */
   if (!strcmp(psz1, "-checkdir")
       || !strcmp(psz1, "-checkdirs")) // sfk197
         { pcs->checkdirs = 1; return true; }
   if (!strcmp(psz1, "-noqwild"))  { pcs->noqwild = 1; return true; }

   bool bdonechan = 0;
   if (!strncmp(psz1,"-chan=",6))      // sfk1972
      { pcs->chan = atol(psz1+6); bdonechan=1; }
   if (!strncmp(psz1,"-channel=",9))
      { pcs->chan = atol(psz1+9); bdonechan=1; }
   if (!strncmp(psz1,"-servchan=",10))      // sfk1972
      { pcs->chanserv = atol(psz1+10); bdonechan=1; }
   if (!strncmp(psz1,"-servchannel=",13))
      { pcs->chanserv = atol(psz1+13); bdonechan=1; }
   if (bdonechan) {
      if (pcs->chan<1 || pcs->chan>=20
          || pcs->chan<1 || pcs->chan>=20)
         perr("invalid channel");
      else
         return true;
   }

   return false;
}

int processDirParms(char *pszCmd, int argc, char *argv[], int iDir, int nAutoComplete, int *iDirNext=0, bool *pAnyDone=0);

// uses szLineBuf. PreCmd is optional prefix, usually "-any" or NULL.
int processFlatDirParms(char *pszPreCmd, char *pszCmdLine, int nAutoComplete)
{
   if (cs.debug) printf("processFlatDirParms\n");

   // make copy of input to allow overwriting.
   strncpy(szLineBuf, pszCmdLine, sizeof(szLineBuf)-10);
   szLineBuf[sizeof(szLineBuf)-10] = '\0';
   pszCmdLine = szLineBuf;
 
   pGlblFileParms = new StringTable(); // processFlatDirParms

   if (pszPreCmd)
      pGlblFileParms->addEntry(pszPreCmd);

   int nAbsPathParms = 0;

   char *psz1 = pszCmdLine;
   while (*psz1)
   {
      // find next token.
      skipSpaceRem(&psz1, 0); // processFlat
 
      // find end of token. support "parm with blanks".
      char *psz2 = psz1+1;
      if (*psz1 == '"')
         while (*psz2 && *psz2!='"')
            psz2++;
      while (*psz2 && *psz2!=' ' && *psz2!='\t' && *psz2!='\r' && *psz2!='\n')
         psz2++;

      // isolate token
      if (*psz2)
         *psz2++ = '\0';

      // line-end may lead to empty entry, therefore
      if (strlen(psz1)) // only if not line-end
      {
         // strip "", if any
         if (*psz1 == '"' && strlen(psz1) >= 2) {
            psz1++;
            int nLen = strlen(psz1);
            if (psz1[nLen-1] == '"')
                psz1[nLen-1] = '\0';
         }
         if (cs.debug) printf("token: <<%s>>\n", psz1);
         pGlblFileParms->addEntry(psz1);

         // count number of parms starting absolute
         if (isAbsolutePath(psz1))
            nAbsPathParms++;

         #ifdef VFILEBASE
         Coi ocoi(psz1, str(""));
         if (maskEndsWithArcExt(psz1, 4) || ocoi.isZipSubEntry())
            setArcTravel(1, 1, 2);
         #endif // VFILEBASE
      }

      // continue with next token, if any
      psz1 = psz2;
   }

   // pGlblFileParms now holds all parms
   int nParms = pGlblFileParms->numberOfEntries();
   mtklog(("pfdp nparms %d", nParms));
   apGlblFileParms = new char*[nParms];
   for (int i=0; i<nParms; i++) {
      char *pszParm = pGlblFileParms->getEntry(i, __LINE__);
      apGlblFileParms[i] = pszParm;
      mtklog(("   copied %s", pszParm ? pszParm : "<null>"));
   }
   nGlblFileParms = nParms;

   // if user drops a bunch of stuff onto the .exe
   if ((nGlblFileParms > 0) && (nGlblFileParms == nAbsPathParms)) {
      // then we don't process "dir .ext1 .ext2" but a mixed list
      bGlblHaveMixedDirFileList = 1;
   }

   return processDirParms(str(""), nParms, apGlblFileParms, 0, nAutoComplete);
}

enum ePDPStates
{
   eST_Idle       = 0,
   eST_RootDirs   = 1,
   eST_FileMasks  = 2,
   eST_GrepPat    = 3,
   eST_IncBin     = 4,
   eST_DirFile    = 5,
   eST_SubDirs    = 6,

   eST_MAXStates
};

int containsWildCards(char *pszName)
{
   if (strchr(pszName, glblWildChar)) return 1;
   if (strchr(pszName, '*')) return 1;
   if (strchr(pszName, '?')) return 1;
   return 0;
}

int lastCharIsBackSlash(char *pszName)
{
   uint nlen = strlen(pszName);
   if (!nlen) return 0;
   return (pszName[nlen-1] == glblPathChar) ? 1 : 0;
}

void stripTrailingBackSlashes(char *psz)
{
   int nidx = (int)strlen(psz);
   while (nidx > 0 && psz[nidx-1] == glblPathChar) {
      psz[nidx-1] = '\0';
      nidx--;
   }
}

cchar *aGlblChainCmds[] =
{
   // list of all chainable commands and their name variations
   // (first unambigious chars). every command is prefixed
   // by the default input data type (1:filenames 2:text)

   "2filt",         // receive+send files and TEXT
   "1ffilt",        // receive+send FILES and text
   "1filefilt",     // receive+send FILES and text
   "1list",         // receive+send FILES and text
   "8sel",          // receive nothing, force flush. sfk181

   "1md5gento",     // receive+pass files
   "1snapto",       // receive+pass files
   "1scantab",      // receive+send files
   "2detab",        // receive+send files and TEXT
   "1entab",        // receive+send FILES [and text]
   "1lf-to-crlf","1crlf-to-lf","1addcr","1remcr",
   "1find","1grep", // receive+send FILES and text
   "1ftext",        // receive+send FILES and text
   "1run",          // receive+send FILES and text
   "1rerun",        // receive+send FILES and text
   "1inst",         // receive files
   "1deblank",      // receive+send files
   "0noop",
   "0begin",        // sfk189
   "0endif",        // sfk189
   "6replytcp",     // receive text and binary
   "1rep",          // receive+send files
   "1extract",      // receive+send files sfk1840 with base
   "1xhex",         // receive+send files
   "1hexfind",      // receive+send files
   "2view",         // receive files and TEXT
   "1fv",           // receive FILES and text (fview)
   "2vc",           // receive files and TEXT
   "1del",          // receive FILES and text
   "1rmtree",       // receive FILES and text
   "0sleep",        // pass-thru text
   "0label",        // pass-thru text
   "3tail",         // receive ANY
   "3head",         // receive ANY
   "2ttail",        // receive TEXT
   "2thead",        // receive TEXT
   #ifdef _WIN32
   "6toclipw",      // receive binary sfk1841
   "2toclip",       // receive text
   #endif
   "2tolog",        // receive text
   "2tonetlog",     // receive text
   "0beep",         // pass-thru
   "0loop",         // restart chain
   "2hextobin",     // receive text
   "8echo",         // receive nothing, force flush. sfk181
   "6hexdump",      // receive text and binary
   "1fhexdump",     // receive filenames
   "1hexfile",      // receive filenames
   "1dup",          // receive filenames
   "1copy",         // receive filenames
   "1move",         // sfk1914 internal
   "2script",       // receive TEXT
   "1fscript",      // receive TEXT
   "1ftee",         // receive filenames
   "2tee",          // receive TEXT
   "2toterm",       // receive TEXT
   "2tofile",       // receive TEXT
   "2append",       // receive TEXT
   "2appendto",     // receive TEXT
   "0sfk",          // flushes chain
   "0then",         // flushes chain
   "8status",       // receive nothing, force flush
   "1stat",         // receive filenames
   "8fromclip",     // receive nothing, force flush
   "0pause",        // receive nothing
   "0prompt",       // sfk189
   "2dec",          // receive TEXT
   "2hex",          // receive TEXT
   "2sort",         // receive TEXT
   "2count",        // receive TEXT
   "1ftp",          // receive filenames
   "1sft",          // receive filenames
   "0mkdir", "0cd", "0getcwd", "0cwd", // pass-thru
   "8ver",          // receive nothing, force flush
   "8winver",       // receive nothing, force flush
   "1md5",          // receive files
   "1crc",          // receive files
   "2wget",         // receive files and text
   "2strlen",       // receive TEXT
   "2linelen",      // receive TEXT
   "2webreq",       // receive TEXT
   "01web",         // receive TEXT, use option chainweb
   "2tweb",         // receive TEXT sfk187
   "2mweb",         // receive TEXT sfk187 internal
   "0cweb",         // receive nothing sfk1872
   "8call",         // receive nothing, force flush sfk181
   "6tcall",        // receive text and binary  sfk181
   "1fcall",        // receive filenames        sfk181
   "0if",           // receive nothing
   "6tif",          // receive TEXT and binary
   "2require",      // receive TEXT
   "2tdifflines",   // receive TEXT sfk193
   "1media",        // receive filenames
   "1filetime",     // receive filenames
   "1touch",        // receive filenames
   "1xfind",        // receive filenames sfk1953
   "6xmlform",      // receive TEXT and binary
   "6xf",           // receive TEXT and binary
   "2storetext",    // receive TEXT
   "8gettext",      // receive nothing, force flush
   "6xed",          // receive TEXT and binary
   "6xex",          // receive TEXT and binary
   "2csvtotab",     // receive TEXT
   "2csvtab",       // receive TEXT
   "2tabtocsv",     // receive TEXT
   "2tabcsv",       // receive TEXT
   "2calc",         // receive TEXT
   "6setvar",       // receive TEXT and binary
   "6addtovar",     // receive TEXT and binary
   "8getvar",       // receive nothing, force flush
   "0dropvar",      // receive nothing
   "2perline",      // receive TEXT
   "2tohtml",       // receive TEXT
   "2tovoid",       // receive TEXT
   "0end",          // pass-thru
   "6tend",         // receive text and binary  sfk181
   "1fend",         // receive filenames        sfk181
   "0stop",         // receive nothing sfk181
   "0goto",         // sfk1812
   "6tgoto",        // sfk193  text and binary
   "8tell",         // receive nothing, force flush
   "6encode",       // receive text and binary
   "6decode",       // receive text and binary
   "6udpsend",      // sfk1833 text and binary
   "0udp",          // sfk1872
   "0cudp",         // sfk1872
   "2spell",        // sfk1833 text
   "6setbytes",     // sfk1840
   "6chars",        // sfk1840
   "0for",          // receive nothing
   "0endfor",       // receive nothing
   "0rand",         // sfk189
   "2addhead",      // sfk187
   "2addtail",      // sfk187
   #ifdef _WIN32
   "6atow",  "6ansitoucs",  // sfk190
   "6iwtoa", "6iucstoansi", // sfk190
   #endif
   "6utow",  "6utftoucs",   // sfk190
   "6iwtou", "6iucstoutf",  // sfk190
   "6atou",  "6ansitoutf",  // sfk1902
   "6utoa",  "6utftoansi",  // sfk1902
   "1uuenc",        // sfk198 fnames
   "2uudec",        // sfk198 text
   "1xxenc",        // sfk198 fnames
   "2xxdec",        // sfk198 text
   #ifdef SFKPACK
   "1zipto",
   "8unzip",
   #endif // SFKPACK
   // sfk1833:
   "8fromnet", "8color", "8make-random-file",
   "8time", "8data", "8home", "8ruler",
   "8space", "8filesys",
   "6swap",
   // not yet:
   // "8ping", "8fuzz",
   // "8split", "8join",
   // "8index", "8gindex",
   // "8reflist", "8deplist",
   // "8ip", "8bin-to-src",
   "2getcol",
   "2tabcol",
   "1put",      // sfk1943 includes putall
   "1mput",     // sfk1944 convenience
   "6jsonform", // sfk1952
   "6jform",    // sfk1952
   0
};

// when passing stuff from one command to another,
// what is most probably used: text or filenames?
cchar *aGlblDefChnModes[] =
{// from       to          use default mode (1==files, 2==text)
   "sel",      "detab",    "1",
   "list",     "detab",    "1",
   "fromclip", "dv",       "2",
   0, 0, 0
};

enum eChainCodes {
   ccftt    = -1,
   ccfile   = -2,
   ccttf    = -3,
   cctext   = -4,
   ccthen   = -5,
   ccto     = -6, // text and binary
};

int checkNoPass(char *argv[], int argc, int iDir,
   int &rtype, int &rbinary, bool bForcePlus)
{
   char *pcmd=argv[iDir];

   if (*pcmd=='+')
      pcmd++;
   else
   if (bForcePlus)
      return 0;

   /*
      unsolved: cmd #(var): future content of var
      is not known, could be option, filename etc.
   */

   // sfk193 ... +setvar a=1 nopass detection
   if (!strcmp(pcmd, "setvar")) {
      char *pparm=str("");
      for (int i=iDir+1; i<argc; i++) {
         char *psz=argv[i];
         if (psz[0]=='-') continue;
         if (psz[0]=='+') break; // sfk1973 fix
         pparm=psz; break;
      }
      if (strchr(pparm,'=')) {
         if (cs.verbose)
            printf("[%s %s expects no chain data.]\n",pcmd,pparm);
         rtype = 0; // none
         return ccthen;
      }
      if (cs.verbose)
         printf("[%s %s requires chain data.]\n",pcmd,pparm);
   }

   // sfk1972 +calc nopass detection
   if (!strcmp(pcmd, "calc")) {
      char *pparm=str("");
      for (int i=iDir+1; i<argc; i++) {
         char *psz=argv[i];
         if (!strcmp(psz,"-sum")) // sfk198
            {pparm=str("#text");break;}
         if (psz[0]=='-') continue;
         if (psz[0]=='+') break;  // sfk1973 fix
         pparm=psz; break;
      }
      if (strstr(pparm,"$text") == 0
          && strstr(pparm,"#text") == 0) {
         if (cs.verbose)
            printf("[%s %s expects no chain data.]\n",pcmd,pparm);
         rtype = 0; // none
         return ccthen;
      }
      if (cs.verbose)
         printf("[%s %s requires chain data.]\n",pcmd,pparm);
   }

   return 0;
}

// rc:  0 if NO chain command
//     <0 if ++ftt, ++ttf etc.
//     >0 if one of aGlblChainCmds
int getChainCodeNoPass(char *argv[], int argc, int iDir, int &rtype, int &rbinary)
{
   char *pszin = argv[iDir];

   if (pszin[0] != '+')
      return 0;

   if (pszin[1] != '+')
      return 0;   // e.g. +then

   if (   !strcmp(pszin, "++ftt")
       || !strcmp(pszin, "++filenamestotext")
      )
   {
      rtype = 1; // files
      return ccftt;
   }

   if (   !strcmp(pszin, "++ttf")
       || !strcmp(pszin, "++texttofilenames")
      )
   {
      rtype = 2; // text
      return ccttf;
   }

   // ++list etc.

   pszin += 2;
   for (int i=0; aGlblChainCmds[i]; i++)
   {
      cchar *psz = aGlblChainCmds[i];
      int aflags = *psz - '0';
      int bbinary = (aflags & 4) ? 1 : 0;
          aflags &= (3+8);
      psz++;
      int aflags2 = 0;
      if (isdigit(*psz)) {
          aflags2 = *psz - '0';
          psz++;
      }
      if (aflags2 == 1)
         aflags = gs.cweb ? 2 : 8;
      if (!strncmp(psz, pszin, strlen(psz)))
      {
         rtype   = aflags;
         rbinary = bbinary;
         // printf("gcc: %d %d %s\n",aflags,bbinary,psz);
         return i;
      }
   }

   rtype = 0;
   return 0;
}

// rc:  0 if NO chain command
//     <0 if +text, +file etc.
//     >0 if one of aGlblChainCmds
int getChainCode(char *argv[], int argc, int iDir, int &rtype, int &rbinary)
{
   if (gs.nopass)
      return getChainCodeNoPass(argv, argc, iDir, rtype, rbinary);

   char *pszin=argv[iDir];

   if (   !strcmp(pszin, "+ftt")
       || !strcmp(pszin, "+filenamestotext")
      )
   {
      rtype = 1; // files
      return ccftt; // == -1
   }

   // if (!strcmp(pszin, "+files")) // del sfk1840
   // {
   //    rtype = 1; // files
   //    return ccfile;
   // }

   if (   !strcmp(pszin, "+ttf")
       || !strcmp(pszin, "+texttofilenames")
      )
   {
      rtype = 2; // text
      return ccttf;
   }

   // if (!strcmp(pszin, "+text")) // del sfk1840
   // {
   //    rtype = 2; // text
   //    return cctext;
   // }

   if (!strcmp(pszin, "+to"))
   {
      rtype = 6; // text+binary
      return ccto;
   }

   if (!strcmp(pszin, "+then"))
   {
      rtype = 0; // none
      return ccthen;
   }

   // --- sfk193: ... +setvar a=foo nopass detection [218991] ---
   if (checkNoPass(argv,argc,iDir,rtype,rbinary,1) == ccthen) // nopass.setvar
      return ccthen;
   // --- ---

   if (pszin[0] == '+')
   {
      pszin++;
      for (int i=0; aGlblChainCmds[i]; i++)
      {
         cchar *psz = aGlblChainCmds[i];
         int aflags = *psz - '0';
         int bbinary = (aflags & 4) ? 1 : 0;
             aflags &= (3+8);
         psz++;
         int aflags2 = 0;
         if (isdigit(*psz)) {
             aflags2 = *psz - '0';
             psz++;
         }
         // sfk187: +web chain input default option
         if (aflags2 == 1)
            aflags = gs.cweb ? 2 : 8;
         if (!strncmp(psz, pszin, strlen(psz)))
         {
            rtype   = aflags;
            rbinary = bbinary;
            // printf("gcc: %d %d %s\n",aflags,bbinary,psz);
            return i;
         }
      }
   }

   rtype = 0;
   return 0;
}

// .
// find next chain command clearly defining a type like FILES or TEXT
// rc: 1==files, 2==text, 0==none
// rforce: type is defined by +text etc. and MUST be used,
//         otherwise caller may use defaults
int findNextChainType(int iDir, char *argv[], int argc, char **pszNext, bool &rforce, int &rbinary)
{
   if (cs.nochain) return 0;

   for (; iDir < argc; iDir++)
   {
      char *psz = argv[iDir];

      if (!psz)
      {
         // happens on %n parm of a script which is missing
         perr("missing or wrong script parameter (%d/%d)", iDir, argc);
         for (int i=0; i<argc; i++)
            printf("  #%d %s\n",i,argv[i]?argv[i]:"<null>");
         return 0;
      }

      int ntype = 0, bbinary = 0;
      int ncode = getChainCode(argv, argc, iDir, ntype, bbinary);

      // fix: 1763: everything after +then must be ignored.
      if (strcmp(psz, "+then") == 0 || ntype != 0)
      {
         if (psz[0] == '+') psz++;
         *pszNext = psz;
         // is it a forced type like +text?
         if (ncode < 0)
            rforce = 1;
         rbinary = bbinary;
         return ntype;
      }

      // +label name is always transparent
      if (!strcmp(psz, "+label")) { // sfk193 nopass.generic exception
         iDir++; // skip label name
         continue;
      }

      if (!cs.keepdata) // sfk193 nopass.generic: disable data tunneling
         break;
   }

   return 0;
}

bool isChainStartInt(char *pszCmd, char *argv[], int argc, int iDir, int *iDirNext, bool bAllowVerbose=0)
{
   if (cs.nochain) return 0;

   // prefix mode switchers:
   int nplus1=0, nplus2=0;
   int ntype = 0, bbin1 = 0;
   int ncode = getChainCode(argv, argc, iDir, ntype, bbin1);

   if (gs.nopass) // sfk1972 internal
   {
      char *psz = argv[iDir];
      if (psz[0] != '+')
         return 0;
      // is +cmd or ++cmd
      if (iDirNext) *iDirNext = iDir;
      if (psz[1] != '+') {
         return 1;
      }
      // is ++cmd
      if (ntype & 1) chain.colfiles  = 1;
      if (ntype & 2) chain.coldata   = 1;
      if (bbin1)     chain.colbinary = 1;
      if (cs.tracechain)
         printf("[chain from %s to %s. collect f=%d t=%d b=%d, n=%u idir %d %p]\n",pszCmd,psz,chain.colfiles,chain.coldata,chain.colbinary,ntype,iDir,iDirNext);
      return 1;
   }

   switch (ncode)
   {
      case ccftt:
         chain.colfiles   = 1;
         chain.files2text = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case ccfile:
         chain.colfiles = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case ccttf:
         chain.coldata    = 1;
         chain.text2files = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case cctext:
         chain.coldata = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case ccto:
         chain.coldata = 1;
         chain.colbinary = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case ccthen:
         chain.coldata    = 0;
         chain.colfiles   = 0;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         // use "then" as next chain command
         break;

      default:
         break;   // fall trough
   }
 
   // if +file or +text is specified, following command
   // is not required to start with "+".

   char *pszParm = argv[iDir];
   if (!strncmp(pszParm, "+", 1)) {
      nplus2 = 1;
      pszParm++;
   }

   if (ncode == ccthen) {
      // +then stops any further chain detections:
      if (iDirNext) *iDirNext = iDir;
      if (cs.tracechain)
         printf("[chain from %s to %s. collect f=%d t=%d, idir %d %p]\n",pszCmd,pszParm,chain.colfiles,chain.coldata,iDir,iDirNext);
      return true;
   }
 
   bool bForceFlush = 0;

   if (nplus1 || nplus2)
   {
      if (nplus2)
         nplus1 = 0;
      for (int i=0; aGlblChainCmds[i]; i++)
      {
         cchar *psz = aGlblChainCmds[i];
         int aflags = *psz - '0';
         int bbin2  = (aflags & 4) ? 1 : 0;
             aflags &= (3+8);
         psz++;
         int aflags2 = 0;
         if (isdigit(*psz)) {
             aflags2 = *psz - '0';
             psz++;
         }
         // sfk187: +web chain input default option
         if (aflags2 == 1)
            aflags = gs.cweb ? 2 : 8;
         if (!strncmp(psz, pszParm, strlen(psz)))
         {
            // standing on the first following chain command.
            if (!chain.coldata && !chain.colfiles)
            {
               // find out what the next typed chain element is,
               // e.g. +noop +sleep 1000 +text +filter -+foo
               // requires to find +text.
               bool bForce    = 0;
               char *pszNext  = 0;
               int  bbin3     = 0;
               int nNextType = findNextChainType(iDir, argv, argc, &pszNext, bForce, bbin3);
               mtklog(("chain: ics: found chain type %d at %s\n", nNextType, pszNext));
 
               if (cs.tracechain && pszNext)
                  printf("[found chain type %d at %s]\n", nNextType, pszNext);

               // if next type is not a forced one like +text,
               if (!bForce && pszNext)
               {
                  // check if there is a default mapping
                  for (int k=0; aGlblDefChnModes[k]; k += 3)
                  {
                     // look into defaults table
                     cchar *pszFrom = aGlblDefChnModes[k+0];
                     cchar *pszTo   = aGlblDefChnModes[k+1];
                     cchar *pszMode = aGlblDefChnModes[k+2];
                     if (   !strncmp(pszCmd , pszFrom, strlen(pszFrom))
                         && !strncmp(pszNext, pszTo  , strlen(pszTo  ))
                        )
                     {
                        // found a default:
                        nNextType = pszMode[0] - '0';
                        if (cs.tracechain)
                           printf("[but using default type mapping %d]\n", nNextType);
                        break;
                     }
                  }
               }
 
               if (nNextType & 1) {
                  chain.colfiles = 1;
                  chain.colbinary = bbin3;
               }

               if (nNextType & 2) {
                  chain.coldata = 1;
                  chain.colbinary = bbin3;
               }

               if (nNextType & 8) { // sfk181
                  chain.coldata = 0;
                  chain.colbinary = 0;
                  bForceFlush = 1;
               }
            }
 
            // if no mode yet set, use command default, if any
            if (!bForceFlush && !chain.coldata && !chain.colfiles) 
            {
               if (aflags==1)
                  chain.colfiles = 1;
               else
               if (aflags==2)
                  chain.coldata  = 1;
               chain.colbinary = bbin2;
            }
 
            if (iDirNext) *iDirNext = iDir;

            if (cs.tracechain)
               printf("[chain from %s to %s. collect f=%d t=%d, idir %d %p]\n",pszCmd,pszParm,chain.colfiles,chain.coldata,iDir,iDirNext);
 
            return true;
         }
      }
   }
 
   if (nplus2) {
      // no chain start although "+" parm
      // find/grep have a very loose syntax, therefore
      if (!strcmp(pszCmd, "find") || !strcmp(pszCmd, "grep"))
         return false; // command handler will issue error
      // check also filter parms
      if (!strncmp(argv[iDir], "++", 2) || !strncmp(argv[iDir], "+ls", 3)) // deprecated with sk197
         return false; // accept non-chain start
      // sfk1892: consider +anycommand as chaining without data
      chain.coldata    = 0;
      chain.colfiles   = 0;
      if (iDirNext) *iDirNext = iDir;
      return true;
      /*
      char *psz = argv[iDir];
      perr("command does not support input chaining: %s\n", psz);
      if (*psz=='+') psz++;
      pinf("try \"+then %s\" if \"%s\" requires no input data\n", psz, psz);
      exit(9);
      */
   }
 
   return false;
}

bool isChainStart(char *pszCmd, char *argv[], int argc, int iDir, int *iDirNext, bool bAllowVerbose=0)
{
   bool bres = isChainStartInt(pszCmd, argv, argc, iDir, iDirNext, bAllowVerbose);

   if (   (bres!=0 || iDir+1>=argc)
       && cs.iotrace && szIOTraceBuf[0] // isChainStart
      )
   {
      bool bcoldata   = chain.coldata;
      bool bcolbinary = chain.colbinary;
      bool bcolfiles  = chain.colfiles;
      if (!strcmp(pszCmd, "stop")) {
         bcoldata = bcolbinary = bcolfiles = 0;
      }
      char szOutInfo[200];
      char *pszTarget = argv[iDir];
      if (bcoldata || bcolbinary) {
         snprintf(szOutInfo,sizeof(szOutInfo)-10, "=> send to %s", pszTarget);
      } else if (bcolfiles) {
         snprintf(szOutInfo,sizeof(szOutInfo)-10, "## %s may use files", pszTarget);
      } else {
         if (!strcmp(pszCmd, "tend") || !strcmp(pszCmd, "fend"))
            strcpy(szOutInfo, "## return chain  ");
         else
            strcpy(szOutInfo, "##               "); // ## print toterm
      }
      fprintf(stderr, "%s %s\n", szIOTraceBuf, szOutInfo);
      szIOTraceBuf[0] = '\0';
   }

   return bres;
}

bool isHttpURL(char *psz)
{
   if (strBegins(psz, "http://"))
      return 1;
   if (strBegins(psz, "https://"))
      return 1;
   return 0;
}

int addConveniencePathMask(char *psz1, int &lRC, int iFromInfo)
{
   // turn a file mask into a path mask
   static char szMaskBuf[100];

   if (cs.debug)
      printf("] addConvPathMask for %s (from=%d)\n", psz1, iFromInfo);

   if (containsWildCards(psz1))
      strcopy(szMaskBuf, psz1);
   else
   if (isNotChar(*psz1))
      snprintf(szMaskBuf, sizeof(szMaskBuf)-10, "%c*%s", glblNotChar, psz1+1);
   else
      snprintf(szMaskBuf, sizeof(szMaskBuf)-10, "*%s", psz1);
   if (cs.verbose > 1)
      pinf("auto-converting %s to path mask %s\n", psz1, szMaskBuf);
   if (lRC |= glblFileSet.addDirMask(szMaskBuf)) // is copied
      return 9;
   return 0;
}

int processDirParms(char *pszCmd, int argc, char *argv[], int iDir, int nModeFlags, int *iDirNext, bool *pAnyDone)
{__
   mtklog(("processDirParms with argc=%d",argc));

   if (cs.debug) printf("process dir parms\n");

   int  nAutoComplete = (nModeFlags & 3);

   bool bStrictOptions = (nModeFlags & 4) ? 1 : 0;
   // strict: accept only -dir ... -file ... but not -pat and general opts,
   //         except for high prio options: -yes.
   //         used by: replace, xreplace, rename, xrename

   bool bReturnOptions = (nModeFlags & 8) ? 1 : 0; // sfk197 expclicitely
   // unknown options should not produce an error,
   // but return to caller for further processing.

   bool bAnyDone = 0; // any user-supplied dir/file parm used
   bool bPreFileFlank = 0;
   bool bConvenience = 0;
   int lRC = 0;

   bool aStateTouched[eST_MAXStates+10];
   memset(aStateTouched, 0, sizeof(aStateTouched));

   // fetch prefixed general options
   while (iDir < argc) {
      if (setGeneralOption(argv, argc, iDir))
         iDir++;
      else if (strlen(argv[iDir])==0)  // sfk1813 empty parm support
         iDir++;
      else
         break;
   }

   if (iDir < argc)
   {
      // check for -root a -using b now as it requires to rebuild text
      bool bRootWithUsing = 0;
      bool bUseUsingSyntax = 0;  // no '#' remarks. use '//' remarks.

      if (!strcmp(argv[iDir], "-root")) do {
         if (iDir+1 >= argc) return 9+perr("missing parameter after -root");
         if (iDir+2 >= argc) break; // no -root x -using y
         if (strcmp(argv[iDir+2], "-using")) break; // no -root x -using y
         bRootWithUsing = 1;
      } while (0);

      // do we have to rebuild a script text?
      if (!strcmp(argv[iDir], "-fileset")
          || !strcmp(argv[iDir], "-using")   // sfk197
          || bRootWithUsing                  // sfk197 -root a -using b
          )
      {
         // re-create parameter array from input file or label text

         char *pszParmFile = 0;
         int   iParmBytes  = 0;

         if (!strcmp(argv[iDir], "-using") || bRootWithUsing)
         {
            // sfk1963: -using label1 [-using label2] [...]
            // sfk197 : -root C: -using label1 -root D: -using label2
            while (iDir < argc)
            {
               // this is ONLY for -root a -using b -root c -using d.
               // this is NOT  for -root a -dir mydir.
               if (!strcmp(argv[iDir], "-root")) 
               {
                  if (iDir+1 >= argc) return 9+perr("missing parameter after -root");
                  if (iDir+2 >= argc) break; // no -root x -using y
                  if (strcmp(argv[iDir+2], "-using")) break; // no -root x -using y

                  iDir++;

                  snprintf(szLineBuf, MAX_LINE_LEN, "-root \"%s\" ", argv[iDir]);
                  int ilen = strlen(szLineBuf);

                  if (pszParmFile == 0) {
                     pszParmFile = new char[ilen+10];
                     memcpy(pszParmFile, szLineBuf, ilen);
                     pszParmFile[ilen] = '\0';
                     iParmBytes = ilen;
                     if (cs.debug) printf("[-root %s with %d chars]\n", argv[iDir], ilen);
                  } else {
                     char *ptmp = new char[iParmBytes+ilen+10];
                     memcpy(ptmp, pszParmFile, iParmBytes);
                     memcpy(ptmp+iParmBytes, szLineBuf, ilen);
                     ptmp[iParmBytes+ilen] = '\0';
                     iParmBytes += ilen;
                     delete [] pszParmFile;
                     pszParmFile = ptmp;
                     if (cs.debug) printf("[-root %s with %d chars]\n", argv[iDir], ilen);
                  }

                  iDir++;
                  continue;
               }

               if (strcmp(argv[iDir], "-using"))
                  break;

               bUseUsingSyntax = 1;

               iDir++;
               if (iDir >= argc) return 9+perr("missing label name after -using");
               char *plabel  = argv[iDir++];
               char *pscript = pGlblCurrentScript;
               if (!pscript) return 9+perr("did not get own script text");

               char szpat[100];
               snprintf(szpat, sizeof(szpat)-10, "sfk label %s", plabel);
               char *plabtext = strstr(pscript, szpat);
               if (!plabtext) return 9+perr("did not find label: %s", plabel);
               plabtext += strlen(szpat);
               skipWhite(&plabtext);

               char *peot = strstr(plabtext, "+end\r");
               if (!peot) peot = strstr(plabtext, "+end\n");
               if (!peot)
                  return 9+perr("did not find +end line after label: %s", plabel);

               int ilen = peot - plabtext;

               if (pszParmFile == 0) {
                  // first -using label
                  pszParmFile = new char[ilen+10];
                  memcpy(pszParmFile, plabtext, ilen);
                  pszParmFile[ilen] = '\0';
                  iParmBytes = ilen;
                  if (cs.debug) printf("[-using %s with %d chars]\n", plabel, ilen);
               } else {
                  // -using label1 -using label2
                  char *ptmp = new char[iParmBytes+ilen+10];
                  memcpy(ptmp, pszParmFile, iParmBytes);
                  memcpy(ptmp+iParmBytes, plabtext, ilen);
                  ptmp[iParmBytes+ilen] = '\0';
                  iParmBytes += ilen;
                  delete [] pszParmFile;
                  pszParmFile = ptmp;
                  if (cs.debug) printf("[-using %s with %d chars (%d total)]\n", plabel, ilen, iParmBytes);
               }
            }
         }
         else 
         {
            // -fileset filename
            iDir++;
            if (iDir >= argc) return 9+perr("missing filename name after -fileset");
            char *pszFilename = argv[iDir++];
            pszParmFile = loadFile(pszFilename);
            if (!pszParmFile) return 9;
         }

         pGlblFileParms = new StringTable(); // processDirParms

         // tokenize -fileset text
         char *psz1 = pszParmFile;
         while (*psz1)
         {
            // find next token.
            skipSpaceRem(&psz1, bUseUsingSyntax); // pdp
            if (!*psz1) break; // fix sfk1963

            // find end of token. support "parm with blanks".
            char *psz2 = psz1+1;
            if (*psz1 == '"')
               while (*psz2 && *psz2!='"')
                  psz2++;
            while (*psz2 && *psz2!=' ' && *psz2!='\t' && *psz2!='\r' && *psz2!='\n')
               psz2++;

            // isolate token
            if (*psz2)
               *psz2++ = '\0';

            // line-end may lead to empty entry, therefore
            if (strlen(psz1)) // only if not line-end
            {
               // strip "", if any
               if (*psz1 == '"' && strlen(psz1) >= 2) {
                  psz1++;
                  int nLen = strlen(psz1);
                  if (psz1[nLen-1] == '"')
                      psz1[nLen-1] = '\0';
               }
               if (cs.debug) printf("token: <<%s>>\n", psz1);
               pGlblFileParms->addEntry(psz1);
            }

            // continue with next token, if any
            psz1 = psz2;
         }
         delete [] pszParmFile;

         // pGlblFileParms now holds all parms
         int nParms = pGlblFileParms->numberOfEntries();
         apGlblFileParms = new char*[nParms];
         for (int i=0; i<nParms; i++)
            apGlblFileParms[i] = pGlblFileParms->getEntry(i, __LINE__);
         nGlblFileParms = nParms;

         // fix sfk1953: -fileset stopped command chain.
         if (iDirNext) {
            int iNext = iDir; // sfk1963 not +1 see above
            int iChainNext = 0;
            for (; iNext < argc; iNext++) {
               if (isChainStart(pszCmd, argv, argc, iNext, &iChainNext))
                  { *iDirNext = iChainNext; break; }
               if (!strcmp(argv[iNext], "-using")) { // sfk1963
                  char *pszInfo = str("");
                  if (iNext+1 < argc) pszInfo = argv[iNext+1];
                  return 9+perr("option not allowed here: %s %s (1)", argv[iNext], pszInfo);
               }
            }
         }

         // restart through recursion
         // printf("[%d parms from file]\n", nParms);
         return processDirParms(pszCmd, nParms, apGlblFileParms, 0, nAutoComplete, 0, pAnyDone); // sfk1963: missing pAnyDone
      }
 
      // init fileset
      if (glblFileSet.beginLayer(false, __LINE__))
         return 9;

      // fetch further prefix options, if any
      char *pszFirstParm = argv[iDir];
      while (!strncmp(pszFirstParm, "-", 1)) {
         if (!setGeneralOption(argv, argc, iDir))
            break; // unknown option, fall through to further processing
         pszFirstParm = (iDir < argc-1) ? argv[++iDir] : (char*)"";
      }

      if (*pszFirstParm == '-')
      {
         if (cs.debug) printf("process long format\n");

         // process int format, allowing multiple dirs:
         // sfk cmd -dir dir1 dir2 !dir3 !dir4 -file .hpp .cpp

         // we now have:
         //   clRootDirs , two rows, DirName(empty) and Cmd(empty)
         // one layer:
         //   clDirMasks , one row , empty
         //   clFileMasks, one row , empty

         int lState = eST_Idle;
         for (; iDir < argc; iDir++)
         {
            // prefix -dir -file combi end marker
            if (!strcmp(argv[iDir], "-enddir")) {
               // continue locally with command parms
               if (iDir+1 >= argc)
                  return 9+perr("-enddir is not allowed as last option");
               if (iDirNext)
                  *iDirNext = iDir+1;
               // fall through to autocomplete
               break;
            }

            if (isChainStart(pszCmd, argv, argc, iDir, iDirNext, 1))
               break;

            // on every state switch, we're first landing here
            if (lState >= 0 && lState < (int)(sizeof(aStateTouched)/sizeof(bool)))
               aStateTouched[lState] = 1;

            char *psz1 = argv[iDir];
 
            if (cs.debug) printf("] \"%s\" [\n",psz1);

            if (!strcmp(psz1, "-debug")) {
               cs.debug = 1;
               continue;
            }

            if (!strcmp(psz1, "-root")) { // sfk197
               iDir++;
               if (iDir >= argc)
                  return 9+perr("missing parameter after -root");
               strcopy(cs.rootdir, argv[iDir]);
               continue;
            }

            if (!strcmp(psz1, "-using")) { // sfk197 this is done above
               char *pszInfo = str("");
               if (iDir+1 < argc) pszInfo = argv[iDir+1];
               return 9+perr("option not allowed here: %s %s (2)", psz1, pszInfo);
            }

            if (!strcmp(psz1, "-dir"))
            {
               aStateTouched[eST_RootDirs] = 1;
               // creation of new dir/file mask layers:
               // 1. PostFileFlank: on change from non -dir to -dir
               // 2. PreFileFlank: on change from -file to -dir
               if (lState == eST_FileMasks && !bPreFileFlank) {
                  if (cs.debug) printf("] -dir: begin layer\n");
                  // not the very first -dir parm: add another layer
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               else
               if (lState == eST_SubDirs) {
                  if (cs.debug) printf("] -dir: begin layer.3\n");
                  // not the very first -dir parm: add another layer
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               else
               if (lState == eST_RootDirs && !bPreFileFlank) {
                  // -dir tmp1 tmp2 -dir tmp3 -file .txt
                  // add implicite "-file *" to first layer
                  lState = eST_FileMasks;
                  lRC |= glblFileSet.addFileMask(str("*"));
                  aStateTouched[lState] = 1;
                  if (cs.debug) printf("] -dir: begin layer.2\n");
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               else {
                  if (cs.debug) printf("] -dir: no begin layer\n");
               }
               // will collect further root dirs next
               lState = eST_RootDirs;
               aStateTouched[eST_FileMasks] = 0;
               continue;
            }
 
            if (!strcmp(psz1, "-sub") || !strcmp(psz1, "-subdir"))
            {
               aStateTouched[eST_SubDirs] = 1;
               if (lState != eST_RootDirs) {
                  perr("-sub[dir] is allowed only after -dir");
                  return 9;
               }
               lState = eST_SubDirs;
               continue;
            }

            if (!strcmp(psz1, "-any")) {
               // list of file- and directory names follows.
               cs.anyused = 1;
               lState = eST_DirFile;
               continue;
            }

            if (   isNotChar(psz1[0]) != 0
                && lState != eST_SubDirs
               )
            {
               if (lState == eST_RootDirs)
                  lRC |= glblFileSet.addDirMask(psz1);
               else
                  lRC |= glblFileSet.addFileMask(psz1);
               bAnyDone = 1;
               continue;
            }

            // collection of directory / file path masks:
            if (lState == eST_RootDirs)
            {
               if (psz1[0] == '+') {
                  if (!glblFileSet.rootDirs().numberOfEntries()) {
                     // +dirmask supplied without any previous root dir.
                     // imply that user wants dirs within the current dir "."
                     glblFileSet.addRootDir(str("."), __LINE__, false);
                     // imply that user does NOT want to process files from "."
                  }
                  bGlblNoRootDirFiles = 1;
                  lRC |= glblFileSet.addDirMask(psz1);
                  bGlblHavePlusDirMasks = 1;
                  bAnyDone = 1;
                  continue;
               }
               else
               if (containsWildCards(psz1))
               {
                  if (!glblFileSet.rootDirs().numberOfEntries())
                     glblFileSet.addRootDir(str("."), __LINE__, false);
                  lRC |= glblFileSet.addDirMask(psz1);
                  bAnyDone = 1;
                  continue;
               }
            }

            if (!strcmp(psz1, "-file"))
            {
               aStateTouched[eST_FileMasks] = 1;
               if (!strncmp(pszCmd, "freezeto=", strlen("freezeto=")))
                  return 9+perr("no -file masks supported with freezeto command.\n");
               if (cs.shortsyntax)
                  return 9+perr("you specified a dir name in short syntax. -file is not allowed then.\n");
               // FIX sfk196: -dir ... -subdir ... -dir selected too few.
               // check for eST_SubDirs was missing, causing beginLayer skip.
               if (lState != eST_RootDirs && lState != eST_SubDirs)
                  bPreFileFlank = 1; // -file coming before -dir
               else
               if (bPreFileFlank) {
                  // not the very first -file parm: add another layer
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               lState = eST_FileMasks;
               continue;
            }

            // used only with grep:
            if (!bStrictOptions && !strcmp(psz1, "-pat")) { // pdp
               lState = eST_GrepPat;
               continue;
            }

            // general option specified inbetween:
            if (bStrictOptions) {
               // unmaskable high prio general options only:
               // FIX 1652: always handle -yes even with strict -dir ... parsing.
               if (!strcmp(psz1, "-yes"))    { cs.yes = 1; continue; }
               // FIX 1660: allow -justrc being written rightmost.
               if (!strcmp(psz1, "-justrc")) { cs.justrc = 1; continue; }
            } else {
               if (setGeneralOption(argv, argc, iDir))
                  continue;
            }

            // workaround for "*" under unix. see also short syntax.
            if (!strcmp(psz1, "-all")) {
               if (lState != eST_FileMasks)
                  return 9+perr("wrong context for -all. use within -file.\n");
               // else fall through to add.
            }
            else
            if (*psz1 == '-') {
               // CHG: 1.69: continue locally with command parms.
               // used by: filter, (x)replace, (x)rename
               // sfk197: only with bReturnOptions set by those commands.
               if (bReturnOptions && iDirNext) {
                  *iDirNext = iDir;
                  // fall through to autocomplete
                  break;
               }
               perr("unknown dir or file parameter: %s\n", psz1);
               pinf("try to specify %s before -dir ... -file\n", psz1);
               return 9;
            }

            // handle all non-command parameters
            switch (lState)
            {
               case eST_RootDirs : {
                  // add another root dir, referencing the current layer.
                  if (glblFileSet.addRootDir(psz1, __LINE__, true, true)) // sfk193: -dir x.zip
                     return 9;
                  bAnyDone = 1;
                  break;
               }
               case eST_SubDirs : {
                  // add another dir mask, referencing the current layer.
                  #ifdef SFKOFFICE
                  // zip.check.mask office.long.subdir
                  // office: extend -subdir .xlsx to -subdir *.xlsx
                  if (cs.office && endsWithOfficeExt(psz1,150)) {
                     if (addConveniencePathMask(psz1,lRC,1))
                        return 9;
                  } else
                  #endif // SFKOFFICE
                  if (glblFileSet.addDirMask(psz1))
                     return 9;
                  bAnyDone = 1;
                  break;
               }
               case eST_FileMasks:
                  #ifdef SFKOFFICE
                  // zip.check.mask office.long.file
                  // office: extend -file .xlsx to -subdir *.xlsx
                  if (cs.office && endsWithOfficeExt(psz1,150)) {
                     if (addConveniencePathMask(psz1,lRC,2))
                        return 9;
                     bConvenience = 1;
                  } else
                  #endif // SFKOFFICE
                  lRC |= glblFileSet.addFileMask(psz1); 
                  break;
               case eST_GrepPat  : {
                  if (!strncmp(psz1, "\\\\", 2) || !strncmp(psz1, "\\+", 2) || !strncmp(psz1, "\\-", 2))
                     psz1++;
                  glblGrepPat.addString(psz1);
                  break;
               }
               case eST_IncBin   : glblIncBin.addString(psz1); break;
               case eST_DirFile  : {
                  // used only in case of explorer drag+drop.
                  Coi ocoi(psz1, 0);
                  if (ocoi.isTravelDir()) {
                     // coi name may have been redirected
                     if (glblFileSet.addRootDir(ocoi.name(), __LINE__, true, false)) // sfk193 x.zip
                        return 9;
                  } else {
                     if (cs.debug) printf("add2flist.2: %s\n", psz1);
                     glblSFL.addEntry(ocoi); // is copied
                  }
                  bAnyDone = 1;
                  break;
               }
               default : {
                  // reached only with -root ... and plain words,
                  // which is an illegal mix of long and short format.
                  perr("unexpected parameter: %s\n", psz1); // sfk197 missing
                  return 9;
               }
            }  // endswitch
         }  // endfor iDir

         // FIX: 169: [2131217] missing write back
         if (iDirNext!=0 && iDir>=argc)
            *iDirNext = 0;
      }
      else
      if (isChainStart(pszFirstParm, argv, argc, iDir, iDirNext))
      {
         // no actual dir parms at all, instead "+end" etc.:
         mtklog(("pdp: no parms, first is chain: %s", pszFirstParm));
         // fall through to autocomplete, if any
      }
      else
      if (strlen(pszFirstParm))
      {
         // process short format, either with single dir and fpatterns
         //    . .cpp .hpp !.hppx
         // or with a list of specified file names
         //    test1.txt test2.txt
         // OR, if simple drag+drop from explorer, mixed list.
         mtklog(("pdp: short: first=%s havemdfl=%d", pszFirstParm,bGlblHaveMixedDirFileList));

         if (cs.debug) printf("process short format\n");

         Coi *pcoi = 0;
         #ifdef VFILEBASE
         pcoi = glblVCache.get(pszFirstParm);
         #endif // VFILEBASE
         if (!pcoi) {
            pcoi = new Coi(pszFirstParm, 0);
            pcoi->incref("pdp");
         }
         CoiAutoDelete odel(pcoi, 1); // with decref

         // sfk1944: must treat office file parm as normal file (1)
         if ((!bGlblHaveMixedDirFileList) && pcoi->isTravelDir(1))
         {
            // fetch dir. coi name may have been redirected.
            glblFileSet.addRootDir(pcoi->name(), __LINE__, false, false);
            bAnyDone = 1;
            iDir++;

            // fetch masks
            for (; iDir < argc; iDir++)
            {
               if (isChainStart(pszCmd, argv, argc, iDir, iDirNext))
                  break;

               // also care about postfix/inbetween options
               char *psz1 = argv[iDir];
               if (setGeneralOption(argv, argc, iDir))
                  continue;
               if (!strcmp(psz1, "-file"))
                  return 9+perr("mixing of short and long syntax not allowed. you may try -dir %s -file ...\n", pszFirstParm);
               if (!strcmp(psz1, "-dir"))
                  return 9+perr("mixing of short and long syntax not allowed. you may try -dir %s ...\n", pszFirstParm);

               // workaround for "*" under unix. see also int syntax.
               if (!strcmp(psz1, "-all")) {
                  // fall through to add
               }
               else
               if (psz1[0] == '-') {
                  perr("unexpected option in short filename list: %s\n", psz1);
                  pinf("try specifying %s directly after %s\n", psz1, pszCmd);
                  return 9;
               }

               #if 0 // def SFKOFFICE - no file mask conversion
               // zip.check.mask office.short.file
               // office: extend short file mask to -subdir *.xlsx
               if (cs.office && endsWithOfficeExt(psz1,151)) {
                  if (addConveniencePathMask(psz1,lRC,3))
                     return 9;
               } else
               #endif // SFKOFFICE
               #ifdef VFILEBASE
               // zip.check.mask zip.short.file
               // zip: extend short file mask to -subdir *.zip
               if (!cs.shallowzips && cs.xelike && cs.travelzips && isArcFile(psz1)) {
                  if (addConveniencePathMask(psz1,lRC,4))
                     return 9;
               } else
               #endif // VFILEBASE
               if (lRC |= glblFileSet.addFileMask(psz1))
                  return 9;
               bAnyDone = 1;
            }
         }
         else
         {
            // todo: split this in 2 paths. there can be no options
            //       in case of drag+drop on .exe.

            // fetch file and/or dir list. this path is called
            // - either from command prompt
            // - or from drag+drop on .exe (no preconfigured icon)
            for (; iDir < argc; iDir++)
            {
               if (isChainStart(pszCmd, argv, argc, iDir, iDirNext))
                  break;

               char *psz1 = argv[iDir];
               if (*psz1 == '-') {
                  if (!setGeneralOption(argv, argc, iDir))
                     return 9+perr("wrong context or unknown option: %s\n", psz1);
               } else {
                  char *pszroot = getAbsPathStart(psz1); // sfk1934 fname parms
                  Coi ocoi(psz1, pszroot); // sfk1934 root with fname parms
                  if (bGlblHaveMixedDirFileList && ocoi.isAnyDir()) {
                     glblFileSet.addRootDir(psz1, __LINE__, false, false);
                     bAnyDone = 1;
                  } else {
                     if (cs.debug) printf("add2flist.3: %s\n", psz1);
                     glblSFL.addEntry(ocoi); // is copied
                     bAnyDone = 1;
                  }
               }
            }
            if (!bGlblHaveMixedDirFileList)
               nAutoComplete = 0;
         }
      }
   }
   else
   {
      // no parms at all supplied:
      if (!cs.blockAutoComplete && (nAutoComplete & 2))
         glblFileSet.addRootDir(str("."), __LINE__, false);
      // possibly redundant, see autocomplete below
   }

   bool bFail = (lRC != 0);

   // plausibility checks
   if (aStateTouched[eST_IncBin] && !glblIncBin.numberOfEntries())
      { bFail=1; perr("please supply a list of file extensions after -addbin or -include-binary-files.\n"); }
   if (aStateTouched[eST_GrepPat] && !glblGrepPat.numberOfEntries())
      { bFail=1; perr("please supply some pattern words after option -pat.\n"); }
   if (!bConvenience && aStateTouched[eST_FileMasks] && !glblFileSet.fileMasks().numberOfEntries())
      { bFail=1; perr("please supply some file extensions after option -file.\n"); }
   if (aStateTouched[eST_RootDirs] && !glblFileSet.rootDirs().numberOfEntries())
      { bFail=1; perr("please supply some directory names after option -dir.\n"); }

   if (!cs.blockAutoComplete && (nAutoComplete != 0))
      glblFileSet.autoCompleteFileMasks(nAutoComplete);

   if (aStateTouched[1] || aStateTouched[2]) // if any -dir or -file
      if (glblFileSet.checkConsistency()) // then no empty layers allowed
         bFail=1;

   if (cs.debug) glblFileSet.dump();

   glblFileSet.setBaseLayer();

   // -sincedir requires root dir parameters
   if (pszGlblSinceDir && !glblFileSet.hasRoot(0)) {
      // Array &aroots = glblFileSet.rootDirs();
      // int nroots = aroots.numberOfEntries(0);
      // if (nroots <= 0)
      return 9+perr("-sincedir/add/diff requires two directories.\n");
   }

   // tell caller if any real dir parms were used
   if (pAnyDone) *pAnyDone = bAnyDone;

   return bFail ? 9 : 0;
}

int setProcessSingleDir(char *pszDirName)
{__
   #ifdef VFILEBASE
   if (   !strBegins(pszDirName, "http://")
       && !strBegins(pszDirName, "https://")
       && !strBegins(pszDirName, "ftp://")
      )
   #endif // VFILEBASE
   {
      Coi ocoi(pszDirName, 0);
      if (!ocoi.isTravelDir())
         return 9+perr("directory not found: %s\n", pszDirName);
   }

   // init fileset
   if (glblFileSet.beginLayer(true, __LINE__))
      return 9;

   glblFileSet.addRootDir(pszDirName, __LINE__, false, false);
   glblFileSet.autoCompleteFileMasks(3);

   if (cs.debug) glblFileSet.dump();

   glblFileSet.setBaseLayer();

   return 0;
}

void trimCR(char *pszBuf) {
   int ilen = strlen(pszBuf);
   if (ilen > 0 && pszBuf[ilen-1] == '\r')
      pszBuf[ilen-1] = '\0';
}

void removeCRLF(char *pszBuf) {
   char *pszLF = strchr(pszBuf, '\n');
   if (pszLF) *pszLF = '\0';
   char *pszCR = strchr(pszBuf, '\r');
   if (pszCR) *pszCR = '\0';
}

void fixPathChars(char *pszBuf) {
   // if path contains foreign path chars, change to local
   char *psz = pszBuf;
   for (; *psz; psz++)
      if (*psz == glblWrongPChar)
          *psz = glblPathChar;
}

int myfseek(FILE *f, num nOffset, int nOrigin)
{
   if (nOrigin != SEEK_SET)
      return 9+perr("internal: myfseek: supports only SEEK_SET");

   #ifdef _WIN32
   if (sizeof(num) != sizeof(fpos_t)) return 9+perr("internal: myfseek: wrong fpos_t size, need 64 bits");
   return fsetpos(f, &nOffset);
   #else
   fpos64_t xpos;
   if (fgetpos64(f, &xpos)) // read xpos.__state
      return 9+perr("internal: myfseek: failed to read position");
    #if defined(MAC_OS_X) || defined(SOLARIS)
     xpos = (fpos_t)nOffset;
    #else
     if (sizeof(xpos.__pos) != sizeof(nOffset)) return 9+perr("internal: myfseek: wrong __pos size, need 64 bits");
     xpos.__pos = nOffset;
    #endif
   return fsetpos64(f, &xpos);
   #endif
}

uchar   aGlblGetBuf[MY_GETBUF_MAX+100];
int    nGlblGetSize  = 0;
int    nGlblGetIndex = 0;
int    nGlblGetEOD   = 0;
num     nGlblGetFPos  = 0;

void myfgets_init()
{
   nGlblGetSize  = 0;
   nGlblGetIndex = 0;
   nGlblGetEOD   = 0;
   nGlblGetFPos  = 0;
}

// replacement for fgets, which cannot cope with 0x00 (and 0x1A under windows)
int myfgets(char *pszOutBuf, int nOutBufLen, FILE *fin, bool *rpIsBinary, char *pAttrBuf)
{
   if (!fin) return 9+perr("int. #66 missing file handle\n");
   if (nGlblGetSize  < 0 || nGlblGetSize  > MY_GETBUF_MAX) return 9+perr("int. #62 %d %d\n",(nGlblGetSize < 0),(nGlblGetSize > MY_GETBUF_MAX));
   if (nGlblGetIndex < 0 || nGlblGetIndex > MY_GETBUF_MAX) return 9+perr("int. #63 %d %d\n",(nGlblGetIndex < 0),(nGlblGetIndex > MY_GETBUF_MAX));
   if (nGlblGetIndex > nGlblGetSize) return 9+perr("int. #64\n");
   if (nGlblGetEOD > 1) return 9+perr("int. #65\n");

   int nBufFree = MY_GETBUF_MAX - nGlblGetSize;
   uchar *pRead  = &aGlblGetBuf[nGlblGetSize];

   // refill read buffer
   int nRead = 0;
   if (!nGlblGetEOD && (nGlblGetSize < MY_GETBUF_MAX/2)) {
      if ((nRead = fread(pRead, 1, nBufFree, fin)) <= 0)
         nGlblGetEOD = 1;
      else
         nGlblGetSize += nRead;
   }

   if (cs.debug) printf("] pre size %d index %d free %d nread %d\n", nGlblGetSize, nGlblGetIndex, nBufFree, nRead);

   // anything remaining?
   if (nGlblGetIndex >= nGlblGetSize) {
      nGlblGetEOD = 2;
      return 0;
   }

   // copy next line from front
   int nIndex     = nGlblGetIndex;
   int nOutIndex  = 0;
   int nOutSecLen = nOutBufLen-10;
   bool bBinary    = 0;
   for (; (nIndex < nGlblGetSize) && (nOutIndex < nOutSecLen);)
   {
      uchar c1 = aGlblGetBuf[nIndex++];
      nGlblGetFPos++; // count source position in file

      if (c1 == 0x00 || c1 == 0x1A) {
         if (!c1)
            bBinary = 1;
         c1 = (uchar)'.';
      }
      else
      if (c1 == (uchar)'\r')
         continue;

      pszOutBuf[nOutIndex++] = (char)c1;

      if (c1 == (uchar)'\n')
         break;
   }
   pszOutBuf[nOutIndex] = '\0';

   // promote binary flag
   if (bBinary && rpIsBinary)
      *rpIsBinary = 1;

   // move remaining cache data
   int nCacheRemain = nGlblGetSize-nIndex;
   if (nIndex + nCacheRemain < 0) return 9+perr("int. #60\n");
   if (nIndex + nCacheRemain > MY_GETBUF_MAX) return 9+perr("int. #61\n");
   if (nCacheRemain > 0)
      memmove(aGlblGetBuf, &aGlblGetBuf[nIndex], nCacheRemain);

   nGlblGetSize -= nIndex;
   nGlblGetIndex = 0;

   // if (cs.debug) printf("] pos size %d index %d out %d\n", nGlblGetSize, nGlblGetIndex, nOutIndex);

   return nOutIndex;
}

// just for sfk run: process text list with file- OR dirnames
int walkStdInListFlat(int nFunc, int &rlFiles, num &rlBytes)
{__
   if (nGlblError)
      return 9;

   nGlblFunc = nFunc;

   int lDirs = 0;
   FileList oLocDirFiles;

   while (fgets(szLineBuf, sizeof(szLineBuf)-10, stdin))
   {
      removeCRLF(szLineBuf);

      if (userInterrupt()) break;

      num nLocalMaxTime = 0, nTreeMaxTime  = 0;

      // skip remark and empty lines
      if (szLineBuf[0] == '#') continue;
      if (!strlen(szLineBuf))  continue;

      if (bGlblStdInFiles)
      {
         Coi ocoi(szLineBuf, 0);

         int lRC = execSingleFile(&ocoi, 0,
                        rlFiles, oLocDirFiles.clNames.numberOfEntries(),
                        lDirs, rlBytes,
                        nLocalMaxTime, nTreeMaxTime);

         if (!lRC) rlFiles++;

         if (cs.stopTree(lRC)) return lRC; else lRC=0;
      }

      if (bGlblStdInDirs)
      {
         rlFiles = 0; // reset tree file count

         Coi ocoi(szLineBuf, 0);

         int rlDirs = 0;
         num  nLocalBytes = 0;
         int lRC = execSingleDir(&ocoi, 0, rlFiles, oLocDirFiles, rlDirs, nLocalBytes,
                                  nLocalMaxTime, nTreeMaxTime);
         nLocalMaxTime = 0; // reset after use in execSingleDir
         rlBytes += nLocalBytes;

         if (cs.stopTree(lRC)) return lRC; else lRC=0;
      }
   }

   return 0;
}

// all commands except sfk run:
// take list with mixed file- and dirnames.
// in case of dirs, process each as root tree.
int walkStdInListDeep(int nFunc, int &rlFiles, num &rlBytes)
{__
   if (nGlblError)
      return 9;

   bool bsilent = 0;

   // select the default mask set.
   glblFileSet.setCurrentRoot(0);

   while (fgets(szLineBuf, sizeof(szLineBuf)-10, stdin))
   {
      removeCRLF(szLineBuf);

      // skip remark and empty lines
      if (szLineBuf[0] == '#') continue;
      if (!strlen(szLineBuf))  continue;

      // now holding a file- OR a dirname.
      int lDirs = 0;
      FileList oLocDirFiles;
      num  nLocalBytes = 0, nLocalMaxTime = 0, ntime2 = 0;

      // szLineBuf may be root itself.
      Coi *pcoi = new Coi(szLineBuf, 0);
      CoiAutoDelete odel(pcoi, 0); // 0: no decref

      if (cs.debug) printf("] siw: %s\n", pcoi->name());
      int lRC = walkFiles(pcoi, 0, rlFiles, oLocDirFiles, lDirs, nLocalBytes, nLocalMaxTime, ntime2);

      if (cs.stopTree(lRC)) return lRC; else lRC=0;

      if (pcoi->isTravelDir())
      {
         lDirs++; // count dir as processed

         rlFiles = 0; // reset tree file count

         // if this succeeded, treat the tree as another dir.
         if (cs.debug) printf("] sid: %s\n", pcoi->name());
         lRC = execSingleDir(pcoi, 0, rlFiles, oLocDirFiles, lDirs, nLocalBytes, nLocalMaxTime, ntime2);
         if (cs.stopTree(lRC, &bsilent))
         {
            nLocalMaxTime = 0;
            if (bsilent)
               return 0;
            nGlblError = 1;
            return 9;
         }
         lRC = 0;
         nLocalMaxTime = 0;
      }

      rlBytes += nLocalBytes;

      if (bGlblEscape)
         break;
   }

   return 0;
}

// process files from sfl or chain file list.
// does NOT recurse into directories.
int walkFileListFlat(CoiTable &oList, int nFunc, int &rlFiles, num &rlBytes, int &rlDirs)
{__
   if (nGlblError)
      return 9;

   int lDirs = 0;
   FileList oLocDirFiles;
   int nLocFiles = 0;
   num  nLocBytes = 0;
   num  nLocalMaxTime = 0, nTreeMaxTime = 0;
   bool bOldTravelZips = cs.travelzips;

   int lRC = 0;

   char szCurPath[300];
   memset(szCurPath, 0, sizeof(szCurPath));

   setUsingFileList(1);

   int nEntries = oList.numberOfEntries();
   for (int i=0; i<nEntries; i++)
   {
      if (userInterrupt()) break;

      Coi *pcoi = oList.getEntry(i, __LINE__);
      if (!pcoi) return 9+perr("int. #50\n");

      // in case a.x//foo was processed
      cs.travelzips = bOldTravelZips;

      #ifdef VFILEBASE
      // optim: if the cache contains an identical url,
      // take that coi instead, to avoid double reads.
      Coi *ptmp = glblVCache.get(pcoi->name());
      // caller (we) MUST RELEASE COI after use!
      if (ptmp) {
         mtklog(("wfl: coi replaced by cache entry: %s", pcoi->name()));
         pcoi = ptmp;
      }
      else
      #endif // VFILEBASE
         pcoi->incref("wff");

      #ifdef SFKDEEPZIP
      // convenience: enable -arc on a.x//inner.txt
      if (pcoi->isZipSubEntry() && !cs.travelzips) {
         if (cs.debug)
            printf("enable -xarc due to %s\n", pcoi->name());
         cs.travelzips = 2;
      }
      #endif // SFKDEEPZIP

      // NO RETURN WITHOUT RELEASE!

      // additional fields available only from chain file list:
      char *pszRoot  = pcoi->root(1);  // returns null if none
      char *pszRef   = pcoi->ref(1);   // returns null if none

      if (cs.debug)
         printf("] wfl: %s   %s   %s   dir=%d\n", pcoi->name(), pszRoot ? pszRoot : "[no root]", pszRef ? pszRef : "[no ref]", pcoi->isTravelDir());

      mtklog(("] wfl: %s   %s   %s   dir=%d", pcoi->name(), pszRoot ? pszRoot : "[no root]", pszRef ? pszRef : "[no ref]", pcoi->isTravelDir()));

      #ifdef SFKOFFICE
      if (cs.office && pcoi->isOffice(108)) {
         lRC = walkFiles(pcoi, 0,
                     rlFiles, oLocDirFiles, rlDirs, rlBytes,
                     nLocalMaxTime, nTreeMaxTime);
      } else
      #endif // SFKOFFICE
      if (cs.withdirs && pcoi->isTravelDir()) {
         // file list mixed with dir names: expect dirname to come last.
         rlFiles  += nLocFiles;
         rlBytes  += nLocBytes;
         // unsolved: exclude previous files that are not part of the dir.
         nLocFiles = -1; // workaround for now: don't list dirs
         nLocBytes = -1; // workaround for now: don't list dirs
         lRC = execSingleDir(pcoi, 0,
                     nLocFiles, oLocDirFiles,
                     lDirs, nLocBytes,
                     nLocalMaxTime, nTreeMaxTime);
         oLocDirFiles.reset();
         nLocFiles = 0;
         nLocBytes = 0;
         rlDirs++;
      } else {
         // process file entry
         lRC = execSingleFile(pcoi, 0,
                     nLocFiles, 1,
                     lDirs, nLocBytes,
                     nLocalMaxTime, nTreeMaxTime);
         if (!lRC) nLocFiles++;
      }

      // RELEASE COI after use:
      pcoi->decref();

      if (cs.stopTree(lRC)) return lRC; else lRC=0;
   }

   // flush yet uncounted values
   rlFiles += nLocFiles;
   rlBytes += nLocBytes;

   setUsingFileList(0);

   return lRC;
}

void resetFileSet()
{
   glblFileSet.reset();

   // sfk1963: missing reset of -fileset etc. parms between commands
   if (pGlblFileParms)  { delete pGlblFileParms; pGlblFileParms=0; }
   if (apGlblFileParms) { delete [] apGlblFileParms; apGlblFileParms=0; }
}

void resetAllFileSets()
{
   resetFileSet();   // sfk1963 safety

   chain.usefiles = 0;
   bGlblStdInAny  = 0;
   glblSFL.resetEntries();
}

int walkAllTreesInt(int nFunc, int &rlFiles, int &rlDirs, num &rlBytes);
int checkAllTreesInt();

int walkAllTrees(int nFunc, int &rlFiles, int &rlDirs, num &rlBytes)
{
   if (cs.checkdirs)
      if (checkAllTreesInt())
         return 9;

   int lRC = walkAllTreesInt(nFunc, rlFiles, rlDirs, rlBytes);

   if (nFunc == eFunc_JamFile && pGlblJamStatCallBack != 0)
   {
      // final statistics update call
      pGlblJamStatCallBack(0, glblFileCount.value(), cs.lines, (uint)(cs.totalbytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
      // ignore rc, does not match walkTrees rc
   }
 
   return lRC;
}

void sendCollectStats( )
{
   if (pGlblJamStatCallBack != 0)
   {
      pGlblJamStatCallBack(0, glblFileCount.value(), cs.lines, (uint)(cs.totalbytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
   }
}

int checkAllTreesInt()
{
   int nmiss = 0;

   for (int nDir=0; glblFileSet.hasRoot(nDir); nDir++)
   {
      char *pszTree = glblFileSet.setCurrentRoot(nDir);
      if (!isDir(pszTree)) {
         perr("dir not found: %s", pszTree);
         nmiss++;
      }
   }

   if (nmiss) {
      // pinf("%d root dir(s) were not found.\n", nmiss);
      pinf("[nopre] check your command for typos and missing quotes.\n");
      return 9;
   }

   return 0;
}

int walkAllTreesInt(int nFunc, int &rlFiles, int &rlDirs, num &rlBytes)
{__ _p("sf.walkall")

   mtklog(("wat: walkAllTrees fn %d err %d",nFunc,nGlblError));

   if (nGlblError)
      return 9;

   nGlblFunc = nFunc;

   int lRC = 0;
   bool bsilent = 0;

   if (chain.usefiles) {
      mtklog(("wat: chain.usefiles is set, %d in queue", chain.numberOfInFiles()));
      if (chain.numberOfInFiles())
         return walkFileListFlat(*chain.infiles, nFunc, rlFiles, rlBytes, rlDirs);
      else if (cs.keepchain || cspre.keepchain) // sfk1933
         return 0;
      else
         return 9+perr("no filenames to process. command chaining stopped.\n");
   }

   if (bGlblStdInAny) {
      mtklog(("wat: processing stdinlist"));
      return walkStdInListDeep(nFunc, rlFiles, rlBytes);
   }

   if (glblSFL.numberOfEntries()) {
      mtklog(("wat: processing SFL entries, %d in queue", glblSFL.numberOfEntries()));
      lRC = walkFileListFlat(glblSFL, nFunc, rlFiles, rlBytes, rlDirs);
      if (cs.stopTree(lRC)) return lRC; else lRC=0;
   }

   for (int nDir=0; glblFileSet.hasRoot(nDir); nDir++)
   {
      mtklog(("wat: processing root dir %d", nDir));
 
      if (userInterrupt())
         break;

      // local tree statistics:
      int nLocalDirs  = 0;
      int nLocalFiles = 0;
      num  nLocalBytes = 0;

      FileList oDirFiles;

      num nLocalMaxTime = 0, nTreeMaxTime  = 0;

      // process one of the trees given at commandline.
      char *pszTree = glblFileSet.setCurrentRoot(nDir);
      if (cs.debug) printf("] wat: tree %s\n", pszTree);

      char *pszRoot = glblFileSet.root(1); // returns 0 if none

      // The topmost coi gets the top root set.
      // All sub-coi's will copy this root.
      Coi *pcoi = 0;

      #ifdef VFILEBASE
      if ((pcoi = glblVCache.get(pszTree))) {
         mtklog(("wat: ... reusing root from vcache"));
      }
      else
      #endif // VFILEBASE
      {
         pcoi = new Coi(pszTree, pszRoot);
         pcoi->incref("wat");
      }
      CoiAutoDelete odel(pcoi, 1); // with decref

      if (cs.predir==1)
      {
         if (cs.debug) printf("] wat: edir %s\n", pszTree);
         lRC = execSingleDir(pcoi, 0, nLocalFiles, oDirFiles, nLocalDirs, nLocalBytes, nLocalMaxTime, nTreeMaxTime);
      }

      lRC = walkFiles(pcoi, 0, nLocalFiles, oDirFiles, nLocalDirs, nLocalBytes, nLocalMaxTime, nTreeMaxTime);

      if (cs.stopTree(lRC, &bsilent)) {
         if (bsilent)
            return 0;
         nGlblError = 1;
         return 9;
      }
      lRC = 0;

      if (cs.predir==0 && cs.withrootdirs==1)
      {
         if (cs.debug) printf("] wat: edir %s\n", pszTree);
         lRC = execSingleDir(pcoi, 0, nLocalFiles, oDirFiles, nLocalDirs, nLocalBytes, nLocalMaxTime, nTreeMaxTime);
      }

      if (cs.flatdirstat) {
         cs.flatdircnt++; // count root dir
         cs.flatdircnt  += nLocalDirs;
         cs.flatfilecnt += nLocalFiles;
         cs.flatbytecnt += nLocalBytes;
      } else {
         rlDirs++; // count root dir
         rlDirs   += nLocalDirs; // add its subdirs
         rlFiles  += nLocalFiles;
         rlBytes  += nLocalBytes;
      }

      if (cs.stopTree(lRC, &bsilent)) {
         nLocalMaxTime = 0;
         if (bsilent)
            return 0;
         nGlblError = 1;
         return 9;
      }
      lRC = 0;

      nLocalMaxTime = 0;

      if (bGlblEscape)
         break;
   }

   return lRC;
}

#ifndef USE_SFK_BASE

#ifdef SFK_W64
void widetochar(ushort *ain, char *aout)
{
   int i=0;
   for (; ain[i]; i++)
      aout[i] = (char)ain[i];
   aout[i] = '\0';
}

int walkFilesW(ushort *atop, int lLevel)
{
   if (bGlblEscape)
      return 0;

   if (cs.debug) printf("] wfl: %s\n", dataAsTraceW(atop));

   int lRC = 0;

   ushort atopmask[1024];
   ushort aabsfile[1024];
   char   szrelfile[1024];

   {
      int i=0;
      for (; atop[i]; i++)
         atopmask[i] = atop[i];
      atopmask[i++] = '\\';
      atopmask[i++] = '*';
      atopmask[i] = '\0';
   }

   sfkfinddata64_t odata;

   bool bfirst = 1;
   intptr_t pdir = 0;

   while (1)
   {
      if (bfirst) {
         bfirst = 0;
         pdir = _wfindfirst64((const wchar_t *)atopmask, &odata);
         if (pdir == -1) {
            if (cs.debug) printf("] wfl: stop\n");
            return 0;
         }
      } else {
         int isubrc = _wfindnext64(pdir, &odata);
         if (isubrc)
            break;
      }

      ushort *arelfile = (ushort*)odata.name;

      // build absolute name
      int i=0;
      for (; atop[i]; i++)
         aabsfile[i] = atop[i];
      aabsfile[i++] = '\\';
      for (int k=0; arelfile[k]; k++)
         aabsfile[i++] = arelfile[k];
      aabsfile[i++] = 0;
      widetochar(arelfile, szrelfile);

      if (odata.attrib & 0x10)
      {
         // sub folder
         if (arelfile[0]=='.' && arelfile[1]==0)
            continue;
         if (arelfile[0]=='.' && arelfile[1]=='.' && arelfile[2]==0)
            continue;
         if (!cs.subdirs)
            continue;

         lRC = walkFilesW(aabsfile, lLevel+1);

         if (cs.stopTree(lRC))
            break;

         lRC = 0;

         continue;
      }
      else if (matchesFileMask(szrelfile, 0, 1))
      {
         lRC = execFixFile(aabsfile, &odata);
         // todo: rc mapping?
      }
   }

   _findclose(pdir);

   return lRC;
}

int walkAllTreesW(int nFunc)
{
   nGlblFunc = nFunc;

   int lRC = 0;
   bool bsilent = 0;

   for (int nDir=0; glblFileSet.hasRoot(nDir); nDir++)
   {
      if (userInterrupt())
         break;

      char *pszTree = glblFileSet.setCurrentRoot(nDir);
      if (cs.debug) printf("] wat: tree %s\n", pszTree);

      uchar *pszRoot = (uchar*)glblFileSet.root(1); // returns 0 if none
      ushort aroot[1024];
      int i=0;
      for (; pszRoot[i]; i++)
         aroot[i] = pszRoot[i];
      aroot[i] = 0;

      lRC = walkFilesW(aroot, 0);

      if (cs.stopTree(lRC, &bsilent)) {
         if (bsilent)
            return 0;
         nGlblError = 1;
         return 9;
      }
      lRC = 0;

      if (cs.stopTree(lRC, &bsilent)) {
         if (bsilent)
            return 0;
         nGlblError = 1;
         return 9;
      }
      lRC = 0;

      if (bGlblEscape)
         break;
   }

   return lRC;
}
#endif

#endif // USE_SFK_BASE

int isDirByName(char *pszName)
{
   // used for not-yet-existing targets:
   // tell if it should be a dir by looking at the name
   int nlen = strlen(pszName);
   if (nlen <= 0) return 0;
   if (!strcmp(pszName, ".")) return 1;
   if (!strcmp(pszName, "..")) return 1;
   char clast = pszName[nlen-1];
   if (clast == glblPathChar) return 1;
   #ifdef _WIN32
   if (clast == ':') return 1;
   #endif
   // todo: aaa/. and aaa/.. detection
   return 0;
}

int isDir(char *pszName)
{
   if (bGlblSyntaxTest) {
      // if just simulating, check how the name looks
      if (!strcmp(pszName, ".")) return 1;
      return strstr(pszName, "dir") ? 1 : 0;
   }
   if (containsWildCards(pszName))
      return 0;

   #ifdef _WIN32

   DWORD nAttrib = GetFileAttributes(pszName);
   if (nAttrib == 0xFFFFFFFF) // "INVALID_FILE_ATTRIBUTES"
      return 0;
   if (nAttrib & FILE_ATTRIBUTE_DIRECTORY)
      return 1;

   #else

   struct stat64 buf;
   if (stat64(pszName, &buf))
      return 0;
   if (buf.st_mode & _S_IFDIR )
      return 1;

   #endif

   return 0;
}

int fileExists(char *pszName, bool bOrDir)
{
   #ifdef _WIN32

   DWORD nAttrib = GetFileAttributes(pszName);
   if (nAttrib == 0xFFFFFFFF) // "INVALID_FILE_ATTRIBUTES"
      return 0;
   if (!bOrDir && (nAttrib & FILE_ATTRIBUTE_DIRECTORY))
      return 0; // is a dir, not a file

   #else

   struct stat64 buf;
   if (stat64(pszName, &buf))
      return 0;
   if (!bOrDir && (buf.st_mode & _S_IFDIR))
      return 0; // is a dir, not a file

   #endif

   // we can get the attribs, and it's not a dir,
   // so expect that it is a file.
   // TODO: maybe further checks should be added.
   return 1;
}

int coiExists(char *pszName, bool bOrDir)
{
   Coi *pcoi = new Coi(pszName, 0);
   if (!pcoi) return 0;
   pcoi->incref("cex");

   int nrc = pcoi->existsFile(bOrDir);

   if (!pcoi->decref())
      delete pcoi;

   return nrc;
}

#ifdef SFK_W64
int mystat64(char *pszName, struct __stat64 *pout)
{
   #if (_MSC_VER >= 1900)

   memset(pout, 0, sizeof(*pout));

   /*
      sometimes win10 produces a junk file creation date before 1970.
      then the visual 2015 runtime refuses to stat on that,
      with errno 132 "Overflow".
      mystat64 returns zero time in such a case.
   */

   WIN32_FILE_ATTRIBUTE_DATA oinf;
   int bok = GetFileAttributesEx(pszName, GetFileExInfoStandard, &oinf);
   if (!bok) return 9;

   pout->st_atime = fileTimeToTimeT(&oinf.ftLastAccessTime);
   pout->st_ctime = fileTimeToTimeT(&oinf.ftCreationTime);
   pout->st_mtime = fileTimeToTimeT(&oinf.ftLastWriteTime);
   unum nsize =      (((unum)oinf.nFileSizeHigh) << 32)
                  |  (((unum)oinf.nFileSizeLow)  <<  0);
   pout->st_size  = nsize;

   uint nmode = _S_IREAD | _S_IWRITE;

   if (oinf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
      nmode |= _S_IFDIR;

   if (oinf.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
      nmode &= (0xFFFFFFFFU ^ _S_IWRITE);

   pout->st_mode = nmode;

   return 0;

   #else

   return _stat64(pszName, pout);

   #endif
}
#endif

int getFileStat( // RC == 0 if exists anything
   char  *pszName,
   int   &rbIsDirectory,
   int   &rbCanRead,
   int   &rbCanWrite,
   num   &rlFileTime,
   num   &rlFileSize,
   num   *ppcatimes,     // optional: creation and access time
   void  *prawstat,      // optional: create copy of stat structure
   int    nrawstatmax,   // size of above buffer
   uint   nmodeflags     // bit 0: use alternative stat, if available
 )
{
   bool bAltStat = (nmodeflags & 1) ? 1 : 0;

   if (prawstat) memset(prawstat, 0, nrawstatmax);

   #ifdef _WIN32

   #ifdef WINFULL
   // special case: top level of UNC paths
   // \\host\root          fails with stat()
   // \\host\root\subdir   can be used
   if (    bAltStat
       || !strncmp(pszName, "\\\\", 2)
       || !strncmp(pszName, "//", 2)
      )
   do
   {
      if (!bAltStat)
      {
         // check UNC path format
         char  psep    = pszName[0];
         char *pszHost = pszName+2;
         char *pszRoot = strchr(pszHost, psep);
         if (!pszRoot) return -1; // wrong format
         pszRoot++;
         char *pszSub  = strchr(pszRoot, psep);
         if (pszSub)
            break; // not top level, fall through
      }
      mtklog(("GetFileAttributesEx %s", pszName));
      WIN32_FILE_ATTRIBUTE_DATA oinf;
      if (!GetFileAttributesEx(pszName, GetFileExInfoStandard, &oinf))
         return -1;
      uint nattrib = oinf.dwFileAttributes;
      rbIsDirectory = (nattrib & FILE_ATTRIBUTE_DIRECTORY) ? 1 : 0;
      rbCanRead     = 1;
      rbCanWrite    = (nattrib & FILE_ATTRIBUTE_READONLY)  ? 0 : 1;
      // on old msvc, this may be 0xFFFF... for timestamps > 2038:
      rlFileSize    =  (((num)oinf.nFileSizeHigh) << 32)
                     | ((num)oinf.nFileSizeLow);
      rlFileTime    =  fileTimeToTimeT(&oinf.ftLastWriteTime);
      if (ppcatimes != 0) {
         ppcatimes[0] = fileTimeToTimeT(&oinf.ftCreationTime);
         ppcatimes[1] = fileTimeToTimeT(&oinf.ftLastAccessTime);
      }
      return 0;
   }
   while (0);
   #else
   uint nattrib = GetFileAttributesA(pszName);
   rbIsDirectory = (nattrib & FILE_ATTRIBUTE_DIRECTORY) ? 1 : 0;
   rbCanRead     = 1;
   rbCanWrite    = (nattrib & FILE_ATTRIBUTE_READONLY)  ? 0 : 1;
   #endif

   // using MSC specific 64-bit filesize and time stamp infos
   #ifdef SFK_W64
   struct __stat64 buf;
   if (mystat64(pszName, &buf))
      return -1;
   #else
   struct stat buf;
   if (stat(pszName, &buf))
      return -1;
   #endif

   rbIsDirectory = (buf.st_mode & _S_IFDIR ) ? 1 : 0;
   rbCanRead     = (buf.st_mode & _S_IREAD ) ? 1 : 0;
   rbCanWrite    = (buf.st_mode & _S_IWRITE) ? 1 : 0;
   // on old msvc, this may be 0xFFFF... for timestamps > 2038.
   // diff msvc14 vs. msvc7:
   rlFileTime    =  buf.st_mtime;
   rlFileSize    =  buf.st_size;
   if (ppcatimes != 0) {
      ppcatimes[0] = buf.st_ctime;
      ppcatimes[1] = buf.st_atime;
   }
   if (prawstat) {
      if (nrawstatmax < sizeof(buf))
         return 9+perr("internal #1090: statbuf too small\n");
      memcpy(prawstat, &buf, sizeof(buf));
   }
   return 0;

   #else

   // generic linux 64-bit stat
   struct stat64 buf;
   if (stat64(pszName, &buf))
      return -1;
   rbIsDirectory = (buf.st_mode & _S_IFDIR ) ? 1 : 0;
   rlFileTime    =  buf.st_mtime;
   rlFileSize    =  buf.st_size;
   rbCanRead     = (buf.st_mode & _S_IREAD ) ? 1 : 0;
   rbCanWrite    = (buf.st_mode & _S_IWRITE) ? 1 : 0;
   if (ppcatimes != 0) {
      ppcatimes[0] = buf.st_ctime;
      ppcatimes[1] = buf.st_atime;
   }
   if (prawstat) {
      if (nrawstatmax < (int)sizeof(buf))
         return 9+perr("internal #1090: statbuf too small\n");
      memcpy(prawstat, &buf, sizeof(buf));
   }
   return 0;

   #endif
}

num getFileSize(char *pszName)
{
   int bIsDir    = 0;
   int bCanRead  = 1;
   int bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize))
      return -1;
   return nFileSize;
}

num getFileSizeSeek(char *pszName)
{
   FILE *fin = fopen(pszName, "rb");
   if (!fin) return -1;

   #ifdef SFK_W64
   if (_fseeki64(fin, 0, SEEK_END))
   #else
   if (fseek(fin, 0, SEEK_END))
   #endif
   {
      fclose(fin);
      return -1; 
   }

   #ifdef SFK_W64
   num npos = (num)_ftelli64(fin);
   #else
   num npos = (num)ftell(fin);
   #endif

   fclose(fin);

   return npos;
}

num getFileTime(char *pszName)
{
   int bIsDir    = 0;
   int bCanRead  = 1;
   int bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize))
      return 0;
   return nFileTime;
}

int mySetFileTime(char *pszFile, num nTime)
{
   FileStat ofs;
   if (ofs.readFrom(pszFile)) {
      pinf("cannot read file time: %s\n", pszFile);
      if (nTime)
         return 9;
   } else {
      if (nTime) {
         ofs.src.nMTime = nTime;
         ofs.src.nCTime = nTime;
         #ifdef _WIN32
         ofs.src.nHaveWFT = 0;
         #endif
      }
      ofs.writeTo(pszFile, __LINE__, 1); // 1: write just time
   }

   return 0;
}

// get file age in seconds
num getFileAge(char *pszName)
{
   num nFileTime = getFileTime(pszName);
   // printf("filetime: %s\n",numtoa(nFileTime));
   num nNow = getSystemTime();
   // printf("now is  : %s\n",numtoa(nNow));
   num nAge = nNow - nFileTime;
   return nAge;
}

bool canWriteFile(char *pszName, bool bTryCreate)
{
   int bIsDir    = 0;
   int bCanRead  = 0;
   int bCanWrite = 0;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (!getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize)) {
      return bCanWrite ? 1 : 0;
   }
   if (bTryCreate) {
      // file does not exist yet: try creation
      FILE *fout = fopen(pszName, "wb");
      if (!fout) return 0;
      fclose(fout);
      remove(pszName);
      return 1;
   }
   return 1;
}

// uses szLineBuf.
int getFileSystemInfoRaw(
   char  *pszPath,          // e.g. "D:\\", "/home/user/"
   num   &nOutTotalBytes,   // total volume size
   num   &nOutFreeBytes,    // free bytes usable for normal users
   char  *pszOutFSName,     // file system name buffer
   int    nOutFSNMaxSize,   // size of this buffer
   char  *pszOutVolID,      // volume name and serial, if any
   int    nOutVolIDMaxSize, // size of this buffer
   uint  &rOutVolID         // numeric volume id
   )
{
   nOutTotalBytes  = -1;
   nOutFreeBytes   = -1;
   pszOutFSName[0] = '\0';
   pszOutVolID[0]  = '\0';
   rOutVolID       =  0;

   #ifdef _WIN32

   #ifdef WINFULL
   char  szVolName[200];
   DWORD nVolSerNum = 0;
   DWORD nMaxFNLen  = 0;
   DWORD nFSFlags   = 0;

   if (!GetVolumeInformation(
      pszPath,
      szVolName, sizeof(szVolName)-10,
      &nVolSerNum, &nMaxFNLen, &nFSFlags,
      pszOutFSName, nOutFSNMaxSize
      ))
      return 9+perr("unable to get volume information for %s\n", pszPath);

   szVolName[sizeof(szVolName)-10] = '\0';
   sprintf(szLineBuf, "%08lX %s", nVolSerNum, szVolName);
   mystrcopy(pszOutVolID, szLineBuf, nOutVolIDMaxSize);

   rOutVolID = nVolSerNum;

   ULARGE_INTEGER nFreeCaller;
   ULARGE_INTEGER nTotalBytes;
   ULARGE_INTEGER nFreeTotal;
   if (!GetDiskFreeSpaceEx(
      pszPath,
      &nFreeCaller, &nTotalBytes, &nFreeTotal
      ))
      return 9+perr("unable to get free space of %s\n", pszPath);

   nOutTotalBytes = nTotalBytes.QuadPart;
   nOutFreeBytes  = nFreeCaller.QuadPart;
 
   // sprintf(szLineBuf, "VOL: %X for %s",nVolSerNum,pszPath);
   // MessageBox(0, szLineBuf, "info", MB_OK);
   #endif

   return 0;

   #else

   // #include <sys/statvfs.h>
   struct statvfs64 oinf;
   if (statvfs64(pszPath, &oinf))
      return 9+perr("unable to get free space of %s\n", pszPath);

   // unsigned int f_bsize   - preferred filesystem blocksize.
   // unsigned int f_frsize  - fundamental filesystem blocksize (if supported)
   // fsblkcnt_t f_blocks     - total number of blocks on the filesystem, in units of f_frsize.
   // fsblkcnt_t f_bfree      - total number of free blocks.
   // fsblkcnt_t f_bavail     - number of free blocks available to a nonsuperuser.
   // fsfilcnt_t f_files      - total number of file nodes (inodes).
   // fsfilcnt_t f_ffree      - total number of free file nodes.
   // fsfilcnt_t f_favail     - number of inodes available to a nonsuperuser.
   // unsigned int f_fsid    - filesystem ID (dev for now).
   // char f_basetype[16]     - type of the target filesystem, as a null-terminated string.
   // unsigned int f_flag    - bitmask of flags; the function can set these flags:
   //    ST_RDONLY -- read-only filesystem.
   //    ST_NOSUID -- the filesystem doesn't support setuid/setgid semantics.
   // unsigned int f_namemax - maximum filename length.

   // not with linux:
   // mystrcopy(pszOutFSName, oinf.f_basetype, nOutFSNMaxSize);
   pszOutFSName[0] = '\0';

   num nTotalBytes = (num)oinf.f_blocks * (num)oinf.f_frsize;
   num nFreeBytes  = (num)oinf.f_bavail * (num)oinf.f_frsize;

   nOutTotalBytes = nTotalBytes;
   nOutFreeBytes  = nFreeBytes;

   return 0;

   #endif
}

int getFileSystemInfo(
   char  *pszPath,          // e.g. "D:\\", "/home/user/"
   num   &nOutTotalBytes,   // total volume size
   num   &nOutFreeBytes,    // free bytes usable for normal users
   char  *pszOutFSName,     // file system name buffer
   int    nOutFSNMaxSize,   // size of this buffer
   char  *pszOutVolID,      // volume name and serial, if any
   int    nOutVolIDMaxSize, // size of this buffer
   uint  &rOutVolID         // numeric volume id
   )
{
   char szPath[SFK_MAX_PATH+10];
   strcopy(szPath, (char*)pszPath);

   #ifdef _WIN32

   // need a root dir path like "C:"
   if (szPath[1] == ':') {
      // there is a C:, or D:, etc.
      szPath[2] = '\\';
      szPath[3] = '\0';
   } else {
      // a relative path: check for invalids
      if (!strncmp(szPath, "\\\\", 2))
         return -1;
      if (!strncmp(szPath, "//", 2))
         return -1;
      // find out our drive
      if (getcwd(szPath,SFK_MAX_PATH)) { }
      if (szPath[1] != ':')
         return -1;
      // we're on C:, or D:, etc.
      szPath[2] = '\\';
      szPath[3] = '\0';
   }

   #else

   // reduce /media/small/dummydir/whatever.txt
   // to the first existing directory
   while (1)
   {
      struct stat oinf;
      if (!stat(szPath, &oinf))
         break; // exists

      char *psz = strrchr(szPath, '/');
      if (!psz)
         return -1; // failed to reduce

      *psz = '\0';
      // and retry on next higher level
   }

   #endif

   return getFileSystemInfoRaw(szPath,
      nOutTotalBytes,
      nOutFreeBytes,
      pszOutFSName,
      nOutFSNMaxSize,
      pszOutVolID,
      nOutVolIDMaxSize,
      rOutVolID
      );
}

num getFreeSpace(char *pszPath)
{
   num nTotal=0, nFree=0;
   char szFSName[200];
   char szVolID[200];
   uint nVolID=0;
 
   if (getFileSystemInfo(pszPath, nTotal, nFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10, nVolID))
      return -1;

   return nFree;
}

// result is always non NULL but can be empty string.
char *timeAsString(num nTime, int iMode, bool bUTC)
{
   static char szTimeStrBuf[200];

   // nTime may be 0xFFFF... in case of times > 2038.

   #ifdef SFK_VC14
   // msvc14 strftime crashes on negative times
   if (nTime < 0)
      return str("");
   #endif

   struct tm *pLocTime = 0;
   mytime_t nTime2 = (mytime_t)nTime;

   if (bUTC || cs.useutc) {
      pLocTime = mygmtime(&nTime2);    // may be NULL
   } else {
      pLocTime = mylocaltime(&nTime2); // may be NULL
   }

   bool bFlat    = (iMode & 1) ? 1 : 0;
   bool bFlatSep = (iMode & 2) ? 1 : 0;
   bool bTabSep  = (iMode & 4) ? 1 : 0;

   // size_t strftime( char *strDest, size_t maxsize, const char *format, const struct tm *timeptr );
   // 20110101 120101
   // 2011-01-01 12:01:01
   // 01234567890
 
   struct tm oNullTime;
   mclear(oNullTime);
 
   if (!pLocTime)
      pLocTime = &oNullTime;
 
   szTimeStrBuf[0] = '\0';

   if (bFlat) {
      if (bFlatSep) {
         strftime(szTimeStrBuf, sizeof(szTimeStrBuf)-10, "%Y%m%d %H%M%S", pLocTime);
         szTimeStrBuf[8] = bTabSep ? '\t' : ' ';
      } else {
         strftime(szTimeStrBuf, sizeof(szTimeStrBuf)-10, "%Y%m%d%H%M%S", pLocTime);
      }
   } else {
      strftime(szTimeStrBuf, sizeof(szTimeStrBuf)-10, "%Y-%m-%d %H:%M:%S", pLocTime);
      szTimeStrBuf[10] = bTabSep ? '\t' : ' ';
   }

   return szTimeStrBuf;
}

static const char *pszGlblMonths[] = {
   "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
};

bool tryGetRelTime(cchar *psz, num &nRetTime)
{
   bool brc = false;

   // get local time (zone)
   mytime_t now = mytime(NULL);
   struct tm *tm = 0;
   tm = mylocaltime(&now);
   tm->tm_isdst = -1;

   int nlen = strlen(psz);

   if (!strcmp(psz, "now")) {
      brc = true;
   }
   else
   if (!strcmp(psz, "today")) {
      tm->tm_hour = 0;
      tm->tm_min  = 0;
      tm->tm_sec  = 0;
      brc = true;
   }
   else
   if (!strcmp(psz, "tomonth")) {
      tm->tm_hour = 0;
      tm->tm_min  = 0;
      tm->tm_sec  = 0;
      tm->tm_wday = 0;  // 0..6
      tm->tm_mday = 1;  // 1..31
      brc = true;
   }
   else
   if (!strcmp(psz, "toyear")) {
      tm->tm_hour = 0;
      tm->tm_min  = 0;
      tm->tm_sec  = 0;
      tm->tm_wday = 0;  // 0..6
      tm->tm_mday = 1;  // 1..31
      tm->tm_yday = 0;  // 0..365
      tm->tm_mon  = 0;  // 0..11
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 'd') {
      mytime_t pre = now - atol(psz) * 3600 * 24;
      tm = mylocaltime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 'h') {
      mytime_t pre = now - atol(psz) * 3600;
      tm = mylocaltime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 'm') {
      mytime_t pre = now - atol(psz) * 60;
      tm = mylocaltime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 's') {
      mytime_t pre = now - atol(psz);
      tm = mylocaltime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }

   mytime_t nTime = mymktime(tm);
   if (!nTime) { perr("cannot calc time: %s\n", psz); return 0; }
   num nTime2 = (num)nTime;
   if (nTime2 <= 0) { perr("cannot calc time: %s\n", psz); return 0; }

   nRetTime = nTime2;
   return brc;
}

num localTimeZoneOffset(mytime_t t1)
{
   struct tm *ptm = mygmtime(&t1);

   // we want pure tzo without dst
   ptm->tm_isdst = 0;

   // mktime expects LOCAL time.
   mytime_t t2 = mymktime(ptm);
   // so now t2 differs from t1.

   num t3 = (num)difftime(t1, t2);

   return t3;
}

int timeFromString(char *pszin, num &nRetTime, bool bsilent, bool bUTC)
{
   char *psz = pszin;

   // get local time
   mytime_t now = mytime(NULL);

   struct tm *tm = 0;
   tm = mylocaltime(&now);

   // mktime below must figure out DST automatically
   tm->tm_isdst = -1;

   // accept formats:
   // 12345678901234567890123456789012345678901234567890
   // 01 Dec 2008 01:01:25 +0200 GMT - 30 chars, FAILS on wrong locale
   // 01 Dec 2008 01:01:25 +0100 - 26 chars, FAILS on wrong locale
   // 01 Dec 2008 01:01:25 GMT   - 24 chars, FAILS on wrong locale
   // 2006-11-21 12:49:36  - 19 chars
   // 2006-11-21           - 10 chars
   // 20061121124936       - 14 chars
   // 20061121             - 08 chars
   // Sep 28 2006          - 11 chars
   // Sep 28 14:37         - 12 chars
   uint nyear=0,nmon=0,nday=0,nhour=0,nmin=0,nsec=0;
   int nslen = strlen(psz);
   int lrc = 0;
   if (nslen == 24 || nslen == 26 || nslen == 30) {
      // TODO: so far, "GMT" or "+0100" postfixes are ignored.
      nday = atol(psz);
      psz += 3;
      char *pszMon = psz;
      for (nmon=0; nmon<12; nmon++)
         if (!strncmp(pszMon, pszGlblMonths[nmon], 3))
            break;
      if (nmon >= 12) {
         if (!bsilent && !cs.nonotes)
            pinf("unknown date/time locale: %s\n", psz);
         return 9;
      }
      psz += 4;
      lrc = sscanf(psz, "%4u %2u:%2u:%2u", &nyear, &nhour, &nmin, &nsec);
      if (lrc != 4) {
         if (!bsilent && !cs.nonotes)
            pinf("wrong date/time format.0: %s\n", psz);
         return 9;
      }
      nmon++; // ONE based months
   }
   else
   if (nslen == 19) {
      lrc = sscanf(psz, "%4u-%2u-%2u %2u:%2u:%2u", &nyear, &nmon, &nday, &nhour, &nmin, &nsec);
      if (lrc != 6) return 9+perr("wrong date/time format.1: %s\n", psz);
   }
   else
   if (nslen == 14) {
      lrc = sscanf(psz, "%4u%2u%2u%2u%2u%2u", &nyear, &nmon, &nday, &nhour, &nmin, &nsec);
      if (lrc != 6) return 9+perr("wrong date/time format.2: %s\n", psz);
   }
   else
   if (nslen == 12) {
      char *pszMon = psz;
      for (nmon=0; nmon<12; nmon++)
         if (!strncmp(pszMon, pszGlblMonths[nmon], 3))
            break;
      if (nmon >= 12) return 9+perr("wrong date/time format.3: %s\n", psz);
      psz += 4;
      lrc = sscanf(psz, "%2u %2u:%2u", &nday, &nhour, &nmin);
      if (lrc == 3) {
         // copy year from current time:
         nyear = tm->tm_year;
         if (nyear < 1970)
            nyear = nyear - 100 + 2000;   // "108" -> "2008"
      } else {
         // retry on "29  2007" with TWO blanks:
         lrc = sscanf(psz, "%2u  %4u", &nday, &nyear);
         if (lrc != 2) return 9+perr("wrong date/time format.4: %s\n", psz);
      }
      nmon++; // ONE based months
   }
   else
   if (nslen == 11) {
      char *pszMon = psz;
      for (nmon=0; nmon<12; nmon++)
         if (!strncmp(pszMon, pszGlblMonths[nmon], 3))
            break;
      if (nmon >= 12) return 9+perr("wrong date/time format.5: %s\n", psz);
      psz += 4;
      lrc = sscanf(psz, "%2u %4u", &nday, &nyear);
      if (lrc != 2) return 9+perr("wrong date/time format.6: %s\n", psz);
      nmon++; // ONE based months
   }
   else
   if (nslen == 10) {
      lrc = sscanf(psz, "%4u-%2u-%2u", &nyear, &nmon, &nday);
      if (lrc != 3) return 9+perr("wrong date format.7: %s\n", psz);
   }
   else
   if (nslen == 8) {
      lrc = sscanf(psz, "%4u%2u%2u", &nyear, &nmon, &nday);
      if (lrc != 3) return 9+perr("wrong date format.8: %s\n", psz);
   }
   else
      return 9+perr("wrong date and/or time format.9: \"%s\"\n", psz);

   if (nyear < 1970) return 9+perr("unexpected year: %u\n", nyear);
   if (nmon < 1 || nmon > 12) return 9+perr("unexpected month: %u in \"%s\" %d\n", nmon, pszin, nslen);
   if (nday < 1 || nday > 31) return 9+perr("unexpected day: %u\n", nday);
   if (nhour > 23) return 9+perr("unexpected hour: %u\n", nhour);
   if (nmin  > 59) return 9+perr("unexpected minute: %u\n", nmin);
   if (nsec  > 59) return 9+perr("unexpected second: %u\n", nsec);

   // adjust values
   nyear -= 1900;
   nmon--; // mktime uses ZERO BASED months

   // printf("] %u-%u-%u %u:%u:%u\n",nyear,nmon,nday,nhour,nmin,nsec);

   tm->tm_year = nyear;
   tm->tm_mon  = nmon;
   tm->tm_mday = nday;
   tm->tm_hour = nhour;
   tm->tm_min  = nmin;
   tm->tm_sec  = nsec;

   bool bNearEpoch = 0;
   if (nyear == 70 && nmon == 0 && nday == 1)
        bNearEpoch = 1;

   // mktime USES LOCAL TIME ONLY.
   // mkgmtime is no standard and available nowhere.
   mytime_t nTime = mymktime(tm);

   // if the string was UTC then nTime is now TOO SMALL
   // as the zone offset and DST was subtracted.
   // so if we need the UTC value we MUST do this:
   if (bUTC) nTime += localTimeZoneOffset(nTime);

   num nTime2 = (num)nTime;
   if (     nTime2 < 0
       || (!bNearEpoch && (nTime2 == 0))
      )
      return 9+perr("invalid date/time: %s (%d %d %d)\n", psz, nyear, nmon, nday);

   // char *psz1 = timeAsString(nTime2);
   // printf("] %s\n", psz1);

   nRetTime = nTime2;
   return 0;
}

char getYNAchar()
{
   while (1) {
      int c1 = getchar();
      if (c1=='\r' || c1=='\n')
         continue;
      return c1;
   }
}

// sizefromstr
num numFromSizeStr(char *psz, cchar *pszLoudInfo, bool bRelaxed)
{
   int nLen = strlen(psz);
   if (nLen >= 1) {
      num lNum = myatonum(psz);
      if (!strncmp(psz, "0x", 2))
         return lNum; // hex: always byte values
      char cPostFix = psz[nLen-1];
      switch (cPostFix) {
         case 'b': return lNum;
         case 'k': return lNum * 1000;
         case 'K': return lNum * 1024;
         case 'm': return lNum * 1000000;
         case 'M': return lNum * 1048576;
         case 'g': return lNum * 1000000000;
         case 'G': return lNum * 1073741824;
         default :
            if (bRelaxed)
               return lNum;
            if (cPostFix >= '0' && cPostFix <= '9')
               return lNum; // no postfix at all: assume bytes
      }
   }
   if (pszLoudInfo) {
      perr("unexpected %s value: %s", pszLoudInfo, psz);
      pinf("supply a value like 1000 500k 100m 5M [k=kbyte,m=mbyte]\n");
   }
   return -1;
}

FileStat::FileStat()
{
   reset();
}

int FileStat::setFilename(char *psz)
{
   strcopy(szClFileName, psz);
   return 0;
}

char *FileStat::filename( )
{
   return szClFileName;
}

int FileStat::copyFrom(FileStat &osrc)
{
   memcpy(this, &osrc, sizeof(*this));
   return 0;
}

num FileStat::getWinTime() {
   num nval = 0;
   #ifdef _WIN32
   if (sizeof(nval) == sizeof(src.ftMTime))
      memcpy(&nval, &src.ftMTime, sizeof(nval));
   #endif
   return nval;
}

char *FileStat::attrStr() {
   memset(szClAttrStr, 0, sizeof(szClAttrStr));
   //                   01234
   strcpy(szClAttrStr, "---- ");
   if (src.bIsReadable)  szClAttrStr[0] = 'a';
   if (src.bIsWriteable) szClAttrStr[1] = 'w';
   #ifdef _WIN32
   // if (src.nAttribs & FILE_ATTRIBUTE_READONLY)   szClAttrStr[0] = 'R';
   if (src.nAttribs & FILE_ATTRIBUTE_HIDDEN)     szClAttrStr[2] = 'h';
   if (src.nAttribs & FILE_ATTRIBUTE_SYSTEM)     szClAttrStr[3] = 's';
   // if (src.nAttribs & FILE_ATTRIBUTE_ARCHIVE)    szClAttrStr[4] = 'a';
   if (src.nAttribs) szClAttrStr[4] = '-';
   #endif
   return szClAttrStr;
}

uchar *FileStat::marshal(int &nRetSize) {
   nRetSize = sizeof(src);
   return (uchar*)&src;
}

int FileStat::setFrom(uchar *pBuf, int nBufSize) {
   if (nBufSize != sizeof(src))
      return 9+perr("internal 612112005\n");
   memcpy(&src, pBuf, sizeof(src));
   return 0;
}

int FileStat::dumpTimeDiff(FileStat &rdst)
{
   num nsec = src.nMTime - rdst.src.nMTime;
   printf("diff: mtime %s sec ",numtoa(nsec));
   num nhours = nsec / 3600;
   printf("(= %s hours)",numtoa(nhours));

   #ifdef _WIN32
   num nSrcWFT = 0;
   num nDstWFT = 0;
   if (sizeof(nSrcWFT) == sizeof(src.ftMTime)) {
      memcpy(&nSrcWFT, &src.ftMTime, sizeof(nSrcWFT));
      memcpy(&nDstWFT, &rdst.src.ftMTime, sizeof(nDstWFT));
      num nxnano = nSrcWFT - nDstWFT;
      num nmsec  = nxnano / 10;
      num nwsec  = nmsec / 1000000;
      num nwhours = nwsec / 3600;
      printf(", wft mtime %s usec*10 ", numtoa(nxnano));
      printf(" (= %s sec, ", numtoa(nwsec));
      printf("or %s hours)",numtoa(nwhours));
   }
   #endif

   printf("\n");

   nsec = src.nCTime - rdst.src.nCTime;
   printf("      ctime %s sec ",numtoa(nsec));
   nhours = nsec / 3600;
   printf("(= %s hours)",numtoa(nhours));

   #ifdef _WIN32
   if (sizeof(nSrcWFT) == sizeof(src.ftCTime)) {
      memcpy(&nSrcWFT, &src.ftCTime, sizeof(nSrcWFT));
      memcpy(&nDstWFT, &rdst.src.ftCTime, sizeof(nDstWFT));
      num nxnano = nSrcWFT - nDstWFT;
      num nmsec  = nxnano / 10;
      num nwsec  = nmsec / 1000000;
      num nwhours = nwsec / 3600;
      printf(", wft ctime %s usec*10 ", numtoa(nxnano));
      printf(" (= %s sec, ", numtoa(nwsec));
      printf("or %s hours)",numtoa(nwhours));
   }
   #endif

   printf("\n");

   return 0;
}

int FileStat::dump()
{
   char szBuf1[100],szBuf2[100],szBuf3[100];
   char szHead[300];
 
   uint nutc = (cs.timemask & 1024);

   if (cs.timemask & 512)
   {
      dumpSub(0, 16+512+nutc, szBuf1, sizeof(szBuf1));
      dumpSub(1, 16+512+nutc, szBuf2, sizeof(szBuf2));
      #ifdef _WIN32
      dumpSub(2, 16+512+nutc, szBuf3, sizeof(szBuf3));
      #endif
 
      cchar *pprem = cs.tabform ? "":"mtime ";
      cchar *pprea = cs.tabform ? "\t":", atime ";
      cchar *pprec = cs.tabform ? "\t":", ctime ";
      cchar *ppos  = cs.tabform ? "\t":", ";

      if (!cs.tabform && !(cs.timemask & 8)) {
         pprem = "";
         pprea = "";
         pprec = "";
         ppos  = " ";
      }

      szHead[0] = '\0';

      if (cs.timemask & 1) { strcat(szHead,pprem); strcat(szHead,szBuf1); }
      if (cs.timemask & 2) { strcat(szHead,pprea); strcat(szHead,szBuf2); }
      #ifdef _WIN32
      if (cs.timemask & 4) { strcat(szHead,pprec); strcat(szHead,szBuf3); }
      #endif

      if (cs.timemask & 256)
         chain.print("%s%s%s\n", szHead, ppos, szClFileName);
      else
         chain.print("%s\n", szHead);
   }
   else
   {
      if (cs.timemask & 1) dumpSub(0, cs.timemask, 0, 0);
      if (cs.timemask & 2) dumpSub(1, cs.timemask, 0, 0);
      #ifdef _WIN32
      if (cs.timemask & 4) dumpSub(2, cs.timemask, 0, 0);
      #endif
   }

   return 0;
}

int FileStat::dumpSub(int nRow, uint nmask, char *pszOut, int iMaxOut)
{
   char szLocDate[100]; szLocDate[0] = '\0';
   char szLocTime[100]; szLocTime[0] = '\0';
   char szUTCTime[100]; szUTCTime[0] = '\0';
   char szUXTime [100]; szUXTime[0]  = '\0';
   char szWFTTime[100]; szWFTTime[0] = '\0';
   char szBuf[200]; szBuf[0] = '\0';

   num nTime = 0;
   cchar *pszPrefix = "";

   switch (nRow)
   {
      case 0: nTime = src.nMTime; pszPrefix = "mtime"; break;
      case 1: nTime = src.nATime; pszPrefix = "atime"; break;
      case 2: nTime = src.nCTime; pszPrefix = "ctime"; break;
   }

   mytime_t tTime = (mytime_t)nTime;

   struct tm *pltime = 0;

   if (nmask & 1024)
      pltime = mygmtime(&tTime);
   else
      pltime = mylocaltime(&tTime);

   if (pltime) {
      if (cs.flatTime) {
         strftime(szLocDate, sizeof(szLocDate)-10, "%Y%m%d", pltime);
         strftime(szLocTime, sizeof(szLocTime)-10, "%H%M%S", pltime);
      } else {
         strftime(szLocDate, sizeof(szLocDate)-10, "%Y-%m-%d", pltime);
         strftime(szLocTime, sizeof(szLocTime)-10, "%H:%M:%S", pltime);
      }
   }

   struct tm *pgtime = mygmtime(&tTime);
   if (pgtime) {
      if (cs.flatTime)
         strftime(szUTCTime, sizeof(szUTCTime)-10, "%H%M%S", pgtime);
      else
         strftime(szUTCTime, sizeof(szUTCTime)-10, "%H:%M:%S", pgtime);
   }

   numtoa(nTime, 10, szUXTime);

   #ifdef _WIN32
   num nWinFileTime = 0;
   bool bCopyDone = 0;
   switch (nRow) {
      case 0:
         if (sizeof(nWinFileTime) == sizeof(src.ftMTime)) {
            memcpy(&nWinFileTime, &src.ftMTime, sizeof(nWinFileTime));
            bCopyDone = 1;
         }
         break;
      case 1:
         if (sizeof(nWinFileTime) == sizeof(src.ftATime)) {
            memcpy(&nWinFileTime, &src.ftATime, sizeof(nWinFileTime));
            bCopyDone = 1;
         }
         break;
      case 2:
         if (sizeof(nWinFileTime) == sizeof(src.ftCTime)) {
            memcpy(&nWinFileTime, &src.ftCTime, sizeof(nWinFileTime));
            bCopyDone = 1;
         }
         break;
   }
   if (bCopyDone)
      numtoa(nWinFileTime, 18, szWFTTime);
   #endif

   cchar *ppre = "";

   int nzones = 0;
   if (nmask &  16) nzones++;
   if (nmask &  32) nzones++;
   if (nmask &  64) nzones++;
   if (nmask & 128) nzones++;

   cchar *pwhite  = cs.tabform ? "\t":" ";
   cchar *pzon    = (nzones > 1) ? ", ":pwhite;
   cchar *pcon    = cs.tabform?"\t":pzon;
   cchar *ptwhite = (cs.flatTime >= 2) ? "":pwhite;

   if (nmask &   8) { mystrcatf(szBuf, sizeof(szBuf), "%s%s"    , pszPrefix, cs.tabform?"":": "); if (cs.tabform) ppre="\t"; }
   if (nmask &  16) { mystrcatf(szBuf, sizeof(szBuf), "%s%s%s%s", ppre, szLocDate, ptwhite, szLocTime); ppre=pcon; }
   if (nmask &  32) { mystrcatf(szBuf, sizeof(szBuf), "%s%s%s"  , ppre, szUTCTime, cs.tabform?"":" utc"  ); ppre=pcon; }
   if (nmask &  64) { mystrcatf(szBuf, sizeof(szBuf), "%s%s%s"  , ppre, szUXTime , cs.tabform?"":" sec"  ); ppre=pcon; }
   #ifdef _WIN32
   if (nmask & 128) { mystrcatf(szBuf, sizeof(szBuf), "%s%s%s"  , ppre, szWFTTime, cs.tabform?"":" wft"  ); ppre=pcon; }
   #endif
   if (nmask & 256) { mystrcatf(szBuf, sizeof(szBuf), "%s%s"    , ppre, szClFileName); ppre=pcon; }

   if (nmask & 512) {
      if (!pszOut)
         return 9;
      snprintf(pszOut, iMaxOut-10, "%s", szBuf);
   } else {
      chain.print("%s\n", szBuf);
   }

   return 0;
}

void FileStat::reset()
{
   memset(this, 0, sizeof(*this));
}

int FileStat::writeStat(int iTraceLine)
{
   if (!szClFileName[0])
      return 9+perr("missing stat filename, cannot write filetime (%d)", iTraceLine);

   if (src.nMTime <= 0)
      return 10+perr("missing stat data, cannot write filetime (%d)", iTraceLine);

   return writeTo(szClFileName, iTraceLine);
}

const char *FileStat::diffReason(int nReason)
{
   if (szClDiffReason[0])
      return szClDiffReason;

   switch (nReason) {
      case  0: return "none";
      case  8: return "newer, wft";
      case  7: return "time, wft";
      case  9: return "newer, uft";
      case 10: return "time, uft";
      case  1: return "size";
      case  3: return "isreadable";
      case  4: return "iswriteable";
      case  5: return "attributes";
   }
   return "unknown";
}

bool is3600Range(num n) {
   if (n >= 3598 && n <= 3602)
      return true;
   return false;
}

/*
   RC 1 ...  5: difference in attributes
   RC 7 ... 10: difference in time
*/
int FileStat::differs(FileStat &oref, bool bSameIfOlderSrc, bool *pSrcIsOlder)
{
   int nTimeState = 0; // 0: time is no reason to process

   szClDiffReason[0] = '\0';

   #ifdef _WIN32
   if (src.nHaveWFT && oref.src.nHaveWFT)
   {
      // compare windows filetime, to be safer on DST switches and time zones.
      // NOTE: files from FAT filesystems will also produce a pseudo wft
      // (calculated implicitely by the OS) that will still jump on DST.

      num nSrcMTime = 0;
      num nRefMTime = 0;
      memcpy(&nSrcMTime, &src.ftMTime, sizeof(nSrcMTime));
      memcpy(&nRefMTime, &oref.src.ftMTime, sizeof(nRefMTime));

      num nSrcSec   = fileTimeToTimeT(nSrcMTime);
      num nNowSec   = getSystemTime();
      num nAgeSec   = nNowSec - nSrcSec;
      int nAgeDays = (int)(nAgeSec / (24 * 3600));

      num ndif = (nSrcMTime - nRefMTime) / 10000000; // in seconds
      if (abs((int)ndif) < 3)
         nTimeState = 0; // time is no reason
      else
      if (bGlblIgnore3600 && is3600Range(abs((int)ndif)) && (nAgeDays > nGlblActiveFileAgeLimit))
      {
         nTimeState = 0; // dst jump difference
      }
      else
      if (bSameIfOlderSrc) {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %d [1]\n", ndif);
         if (ndif > 0) {
            sprintf(szClDiffReason, "newer, wft by %s sec", numtoa(ndif));
            nTimeState = 8; // src is newer, must process
         }
         if ((ndif < 0) && pSrcIsOlder) {
            if (is3600Range(abs((int)ndif)))
               *pSrcIsOlder = 2; // notice: probably older due to dst jump
            else
               *pSrcIsOlder = 1; // notice
         }
      } else {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %d [2]\n", ndif);
         if (nRefMTime != nSrcMTime) {
            sprintf(szClDiffReason, "time, wft by %s sec", numtoa(ndif));
            nTimeState = 7; // any time diff, must process
         }
         if ((ndif < 0) && pSrcIsOlder)
            *pSrcIsOlder = 1; // just a notice
      }
      // else fall through, time check passed
   }
   else
   #endif
   if (src.nMTime != oref.src.nMTime)
   {
      // a time difference: ignore below a threshold
      //   NTFS : 100 nanoseconds resolution
      //   Linux:   1 second resolution
      //   FAT32:   2 seconds resolution
      // therefore all differences below 3 seconds are ignored.

      num nSrcSec   = src.nMTime;
      num nNowSec   = getSystemTime();
      num nAgeSec   = nNowSec - nSrcSec;
      int nAgeDays = (int)(nAgeSec / (24 * 3600));

      num ndif = src.nMTime - oref.src.nMTime;
      if (abs((int)ndif) < 3)
         nTimeState = 0; // time is no reason
      else
      if (bGlblIgnore3600 && is3600Range(abs((int)ndif)) && (nAgeDays > nGlblActiveFileAgeLimit))
      {
         nTimeState = 0; // dst jump difference
      }
      else
      if (bSameIfOlderSrc) {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %d [3]\n", (int)ndif);
         if (ndif > 0) {
            sprintf(szClDiffReason, "newer, uft by %s sec", numtoa(ndif));
            nTimeState = 9; // src is newer, must process
         }
         if ((ndif < 0) && pSrcIsOlder) {
            if (is3600Range(abs((int)ndif)))
               *pSrcIsOlder = 2; // notice: probably older due to dst jump
            else
               *pSrcIsOlder = 1; // notice
         }
      }
      else {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %d [4]\n", (int)ndif);
         sprintf(szClDiffReason, "time, uft by %s sec", numtoa(ndif));
         nTimeState = 10; // any time diff, must process
         if ((ndif < 0) && pSrcIsOlder)
            *pSrcIsOlder = 1; // just a notice
      }
   }

   // with "sameifolder", processing is based only on timestamp.
   if (bSameIfOlderSrc)
   {
      // if time is equal, don't process , no matter if size etc. differs!
      // if src  is older, don't process , no matter if size etc. differs!
      // if src  is newer, always process, no matter if size etc. is equal!
      return nTimeState;
   }

   // else process on size or attribute difference.
   if (src.bIsDir != oref.src.bIsDir   // sfk1972 filestat mark dir vs file diff as size
       || (src.bIsDir == 0             // sfk1972 filestat ignore 'size' diff on folder objects,
           && src.nSize != oref.src.nSize)   // as these cannot be cloned, across disks.
      )
   {
      if (cs.verbose > 1)
         printf("[size differs, %u %u dir=%u/%u]\n",(uint)src.nSize,(uint)oref.src.nSize,
            src.bIsDir, oref.src.bIsDir);
      return 1;
   }

   if (src.bIsReadable  != oref.src.bIsReadable ) return 3;
   if (src.bIsWriteable != oref.src.bIsWriteable) return 4;

   #ifdef _WIN32
   if (   (src.nAttribs      & WINFILE_ATTRIB_MASK)
       != (oref.src.nAttribs & WINFILE_ATTRIB_MASK)
      )
   {
      if (cs.verbose > 1)
         printf("[win_attributes differ, %x %x]\n",src.nAttribs,oref.src.nAttribs);
      return 5;
   } else {
      if (cs.verbose > 2)
         printf("[win_attributes match, %x %x]\n",src.nAttribs,oref.src.nAttribs);
   }
   #endif

   return nTimeState;
}

// no vname support so far, due to getFileStat
int FileStat::readFrom(char *pszSrcFile, bool bWithFSInfo, bool bSilent)
{
   reset();

   sfkstat_t ostat;

   szClFileName[0] = '\0'; // safety

   num aExtTimes[2];
   mclear(aExtTimes);
   if (getFileStat(pszSrcFile, src.bIsDir, src.bIsReadable, src.bIsWriteable, src.nMTime, src.nSize, aExtTimes, &ostat, sizeof(ostat)))
      return 10;

   strcopy(szClFileName, pszSrcFile);

   src.nCTime = aExtTimes[0];
   src.nATime = aExtTimes[1];

   #if (_MSC_VER >= 1900)
   src.bIsUTCTime = 1; // FIX sfk197 vc14
   #else
   src.bIsUTCTime = 0;
   #endif

   num   nTotalBytes = 0;
   num   nFreeBytes  = 0;

   if (bWithFSInfo)
   {
      // must extract path from pszSrcFile. if there is none, use ".".
      mystrcopy(szClSrcPath, pszSrcFile, sizeof(szClSrcPath)-10);
 
      // turn the/dir into the/dir/
      if (src.bIsDir && strlen(szClSrcPath)>0)
         if (szClSrcPath[strlen(szClSrcPath)-1] != glblPathChar)
            strcat(szClSrcPath,glblPathStr);
 
      #ifdef _WIN32
      // windows only: if path starts with c: ...
      if (strlen(szClSrcPath) >= 2 && szClSrcPath[1] == ':') {
         // then reduce c:\whatever to c:\, extend c: to c:/
         szClSrcPath[2] = glblPathChar;
         szClSrcPath[3] = '\0';
      }
      else
      if (!strncmp(szClSrcPath, "\\\\", 2)) {
         // network path
      }
      else {
         // relative path: reduce to "\\", should be same volume.
         // will probably NOT work with LINKS.
         strcpy(szClSrcPath, "\\");
      }
      #endif
 
      // try for x:\thefile, \thefile, the\path\file
      char *psz1 = strrchr(szClSrcPath, glblPathChar);
      if (psz1 && (psz1 > szClSrcPath)) {
         psz1++;
         *psz1 = '\0';
      } else {
         #ifdef _WIN32
         // try for x:thefile
         psz1 = strchr(szClSrcPath, ':');
         if (psz1 && (psz1 > szClSrcPath)) {
            // change x:thefile to x:/
            psz1++;
            *psz1++ = glblPathChar;
            *psz1   = '\0';
         }
         else
            strcpy(szClSrcPath, "\\");
         #else
         // TODO: use /, ./ or "." with linux?
         strcpy(szClSrcPath, ".");
         #endif
      }

      if (cs.debug)
         printf("filestat: \"%s\" => \"%s\"\n",pszSrcFile,szClSrcPath);

      uint nVolID = 0;
      if (getFileSystemInfo(szClSrcPath, nTotalBytes, nFreeBytes,
         szClSrcFSName, sizeof(szClSrcFSName)-10,
         szClSrcVolID , sizeof(szClSrcVolID)-10,
         nVolID
         ))
         return 11;
 
      #ifdef _WIN32
      if (cs.debug)
         printf("\"%s\" => %s, %s\n",szClSrcPath, szClSrcFSName, szClSrcVolID);
      #endif
   }

   #ifdef _WIN32

   #ifdef WINFULL
   WIN32_FILE_ATTRIBUTE_DATA oinf;
   BOOL bok2 = 0;
   if (vname()) {
      sfkname oname(pszSrcFile);
      bok2 = GetFileAttributesExW((const wchar_t *)oname.wname(), GetFileExInfoStandard, &oinf);
   } else {
      bok2 = GetFileAttributesEx(pszSrcFile, GetFileExInfoStandard, &oinf);
   }
   if (!bok2) {
      src.nAttribs = 0;
      if (!bSilent)
         perr("cannot read attributes: %s (rc %u)\n", pszSrcFile, GetLastError());
      return 12;
   }
   src.nAttribs = oinf.dwFileAttributes;
   // => see WINFILE_ATTRIB_MASK
   // ftCreationTime; ftLastAccessTime; ftLastWriteTime
   memcpy(&src.ftMTime, &oinf.ftLastWriteTime , sizeof(src.ftMTime));
   memcpy(&src.ftCTime, &oinf.ftCreationTime  , sizeof(src.ftCTime));
   memcpy(&src.ftATime, &oinf.ftLastAccessTime, sizeof(src.ftATime));
   src.nHaveWFT = 2;
   #else
   src.nAttribs = GetFileAttributes(pszSrcFile);
   #endif

   #else

   // src.bIsReadable, src.bIsWriteable
   src.nAttribs = (uint)ostat.st_mode;

   #endif

   return 0;
}

num calcSumTime(num nRawTime, int nTimeDiff, char *pszInfo)
{
   // does RawTime point into a summertime section?
   mytime_t ntmod = (mytime_t)nRawTime;
   tm *ptmod = mylocaltime(&ntmod);
   if (ptmod && ptmod->tm_isdst) {
      // YES: change by one hour
      nRawTime += (num)nTimeDiff; // seconds
      if (pszInfo)
         printf("%s time adapted, %02d.%02d., %d\n",pszInfo,ptmod->tm_mday,ptmod->tm_mon+1,nTimeDiff);
   }
   if (ptmod && !ptmod->tm_isdst) {
      if (pszInfo)
         printf("%s time not adapted, %02d.%02d., %d\n",pszInfo,ptmod->tm_mday,ptmod->tm_mon+1,nTimeDiff);
   }
   return nRawTime;
}

#ifdef _WIN32
bool isSystemInDST()
{
   mytime_t n = (mytime_t)time(0);
   struct tm *loctm = mylocaltime(&n);
   if (loctm)
      return loctm->tm_isdst;
   return 0;
}

int makeWinFileTime(num nsrctime, FILETIME &rdsttime, num nSrcNanoSec, bool bUTC)
{
   mytime_t ftime = (mytime_t)nsrctime;
   struct tm *loctm;
   SYSTEMTIME st;
   FILETIME locft, modft;

   if (bUTC)
      loctm = mygmtime(&ftime);
   else
      loctm = mylocaltime(&ftime);

   if (loctm == NULL)
      return 9+perr("cannot convert time %s (%u)\n",numtoa(nsrctime),(uint)GetLastError());

   st.wYear         = (WORD)loctm->tm_year + 1900;
   st.wMonth        = (WORD)loctm->tm_mon + 1;
   st.wDayOfWeek    = (WORD)loctm->tm_wday;
   st.wDay          = (WORD)loctm->tm_mday;
   st.wHour         = (WORD)loctm->tm_hour;
   st.wMinute       = (WORD)loctm->tm_min;
   st.wSecond       = (WORD)loctm->tm_sec;
   // loctm->tm_isdst: no field in SYSTEMTIME
   st.wMilliseconds = 0;

   if (cs.debug) printf("mwft using time %02u:%02u\n", st.wHour, st.wMinute);

   if (bUTC)
   {
      SystemTimeToFileTime(&st, &modft);
   } 
   else 
   {
      if (!SystemTimeToFileTime(&st, &locft))
         return 9+perr("cannot convert time %s (%u)\n",numtoa(nsrctime),(uint)GetLastError());

      #if _MSC_VER >= 1900 // visual c++ 14.0

      /*
         A sick behaviour introduced with Visual 2015:

         LocalFileTimeToFileTime looks at the current DST of the PC,
           no matter which date locft represents.

         So when converting 2020-01-01 12:01:01 during SUMMER
           it will subtract one hour, while when doing this
           in WINTER it will NOT subtract one hour.

         This causes time chaos with touch, zip/unzip, sft etc.
         so it must be fixed. Of course we want to take the
         TIME ZONE of the PC into account, but never the
         (random) DST of the PC.
      */

      bool bFileTimeHasDST = loctm->tm_isdst;
      bool bThisPCHasDST   = isSystemInDST();

      num  ntime = fileTimeToTimeT(&locft);

      if (bFileTimeHasDST == 0 && bThisPCHasDST == 0) { }
      if (bFileTimeHasDST == 0 && bThisPCHasDST == 1) { ntime += 3600; }
      if (bFileTimeHasDST == 1 && bThisPCHasDST == 0) { ntime -= 3600; }
      if (bFileTimeHasDST == 1 && bThisPCHasDST == 1) { }

      timetToFileTime(ntime, &locft);

      #endif

      if (!LocalFileTimeToFileTime(&locft, &modft))
         return 9+perr("cannot convert time %s (%u)\n",numtoa(nsrctime),(uint)GetLastError());

      if (cs.debug) printf("mwft winft 0x%08x%08x\n", modft.dwHighDateTime, modft.dwLowDateTime);
   }

   if (nSrcNanoSec > 0)
   {
      modft.dwLowDateTime += (nSrcNanoSec / 100);
   }

   rdsttime = modft;

   return 0;
}
#endif

/*
   Factors influencing conversion:
      1. is src on UTC or non-UTC file system
      2. is src time dependent on DST, i.e. is it different
         depending on the fact that we currently have DST or not?
      3. is src's date stamp lying within a DST zone?
      4. all above for dst as well
*/

int FileStat::writeTo(char *pszDstFile, int nTraceLine, bool bWriteJustTime)
{
   if (!pszDstFile || !pszDstFile[0])
   {
      perr("missing stat filename, cannot write file time (%d)\n", nTraceLine);
      return 9;
   }

   // totally experimental and incomplete,
   // esp. on NTFS <-> FAT file transfers.

   #ifdef _WIN32
   HANDLE hDst = CreateFile(
      pszDstFile,
      FILE_WRITE_ATTRIBUTES,
      0,    // share
      0,    // security
      OPEN_EXISTING,
      src.bIsDir ? FILE_FLAG_BACKUP_SEMANTICS : FILE_ATTRIBUTE_NORMAL,
      0     // template file
      );
   if (hDst == INVALID_HANDLE_VALUE) {
      uint nerr = GetLastError();
      perr("cannot set attributes (rc=%u): %s\n",nerr,pszDstFile);
      if (nerr == ERROR_ACCESS_DENIED)
        pinf("make sure you have full access rights. maybe you have to be administrator.\n");
      return 9;
   }

   int nrc = 0;

   // src.nMTime is a value in SECONDS since 1970.

   FILETIME nDstMTime, nDstCTime, nDstATime;

   // native windows file times are copied 1:1
   if (src.nHaveWFT)
   {
      memcpy(&nDstMTime, &src.ftMTime, sizeof(nDstMTime));

      if (src.nHaveWFT > 1)
         memcpy(&nDstCTime, &src.ftCTime, sizeof(nDstCTime));

      if (src.nHaveWFT > 1)
         memcpy(&nDstATime, &src.ftATime, sizeof(nDstATime));
   }
   else
   {
      if (!nrc && src.nMTime)
         if (makeWinFileTime(src.nMTime, nDstMTime, 0, src.bIsUTCTime)) // FileStat
            nrc = 9;
 
      if (!nrc && src.nCTime)
         if (makeWinFileTime(src.nCTime, nDstCTime))
            nrc = 9;
 
      if (!nrc && src.nATime)
         if (makeWinFileTime(src.nATime, nDstATime))
            nrc = 9;
   }

   #ifdef WINFULL
   if (!nrc) {
      if (!SetFileTime(hDst, &nDstCTime, &nDstATime, &nDstMTime)) {
         perr("cannot set file time (rc=%u): %s %s\n", (uint)GetLastError(), pszDstFile, numtohex(src.nMTime));
         nrc = 9;
      }
   }
   #endif
 
   CloseHandle(hDst);

   if (!bWriteJustTime)
   {
      // CreateFile() was done ONLY to set filetime.
      // the attributes require another API call:
      if (src.nAttribs == 0) {
         perr("no attributes to set for %s\n",pszDstFile);
         nrc = 9;
      }
      else
      if (!SetFileAttributes(pszDstFile, src.nAttribs)) {
         perr("failed to set attributes (rc=%u): %s %s\n", (uint)GetLastError(), pszDstFile, numtohex(src.nMTime));
         nrc = 9;
      }
   }

   return nrc;

   #else

   // linux generic

   struct utimbuf otimes;
   mclear(otimes); // FIX: 167: missing actime init
   if (src.nATime)
      otimes.actime = src.nATime;
   otimes.modtime = src.nMTime;
   int iRC = utime(pszDstFile, &otimes);
   if (iRC) return 9+perr("failed to set file times (rc=%d): %s\n",iRC,pszDstFile);

   if (!bWriteJustTime)
   {
      mode_t nmode = (mode_t)src.nAttribs;
      if (nmode == 0) return 9+perr("no attributes to set for %s\n",pszDstFile);
      iRC = chmod(pszDstFile, nmode);
      if (iRC) return 9+perr("failed to set file attributes (rc=%d): %s\n",iRC,pszDstFile);
   }

   return 0;

   #endif
}

int cloneAttributes(char *pszSrc, char *pszDst, int nTraceLine)
{
   FileStat ofs;
   if (ofs.readFrom(pszSrc)) return 9;
   if (ofs.writeTo(pszDst, nTraceLine)) return 9;
   return 0;
}

int getFileMD5(Coi *pcoi, SFKMD5 &md5, bool bSilent, bool bInfoCycle)
{
   if (pcoi->open("rb")) {
      if (!bSilent) pferr(pcoi->name(), "cannot read: %s\n", pcoi->name());
      return 9;
   }
   size_t nRead = 0;
   while ((nRead = pcoi->read(abBuf,sizeof(abBuf)-10)) > 0) {
      md5.update(abBuf,nRead);
      cs.totalbytes += nRead;
      if (bInfoCycle)
         info.cycle();
   }
   pcoi->close();
   return 0;
}

int getFileMD5(char *pszFile, SFKMD5 &md5, bool bSilent, bool bInfoCycle)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      if (!bSilent) pferr(pszFile, "cannot read: %s\n", pszFile);
      return 9;
   }
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      cs.totalbytes += nRead;
      if (bInfoCycle)
         info.cycle();
   }
   fclose(fin);
   return 0;
}

int getFileMD5(char *pszFile, uchar *abOut16)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;
   SFKMD5 md5;
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      cs.totalbytes += nRead;
   }
   fclose(fin);
   uchar *pmd5 = md5.digest();
   for (uint k=0; k<16; k++)
      abOut16[k] = pmd5[k];
   return 0;
}

#ifdef _WIN32
// size of windows-specific read buffer must be
// a multiple of disk's sector size. the following
// should be sufficient for everything.
int   nGlblMD5NoCacheBufSize = 128000;
LPVOID pGlblMD5NoCacheBuf     = 0;
#endif

int getFileMD5NoCache(char *pszFile, uchar *abOut16, bool bSilent)
{
   #ifdef _WIN32
   int lRC = 0;

   int nBufSize = nGlblMD5NoCacheBufSize;

   // alloc read buffer on demand
   if (pGlblMD5NoCacheBuf == 0) {
      pGlblMD5NoCacheBuf = VirtualAlloc(0, nBufSize, MEM_COMMIT, PAGE_READWRITE);
      if (!pGlblMD5NoCacheBuf) return 11;
   }

   LPVOID pBuf = pGlblMD5NoCacheBuf;

   /*
   DWORD nBytesPerSector = 0;
   DWORD nDummy1, nDummy2, nDummy3;
   // try to get sector size
   if (GetDiskFreeSpace(szRootDir, &nDummy1, &nBytesPerSector, &nDummy2, &nDummy3)) {
      // adjust max. read size to multiples of sector size
      if (nBytesPerSector > 0) {
         int nBufSize2 = (int)(nBufSize / nBytesPerSector) * nBytesPerSector;
         printf("adjusted %d => %d by %d\n",nBufSize,nBufSize2,nBytesPerSector);
         nBufSize = nBufSize;
      }
   } else {
      printf("GetDiskFreeSpace failed\n");
   }
   */

   HANDLE hDst = CreateFile(
      pszFile,
      FILE_READ_DATA,
      0,    // share
      0,    // security
      OPEN_EXISTING,
      FILE_FLAG_NO_BUFFERING,
      0     // template file
      );

   if (hDst == INVALID_HANDLE_VALUE)
      return 9;

   SFKMD5 md5;
   DWORD nRead = 0;
   while (true) {
      nRead = 0;
      if (!ReadFile(hDst, pBuf, nBufSize, &nRead, 0))
         {  lRC = 10; break;   }
      if (nRead <= 0)
         break;
      // printf("%d bytes,\n\"%.*s\"\n",nRead,(int)nRead,pBuf);
      md5.update((uchar*)pBuf,nRead);
      cs.totalbytes += nRead;
      if (userInterrupt(bSilent))
         {  lRC = 8; break;   }
      info.cycle();
   }

   CloseHandle(hDst);

   if (lRC == 10 && GetLastError() == 87) {
      // ReadFile did not accept buffer size. try fallback:
      // pwarn("md5nocache: readfile failed, using fallback\n");
      return getFileMD5(pszFile, abOut16);
   }

   uchar *pdigest = md5.digest();
   memcpy(abOut16, pdigest, 16);

   return lRC;
   #else
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;
   SFKMD5 md5;
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      cs.totalbytes += nRead;
      if (userInterrupt(bSilent)) {
         fclose(fin);
         return 8;
      }
      info.cycle();
   }
   fclose(fin);
   uchar *pmd5 = md5.digest();
   for (uint k=0; k<16; k++)
      abOut16[k] = pmd5[k];
   return 0;
   #endif
}

num currentElapsedMSec() {
   return getCurrentTime() - nGlblStartTime;
}

uint currentKBPerSec() {
   num lMSElapsed = currentElapsedMSec();
   if (lMSElapsed == 0) lMSElapsed = 1;
   return (uint)(cs.totalbytes / lMSElapsed);
}

uint currentMBPerSec() {
   num lMSElapsed = currentElapsedMSec();
   if (lMSElapsed == 0) lMSElapsed = 1;
   return (uint)((cs.totalbytes / lMSElapsed) / 1000);
}

char szCmpBuf1[4096];
char szCmpBuf2[4096];

// 1694: new strstri without size limit
char *mystrstri(char *phay, cchar *ppat)
{
   int i=0,j=0,ncmp=0,ndiff=0;

   int llen = (int)strlen(phay);
   int slen = (int)strlen(ppat);

   ncmp = (llen-slen)+1;

   if (ncmp < 0)
      return 0;

   for (j=0; j<ncmp; ++j)
   {
      ndiff = 0;

      for (i=0; (i<slen) && !ndiff; ++i)
         ndiff = sfktolower(phay[j+i]) - sfktolower(ppat[i]);

      if (!ndiff)
         return (char *)phay+j;
   }

   return 0;
}

// 1694: replacement for old strstri
int mystrstrip(char *psz1, cchar *psz2, int *lpAtPosition)
{
   char *pHit = mystrstri(psz1, psz2);
   int iPos = pHit ? (int)(pHit - psz1) : -1;
   if (lpAtPosition)
      *lpAtPosition = iPos;
   return pHit ? 1 : 0;
}

// same as above, but support "?" wildcards.
// only for strings up to 4k length.
int mystrstriq4k(char *psz1, cchar *psz2, int *lpAtPosition=0)
{
   int slen1 = strlen(psz1);
   if (slen1 > (int)sizeof(szCmpBuf1)-10)
       slen1 = (int)sizeof(szCmpBuf1)-10;
   memcpy(szCmpBuf1, psz1, slen1);
   szCmpBuf1[slen1] = '\0';

   int slen2 = strlen(psz2);
   if (slen2 > (int)sizeof(szCmpBuf2)-10)
       slen2 = (int)sizeof(szCmpBuf2)-10;
   memcpy(szCmpBuf2, psz2, slen2);
   szCmpBuf2[slen2] = '\0';

   for (int i1=0; i1<slen1; i1++)
      szCmpBuf1[i1] = sfktolower(szCmpBuf1[i1]);
   for (int i2=0; i2<slen2; i2++) {
      szCmpBuf2[i2] = sfktolower(szCmpBuf2[i2]);
      if (glblUPatMode!=0 && szCmpBuf2[i2]==glblWrongPChar) // sfk183
         szCmpBuf2[i2] = glblPathChar;
   }

   char *pszHay = szCmpBuf1;  // HayStack
   char *pszNed = szCmpBuf2;  // Needle
   char *pszHit = 0;
   while (*pszHay) {
      // optim: quick check of current char
      if ((cs.noqwild == 1 || *pszNed != '?') // sfk1972 -noqwild
          && *pszHay != *pszNed)
         { pszHay++; continue; }
      // compare against needle at current hay position
      int i=0;
      for (; pszHay[i] && pszNed[i]; i++) {
         char c = pszNed[i];
         if (cs.noqwild == 0 && c == '?') // sfk1972 -noqwild
            continue;
         if (c != pszHay[i])
            break;
      }
      // comparison stopped: why?
      if (!pszNed[i]) {
         // needle elapsed: success
         pszHit = pszHay;
         break;
      }
      // needle not elapsed: no hit here
      pszHay++;
   }

   if (lpAtPosition) {
      if (pszHit)
         *lpAtPosition = (int)(pszHit - szCmpBuf1);
      else
         *lpAtPosition = -1;
   }

   return (pszHit != 0) ? 1 : 0;
}

// returns 0 if equal.
int mystrncmp(char *psz1, cchar *psz2, int nLen, bool bCase)
{
   if (bCase)
      return strncmp(psz1, psz2, nLen);

   int i=0;
   for (i=0; i<nLen && psz1[i] && psz2[i]; i++)
      if (sfktolower(psz1[i]) != sfktolower(psz2[i]))
         return 1;

   return (i==nLen) ? 0 : 1;
}

int mystricmp(char *psz1, cchar *psz2)
{
   while (*psz1 && *psz2 && sfktolower(*psz1) == sfktolower(*psz2)) {
      psz1++;
      psz2++;
   }
   return sfktolower(*psz1) - sfktolower(*psz2);
}

int mystrnicmp(char *psz1, cchar *psz2, int nLen)
{
   int i=0;
   for (i=0; i<nLen && psz1[i] && psz2[i]; i++)
      if (sfktolower(psz1[i]) != sfktolower(psz2[i]))
         return sfktolower(psz1[i]) - sfktolower(psz2[i]);

   if (i >= nLen) return 0;

   return sfktolower(psz1[i]) - sfktolower(psz2[i]);
}

bool stricase(char *psz, cchar *ppat)
   {  return mystricmp(psz, ppat) ? 0 : 1; }

bool strnicase(char *psz, cchar *pstart, int nlen)
   {  return mystrnicmp(psz, pstart, nlen) ? 0 : 1; }

bool stribeg(char *psz, cchar *pstart)
   {  return mystrnicmp(psz, pstart, strlen(pstart)) ? 0 : 1; }

/*
.
*/
#ifdef _WIN32
// type: 1==onlyDown 2==onlyUp 0==any
int getKeyPress(int ntype=0)
{
   #ifdef WINFULL
   DWORD dwNumEvents, dwEventsPeeked, dwInputEvents;
   INPUT_RECORD aInputBuffer[1];

   HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);

   if (!GetNumberOfConsoleInputEvents(hStdIn, &dwNumEvents))
      return -1;

   if (dwNumEvents <= 0)
      return -1;

   if (!PeekConsoleInput(hStdIn, aInputBuffer, 1, &dwEventsPeeked))
      return -1;
 
   if (!ReadConsoleInput(hStdIn, &aInputBuffer[0], 1, &dwInputEvents))
      return -1;

   if (dwInputEvents != 1)
      return -1;

   if (aInputBuffer[0].EventType == KEY_EVENT) {
      int ncode = aInputBuffer[0].Event.KeyEvent.wVirtualKeyCode;
      bool bdown = aInputBuffer[0].Event.KeyEvent.bKeyDown;
      // react only on key down or key up?
      if (ntype == 1 && !bdown) return -1; // no type match
      if (ntype == 2 &&  bdown) return -1; // no type match
      return ncode;
   }
   #endif

   return -1;
}

bool userInterrupt(bool bSilent, bool bWaitForRelease) 
{
   if (bGlblEscape)
      return 1;
   static bool bTold = 0;
   int nKey = getKeyPress(1);
   if (bGlblDisableEscape == 0 && nKey == VK_ESCAPE)
   {
      if (!bSilent && !bTold) {
         bTold = 1;
         info.clear(); // if any
         printf("[stopped by user]%.50s\n", pszGlblBlank);
      }
      if (bWaitForRelease)
         while (getKeyPress() == VK_ESCAPE)
            doSleep(200);
      bGlblEscape = 1; // on esc key
      return 1;
   }
   if (nKey == '\r')
   {
      if (!bSilent) {
         num nTime = mytime(NULL);
         mytime_t nTime2 = (mytime_t)nTime;
         struct tm *pLocTime = mylocaltime(&nTime2);
         if (pLocTime) {
            char szBuf[100+10];
            strftime(szBuf, 100, "%H:%M:%S", pLocTime);
            printf("--- %s ---   \n", szBuf);
         } else {
            printf("---\n");
         }
      }
      bGlblEnter = 1;
   }
   return 0;
}
#else
bool userInterrupt(bool bSilent, bool bWait)
{
   // FIX 1642: always returned 0
   return bGlblEscape;
}
#endif

struct SFKLoadNode
{
   struct SFKLoadNode *pNext;
   int iSize;
   char abData[1000000];
};

char *loadStdIn(num &rnFileSize)
{
   SFKLoadNode *pFirst=0,*pCur=0,*pPrev=0,*pDel=0;

   int iRC=0,iTotal=0;

   // load packages
   while (1)
   {
      if (!(pCur = new SFKLoadNode())) {
         perr("out of memory");
         iRC = 9;
         break;
      }
      memset(pCur, 0, sizeof(SFKLoadNode));

      int iRead = fread(pCur->abData, 1, sizeof(pCur->abData), stdin);

      if (iRead <= 0) {
         delete pCur;
         break;
      }

      if (!pFirst)
         pFirst = pCur;

      pCur->iSize = iRead;
      iTotal += iRead;

      if (pPrev)
         pPrev->pNext = pCur;

      pPrev = pCur;
   }

   // join packages
   char *pOut = 0;
 
   if (!iRC)
   {
      if (!(pOut = new char[iTotal+100]))
      {
         perr("out of memory");
         iRC = 10;
      }
      else
      {
         int iOff=0;
         for (pCur = pFirst; pCur; pCur=pCur->pNext)
         {
            memcpy(pOut+iOff, pCur->abData, pCur->iSize);
            iOff += pCur->iSize;
         }
         pOut[iOff] = '\0';
      }
   }
 
   // cleanup
   pCur = pFirst;
   while (pCur)
   {
      SFKLoadNode *pTmp = pCur->pNext;
      delete pCur;
      pCur = pTmp;
   }

   if (iRC)
      return 0;
 
   rnFileSize = iTotal;

   return pOut;
}

char *loadFile(char *pszFile, bool bquiet)
{
   num nFileSize = getFileSize(pszFile);
   if (nFileSize < 0) {
      if (!bquiet) perr("file not found: %s", pszFile);
      return 0;
   }

   num nTolerance = 10;
   char *pOut = new char[nFileSize+nTolerance+4];
   if (!pOut) {
      perr("out of memory: %s\n", pszFile);
      return 0;
   }
   memset(pOut+nFileSize, 0, nTolerance); // added safety

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      if (!bquiet) pferr(pszFile, "cannot read: %s\n", pszFile);
      delete [] pOut;
      return 0;
   }

   int nRead = fread(pOut, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      if (!bquiet) pferr(pszFile, "cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pOut;
      return 0;
   }

   // loadFile guarantees zero termination after buffer:
   pOut[nFileSize] = '\0';
   return pOut;
}

uchar *loadBinaryFile(char *pszFile, num &rnFileSize)
{
   num nFileSize = getFileSize(pszFile);
   if (nFileSize < 0)
      return 0;

   num nTolerance = 10;
   char *pOut = new char[nFileSize+nTolerance+4];
   if (!pOut) {
      perr("out of memory: %s\n", pszFile);
      return 0;
   }
   memset(pOut+nFileSize, 0, nTolerance); // added safety

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      pferr(pszFile, "cannot read: %s\n", pszFile);
      delete [] pOut;
      return 0;
   }

   int nRead = fread(pOut, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      pferr(pszFile, "cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pOut;
      return 0;
   }

   // not strictly needed w/binary data, but anyway.
   pOut[nFileSize] = '\0';

   rnFileSize = nFileSize;
   return (uchar*)pOut;
}

uchar *loadBinaryFlex(Coi &ocoi, num &rnFileSize)
{
   #ifdef VFILEBASE
   if (ocoi.preload("lbf", 0, 0)) // loadBinaryFlex
      return 0;
   #endif // VFILEBASE

   num nFileSize = ocoi.getSize();
   if (nFileSize < 0)
      return 0;

   num nTolerance = 10;
   char *pOut = new char[nFileSize+nTolerance+4];
   if (!pOut) {
      perr("out of memory: %s\n", ocoi.name());
      return 0;
   }
   memset(pOut+nFileSize, 0, nTolerance); // added safety

   if (ocoi.open("rb")) {
      pferr(ocoi.name(), "cannot read: %s\n", ocoi.name());
      delete [] pOut;
      return 0;
   }

   int nRead = ocoi.read(pOut, nFileSize);

   ocoi.close();

   if (nRead != nFileSize) {
      pferr(ocoi.name(), "cannot read: %s (%d %d)\n", ocoi.name(), nRead, nFileSize);
      delete [] pOut;
      return 0;
   }

   // not strictly needed w/binary data, but anyway.
   pOut[nFileSize] = '\0';

   rnFileSize = nFileSize;
   return (uchar*)pOut;
}

uchar *loadBinaryFlex(char *pszFile, num &rnFileSize)
{
   Coi *pcoi = new Coi(pszFile, 0);
   if (!pcoi) return 0;

   CoiAutoDelete odel(pcoi, 0); // no decref

   return loadBinaryFlex(*pcoi, rnFileSize);
}

int saveFile(char *pszName, uchar *pData, int iSize, const char *pszMode)
{
   FILE *fout = fopen(pszName, pszMode);
   if (!fout)
      return 9+perr("cannot write: %s\n", pszName);

   if (myfwrite(pData, iSize, fout) != iSize) {
      fclose(fout);
      return 10+perr("cannot fully write (disk full?): %s\n", pszName);
   }

   fclose(fout);
   return 0;
}

// used by matchesNormName only to check .ext dir masks
bool dirExtEndMatch(char *pszHay, char *pszPat)
{
   // hay1: ".svn/"
   // pat1: ".svn"
   // pat2: ".svn/"
   int npatlen = strlen(pszPat);
   if (npatlen < 1) return 0; // shouldn't happen
   // case ".svn/" == ".svn/"
   if (pszPat[npatlen-1] == glblPathChar)
      return mystricmp(pszHay, pszPat) ? 0 : 1;
   // pat differs in length to hay,
   // case ".svn/" == ".svn"
   int nhaylen = strlen(pszHay);
   if (nhaylen != npatlen+1)
      return 0;
   if (mystrnicmp(pszHay, pszPat, npatlen))
      return 0;
   if (pszHay[npatlen] != glblPathChar)
      return 0;
   return 1;
}

int normalizePath(char *pszSrc, char *pszDst, int iMaxDst)
{
   if (iMaxDst < 100)
      return 9+perr("buffer overflow #213461 %d", iMaxDst);

   char *pszMaxDst = pszDst+iMaxDst-10;

   pszDst[0] = '\0';

   int iNameLen = strlen(pszSrc);

   if (iMaxDst < iNameLen+4)
      return 10+perr("buffer overflow #213462 %d %d", iMaxDst, iNameLen);

   if (pszSrc[0] != glblPathChar)
      strcat(pszDst, glblPathStr);

   if (iNameLen > 0)
   {
      int iAppendPos = strlen(pszDst);

      if (pszDst+iAppendPos+iNameLen > pszMaxDst)
         return 11; // safety

      memcpy(pszDst+iAppendPos, pszSrc, iNameLen);
      pszDst[iAppendPos+iNameLen] = '\0';
   }

   if (iNameLen == 0 || pszSrc[iNameLen-1] != glblPathChar)
      strcat(pszDst, glblPathStr);

   return 0;
}

// IN: pszStr must be /thedir/file.txt/ normalized
//     with surrounding slashes. see normalizePath.
//     always use nflags = 1 or 3 then.
bool matchesNormName(char *pszStr, char *pszMask,
   bool *rPartMatch = 0, int nFlags = 0,
   int *pHitPos = 0, int *pHitLen = 0
   )
{
    if (cs.verbose >= 4)
       printf("\nmname %s %s flags=%u\n",pszStr,pszMask,nFlags);

    // flags, bit 0: DISABLE start of name comparison
    bool bEnableSNC = ((nFlags & 1) == 0);

    // flags, bit 1: PATH matching mode i/o FILE.
    bool bPathMatch =  (nFlags & 2) ? 1 : 0;

    // flags, bit 2: matchesDirMask mode, no ".ext" comparison.
    bool bMDirMask  =  (nFlags & 4) ? 1 : 0;

    // printf("SNC=%d PM=%d MDirMask=%d\n",bEnableSNC,bPathMatch,bMDirMask);

    //  foo         -> thefoosys.txt
    //  *foo*bar*   -> thefooanybar.txt
    //  .txt        -> only .txt files
    //  !.txt       -> all except .txt files
    //  * anywhere  -> ignore . position

    if (rPartMatch) *rPartMatch = false;

    szMatchBuf[0] = '\0';

    int nMinHitPos = -1;
    int nMaxHitLen =  0;

    char *pstr1  = pszStr;
    char *pmsk1  = pszMask;
    char *pmsk2  = pmsk1;
    bool  bneg   = 0;
    bool  bimt   = true; // inner match
    int  nmpos  = 0;
    int  nlen   = 0;
    bool  bwild2 = 0;

    while (*pmsk1)
    {
        char c = *pmsk1;
        bool bIsLastChr = (*(pmsk1+1) == '\0');

        // initial negation
        if (!nmpos && isNotChar(c))
            { bneg=1; pmsk1++; pmsk2=pmsk1; nmpos++; continue; }
        nmpos++;

        // identify tokens between *
        bool bwild = isWildChar(c); // checks for *, but not ?
        if (bwild || bIsLastChr)
        {
            // have mask part from pmsk2 to pmsk1-1
            nlen = pmsk1 - pmsk2;
            if (!bwild) nlen++; // do not exlude * then

            // "*" as first character of mask?
            if (nlen <= 0) {
               if (bPathMatch) {
                  pmsk1++; pmsk2=pmsk1; bwild2=1; continue;
               } else {
                  pmsk1++; pmsk2=pmsk1; continue;
               }
            }

            // have mask part from pmsk2 with length nlen
            if (nlen > MAX_MATCH_BUF-2) {
               if (cs.verbose >= 3) printf("0 = MATCH1 (msk %.100s, str %s) r2\n",pmsk2,pszStr);
               return false;
            }
            memcpy(szMatchBuf, pmsk2, nlen);
            szMatchBuf[nlen] = '\0';
            if (cs.verbose >= 4) printf("PART %s neg %d\n", szMatchBuf, bneg);

            // special case ".ext" part at end of mask?
            if (!bwild && !bwild2 && szMatchBuf[0] == '.')
            {
                // compare mask: szMatchBuf e.g. ".1.txt"
                // against end of: pstr1    e.g. "foo.1.txt"
                int nMaskLen = strlen(szMatchBuf);
                int nNameLen = strlen(pstr1);

                // FIX: R157: no longer use strrchr(pstr1, '.')
                char *psz5 = 0;
                if (endsWithPathChar(szMatchBuf, glblUPatMode)) {
                   if (nMaskLen <= nNameLen) {
                      psz5 = pstr1 + nNameLen - nMaskLen;
                      if (*psz5 != '.') psz5 = 0;
                   }
                } else {
                   // FIX 163R3: .txt <-> tmp1.txt/
                   // fix includes strnicmp below i/o stricmp
                   if (nMaskLen+1 <= nNameLen) {
                      psz5 = pstr1 + nNameLen - (nMaskLen+1);
                      if (*psz5 != '.') psz5 = 0;
                   }
                }
                bool bmatch1 = false;
                if (!psz5)
                    bmatch1 = false;
                else
                if (bMDirMask)
                    bmatch1 = dirExtEndMatch(psz5, szMatchBuf);
                else
                    bmatch1 = !mystrnicmp(psz5, szMatchBuf, nMaskLen);
                if (bmatch1 && rPartMatch) *rPartMatch = true;
                // final match decision by extension:
                if (cs.verbose >= 3) printf("%d = MATCH2 (msk %s, str %s) %d^%d r3 pcmp=%p\n",bneg^bmatch1,szMatchBuf,pszStr,bneg,bmatch1,psz5);
                return bneg ^ bmatch1;
            }

            int nHitPos = 0;

            // string cursor is pstr1
            bool bmatch2 = false;

            if (bEnableSNC && isUniPathChar(szMatchBuf[0]) && (szMatchBuf[1] != '\0'))
            {
               // start of name comparison:
               if (mystrstriq4k(pstr1, &szMatchBuf[1], &nHitPos))
                  if (nHitPos == 0) {
                     bmatch2 = true;
                     if (pHitPos) {
                        nMinHitPos = 0;
                        nMaxHitLen = strlen(&szMatchBuf[1]);
                     }
                  }
            }
            else
            {
               // normal within-name comparison:
               if (mystrstriq4k(pstr1, szMatchBuf, &nHitPos)) {
                   // part matches:
                   if (rPartMatch) *rPartMatch = true;
                   if (cs.verbose >= 4) printf("CHK0 bneg %d (msk %s,str %s)\n",bneg,szMatchBuf,pszStr);
                   // if (bneg) return false;
                   // else continue, no mismatch yet.
                   if (pHitPos) {
                      int nAbsPos1 = (pstr1-pszStr)+nHitPos;
                      if (nMinHitPos < 0) nMinHitPos = nAbsPos1;
                      int nAbsPos2 = nAbsPos1 + strlen(szMatchBuf);
                      nMaxHitLen = nAbsPos2 - nMinHitPos;
                   }
                   // have to step past hit in string.
                   pstr1 += nHitPos + strlen(szMatchBuf);
                   pmsk1++; pmsk2=pmsk1;
                   continue;
               }
               // else fall through, bmatch2 hasn't been raised.
            }

            if (!bmatch2)
            {
                // part mismatch:
                bimt = false; // no inner match
                if (!bneg) {
                   if (cs.verbose >= 3) printf("0 = MATCH3 (msk %s, str %s) r4\n",szMatchBuf,pszStr);
                   return false;
                }
                if (cs.verbose >= 4) printf("CHK2 bneg %d (msk %s,str %s)\n",bneg,szMatchBuf,pszStr);
                // else continue, no negation match yet
                // e.g. "!the*foo" over "bigtest.txt";
                // do not step pstr1 at all.
                if (cs.verbose >= 4) printf("CNT2 bneg %d\n",bneg);
                pmsk1++; pmsk2=pmsk1; continue;
            } else {
                pmsk1++; pmsk2=pmsk1; continue;
            }
        }
        // continue on characters within tokens
        pmsk1++;
    }
    // the string past "!" (if any) matches:
    if (cs.verbose >= 3) printf("%d = MATCH4 (msk \"%s\", str \"%s\") %d^%d\n",bimt^bneg,szMatchBuf,pszStr,bimt,bneg);
    bool brc = bimt ^ bneg;
    if (brc && pHitPos && (nMinHitPos >= 0) && (nMaxHitLen > 0)) {
       if (pHitPos) *pHitPos = nMinHitPos;
       if (pHitLen) *pHitLen = nMaxHitLen;
    }
    return brc;
}

// RC 0 : no match
// RC 1 : match, but just by wildcard
// RC 2 : match by non wildcard pattern
// RC 3 : matches by .ext // sfk1944
int matchesFileMask(char *pszFile, char *pszInfoAbsName, int iFromInfo)
{
   int iRC = 1;
 
   // build normalized filename
   //    foo.txt     -> /foo.txt/
   //    foo\bar.txt -> /foo/bar.txt/
   int iNameLen = strlen(pszFile);
 
   char *pszNormSubName = new char[iNameLen + 10];
   CharAutoDel odel(pszNormSubName);

   pszNormSubName[0] = '\0';
   if (pszFile[0] != glblPathChar)
      strcat(pszNormSubName, glblPathStr);
   if (iNameLen > 0) {
      int iAppendPos = strlen(pszNormSubName);
      memcpy(pszNormSubName+iAppendPos, pszFile, iNameLen);
      pszNormSubName[iAppendPos+iNameLen] = '\0';
   }
   if (iNameLen == 0 || pszFile[iNameLen-1] != glblPathChar)
      strcat(pszNormSubName, glblPathStr);

   int iNumberOfWhiteMasks    = 0;
   int iNumberOfWhiteMatches  = 0;
   int iNumberOfBlackMasks    = 0;
   int iNumberOfWildMasks     = 0;

   Array &rMasks = glblFileSet.fileMasks();
   for (int i=0; rMasks.isStringSet(i); i++)
   {
      char *pszMask = rMasks.getString(i);

      if (isNotChar(pszMask[0]))
      {
         iNumberOfBlackMasks++;
         if (matchesNormName(pszNormSubName, pszMask+1, 0, 3)) { // ,3: no start-of-name + cmp-path
            if (nGlblTraceSel & 1) {
               setTextColor(nGlblTraceExcColor);
               info.print("file-exclud: %s due to \"%s\" (from=%d)\n", pszNormSubName, pszMask, iFromInfo);
               setTextColor(-1);
            }
            return 0;
         } else {
            if (cs.verbose >= 4)
               printf("1 = msbm (msk %s, str %s) (from=%d)\n", pszMask, pszNormSubName, iFromInfo);
         }
      }
      else
      {
         iNumberOfWhiteMasks++;
         if (matchesNormName(pszNormSubName, pszMask, 0, 3)) { // ,3: no start-of-name + cmp-path
            iNumberOfWhiteMatches++;
            if (!containsWildCards(pszMask)) {
               iRC = 2;
               if (pszMask[0] == '.')  // sfk1944
                  iRC = 3;
            }
            if (nGlblTraceSel & 1) {
               setTextColor(nGlblTraceExcColor);
               info.print("file-wmatch: %s to \"%s\" (from=%d)\n", pszNormSubName, pszMask, iFromInfo);
               setTextColor(-1);
            }
         } else {
            if (cs.verbose >= 4)
               printf("0 = mswm (msk %s, str %s) (from=%d)\n", pszMask, pszNormSubName, iFromInfo);
         }
      }
   }

   // if any white masks given, at least one or all must match
   if (cs.fileMaskAndMatch) {
      if (iNumberOfWhiteMasks > 0 && iNumberOfWhiteMatches < iNumberOfWhiteMasks)
         iRC = 0;
   } else {
      if (iNumberOfWhiteMasks > 0 && iNumberOfWhiteMatches < 1)
         iRC = 0;
   }

   if (nGlblTraceSel & 1) {
      if (iRC) {
         setTextColor(nGlblTraceIncColor);
         info.print("file-keep  : %s (wmask=%d/%d bmask=0/%d) (from=%d)\n", pszNormSubName, iNumberOfWhiteMatches, iNumberOfWhiteMasks, iNumberOfBlackMasks, iFromInfo);
         // mtklog(("mdm: include %s", pszStr));
      } else {
         setTextColor(nGlblTraceExcColor);
         info.print("file-exclud: %s (wmask=%d/%d bmask=0/%d) (from=%d)\n", pszNormSubName, iNumberOfWhiteMatches, iNumberOfWhiteMasks, iNumberOfBlackMasks, iFromInfo);
         // mtklog(("mdm: exclude %s", pszStr));
      }
      setTextColor(-1);
   }

   // mtklog(("mdm: %d for %s", iRC, pszStr));

   return iRC;
}

bool matchesDirMask(char *pszFullPath, bool bTakeFullPath, bool bApplyWhiteMasks, int iFromInfo)
{_p("sf.mtchdir")

   bool bRC = 1;

   // build normalized path name
   //    include  -> /include/
   //    \foo\bar -> /bar/
   // if input path is an absolute filename
   //    include\foo.hpp -> /include/
   int iPathLen = strlen(pszFullPath);
   if (!bTakeFullPath) {
      char *pszRelName = strrchr(pszFullPath, glblPathChar);
      if (!pszRelName)
         iPathLen = 0;
      else
         iPathLen = pszRelName - pszFullPath;
   }

   char *pszNormSubName = new char[iPathLen + 10];
   CharAutoDel odel(pszNormSubName);

   pszNormSubName[0] = '\0';
   if (pszFullPath[0] != glblPathChar)
      strcat(pszNormSubName, glblPathStr);
   if (iPathLen > 0) {
      int iAppendPos = strlen(pszNormSubName);
      memcpy(pszNormSubName+iAppendPos, pszFullPath, iPathLen);
      pszNormSubName[iAppendPos+iPathLen] = '\0';
   }
   if (iPathLen == 0 || pszFullPath[iPathLen-1] != glblPathChar)
      strcat(pszNormSubName, glblPathStr);
 
   int iNumberOfWhiteMasks    = 0;
   int iNumberOfWhiteMatches  = 0;
   int iNumberOfBlackMasks    = 0;
   int iNumberOfWildMasks     = 0;

   Array &rMasks = glblFileSet.dirMasks();
   for (int i=0; rMasks.isStringSet(i); i++)
   {
      char *pszMask = rMasks.getString(i);

      if (isNotChar(pszMask[0]))
      {
         // black masks are applied asap, both during directory travel
         // and later when checking file paths.
         iNumberOfBlackMasks++;
         if (matchesNormName(pszNormSubName, pszMask+1, 0, 3)) { // ,3: no start-of-name + cmp-path
            if (nGlblTraceSel & 1) {
               setTextColor(nGlblTraceExcColor);
               info.print("dir-exclude: %s due to \"%s\" (from=%d)\n", pszNormSubName, pszMask, iFromInfo);
               setTextColor(-1);
            }
            return 0;
         } else {
            if (cs.verbose >= 4)
               printf("1 = msbm (msk %s, str %s) (from=%d)\n", pszMask, pszNormSubName, iFromInfo);
         }
      }
      else
      if (bApplyWhiteMasks)
      {
         // white masks are applied on file path checking,
         // but not on directory travel.
         iNumberOfWhiteMasks++;
         if (matchesNormName(pszNormSubName, pszMask, 0, 3)) { // ,3: no start-of-name + cmp-path
            iNumberOfWhiteMatches++;
            if (nGlblTraceSel & 1) {
               setTextColor(nGlblTraceExcColor);
               info.print("dir-wmatch : %s to \"%s\" (from=%d)\n", pszNormSubName, pszMask, iFromInfo);
               setTextColor(-1);
            }
         } else {
            if (cs.verbose >= 4)
               printf("0 = mswm (msk %s, str %s) (from=%d)\n", pszMask, pszNormSubName, iFromInfo);
         }
      }
   }
 
   // if any white masks given, at least one or all must match
   if (cs.dirMaskAndMatch) {
      if (iNumberOfWhiteMasks > 0 && iNumberOfWhiteMatches < iNumberOfWhiteMasks)
         bRC = 0;
   } else {
      if (iNumberOfWhiteMasks > 0 && iNumberOfWhiteMatches < 1)
         bRC = 0;
   }
 
   if (nGlblTraceSel & 1) {
      if (bRC) {
         setTextColor(nGlblTraceIncColor);
         info.print("dir-keep   : %s (wmask=%d/%d bmask=0/%d) (from=%d)\n", pszNormSubName, iNumberOfWhiteMatches, iNumberOfWhiteMasks, iNumberOfBlackMasks, iFromInfo);
         // mtklog(("mdm: include %s", pszStr));
      } else {
         setTextColor(nGlblTraceExcColor);
         info.print("dir-exclude: %s (wmask=%d/%d bmask=0/%d) (from=%d)\n", pszNormSubName, iNumberOfWhiteMatches, iNumberOfWhiteMasks, iNumberOfBlackMasks, iFromInfo);
         // mtklog(("mdm: exclude %s", pszStr));
      }
      setTextColor(-1);
   }

   // mtklog(("mdm: %d for %s", bRC, pszStr));

   return bRC;
}

void padBuffer(char *pszBuf, int nMaxLen, char c, int nTargLen)
{
   int nlen = strlen(pszBuf);
   if (nlen < nTargLen) {
      int ndif = nTargLen-nlen;
      if (nlen+ndif < nMaxLen) {
         memset(pszBuf+nlen, c, ndif);
         pszBuf[nlen+ndif] = '\0';
      }
   }
}

// .
int execFind(Coi *pcoi)
{__
   bool isBinaryFile(char *pszFile);

   info.setAddInfo("%u files, %u dirs", cs.filesScanned, cs.dirsScanned);
   info.setStatus("scan ", pcoi->name(), 0, eKeepAdd);

   bool bBinGrep = bGlblBinGrep;
 
   if (bGlblBinGrepAutoDetect)
   {
      bBinGrep = pcoi->isBinaryFile();
   }

   if (bBinGrep)
   {
      if (pcoi->open("rb"))
         { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

      cs.filesScanned++;
 
      BinTexter bt(pcoi);
      bt.process(BinTexter::eBT_Grep);
 
      pcoi->close();
   }
   else
   {
      // this is only reached with "-text" option specified.
      // we're using TEXT MODE and fgets BY INTENTION.
      // on the first NULL or EOF byte, the scanning will stop.
 
      if (pcoi->open("r")) // TEXT only read mode
         { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

      cs.filesScanned++;

      int nMaxLineLen = sizeof(szLineBuf)-10; // YES, szLineBuf
      memset(abBuf, 0, nMaxLineLen+2); // yes, abBuf is larger by far
 
      int nLocalLines = 0;
      int nMatchLines = 0;
      bool bDumpedFileName = 0;
      bool btold1 = 0;

      while (pcoi->readLine((char*)abBuf, nMaxLineLen) > 0) // yes, exact len
      {
         cs.lines++;
         nLocalLines++;

         // sfk181: option -maxlines with find
         if (cs.maxlines>0 && nLocalLines>cs.maxlines)
            break;

         if (!btold1 && ((int)strlen((char*)abBuf) == nMaxLineLen)) {
            btold1 = 1;
            pwarn("max line length %d reached, splitting input line(s) in file %s\n", nMaxLineLen, pcoi->name());
         }
 
         removeCRLF((char*)abBuf);
 
         int nMatch = 0;
         int nGrepPat = glblGrepPat.numberOfEntries();
         for (int i=0; (nMatch < nGrepPat) && (i<nGrepPat); i++)
            if (mystrhit((char*)abBuf, glblGrepPat.getString(i), cs.usecase, 0))
               nMatch++;
 
         if (nMatch == nGrepPat)
         {
            // found a matching file
            cs.anymatches = 1;

            if (chain.colfiles) {
               #ifdef SFKOFFICE
               // filenames only, as filename chain
               if (cs.office>0) { // sfk193
                  if (useOfficeBaseNames())
                     pcoi->stripOfficeName(); // find -names
                  if (!chain.hasFile(pcoi->name()))
                     chain.addFile(*pcoi); // is copied
               }
               else 
               #endif // SFKOFFICE
                  chain.addFile(*pcoi); // is copied
               break;
            }

            if (cs.justrc || cs.useJustNames || cs.useNotNames)
            {
               nMatchLines++;
               // if counting matches, continue until end of file.
               if (cs.countMatchLines)
                  continue;
               // fall through to (not) printing of filename.
               break;
            }

            // actually dump the content:

            // list filename first
            if (!bDumpedFileName && !cs.nonames && !cs.pure) {
               bDumpedFileName = 1;
               if (chain.coldata) {
                  sprintf(szLineBuf2, ":file %s", pcoi->name());
                  // note: +view scans extended end of attribute line
                  //       to identify 'f'ile header lines, therefore +2:
                  setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
                  chain.addLine(szLineBuf2, szAttrBuf2);
               } else {
                  setTextColor(nGlblFileColor);
                  info.print("%s :\n", pcoi->name());
                  setTextColor(-1);
               }
            }

            // list the line
            bool bPrefixed = 0;
 
            if (bGlblGrepLineNum)
               { sprintf(szLineBuf2, "   %04u ", nLocalLines); bPrefixed=1; }
            else
            if (!cs.pure)
               { sprintf(szLineBuf2, "   "); bPrefixed=1; }

            if (bPrefixed) {
               if (chain.coldata) {
                  szAttrBuf2[0] = '\0';
                  padBuffer(szAttrBuf2, MAX_LINE_LEN, ' ', strlen(szLineBuf2));
                  // FIX: 163: create new record here
                  chain.addLine(szLineBuf2, szAttrBuf2);
               } else {
                  info.print("%s", szLineBuf2);
               }
            }

            char *pszTmp  = (char*)abBuf;
            int nAttrPad = strlen(pszTmp);
            if (nAttrPad > (int)sizeof(szAttrBuf)-10)
                nAttrPad = (int)sizeof(szAttrBuf)-10;

            memset(szAttrBuf, ' ', nAttrPad);
            szAttrBuf[nAttrPad] = '\0';

            for (int k=0; k<nGrepPat; k++)
            {
               char *pszPat = glblGrepPat.getString(k);
               int nPatLen = strlen(pszPat);
               int nTmpLen = strlen(pszTmp);
               int nCur = 0, nRel = 0;
               while (mystrhit(pszTmp+nCur, pszPat, cs.usecase, &nRel))
               {
                  if (nCur+nRel+nPatLen < (int)sizeof(szAttrBuf)-10)
                     memset(&szAttrBuf[nCur+nRel], 'i', nPatLen);
                  nCur += nRel+nPatLen;
                  if (nCur >= nTmpLen-1)
                     break;
               }
            }

            if (!cs.justrc) {
               if (chain.coldata) {
                  // FIX: 163: if prefix, append after that
                  if (bPrefixed)
                     chain.addToCurLine((char*)abBuf, szAttrBuf, 0);
                  else
                     chain.addLine((char*)abBuf, szAttrBuf);
               } else {
                  printColorText((char*)abBuf, szAttrBuf);
               }
            }
 
            if (cs.useFirstHitOnly)
               break;

         }  // endif all patterns match

      }  // endwhile fgets
 
      pcoi->close();

      if (   (cs.useJustNames && nMatchLines)
          || (cs.useNotNames>0 && nMatchLines==0))
      {
         // filenames only, as text data, NOT prefixing
         // further text data, therefore NOT including ":file "
         strcopy(szLineBuf3, pcoi->name()); // sfk193
         if (useOfficeBaseNames())
            stripOfficeName(szLineBuf3); // find -names
         if (chain.coldata) {
            if (cs.countMatchLines) {
               // do not pass file headers, but pure text
               sprintf(szLineBuf2, "%05d : %s", nMatchLines, szLineBuf3);
               setattr(szAttrBuf2, ' ', strlen(szLineBuf2), MAX_LINE_LEN);
            } else {
               sprintf(szLineBuf2, "%s", szLineBuf3);
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
            }
            chain.addLine(szLineBuf2, szAttrBuf2);
         } else {
            if (cs.countMatchLines)
               info.print("%05d : %s\n", nMatchLines, szLineBuf3);
            else
               info.print("%s\n", szLineBuf3);
         }
         if (chain.justNamesFilter)
            chain.justNamesFilter->put(szLineBuf3);
      }

   }  // endelse bingrep
 
   return 0;
}

CoiTable glblFileListCache;

int prtFile(char *pszPreInfo, char *pszRelName, Coi *pcoi, char *pszZip, int nFlags, const char *pszFormat, ...)
{__
   char *pszFilename = pszRelName;

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';

   char *pq = bGlblQuoted ? (char*)"\"" : (char*)"";

   bool bshowprog = 0;

   if (cs.listByTime || cs.listBySize || cs.listByName) {
      // remember string with metadata length prefix, for easier output formatting
      char cOrder = 0;
      if (cs.listByTime) cOrder = (cs.listByTime < 0) ? 't':'T';
      if (cs.listBySize) cOrder = (cs.listBySize < 0) ? 's':'S';
      if (cs.listByName) cOrder = (cs.listByName < 0) ? 'n':'N';
      int nLen = strlen(pszFilename);
      if (nLen > (int)sizeof(szPrintBuf2)-100)
          nLen = (int)sizeof(szPrintBuf2)-100;
      sprintf(szPrintBuf2, "%05u %s%s%.*s%s", (uint)strlen(szPrintBuf1), szPrintBuf1, pq,nLen,pszFilename,pq);
      pcoi->setExtStr(szPrintBuf2);
      if (glblFileListCache.addSorted(*pcoi, cOrder, cs.usecase))
         return 9;
      bshowprog = 1;
   }
   else
   if (cs.outfile) {
      // direct filename listing to an output file
      chain.print("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
      bshowprog = 1;
   }
   else
   if (chain.colfiles) {
      // chain mode: do not print files, collect them
      // if (pszZip)
      //    sprintf(szPrintBuf2, "%s%c%s", pszZip, glblPathChar, pszFilename);
      // else
      //    strcopy(szPrintBuf2, pszFilename);
      chain.addFile(*pcoi); // is COPIED
      bshowprog = 1;
   }
   else
   {
      StringPipe *pout = 0;
      if (chain.coldata) {
         nFlags = 0; // no highlighting, just collect text
         pout = chain.outdata;
         bshowprog = 1;
      }

      // no sorted listing: try to highlight files by attribute
      if (nFlags & 128) { // link
         setTextColor(nGlblLinkColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      }
      else
      if (nFlags & 64) { // hidden
         setTextColor(nGlblFileColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      }
      else
      if (nFlags & 4) { // added
         setTextColor(nGlblWarnColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      }
      else
      if (nFlags & 1) { // time
         setTextColor(nGlblTimeColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      }
      else {
         oprintf(pout, "%s%s%s%s%s\n", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
      }
   }

   // show progress info, if filenames are not printed
   // onto terminal, but redirected:
   if (bshowprog) {
      cs.filesScanned++;
      mtklog(("prtfile.bshowprog=%d q=%d nhead=%d",bshowprog,cs.quiet,cs.nohead));
      if (!cs.quiet && !cs.nohead) {
         info.setAddInfo("%u files", cs.filesScanned);
         info.setStatus("scan", pszFilename, 0, eKeepAdd);
      }
   }
 
   if (cs.crashtest)
      crashTest();

   return 0;
}

char *sizeOrDir(num nSize, int nFlags)
{
   static char szInfo[200];
   int ndig = (uint)nGlblListDigits;
   if (ndig < 1) ndig = 1;
   if (ndig > (int)sizeof(szInfo)-10) ndig = sizeof(szInfo)-10;
   if (nFlags & 1) {
      snprintf(szInfo, sizeof(szInfo)-10, "%*.*s",(int)ndig,(int)ndig,"[dir]");
   } else {
      if (ndig >= 4)
      switch (cs.listunit) {
         case 'k': case 'm': case 'g':
            ndig -= 3; // for " kb"
            break;
      }
      switch (cs.listunit)
      {
         case 'k': snprintf(szInfo, sizeof(szInfo)-10, "%*s kb",(int)ndig,numtoa(nSize/1000UL)); break;
         case 'm': snprintf(szInfo, sizeof(szInfo)-10, "%*s mb",(int)ndig,numtoa(nSize/1000000UL)); break;
         case 'g': snprintf(szInfo, sizeof(szInfo)-10, "%*s gb",(int)ndig,numtoa(nSize/1000000000UL)); break;
         case 'K': snprintf(szInfo, sizeof(szInfo)-10, "%*s",(int)ndig,numtoa(nSize/1000UL)); break;
         case 'M': snprintf(szInfo, sizeof(szInfo)-10, "%*s",(int)ndig,numtoa(nSize/1000000UL)); break;
         case 'G': snprintf(szInfo, sizeof(szInfo)-10, "%*s",(int)ndig,numtoa(nSize/1000000000UL)); break;
         default:
            strcpy(szInfo, numtoa_blank(nSize, ndig));
            break;
      }
   }
   return szInfo;
}

int listSingleFile(int lLevel, Coi *pcoi, char *pszParentZip, bool bIsDir, int nSinceReason)
{__
   char *pszFileName = pcoi->name();
   num   nFileTime   = pcoi->getTime();
   num   nFileSize   = pcoi->getSize();

   const char *p1 = "";
   const char *p2 = "";

   char *pz = pszParentZip;

   int nf = 0; // flags
   if (bIsDir)
        nf |= 32;
   if (pcoi->isHidden())
        nf |= 64;
   if (pcoi->isLink())
        nf |= 128;

   char szSinceInfo[50];
   szSinceInfo[0] = '\0';
   if (!cs.pure) {
      if (nSinceReason & 2) { strcpy(szSinceInfo, "[dif] "); nf |= 2; }
      else
      if (nSinceReason & 1) { strcpy(szSinceInfo, "[tim] "); nf |= 1; }
      if (nSinceReason & 4) { strcpy(szSinceInfo, "[add] "); nf |= 4; }
   }
   char *ps = szSinceInfo;

   // relativize or absolutize filename
   char szPwdBuf[SFK_MAX_PATH+100];
   char szAbsNameBuf[SFK_MAX_PATH+100];
   char *pf = pszFileName;
   if (cs.forceabsname) {
      if (!isAbsolutePath(pszFileName)) {
         szPwdBuf[0] = szAbsNameBuf[0] = '\0';
         if (getcwd(szPwdBuf,SFK_MAX_PATH)) { }
         joinPath(szAbsNameBuf, SFK_MAX_PATH, szPwdBuf, pszFileName);
         pf = szAbsNameBuf;
      }
   }
   else if (cs.rootrelname)
      pf = pcoi->rootRelName();
   if (!pf)
      return 9;
 
   char csep = cs.listTabs ? '\t':' ';
   int  iTimeMode = 0;
   if (cs.flatTime) iTimeMode |= 3; // flat and separated
   if (cs.listTabs) iTimeMode |= 4; // use tabs

   // optional content info:
   char szcont[100];
   szcont[0] = '\0';

   switch (nGlblListMode)
   {
      case 1:
         if (!cs.quiet && (nGlblListMinSize > 0))
         {
            int lMBytes = (int)(nFileSize / 1000000L);
            if (nFileSize >= nGlblListMinSize)
            {
               int nIndent = (int)lLevel;
               if (nIndent > (int)strlen(pszGlblBlank)) nIndent = strlen(pszGlblBlank);
               if (nIndent > 10) nIndent = 10;

               switch (cs.listunit) {
                  case 'b':
                     prtFile(ps,pf,pcoi,pz,nf, "%s,              %.*s%s%s", numtoa_blank(nFileSize, 12), nIndent, pszGlblBlank, p1,p2);
                     break;
                  case 'k':
                     prtFile(ps,pf,pcoi,pz,nf, "%s kb,              %.*s%s%s", numtoa_blank(nFileSize/1000, 10), nIndent, pszGlblBlank, p1,p2);
                     break;
                  default :
                     prtFile(ps,pf,pcoi,pz,nf, "%5d mb,               %.*s%s%s", lMBytes, nIndent, pszGlblBlank, p1,p2);
                     break;
               }
            }
         }
         break;

      case 2:
         #ifndef _WIN32
         if (cs.traceFileFlags) {
            printf("t=%04x m=%04x l=%04x ", pcoi->rawtype, pcoi->rawmode, pcoi->rawnlnk);
         }
         #endif
         if (cs.listContent)
         {
            char cBinary   = pcoi->isBinaryFile() ? 'b':'t';
            char cArchive  = pcoi->isKnownArc()   ? 'a':'-';
            char cWideChar = pcoi->isUTF16()      ? 'w':'-';
            sprintf(szcont, "%c%c%c%c", cBinary,cArchive,cWideChar,csep);
         }
         switch (cs.listForm)
         {
            // default: plain filename, nothing else
            case 0: prtFile(ps,pf,pcoi,pz,nf, "%s%s%s", szcont,p1,p2); break;

            // -size: size and filename
            case 1: prtFile(ps,pf,pcoi,pz,nf, "%s%c%s%s%s", sizeOrDir(nFileSize, nf), csep, szcont,p1,p2); break;
            // -time: time and filename
            case 2: prtFile(ps,pf,pcoi,pz,nf, "%s%c%s%s%s", timeAsString(nFileTime, iTimeMode), csep, szcont,p1,p2); break;

            // size time filename:
            case 0x0102: prtFile(ps,pf,pcoi,pz,nf, "%s%c%s%c%s%s%s", sizeOrDir(nFileSize, nf), csep, timeAsString(nFileTime, iTimeMode), csep, szcont,p1,p2); break;
            // time size filename:
            case 0x0201: prtFile(ps,pf,pcoi,pz,nf, "%s%c%s%c%s%s%s", timeAsString(nFileTime, iTimeMode), csep, sizeOrDir(nFileSize, nf), csep, szcont,p1,p2); break;

            // crc and filename
            case 3: prtFile(ps,pf,pcoi,pz,nf, "%08x%c%s%s%s", pcoi->crc, csep, szcont,p1,p2); break;
            // size crc filename:
            case 0x0103: prtFile(ps,pf,pcoi,pz,nf, "%s%c%08x%c%s%s%s", sizeOrDir(nFileSize, nf), csep, pcoi->crc, csep, szcont,p1,p2); break;
            // crc size filename:
            case 0x0301: prtFile(ps,pf,pcoi,pz,nf, "%08x%c%s%c%s%s%s", pcoi->crc, csep, sizeOrDir(nFileSize, nf), csep, szcont,p1,p2); break;
         }
         break;
   }

   return 0;
}

#ifndef USE_SFK_BASE
int execDupScan(Coi *pcoi)
{
   int irc = 0;

   if (glblDupScan.clSyncNames) 
   do
   {
      char *psrcroot = glblDupScan.pszClSrcRoot;
      char *pdstroot = glblDupScan.pszClDstRoot;

      char *pabsnam = pcoi->name();
      if (strbeg(pabsnam, psrcroot))
      {
         // have a dst file. is there a matching dst file?
         char *psrcnam = pabsnam;
         char *psrcrel = pcoi->rootRelName();
         joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pdstroot, psrcrel);
         char *pdst = szRefNameBuf;
         int ihave = fileExists(pdst);
         if (cs.debug && ihave) printf("skip: %s - have target\n", psrcnam);
         if (ihave)
            { glblDupScan.clSkipMatch++; return 0; }
      }
      else
      if (strbeg(pabsnam, pdstroot))
      {
         // have a dst file. is there a matching src file?
         char *pdstnam = pabsnam;
         char *pdstrel = pcoi->rootRelName();
         joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, psrcroot, pdstrel);
         char *psrc = szRefNameBuf;
         int ihave = fileExists(psrc);
         if (cs.debug && ihave) printf("skip: %s - have source\n", pdstnam);
         if (ihave)
            { return 0; } // do not count redundant
      }
   }
   while (0);

   if (irc = glblDupScan.addFile(pcoi))
      return irc;

   char szAddInfo[200];
   sprintf(szAddInfo, "%d files", glblDupScan.clSizes.numberOfEntries());
   info.setStatus("scan", pcoi->name(), szAddInfo);
   return 0;
}
#endif // USE_SFK_BASE

// uses szLineBuf, szLineBuf2
int execAliasList(char *pszFileName, bool *pbIsAlias = 0)
{__
   FILE *fin = fopen(pszFileName, "r");
   if (!fin) return 1; // ignore

   // read header of potential alias batch
   szLineBuf[0] = '\0';
   if (!fgets(szLineBuf, sizeof(szLineBuf)-10, fin))
      { fclose(fin); return 1; } // ignore

   int lRC = 0;

   if (!strncmp(szLineBuf, pszGlblAliasBatchHead, strlen(pszGlblAliasBatchHead)))
   {
      /* get additional info
      char *psz2 = szLineBuf+strlen(pszGlblAliasBatchHead);
      if (*psz2 == ' ') psz2++;
      int nCmdLines = atol(psz2);
      */

      if (pbIsAlias)
         *pbIsAlias = 1;

      // reduce filename back to alias name
      char *psz1 = strrchr(pszFileName, glblPathChar);
      if (psz1) pszFileName = psz1+1;
      int nLen = strlen(pszFileName);
      char *pszBat = strstr(pszFileName, ".bat");
      if (pszBat) nLen = pszBat-pszFileName;

      sprintf(szLineBuf2, "%.*s\t= ", (int)nLen, pszFileName);
      if (chain.coldata) {
         chain.addToCurLine(szLineBuf2, str(""), 1); // 1: add new line first
      } else {
         printf("%s", szLineBuf2);
      }

      // read the actual command lines
      int nMaxLines = 10;
      bool bFirst = 1;
      while (nMaxLines-- > 0)
      {
         if (!fgets(szLineBuf, sizeof(szLineBuf)-10, fin))
            break;
         int nLen2 = strlen(szLineBuf);
         if (nLen2 > 0) nLen2--; // strip linefeed
         char *pszCmd = szLineBuf;
         #ifdef _WIN32
         if ((*pszCmd == '@') && nLen2) { pszCmd++; nLen2--; } // strip silencer
         #else
         if ((*pszCmd == '#') && nLen2) { pszCmd++; nLen2--; } // strip silencer
         #endif
         sprintf(szLineBuf2, "%s%.*s", bFirst ? "":" , ", (int)nLen2, pszCmd);
         if (chain.coldata)
            chain.addToCurLine(szLineBuf2, str(""));
         else
            printf("%s", szLineBuf2);
         bFirst = 0;
      }

      if (!chain.coldata)
         printf("\n");
   }

   fclose(fin);

   return lRC;
}

// for windows: convert "/" to "\\"
void setSystemSlashes(char *pdst)
{
   #ifdef _WIN32
   for (; *pdst; pdst++)
      if (*pdst == glblWrongPChar)
          *pdst = glblPathChar;
   #endif
}

void setNetSlashes(char *pdst)
{
   for (; *pdst; pdst++)
      if (*pdst == '\\')
          *pdst = '/';
}

int execFileStat(Coi *pcoi, int lLevel, int &lFiles, int &lDirs, num &lBytes, num &nLocalMaxTime, num &nTreeMaxTime, int nSinceReason)
{__
   char *pszFileName = pcoi->name();

   /*
   int bIsDir    = 0;
   int bCanRead  = 1;
   int bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   getFileStat(pszFileName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize);
   */

   if (cs.probefiles)
      pcoi->probeFile();

   num  nFileTime = pcoi->getTime();
   num  nFileSize = pcoi->getSize();

   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   if (!cs.nonames) // sfk1934 dir -noname
      listSingleFile(lLevel, pcoi, 0, 0, nSinceReason);

   cs.files++;
   cs.totalbytes += nFileSize;

   if (pcoi->isHidden())
      cs.numHiddenFiles++;

   #ifndef VFILEZIP
   if (cs.travelzips)
   {
      // char *psz1 = strrchr(pszFileName, '.');
      // if (psz1 &&
      //     (   !mystricmp(psz1, ".zip") || !mystricmp(psz1, ".jar")
      //      || !mystricmp(psz1, ".war") || !mystricmp(psz1, ".aar") || !mystricmp(psz1, ".ear")
      //      || !mystricmp(psz1, ".xpi")
      //     )
      //    )
      if (endsWithArcExt(pszFileName, 5))
      {
         // int getZipMD5(char *pszFile, SFKMD5 &md5, FileList &rFileList, bool bMakeList);
         int getZipList(char *pszFile, FileList &rFileList);
         // SFKMD5 md5;
         FileList oFiles;
         // uses szLineBuf2
         char *pszRootZip = pszFileName;
         if (!getZipList(pszRootZip, oFiles))
         {
            int nFiles = oFiles.clNames.numberOfEntries();
            for (int i=0; i<nFiles; i++)
            {
               char *pRelSubName = oFiles.clNames.getEntry(i, __LINE__);
               num nSize = oFiles.clSizes.getEntry(i, __LINE__);
               num nTime = oFiles.clTimes.getEntry(i, __LINE__);

               // construct absolute, double-slashed name of zip file entry
               int nRootLen  = strlen(pszRootZip);
               int nSubLen   = strlen(pRelSubName);
               char *psubname = new char[nRootLen+nSubLen+10]; // TEMPORARY
               if (!psubname) return 9+perr("out of memory");
               sprintf(psubname, "%s%c%c%s", pszRootZip, glblPathChar, glblPathChar, pRelSubName);
               setSystemSlashes(psubname + nRootLen + 2);

               // create a temporary coi, which may be copied in listSingleFile.
               Coi *psub = new Coi(psubname, pszRootZip);
               psub->incref("efs"); // mark as used

               psub->setSize(nSize);
               psub->setTime(nTime);
               listSingleFile(lLevel+1, psub, pszRootZip, 0, nSinceReason);

               // cleanup temporary data
               delete [] psubname;  // was copied in ctr
               if (!psub->decref())
                  delete psub;      // no longer used

               cs.files++;
               cs.totalbytes += nSize;
            }
         }
      }
   }
   #endif

   // update maxtimes
   if (nFileTime > nLocalMaxTime)
       nLocalMaxTime = nFileTime;
   if (nFileTime > nTreeMaxTime)
       nTreeMaxTime = nFileTime;

   lBytes += nFileSize;
   return 0;
}

// for ftpserver folder size limit checks.
// does not support any archive file content scanning.
int execSumFiles(Coi *pcoi, int lLevel, int &lFiles, int &lDirs, num &lBytes, num &nLocalMaxTime, num &nTreeMaxTime)
{__
   char *pszFileName = pcoi->name();

   if (cs.probefiles)
      pcoi->probeFile();

   num  nFileTime = pcoi->getTime();
   num  nFileSize = pcoi->getSize();

   cs.files++;

   cs.totalbytes += nFileSize;

   if (pcoi->isHidden())
      cs.numHiddenFiles++;

   if (nFileTime > nLocalMaxTime)
       nLocalMaxTime = nFileTime;

   if (nFileTime > nTreeMaxTime)
       nTreeMaxTime = nFileTime;

   lBytes += nFileSize;

   return 0;
}

int execFileTime(char *pszFileName)
{__
   FileStat ofs;

   if (ofs.readFrom(pszFileName))
      return 9+pferr(pszFileName, "cannot read: %s\n", pszFileName);

   ofs.dump();

   return 0;
}

int execDirTime(char *pszFileName)
{__
   if (cs.withdirs || cs.justdirs)
      return execFileTime(pszFileName);

   return 0;
}

FileStat glblTouchSrc;

struct FileTouchOpts {
   bool bATime;
   bool bMTime;
   bool bCTime;
   bool bUseWFT;
   int  iCopySrc;
   int  iCopyDst;
   bool bSelf;
} glblTouchOpt;

/*
.
*/
int execTouch(char *pszDst, bool bSingleFileMode)
{__
   FileStat ofdst;
 
   if (ofdst.readFrom(pszDst))
      return 9+pferr(pszDst, "cannot read: %s\n", pszDst);
 
   if (cs.sim) {
      printx("$totouch:<def> %s\n", pszDst);
      return 0;
   }

   if (glblTouchOpt.iCopySrc)
   {
      if (glblTouchOpt.bSelf)
         glblTouchSrc.copyFrom(ofdst);

      // copy unix ctime to mtime etc.
      num nsrc = 0;
      switch (glblTouchOpt.iCopySrc)
      {
         case 1: nsrc = glblTouchSrc.src.nATime; break;
         case 2: nsrc = glblTouchSrc.src.nMTime; break;
         case 3: nsrc = glblTouchSrc.src.nCTime; break;
      }
      switch (glblTouchOpt.iCopyDst)
      {
         case 1: ofdst.src.nATime = nsrc; break;
         case 2: ofdst.src.nMTime = nsrc; break;
         case 3: ofdst.src.nCTime = nsrc; break;
      }

      #ifdef _WIN32
      FILETIME osrc;
      if (glblTouchOpt.bUseWFT)
      {
         switch (glblTouchOpt.iCopySrc)
         {
            case 1: memcpy(&osrc, &glblTouchSrc.src.ftATime, sizeof(glblTouchSrc.src.ftATime)); break;
            case 2: memcpy(&osrc, &glblTouchSrc.src.ftMTime, sizeof(glblTouchSrc.src.ftMTime)); break;
            case 3: memcpy(&osrc, &glblTouchSrc.src.ftCTime, sizeof(glblTouchSrc.src.ftCTime)); break;
         }
         switch (glblTouchOpt.iCopyDst)
         {
            case 1: memcpy(&ofdst.src.ftATime, &osrc, sizeof(ofdst.src.ftATime)); break;
            case 2: memcpy(&ofdst.src.ftMTime, &osrc, sizeof(ofdst.src.ftMTime)); break;
            case 3: memcpy(&ofdst.src.ftCTime, &osrc, sizeof(ofdst.src.ftCTime)); break;
         }
      }
      #endif
   }
   else
   {
      if (glblTouchOpt.bATime) ofdst.src.nATime = glblTouchSrc.src.nATime;
      if (glblTouchOpt.bMTime) ofdst.src.nMTime = glblTouchSrc.src.nMTime;
      if (glblTouchOpt.bCTime) ofdst.src.nCTime = glblTouchSrc.src.nCTime;
 
      #ifdef _WIN32
      if (glblTouchOpt.bUseWFT)
      {
       if (glblTouchOpt.bATime) memcpy(&ofdst.src.ftATime, &glblTouchSrc.src.ftATime, sizeof(ofdst.src.ftATime));
       if (glblTouchOpt.bMTime) memcpy(&ofdst.src.ftMTime, &glblTouchSrc.src.ftMTime, sizeof(ofdst.src.ftMTime));
       if (glblTouchOpt.bCTime) memcpy(&ofdst.src.ftCTime, &glblTouchSrc.src.ftCTime, sizeof(ofdst.src.ftCTime));
      }
      #endif
   }

   if (ofdst.writeTo(pszDst, __LINE__, 1))
      return 9+perr("cannot change time: %s\n", pszDst);

   if (!cs.quiet && (!bSingleFileMode || cs.verbose))
      printx("$touched:<def> %s\n", pszDst);

   return 0;
}

#ifdef WITH_FN_INST
int execInst(char *pszFileName, int lLevel, int &lFiles, int &lDirs, num &lBytes)
{__
   extern int sfkInstrument(char *pszFile, cchar *pszInc, cchar *pszMac, bool bRevoke, bool bRedo, bool bTouchOnRevoke, int nmode);

   // source code automatic instrumentation
   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   int nmode = bGlblInstEol ? 1 : 0;

   int nRC = sfkInstrument(pszFileName, pszGlblInstInc, pszGlblInstMac, bGlblInstRevoke, bGlblInstRedo, bGlblTouchOnRevoke, nmode);

   if (nRC < 9)
      return 0;

   return nRC;
}
#endif

enum eRunExpressions
{
   erun_path      = 0,
   erun_file      = 1,
   erun_upath     = 2,
   erun_ufile     = 3,
   erun_relfile   = 4,
   erun_base      = 5,
   erun_ext       = 6,
   erun_since     = 7,
   erun_text      = 8,
   erun_relpath   = 9,   // sfk1973
   erun_targ      = 10,  // sfk182 with -tomake only
   erun_outext    = 11   // sfk1973 with [f]pic only
};

const char *apRunTokens[] =
{
   // new and simple     kept for compatibility     quoted expressions           new ease
   "path"    , ""      , "purepath"    , "ppath"  , "quotpath"     , "qpath"   , "",
   "file"    , ""      , "purefile"    , "pfile"  , "quotfile"     , "qfile"   , "",
   "upath"   , ""      , ""            , ""       , "quotupath"    , "qupath"  , "",
   "ufile"   , ""      , ""            , ""       , "quotufile"    , "qufile"  , "",
   "relfile" , "rfile" , "purerelfile" , "prfile" , "quotrelfile"  , "qrfile"  , "qrelfile",
   "base"    , ""      , "purebase"    , "pbase"  , "quotbase"     , "qbase"   , "",
   "ext"     , ""      , "pureext"     , "pext"   , "quotext"      , "qext"    , "",
   "since"   , ""      , "puresince"   , "psince" , "quotsince"    , "qsince"  , "",
   "text"    , ""      , ""            , ""       , "quottext"     , "qtext"   , "",
   // sfk1973
   "relpath" , ""      , ""            , ""       , "quotrelpath"  , "qrelpath", "",
   // sfk182 only with -tomake;
   "targ"    , ""      , ""            , ""       , "quottarg"     , "qtarg"   , "",
   // sfk1973 only with [f]pic
   "outext"  , ""      , ""            , ""       , ""             , ""        , "",
};

#define RUNTPR 7  // run tokens per row

// tell if a supplied user command references single files.
// if not, it will be applied on directories only.
bool anyFileInRunCmd(char *pszCmd, bool bIncludePath)
{
   char abToken[100];
   // starts at RUNPTR as path is not a single file
   uint istart = bIncludePath ? 0 : RUNTPR;
   for (uint i=istart; i<(sizeof(apRunTokens)/sizeof(apRunTokens[0])); i++)
   {
      // skip (q)targ if no -tomake
      if (!bGlblGotToMake && !strcmp(apRunTokens[i], "targ"))
         { i += (RUNTPR-1); continue; }
      strcpy(&abToken[1], apRunTokens[i]);
      if (!abToken[1]) continue;
      abToken[0] = '#';
      if (strstr(pszCmd, abToken))
         return true;
      #ifdef SFK_BOTH_RUNCHARS
      abToken[0] = '$';
      if (strstr(pszCmd, abToken))
         return true;
      #endif
   }
   return false;
}

bool anyTextInRunCmd(char *pszCmd)
{
   char abToken[100];
   for (uint i=RUNTPR*7; i<(sizeof(apRunTokens)/sizeof(apRunTokens[0])); i++)
   {
      // skip (q)targ if no -tomake
      if (!bGlblGotToMake && !strcmp(apRunTokens[i], "targ"))
         { i += (RUNTPR-1); continue; }
      strcpy(&abToken[1], apRunTokens[i]);
      if (!abToken[1]) continue;
      abToken[0] = '#';
      if (strstr(pszCmd, abToken))
         return true;
      #ifdef SFK_BOTH_RUNCHARS
      abToken[0] = '$';
      if (strstr(pszCmd, abToken))
         return true;
      #endif
   }
   return false;
}

int onRunExpression(char *psz1, int &lExpLength, bool &bquot, bool &btext)
{
   char abToken[100];
   uint nPtrs = (sizeof(apRunTokens)/sizeof(apRunTokens[0]));
   uint nRows = nPtrs / RUNTPR;
   for (uint irow=0; irow<nRows; irow++)
   {
      // skip (q)targ if no -tomake
      if (!bGlblGotToMake && !strcmp(apRunTokens[irow * RUNTPR], "targ"))
         continue;
      if (!cs.procpic && !strcmp(apRunTokens[irow * RUNTPR], "outext"))
         continue;
      for (uint icol=0; icol < RUNTPR; icol++)
      {
         strcpy(&abToken[1], apRunTokens[irow * RUNTPR +icol]);
         abToken[0] = '#';
         if (!abToken[1]) continue;
         char *psz2 = abToken;
         if (!strncmp(psz1, psz2, strlen(psz2)))
         {
            lExpLength = strlen(psz2);
            bquot = (icol >= 4) ? true : false;
            if (strstr(psz2, "text")) btext=1;
            // if (cs.debug) printf("orp %u %u - %s row %d\n", lExpLength, bquot, psz2, irow);
            return irow;
         }
         #ifdef SFK_BOTH_RUNCHARS
         else {
          abToken[0] = '$';
          if (!strncmp(psz1, psz2, strlen(psz2)))
          {
            lExpLength = strlen(psz2);
            bquot = (icol >= 4) ? true : false;
            if (strstr(psz2, "text")) btext=1;
            // if (cs.debug) printf("orp %u %u - %s row %d\n", lExpLength, bquot, psz2, irow);
            return irow;
          }
         }
         #endif
      }
   }
   // if (cs.debug) printf("orp none in %s\n", psz1);
   return -1;
}

bool isQuoteChar(char c)
{
   switch ((uchar)c)
   {
      case '\"': return 1;
      case '\'': return 1;
      case 0x60: return 1;
      case 0x91: return 1;
      case 0x92: return 1;
      case 0x93: return 1;
      case 0x94: return 1;
   }
   return false;
}

int copyFormStr(char *pszDst, int nMaxDst, char *pszSrc, int nSrcLen, uint nflags=0);

// turn \+file into +file
char *unescf(char *pszFile)
{
   if (pszFile[0] == '\\')
      pszFile++;
   return pszFile;
}

// out   : pDstBuf with MAX_LINE_LEN
// uses  : szLineBuf
// rc    : 0 if replacements done, 1 if none found,
//         >= 9 on format error
int renderOutMask(char *pDstBuf, Coi *pcoi, char *pszMask, cchar *pszCmd, bool bUniPath=0)
{__
   if (cs.debug)
      printf("[render command mask: %s]\n", pszMask);

   if (cs.upath)
      bUniPath = 1;

   char   inPathChar = bUniPath ? '/'  : glblPathChar;
   cchar *inDotSlash = bUniPath ? "./" : glblDotSlash;

   char *pszInFile   = pcoi->name();
   char *pszFileName = pszInFile;

   if (!strncmp(pszFileName, inDotSlash, 2))
      pszFileName += 2;

   // relativize filename. todo: used at all?
   if (cs.rootrelname)
      pszFileName = pcoi->rootRelName();

   // copy command template to command buffer
   copyFormStr(pDstBuf, MAX_LINE_LEN, pszMask, strlen(pszMask));

   // preparations
   char *pszRelFilename = 0;
   if (bUniPath) {
      pszRelFilename = strrchr(pszFileName, '/');
      if (pszRelFilename)
         pszRelFilename++;
      else
         pszRelFilename = pszFileName;
   } else {
      pszRelFilename = relativeFilename(pszFileName);
   }

   bool bDoneAny = 0;
   bool bUsingText = false;

   char *psz1 = pDstBuf;
   int   iexp = 0;

   #ifdef SFK_BOTH_RUNCHARS
   while (*psz1!=0 && *psz1!='#' && *psz1!='$') psz1++;
   #else
   while (*psz1!=0 && *psz1!='#') psz1++;
   #endif

   while (psz1 && *psz1)
   {
      int lTokenLen = 0;
      bool bQuoted  = false;
      // sfk181: support for $$ or ## escape
      if (cs.strict!=0 && psz1[1]==psz1[0]) {
         memmove(psz1,psz1+1,strlen(psz1+1)+1);
         psz1++;
      }
      else
      switch (iexp = onRunExpression(psz1, lTokenLen, bQuoted, bUsingText))
      {
         case erun_file:
         case erun_text:
         case erun_ufile:
         {
            // replace absolute filename
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszFileName);
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            // apply unix path conversion?
            if (iexp == erun_ufile)
               for (int i=0; pDstBuf[i]; i++)
                  if (pDstBuf[i]=='\\')
                     pDstBuf[i]='/';
            bDoneAny = 1;
            break;
         }

         case erun_relfile:
         {
            // replace relative filename
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszRelFilename);
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_path:
         case erun_upath:
         {
            // replace filename path
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
            char *psz3 = strrchr(pszFileName, inPathChar);
            if (psz3 && (psz3-pszFileName)>0)
               strncat(szLineBuf, pszFileName, psz3-pszFileName);
            else
               strcat(szLineBuf, ".");
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            // apply unix path conversion?
            if (iexp == erun_upath)
               for (int i=0; pDstBuf[i]; i++)
                  if (pDstBuf[i]=='\\')
                     pDstBuf[i]='/';
            bDoneAny = 1;
            break;
         }

         case erun_relpath:   // sfk1973
         {
            // replace filename path
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");

            char *psz3 = pcoi->rootRelName();
            char *psz4 = strrchr(psz3, inPathChar);
            if (psz4 && (psz4-psz3)>0
                && strlen(szLineBuf)+strlen(psz3) < MAX_LINE_LEN)
               strncat(szLineBuf, psz3, psz4-psz3);

            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            // apply unix path conversion?
            if (iexp == erun_upath)
               for (int i=0; pDstBuf[i]; i++)
                  if (pDstBuf[i]=='\\')
                     pDstBuf[i]='/';
            bDoneAny = 1;
            break;
         }

         case erun_base:
         {
            // replace file base name, without ".ext"
            // have to use relative filename for this.
            // note: ".afile" has ".afile" as base
            // note: "afile.int.longext" has ".longext" as ext
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
            char *psz3 = strrchr(pszRelFilename, '.');
            if (psz3 && (psz3 > pszRelFilename)) {
               // can identify extension
               strncat(szLineBuf, pszRelFilename, psz3-pszRelFilename);
            } else {
               // cannot identify extension
               strcat(szLineBuf, pszRelFilename);
            }
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_ext:
         {
            // replace file extension
            // have to use relative filename for this.
            // note: ".afile" has ".afile" as base
            // note: "afile.int.longext" has ".longext" as ext
            // note: "afile." has "" as extension
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
            char *psz3 = strrchr(pszRelFilename, '.');
            if (psz3 && (psz3 > pszRelFilename)) {
               // can identify extension, zero length accepted
               strcat(szLineBuf, psz3+1);
            } else {
               // cannot identify extension, leave empty
            }
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_outext:
         {
            // replace $outext
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
            if (pcoi)
               strcat(szLineBuf, pcoi->szClOutExt);
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_since:
         case erun_targ:
         {
            // replace absolute sincedir filename incl. root
            char *pszSinceFile = pcoi->ref(1); // returns null if none
            if (!pszSinceFile) {
               if (iexp == erun_targ) {
                  perr("missing reference name, cannot replace \"targ\" token.\n");
                  pinf("-tomake may not have been specified before.\n");
                  pinf("a previous command may not support passing -tomake names.\n");
               } else {
                  perr("missing reference name, cannot replace \"since\" token.\n");
                  pinf("-sincedir/add/diff may not have been specified before.\n");
                  pinf("a previous command may not support passing -since names.\n");
               }
               return 9;
            }
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszSinceFile);
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         default:
         {
            if (cs.strict) {
               perr("unknown token in command mask: %s\n",psz1);
               if (cs.usevars)
                  pinf("use %c%.20s or %c%c%.20s to escape the text.\n",
                     *psz1,psz1, *psz1,*psz1,psz1);
               else
                  pinf("use %c%.20s ... to escape the text.\n",*psz1,psz1);
               static bool btold=0;
               if (cs.strict<2 && btold==0) {
                  btold=1;
                  pinf("use option -nostrict to ignore. note that this option\n");
                  pinf("may cause a script failure with future sfk versions.\n");
               }
               return 10;
            } else {
               if (cs.debug)
                  printf("[skipping no-mask token: %s]\n",psz1);
            }
            psz1++;
            break;
         }

      }  // end switch

      // find next potential token, if any
      #ifdef SFK_BOTH_RUNCHARS
      while (*psz1!=0 && *psz1!='#' && *psz1!='$') psz1++;
      #else
      while (*psz1!=0 && *psz1!='#') psz1++;
      #endif
   }

   // user error detection:
   // if filename contains blanks,
   if (!bUsingText && !cs.quiet && !cs.noinfo) {
      if (strchr(pszInFile, ' ')) {
         cs.blankRunFiles++;
         // then count quotes in produced expression
         int nlen  = strlen(pDstBuf);
         int nquot = 0;
         for (int i=0; i<nlen; i++)
            if (isQuoteChar(pDstBuf[i]))
               nquot++;
         if (nquot == 0) cs.badNameForm |= 1;
      }
      if (!bUniPath && strchr(pszInFile, glblWrongPChar)) {
         cs.wrongpcRunFiles++;
         cs.badNameForm |= 2;
      }
   }

   return bDoneAny ? 0 : 1;
}

int submain(int argc, char *argv[], char *penv[], char *pszCmd, int iDir, bool &bFatal);

// run program with output to chain redirect
int runExtProg(char *psz)
{
   // sfk198 rerun with new runtime run

   psz = safeRunCommand(psz); // redirect stderr

   #ifdef _WIN32
   FILE *pPipe = _popen(psz, "r");
   #else
   FILE *pPipe = popen(psz, "r"); // no binary support
   #endif

   if (!pPipe)
      return 9+perr("cannot run (err=%d): %s\n", lastErrno(), psz);

   // c:\tools\foo.exe -parm1 -parm2
   // c:\tools\foo.exe
   char *psz2 = strchr(psz, ' ');
   if (!psz2) psz2 = psz+strlen(psz);
   while (psz2>psz && psz2[-1]!=glblPathChar && psz2[-1]!=glblWrongPChar)
      psz2--;
   if (*psz2==glblPathChar || *psz2==glblWrongPChar)
      psz2++;
   char *pszProgName = psz2;

   bool bShowInfo = (chain.coldata && !cs.quiet && !cs.noprog) ? 1 : 0;
   int iLines = 0;

   // can NOT use userInterrupt() check here.
   // to stop external process, user must CTRL+C.

   while (fgets(szLineBuf, MAX_LINE_LEN, pPipe))
   {
      removeCRLF(szLineBuf);
      iLines++;
      if (chain.coldata) {
         if (bShowInfo) {
            info.setAddInfo("%u lines", iLines);
            info.setStatus(pszProgName, szLineBuf, 0, eKeepAdd);
            if (cs.verbose)
               info.printLine(1<<2);
            else
               info.dumpTermStatus();
         }
         chain.addLine(szLineBuf, str(""));
      } else {
         printf("%s\n", szLineBuf);
      }
   }

   #ifdef _WIN32
   int isubrc = _pclose(pPipe);
   #else
   int isubrc = pclose(pPipe);
   #endif

   if (bShowInfo)
      info.clear();

   if (cs.verbose)
      printf("[ext-prog-rc %d]\n", isubrc);

   return 0;
}

int execRunFile(Coi *pcoi, char *pszOutFile,
   int lLevel, int &lFiles, int &lDirs, num &lBytes
   )
{__
   char *pszFileName = pcoi->name();

   mtklog(("execRunFile: %s", pszFileName));

   int nrc = renderOutMask(szRunCmdBuf, pcoi, cs.runCmd, "run"); // execRun
   if (nrc >= 9) return nrc;

   bool bDoneAny = (nrc == 0);

   if (!bDoneAny && !cs.force)
      return 9+perr("no valid token in run command. type \"sfk run\" for help.\n");

   int  iRC = 0;
   bool btoldcmd = 0; // command was fully printed, but w/o rc
   bool btoldrc  = 0; // rc status was printed
   char szRCBuf[100], szAddInfo[200];
   int nclines = 0; // no. of collected lines, if any

   if (cs.sim)
   {
      // simulation: just dump resulting command to terminal
      printf("%s\n", szRunCmdBuf);
      btoldcmd = 1;
   }
   else
   {
      SFTmpFile ftmp(".txt", cperm.keeptmp);
      char *pszTmpFile = 0;

      // if -to outfile specified, OR collecting chain data
      if (!cs.rerun && (pszOutFile || chain.coldata))
      {
         // prepare redirection of command output
         pszTmpFile = pszOutFile ? pszOutFile : ftmp.name();
         if (!pszTmpFile) return 9;
         int nlen = strlen(szRunCmdBuf);
         if (nlen > MAX_LINE_LEN-20)
            return 9+perr("command buffer overflow\n");
         // todo: detect > and print warn if -to used
         // todo: detect > within double quotes
         sprintf(&szRunCmdBuf[nlen], " >\"%s\"", pszTmpFile);
         // todo: detect 2> within double quotes
         if (!strstr(szRunCmdBuf, " 2>")) // AND " 2>>"
            strcat(szRunCmdBuf, " 2>&1");

         // create output directories on demand
         // uses: szLineBuf, abBuf
         if (pszOutFile)
            if (createOutDirTree(pszOutFile))
               return 9;

         // print pre-execution info
         if (cs.printcmd) {
            printf("%s\n", szRunCmdBuf);
            btoldcmd = 1;
         }
         else
         if (!cs.quiet && !cs.rerun) {
            info.setStatus("run", pszFileName); // temporary display
            // cmd is not yet permanently printed
         }
      }
      else if (cs.printcmd) {
         // non-chaining: print command - fix sfk193
         printf("%s\n", szRunCmdBuf);
         btoldcmd = 1;
      }
      else if (!cs.quiet && !cs.rerun) {
         // non-chaining: print filename to terminal
         info.setStatus("run", pszFileName);
         info.printLine(1<<2);
         btoldcmd = 1;
      }

      if (!cs.nonames && chain.coldata) {
         sprintf(szLineBuf3, ":file %s", pszFileName);
         // note: +view scans extended end of attribute line
         //       to identify 'f'ile header lines, therefore +2:
         setattr(szAttrBuf3, 'f', strlen(szLineBuf3)+2, MAX_LINE_LEN);
         chain.addLine(szLineBuf3, szAttrBuf3);
      }

      #ifdef _WIN32
      if (cs.openbyapp)
         ShellExecute(NULL, "open", szRunCmdBuf, NULL, NULL, SW_SHOWNORMAL);
      else
      #endif
      if (cs.rerun) // runfile
         iRC = runExtProg(szRunCmdBuf); // run file
      else
         iRC = system(szRunCmdBuf);

      #if (!defined(USE_SFK_BASE))
      sprintf(szRCBuf, "%d", iRC);
      sfksetvar(str("run.lastrc"), (uchar*)szRCBuf, strlen(szRCBuf), 4); // sfk1973
      #endif

      if (chain.coldata && pszTmpFile)
      {
         // chaining: collect redirected command output
         FILE *fin = fopen(pszTmpFile, "rb");
         if (!fin) return 9+perr("cannot read command output file: %s\n", pszTmpFile);
         myfgets_init();
         while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin))
         {
            szLineBuf[sizeof(szLineBuf)-10] = '\0';
            removeCRLF(szLineBuf);
            chain.addLine(szLineBuf, str(""));
            nclines++;
         }
         fclose(fin);
      }

      // by default, tmpfile is autodeleted here
   }

   if (!cs.quiet && !btoldcmd) {
      if (pszOutFile) {
         if (chain.coldata)
            sprintf(szAddInfo, "cached %d lines, rc %d", nclines, iRC);
         else
            sprintf(szAddInfo, "rc %d", iRC);
         info.setStatus("wrote", pszOutFile, szAddInfo);
         info.printLine(1<<2);
         btoldrc = 1;
      }
      else
      if (chain.coldata && !cs.rerun) {
         sprintf(szAddInfo, "%d lines, rc %d", nclines, iRC);
         info.setStatus("run", pszFileName, szAddInfo);
         btoldrc = 1;
      }
   }

   // extra chain support:
   if (chain.colfiles) {
      // next chain step expects filename list
      if (!chain.usefiles || pszOutFile) {
         // there is either nothing to pass thru,
         // or the filenames changed on output, so create new list:
         if (pszOutFile) {
            Coi ocoi(pszOutFile, 0);
            chain.addFile(ocoi); // is copied
         } else {
            chain.addFile(*pcoi); // pass input file
         }
      }
   }

   if (cs.stoprc && iRC >= cs.stoprc) {
      perr("... rc %d - stopping due to return code.\n",iRC);
      return 19; // fix: sfk181
   }
   else
   if (!cs.quiet && !cs.sim && !btoldrc) {
      if (iRC) {
         printf("... rc %d\n", iRC);
         fflush(stdout);
      }
   }

   return 0;
}

int execRunDir(Coi *pcoi, int lLevel, int &lFiles, int &lDirs, num &lBytes)
{__
   char *pszFileName = pcoi->name();

   if (!strcmp(pszFileName, "."))
      return 0;

   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   // copy command template to command buffer
   copyFormStr(szLineBuf, MAX_LINE_LEN, cs.runCmd, strlen(cs.runCmd), 0);

   bool bDoneAny = 0;

   char *psz1 = szLineBuf;

   #ifdef SFK_BOTH_RUNCHARS
   while (*psz1!=0 && *psz1!='#' && *psz1!='$') psz1++;
   #else
   while (*psz1!=0 && *psz1!='#') psz1++;
   #endif

   while (psz1 && *psz1)
   {
      int lTokenLen = 0;
      bool bQuoted   = false;
      bool bText     = false;
      switch (onRunExpression(psz1, lTokenLen, bQuoted, bText))
      {
         case erun_path:
         case erun_text:
         {
            // replace filename path
            memset(szLineBuf2, 0, sizeof(szLineBuf2));
            strncpy(szLineBuf2, szLineBuf, psz1-szLineBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf2, "\"");
             strcat(szLineBuf2, pszFileName);
            if (bQuoted) strcat(szLineBuf2, "\"");
            // remember position past insert
            psz1 = szLineBuf+strlen(szLineBuf2);
            // right
            strcat(szLineBuf2, psz2);
            // copy back result
            strncpy(szLineBuf, szLineBuf2, sizeof(szLineBuf));
            bDoneAny = 1;
            break;
         }

         default:
            psz1++;
            break;
      }

      // find next potential token, if any
      #ifdef SFK_BOTH_RUNCHARS
      while (*psz1!=0 && *psz1!='#' && *psz1!='$') psz1++;
      #else
      while (*psz1!=0 && *psz1!='#') psz1++;
      #endif
   }

   if (!bDoneAny && !cs.force)
      return 9+perr("no valid token in run command. type \"sfk run\" for help.\n");

   if (!cs.quiet && !cs.sim) {
      printf("%s\n", szLineBuf);
      fflush(stdout);
   }

   int iRC = 0;

   if (cs.sim) {
      // special case: just dump resulting command to terminal
      printf("%s\n", szLineBuf);
   } else {
      if (cs.rerun) // rundir
         iRC = runExtProg(szLineBuf); // run dir
      else
         iRC = system(szLineBuf);
   }

   if (!cs.quiet && !cs.sim) {
      if (iRC) {
         printf("... error, rc %d\n", iRC);
         fflush(stdout);
      }
   }

   // extra chain support:
   if (chain.colfiles) {
      // next chain step expects filename list
      if (!chain.usefiles) {
         // but there is nothing to pass thru, so create
         chain.addFile(*pcoi);
      }
   }

   return 0;
}

int execDirStat(Coi *pcoi, int lLevel, int lFiles, int lDirs, num lBytes, num &nLocalMaxTime, num &ntime2)
{__
   char *pszDir = pcoi->name();

   StringPipe *pout = 0;
   if (chain.coldata)
      pout = chain.outdata;

   if (nGlblListMode == 1)
   {
      int nIndent = (int)lLevel;
      if (nIndent > (int)strlen(pszGlblBlank)) nIndent = strlen(pszGlblBlank);
      if (nIndent > 10) nIndent = 10;
 
      if (!strncmp(pszDir, glblDotSlash, 2))
         pszDir += 2;
 
      int lMBytes = (lBytes / 1000000UL);

      if (cs.statonlysum)
      { }
      else
      if (cs.quiet) {
         if (lLevel == 0)
            oprintf(pout, "%5d mb %s\n", lMBytes, pszDir);
      } else {
         if (lBytes < 0) // for sfk sel -withdirs ... +stat
         { } // print nothing, there are no stats.
         else
         if (lBytes < nGlblListMinSize)
         { } // print nothing, dir content too small to list.
         else
         {
            // dir content size can be listed
            if (lLevel <= cs.stathilitelevel) setTextColor(nGlblFileColor);
            switch (cs.listunit) {
               case 'b':
                  oprintf(pout, "%s, %5d files, %.*s%s\n", numtoa_blank(lBytes, 12), lFiles, nIndent, pszGlblBlank, pszDir);
                  break;
               case 'k':
                  oprintf(pout, "%s kb, %5d files, %.*s%s\n", numtoa_blank(lBytes/1000, 10), lFiles, nIndent, pszGlblBlank, pszDir);
                  break;
               case 'g':
                  oprintf(pout, "%s gb, %5d files, %.*s%s\n", numtoa_blank(lBytes/1000000000, 10), lFiles, nIndent, pszGlblBlank, pszDir);
                  break;
               default :
                  oprintf(pout, "%5ld mb, %5d files, %.*s%s\n", lMBytes, lFiles, nIndent, pszGlblBlank, pszDir);
                  break;
            }
            if (lLevel <= cs.stathilitelevel) setTextColor(-1);
         }
      }
   }
   else
   if (nGlblListMode == 2)
   {
      if ((cs.withdirs || cs.justdirs) && strcmp(pszDir, "."))
         listSingleFile(lLevel, pcoi, 0, 1, 0);
   }

   cs.dirs++;
   if (pcoi->isHidden())
      cs.numHiddenDirs++;

   return 0;
}

bool matchesCurrentRoot(char *pszDir)
{
   if (!glblFileSet.hasRoot(0)) return false;
   char *pszRoot = glblFileSet.getCurrentRoot();
   if (!pszRoot) { perr("internal 812064\n"); return false; }
   bool brc = equalFileName(pszDir, pszRoot);
   // printf("%d = mcr(%s)\n", brc, pszDir);
   return brc;
}

bool isEmptyDir(char *pszIn)
{
   bool bRC = 1;

   int lSize1       = strlen(pszIn);
   char *pszPattern  = new char[lSize1+10];
   char *pszBasePath = new char[lSize1+10];

   // pszIn might be
   // -  a directory, with or w/o slash at end
   // -  a pattern expression: dir\a*b??.cpp
   char *pszLastSlash = strrchr(pszIn, glblPathChar);

   #ifdef _WIN32
   const char *szAddWildCard = "*";
   #else
   const char *szAddWildCard = "";
   #endif

   if (!pszLastSlash) {
      strcpy(pszBasePath, pszIn);
      joinPath(pszPattern, lSize1+10, pszIn, (char*)szAddWildCard);
   } else {
      joinPath(pszPattern, lSize1+10, pszIn, (char*)szAddWildCard);
      strcpy(pszBasePath, pszIn);
   }

   #ifdef _WIN32 // --------- Windows directory walking code ----------

   #ifdef SFK_W64
   SFKFindData myfdat;
   intptr_t myfdh = _findfirst64(pszPattern, &myfdat);
   #else
    #ifndef _INTPTR_T_DEFINED
     typedef int intptr_t;
    #endif
   SFKFindData myfdat;
   intptr_t myfdh = _findfirst(pszPattern, &myfdat);
   #endif

   if (myfdh == -1) {
      delete [] pszPattern;
      delete [] pszBasePath;
      return 1; // yes, seems to be empty
   }

   do
   {

   #else // ----------- unix directory walking code -------------

   SFKFindData myfdat;

   DIR *myfdh = opendir(pszPattern);

   if (!myfdh) {
      delete [] pszPattern;
      delete [] pszBasePath;
      return 1;
   }

   while (1)
   {
      struct dirent *e = readdir(myfdh);
      if (e == NULL)
         break; // while

      memset(&myfdat, 0, sizeof(myfdat));
      myfdat.name   = e->d_name;
      myfdat.attrib = 0;

   #endif // _WIN32
 
      char *pszFile = myfdat.name;

      if (   !strcmp(pszFile, ".")
          || !strcmp(pszFile, ".."))
         continue;

      // first "real" file reached
      bRC = 0;
      break;
   }
   #ifdef _WIN32
    #ifdef SFK_W64
    while (!_findnext64(myfdh, &myfdat));
    #else
    while (!_findnext(myfdh, &myfdat));
    #endif
   _findclose(myfdh);
   #else
   closedir(myfdh);
   #endif

   delete [] pszPattern;
   delete [] pszBasePath;

   if (cs.verbose >= 2)
      printf("%d = isEmptyDir(%s)\n", bRC, pszIn);

   return bRC;
}

// NOTE: walkFiles does NOT accept stack-based AUTOMATIC Coi's!
//       whatever ptop is passed into here must've been created
//       with "new", otherwise the reference counting will fail.
int walkFiles(
   Coi *ptop, int lLevel,
   int &nGlobFiles, FileList &rParentDirFiles,
   int &lDirs, num &lBytes,
   num &nLocalMaxTime, num &nTreeMaxTime
 )
{__ _p("sf.wfiles")

   mtklog(("walkFiles %s", ptop->name()));

   if (bGlblEscape)
      return 0;

   int lRC = 0;

   // this function accepts
   // -  directory Cois   like c:\\thedir
   // -  single file Cois like c:\\thefile.txt

   Coi *psub = 0;

   // in case of a return, make sure dirs are closed:
   AutoCoiDirClose odirclose(ptop);

   #ifdef SFKDEEPZIP
   if (cs.probefiles)
      ptop->probeFile();
   #endif // SFKDEEPZIP

   bool bTravelTop = ptop->isTravelDir();

   #ifndef _WIN32
   // if on top level, reset the circle map, to avoid
   // unwanted blockings on multi-root dir commands:
   if (lLevel <= 0) {
      mtklog((" wfiles1.level0: resetting circle map"));
      glblCircleMap.reset();
   }
   // check for circular (endless) travels:
   if (cs.usecirclemap && bTravelTop && ptop->haveFileID()) {
      if (glblCircleMap.isset(ptop->getFileID())) {
         if (cs.debug)
            pinf("fileid already set: %s\n", ptop->getFileID());
         if (cs.showdupdirs)
            pinf("skipping content, already done: %s\n", ptop->name());
         bTravelTop = 0;
      } else {
         // printf("node %xh is not set: %s\n", (uint)ptop->getNode(),ptop->name());
      }
   }
   #endif

   if (bTravelTop)
   {
      mtklog((" wfiles1.travel %s", ptop->name()));
      // open dir for traversal
      if (ptop->openDir()) {
         if (cs.verbose > 1)
            printf("cannot read dir: %s\n", ptop->name());
         return 0;
      }
      // fetch first entry
      psub = ptop->nextEntry();
      mtklog((" wfiles1.get1st of coi %p sub %p", ptop, psub));
      // caller (we) MUST RELEASE COI after use!
      // if refcnt is zero then, we also DELETE it.
      if (!psub) {
         if (cs.verbose > 1)
            printf("empty dir: %s\n", ptop->name());
         return 0; // empty directory
      }
      #ifdef VFILEBASE
      // if top is virtual, cache it now, as the child members
      // may need the data. do not use ptop->name() to check
      // the cache, as a redirect may have renamed the coi.
      // NOTE: caching is the reason why automatic cois
      //       are strictly not allowed as ptop.
      if (ptop->isVirtual() && !ptop->isCached())
      {
         mtklog(("vpar-register %s", ptop->orgName()));
         glblVCache.put(ptop->orgName(), ptop, "wf");
         // ptop is now MANAGED BY CACHE.
         // cache has incremented the refcnt.
      }
      #endif // VFILEBASE
      #ifndef _WIN32
      // remember that we traveled this directory:
      if (ptop->haveFileID()) {
         // printf("node %xh is stored: %s\n", (uint)ptop->getNode(),ptop->name());
         glblCircleMap.put(ptop->getFileID());
      }
      #endif
   }
   else
   if (ptop->status() >= 9) {
      // non-existing filesystem object:
      if (lLevel < 1 || cs.verbose)
         pwarn("cannot read: %s\n", ptop->name());
      mtklog((" wfiles1.noread %s", ptop->name()));
      return 0;
   } else {
      // process dir or file w/o traveling:
      mtklog((" wfiles1.any %s coi %p", ptop->name(), ptop));
      psub = ptop;
      // NOTE: WE DO NOT OWN psub NOW.
      // must check later if == ptop.
   }

   do
   {
     if (psub->isHidden() && !cs.hidden)
     {
         // hidden or system file or dir,
         // but inclusion of hidden not selected: skip
         if (psub->isAnyDir()) {
            mtklog((" wfiles2.hidden.dir %s", psub->name()));
            cs.numHiddenDirsSkipped++;
         } else {
            mtklog((" wfiles2.hidden.file %s", psub->name()));
            cs.numHiddenFilesSkipped++;
         }
     }
     #ifdef SFKOFFICE
     else // sfk1944 -justoffice filtering
     if (cs.justoffice
         && !psub->isAnyDir()
         && !(psub->isOffice(121,1) || psub->isOfficeSubEntry())
         && matchesFileMask(psub->name(), psub->name(), 10) < 3
         )
     {
         if (nGlblTraceSel & 1) {
            setTextColor(nGlblTraceExcColor);
            info.print("file-exclud: %s (not office)\n", psub->name());
            setTextColor(-1);
         }
     }
     else // sfk1944 apply filemask to office files
     if (cs.office
         && psub->isOffice(122,1) // but not isOfficeSubEntry()
         && !matchesFileMask(psub->name(), psub->name(), 11))
     {
         // skip non-matching .docx etc.
     }
     #endif // SFKOFFICE
     else
     {
      if (psub->isAnyDir())
      {
         // subdirectory
         mtklog((" wfiles2.isdir %s", psub->name()));

         // allowed to travel?
         bool bTravelSub = 0;

         if (psub == ptop) {
            bTravelSub = bTravelTop;
         } else {
            bTravelSub = psub->isTravelDir();
            {
            #ifdef VFILEBASE
             #ifdef DEEP_FTP
             if (psub->isFtp()) { } else
             #endif
             if (psub->isNet()) {
               bTravelSub = 0;
             }
            #endif // VFILEBASE
            }
         }

         FileList oLocDirFiles;
         int nTreeFileCnt = 0;
         int nDirDirs  = 0;
         num  nDirBytes = 0, nDirLocalMaxTime = 0, nDirTreeMaxTime = 0;

         bool bMatch = 1;

         #ifndef USE_SFK_BASE
         // some commands want to skip own meta dir
         if (cs.skipOwnMetaDir) {
            if (filedb.metaDir() && !mystricmp(filedb.metaDir(), psub->name()))
               bMatch = 0;
         }
         #endif // USE_SFK_BASE

         if (cs.hidesubdirs)
            bMatch = 0; // sfk1912: pure -nosub with zip
         else
         if (bMatch)
         {
            bMatch = matchesDirMask(psub->name(), 1, 0, 100); // on subdir
            // ,1 : take full path as it's a dir name
            // ,0 : check only against negative dir masks
         }

         // general processing: recursion and the like
         if (bMatch)
         {
            if (cs.predir==1)
            {
               if (cs.debug) printf("] esd: %d %s files=%d ts=%d sd=%d\n", lLevel, psub->name(), nTreeFileCnt, bTravelSub, cs.subdirs);
               lRC = execSingleDir(psub, lLevel+1, nTreeFileCnt, oLocDirFiles, nDirDirs, nDirBytes,
                                   nDirLocalMaxTime, nDirTreeMaxTime);
               if (cs.stopTree(lRC))
               {
                  nDirLocalMaxTime = 0;
                  break; // while
               }
               lRC = 0;
            }

            if (bTravelSub && cs.subdirs && !(psub->isLink() && cs.skipLinks))
            {
               mtklog((" wfiles2.walksub top=%p sub=%p %s", ptop, psub, psub->name()));
               lRC = walkFiles(psub, lLevel+1, nTreeFileCnt, oLocDirFiles, nDirDirs, nDirBytes,
                               nDirLocalMaxTime, nDirTreeMaxTime);
            } else {
               lRC = 0;
            }

            lDirs++; // count directory as processed

            if (cs.predir==0 && cs.stopTree(lRC)==0)
            {
               if (cs.debug) printf("] esd: %d %s files=%d ts=%d sd=%d\n", lLevel, psub->name(), nTreeFileCnt, bTravelSub, cs.subdirs);
               lRC = execSingleDir(psub, lLevel+1, nTreeFileCnt, oLocDirFiles, nDirDirs, nDirBytes,
                                   nDirLocalMaxTime, nDirTreeMaxTime);
               if (cs.stopTree(lRC))
               {
                  nDirLocalMaxTime = 0;
                  break; // while
               }
               lRC = 0;
            }
            nDirLocalMaxTime = 0;

            // NOTE: local maxtime is NOT promoted, it was used w/in execSingleDir.
            //       we only promote the tree max time:
            if (nDirTreeMaxTime > nTreeMaxTime)
                nTreeMaxTime = nDirTreeMaxTime;

         }  // endif bmatch

         // add subdir stats to next higher level
         if (cs.flatdirstat) {
            cs.flatfilecnt += nTreeFileCnt;
            cs.flatdircnt  += nDirDirs ;
            cs.flatbytecnt += nDirBytes;
         } else {
            nGlobFiles += nTreeFileCnt;
            lDirs      += nDirDirs ;
            lBytes     += nDirBytes;
         }

         if (cs.stopTree(lRC))
            break; // while

         lRC = 0;
      }
      else
      if ((lLevel<1) && bGlblNoRootDirFiles && matchesCurrentRoot(ptop->name())) {
         mtklog((" wfiles2.skip %s", psub->name()));
         // list -dir +simp +test: walk "." but do not process files,
         // we only want to filter the contained directories.
      }
      else
      {
         // normal file: check dir mask also against full file path
         bool bpmmatch = matchesDirMask(psub->name(), cs.incFNameInPath, 1, 101); // on file
         // ,0 : default is not to include filename, extract path first
         // ,1 : check both black and white masks against file path

         int ifmmatch = 0;

         #ifdef SFKOFFICE
         // sfk1944: with -office never match filemask against "/document.xml".
         // getting an officeSubEntry here means checks were done already.
         if (cs.office && psub->isOfficeSubEntry())
            ifmmatch = 1; // not matchesFileMask(psub->name(), psub->name(), 20);
         else
         #endif // SFKOFFICE
            ifmmatch = matchesFileMask(psub->relName(), psub->name(), 2);

         // normal file: check file mask
         if (bpmmatch && (ifmmatch > 0))
         {
            mtklog((" wfiles2.match %s", psub->name()));

            // char *pszRoot = glblFileSet.root(1); // returns 0 if none

            // TODO: set psub->root here?
            if (cs.justdirs) {
               // since sfk 1.5.5, -justdirs counts the number of matching files
               // within a folder, but does not process any of those files.
               lRC = 0;
            } else {
               lRC = execSingleFile(psub, lLevel+1,
                           nGlobFiles, rParentDirFiles.clNames.numberOfEntries(),
                           lDirs, lBytes,
                           nLocalMaxTime, nTreeMaxTime);
            }
 
            if (cs.stopTree(lRC))
               break; // while
            else
            if (!lRC)
            {
               // count file as processed.
               nGlobFiles++;
               if (!cs.skipDirFileColl)
                  // TODO: add to a coi list here?
                  if (rParentDirFiles.addFile(psub->name(), glblFileSet.root(), psub->getTime(), psub->getSize()))
                     return 9; // shouldn't happen (outofmem)
            }
            lRC = 0;
         } else {
            mtklog((" wfiles2.miss  %s pmatch=%d", psub->name(), bpmmatch));
         }
      } // endelse dir or file
     } // endelse hidden

      // cleanup current sub entry:
      if (psub != ptop) {
         // decrement refcnt, and optionally delete
         if (!psub->decref())
            delete psub; // no refs remaining, not cached
         psub = 0;
      }

      if (userInterrupt())
         break;

      if (!bTravelTop)
         break;   // single dir or file processed

      psub = ptop->nextEntry();

      mtklog((" sub %p = wfiles2.getnext of coi %p", psub, ptop));
      mtklog((" (%s = wfiles2.getnext of coi %s)", psub ? psub->name():"", ptop ? ptop->name():""));
   }
   while (psub);

   // cleanup sub on loop break:
   if (psub && (psub != ptop)) {
      if (!psub->decref())
         delete psub; // no refs remaining, not cached
      psub = 0;
   }

   if (bTravelTop) {
      mtklog(("top travel done, close coi %p", ptop));
      ptop->closeDir();
   }

   // mtklog(("%d = walkfiles.end", lRC));
   return lRC;
}

int dumpBlock(uchar *pCur, int lSize, int nmode);
uchar *binPack(uchar *pIn, uint nInSize, ulong &rnOutSize);
uchar *binUnpack(uchar *pIn, uint nInSize, ulong &rnOutSize);
int execBinToJava(uchar *pIn, int lInSize, bool bPack, char *pszNameBase, bool bClass, int nRecSize);
int execBinToCpp(uchar *pIn, int lInSize, bool bPack, char *pszNameBase, bool bHex);

bool equalFileContent(char *pszFile1, char *pszFile2, uchar *psrcmd5=0, uchar *pdstmd5=0)
{
   if (psrcmd5) memset(psrcmd5, 0, 16);
   if (pdstmd5) memset(pdstmd5, 0, 16);
   uchar absum1[20];
   uchar absum2[20];
   if (getFileMD5(pszFile1, absum1)) return false;
   if (psrcmd5) memcpy(psrcmd5, absum1, 16);
   if (getFileMD5(pszFile2, absum2)) return false;
   if (pdstmd5) memcpy(pdstmd5, absum2, 16);
   if (!memcmp(absum1, absum2, 16))
      return 1; // equal
   return 0;
}

// uses szLineBuf. pOutBuf must be >= 16 bytes.
int getFuzzyTextSum(char *pszFile, uchar *pOutBuf)
{
   // this function reads a text file line by line, and
   // - strips line endings
   // - turns all \\ slashes into /
   // - ignores the SEQUENCE of lines
   // to make result files of sfk commands comparable
   // both accross platforms, and independent from the sequence
   // in which files happen to be read from the file system.
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+pferr(pszFile, "cannot read: %s\n", pszFile);
   uchar abSum[16];
   memset(abSum, 0, sizeof(abSum));
   myfgets_init();
   while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin))
   {
      szLineBuf[sizeof(szLineBuf)-10] = '\0';
      removeCRLF(szLineBuf);
      uint nLen = strlen(szLineBuf);
      // turn all non-/ slashes into /
      for (uint i=0; i<nLen; i++)
         if (szLineBuf[i] == '\\')
             szLineBuf[i] = '/';
      if (cs.verbose) printf("sum: \"%s\"\n", szLineBuf);
      // build local checksum over line
      SFKMD5 md5;
      md5.update((uchar*)szLineBuf, nLen);
      // xor this with overall checksum
      unsigned char *pmd5 = md5.digest();
      for (uint k=0; k<16; k++)
         abSum[k] ^= pmd5[k];
   }
   fclose(fin);
   memcpy(pOutBuf, abSum, 16);
   return 0;
}

int getFuzzyTextSum(char *pszText, int iTextLen, uchar *pOutBuf)
{
   uchar abSum[16];
   memset(abSum, 0, sizeof(abSum));
 
   char *pszCur = pszText;
   char *pszMax = pszText + iTextLen;

   bool bStop=0;
   while (pszCur < pszMax)
   {
      char *pszNext = strchr(pszCur, '\n');
      if (!pszNext) {
         pszNext = pszCur+strlen(pszCur);
         bStop=1;
      }

      int iLen = pszNext-pszCur;
      if (iLen > MAX_LINE_LEN)
         break;
      memcpy(szLineBuf, pszCur, iLen);
      szLineBuf[iLen] = '\0';

      removeCRLF(szLineBuf);
      uint nLen = strlen(szLineBuf);
      // turn all non-/ slashes into /
      for (uint i=0; i<nLen; i++)
         if (szLineBuf[i] == '\\')
             szLineBuf[i] = '/';
      if (cs.verbose) printf("sum: \"%s\"\n", szLineBuf);
      // build local checksum over line
      SFKMD5 md5;
      md5.update((uchar*)szLineBuf, nLen);
      // xor this with overall checksum
      unsigned char *pmd5 = md5.digest();
      for (uint k=0; k<16; k++)
         abSum[k] ^= pmd5[k];

      if (bStop)
         break;

      pszCur = pszNext;
      pszCur++;
   }

   memcpy(pOutBuf, abSum, 16);

   return 0;
}

uint getLong(uchar ab[], uint noffs) {
   return  (((uint)ab[noffs+3])<<24)
          |(((uint)ab[noffs+2])<<16)
          |(((uint)ab[noffs+1])<< 8)
          |(((uint)ab[noffs+0])<< 0);
}

uint getShort(uchar ab[], uint noffs) {
   return  (((uint)ab[noffs+1])<< 8)
          |(((uint)ab[noffs+0])<< 0);
}

mytime_t zipTimeToMainTime(num nZipTime)
{
   mytime_t now = mytime(NULL);
   struct tm *tm = 0;
   tm = mylocaltime(&now);
   tm->tm_isdst = -1;

   tm->tm_year = ((int)(nZipTime >> 25) & 0x7f) + (1980 - 1900);
   tm->tm_mon  = ((int)(nZipTime >> 21) & 0x0f) - 1;
   tm->tm_mday = ((int)(nZipTime >> 16) & 0x1f);

   tm->tm_hour = (int)((unsigned)nZipTime >> 11) & 0x1f;
   tm->tm_min  = (int)((unsigned)nZipTime >>  5) & 0x3f;
   tm->tm_sec  = (int)((unsigned)nZipTime <<  1) & 0x3e;

   // rebuild main time
   mytime_t nTime = mymktime(tm); // sfk1933

   // check for overflows
   #ifndef S_TIME_T_MAX
    #define S_TIME_T_MAX ((mytime_t)0x7fffffffUL)
   #endif

   #ifndef U_TIME_T_MAX
    #define U_TIME_T_MAX ((mytime_t)0xffffffffUL)
   #endif

   #define DOSTIME_2038_01_18 ((uint)0x74320000L)
   if ((nZipTime >= DOSTIME_2038_01_18) && (nTime < (mytime_t)0x70000000L))
      nTime = U_TIME_T_MAX;

   if (nTime < (mytime_t)0L) // sfk1933
      nTime = S_TIME_T_MAX;

   return nTime;
}

// offsets taken from InfoZIP's UnZip 5.52:
#define L_VERSION_NEEDED_TO_EXTRACT_0  0
#define L_VERSION_NEEDED_TO_EXTRACT_1  1
#define L_GENERAL_PURPOSE_BIT_FLAG     2
#define L_COMPRESSION_METHOD           4
#define L_LAST_MOD_DOS_DATETIME        6
#define L_CRC32                        10
#define L_COMPRESSED_SIZE              14 // 32-bit
#define L_UNCOMPRESSED_SIZE            18
#define L_FILENAME_LENGTH              22 // 16-bit
#define L_EXTRA_FIELD_LENGTH           24 // 16-bit

#define L_LOCAL_HEADER_SIZE (L_EXTRA_FIELD_LENGTH+2)

// build md5 over a zip file AND:
// -  read all its filenames
// -  check them against provided list

// USES: szLineBuf2
int getZipMD5(char *pszFile, SFKMD5 &md5, FileList &rFileList, bool bMakeList=0)
{__
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;

   size_t nRead = 0;

   while (1)
   {
      uchar abLocHdrPre[4+4];
      uchar abLocHdrPreTpl[] = { 0x50, 0x4b, 0x03, 0x04 };
      uchar abCntDirHdrTpl[] = { 0x50, 0x4b, 0x01, 0x02 };
 
      // read local file header magic.
      nRead = fread(abLocHdrPre,1,4,fin);
      if (nRead <= 0)
         break;   // EOD
      if (nRead != 4) { fclose(fin); return 9; }

      md5.update(abLocHdrPre, 4);
      cs.totalbytes += nRead;
      if (!memcmp(abLocHdrPre, abCntDirHdrTpl, 4))
         break;   // central directory begin: don't parse further
      if (memcmp(abLocHdrPre, abLocHdrPreTpl, 4)) { fclose(fin); return 8; }
 
      // local file header.
      uchar abLocHdr[L_LOCAL_HEADER_SIZE+4];
      if ((nRead = fread(abLocHdr,1,L_LOCAL_HEADER_SIZE,fin)) != L_LOCAL_HEADER_SIZE) { fclose(fin); return 9; }
      md5.update(abLocHdr, L_LOCAL_HEADER_SIZE);
      cs.totalbytes += nRead;
 
      uint nCmpSize     = getLong (abLocHdr, L_COMPRESSED_SIZE);
      uint nFileNameLen = getShort(abLocHdr, L_FILENAME_LENGTH);
      uint nExtraLen    = getShort(abLocHdr, L_EXTRA_FIELD_LENGTH);
      // uint nGenFlags = getShort(abLocHdr, L_GENERAL_PURPOSE_BIT_FLAG);

      // if bit 3 of general purpose is set,
      // bool bDataDesc = ((nGenFlags & (1<<3)) != 0);
      // then nCmpSize is null, and a data descriptor follows.

      // printf("bDataDesc %x nCmpSize %x\n", bDataDesc, nCmpSize);

      // PkZip format seems not to support 64-bit sizes and timestamps.
      // num nTimeStamp = getLong (abLocHdr, L_LAST_MOD_DOS_DATETIME);
      num nFileSize   = getLong (abLocHdr, L_UNCOMPRESSED_SIZE);
      num nZipDOSTime = getLong (abLocHdr, L_LAST_MOD_DOS_DATETIME);
      num nTimeStamp  = zipTimeToMainTime(nZipDOSTime);

      // filename.
      if (nFileNameLen > sizeof(szLineBuf2)-10) { fclose(fin); return 9; }
      if ((nRead = fread(szLineBuf2, 1, nFileNameLen, fin)) != nFileNameLen) { fclose(fin); return 9; }
      md5.update((uchar*)szLineBuf2, nFileNameLen);
      cs.totalbytes += nRead;
 
      // printf("file: %.*s %d\n", (int)nFileNameLen, szLineBuf2, nFileNameLen);

      szLineBuf2[nFileNameLen] = '\0';

      #ifdef _WIN32
      // convert path chars from zip format '/' to local
      char *psz1 = 0;
      while (psz1 = strchr(szLineBuf2, glblWrongPChar))
         *psz1 = glblPathChar;
      #endif

      if (bMakeList)
         rFileList.addFile(szLineBuf2, str(""), nTimeStamp, nFileSize);
      else {
         int lRC = rFileList.checkAndMark(szLineBuf2, nFileSize);
         if (lRC == 1) {
            static bool bInfoDone = 0;
            logError("info   : outdated file \"%s\" in archive \"%s\"", szLineBuf2, pszFile);
            if (!bInfoDone) {
               bInfoDone = 1;
               logError("info   : if you want to cleanup your archive tree later, see 10-stale-list.txt");
            }
            trackStaleZip(pszFile);
         }
         if (lRC == 2) {
            static bool bInfoDone2 = 0;
            logError("error  : size mismatch of \"%s\" in archive \"%s\"", szLineBuf2, pszFile);
            if (!bInfoDone2) {
               bInfoDone2 = 1;
               logError("error  : maybe the file is too large, empty, unaccessible, or not zip compatible.");
            }
         }
      }

      // skip to next local file header.
      num nRemain = nExtraLen + nCmpSize;
      while (nRemain > 0) {
         size_t nBlockLen = sizeof(abBuf)-10;
         if (nBlockLen > nRemain) nBlockLen = nRemain;
         nRead = fread(abBuf,1,nBlockLen,fin);
         if (nRead <= 0)
            break;
         md5.update(abBuf,nRead);
         cs.totalbytes += nRead;
         nRemain -= nRead;
      }
   }

   // read remaining data (central dir) as black box
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      cs.totalbytes += nRead;
   }

   // unsigned char *pmd5 = md5.digest();
   // for (int i=0; i<16; i++)
   //    fprintf(stdout,"%02x",pmd5[i]);
   // printf("\n");

   fclose(fin);
   return 0;
}

#ifndef NO_ZIP_LIST

#ifdef _WIN32
int mygetpos(FILE *f, num &rpos, char *pszFile)
{
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   rpos = (num)npos1;
   return 0;
}
int mysetpos(FILE *f, num pos, char *pszFile)
{
   fpos_t npos1 = (fpos_t)pos;
   if (fsetpos(f, &npos1))
      return 9+perr("setpos failed on %s\n", pszFile);
   return 0;
}
#else
int mygetpos(FILE *f, num &rpos, char *pszFile)
{
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   #if defined(MAC_OS_X) || defined(SOLARIS)
   rpos = (num)npos1;
   #else
   rpos = (num)npos1.__pos;
   #endif
   return 0;
}
int mysetpos(FILE *f, num pos, char *pszFile)
{
   // fetch "status" first
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   #if defined(MAC_OS_X) || defined(SOLARIS)
   npos1 = (fpos_t)pos;
   #else
   npos1.__pos = (__off_t)pos;
   #endif
   if (fsetpos(f, &npos1))
      return 9+perr("setpos failed on %s\n", pszFile);
   return 0;
}
#endif

bool hasData(SOCKET &hSock, int lTimeoutMS, bool bOnConnect=0);

int getZipList(char *pszFile, FileList &rFileList)
{__
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+perr("unable to open: %s\n", pszFile);
 
   int rc=0;
   uint sig;
   fseek(fin, -18, SEEK_END);
   fread(&sig, 1, sizeof(sig), fin);

   #define ENDOFCDIR_SIZE 18
   #define EOCDIR_CDOFFS  12

   num g_diroff = 0; // offset of central directory

   while (1)
   {
      num npos2 = 0;
      if (mygetpos(fin, npos2, pszFile)) {
         fclose(fin);
         return 9;
      }
      if (npos2 <= 32)
         break;

      if (sig==0x06054b50)
      {
         rc = fread(abBuf, 1, ENDOFCDIR_SIZE, fin);
         if (rc == ENDOFCDIR_SIZE)
            g_diroff = getLong(abBuf, EOCDIR_CDOFFS);
         break;
      } else {
         fseek(fin, -5, SEEK_CUR);
         fread(&sig, 1, sizeof(sig), fin);
      }
   }

   #define ZIPFHEAD_SIZE   42
   #define ZIPFNAMLEN_OFFS 24 // 2 bytes
   #define ZIPFCRC_OFFS    12 // 4 bytes
   #define ZIPFCMPS_OFFS   16 // 4 bytes
   #define ZIPFORGS_OFFS   20 // 4 bytes
   #define ZIPFEXTL_OFFS   26 // 2 bytes
   #define ZIPFREML_OFFS   28 // 2 bytes
   #define ZIPFIATTR_OFFS  32 // 4 bytes
   #define ZIPFEATTR_OFFS  34 // 4 bytes

   num npos1 = (num)g_diroff;
   if (mysetpos(fin, npos1, pszFile)) {
      fclose(fin);
      return 9;
   }

   rc = fread(&sig, 1, sizeof(sig), fin);

   while (rc > 3)
   {
      if (sig == 0x02014b50)
      {
         num npos1 = 0;
         if (mygetpos(fin, npos1, pszFile))
            break;

         num boo = (num)npos1;
 
         rc = fread(abBuf, 1, ZIPFHEAD_SIZE, fin);
         if (rc < ZIPFHEAD_SIZE)
            break;
 
         uint nNameLen = getShort(abBuf, ZIPFNAMLEN_OFFS);
         if (nNameLen > MAX_LINE_LEN-10)
            break;
 
         rc = fread(szLineBuf, 1, nNameLen, fin);
         if (rc < (int)nNameLen)
            break;
         szLineBuf[nNameLen] = '\0';

         // under windows, convert slashes
         setSystemSlashes(szLineBuf);

         // directory of file entry?
         // uint nExtAttr = getLong(abBuf, ZIPFEATTR_OFFS);
         // NOTE: attributes are NOT given in JAR files.
         // bool  bIsDir   = (nExtAttr & (0040000UL << 16)) ? 1 : 0;
         // printf("attr %xh dir=%d %s\n",nExtAttr,bIsDir,szLineBuf);
         bool  bIsDir   = endsWithPathChar(szLineBuf);

         // list dirs only if withdirs selected
         if (!bIsDir || cs.withdirs)
         {
            // uint nCRCSum  = getLong(abBuf, ZIPFCRC_OFFS );
            uint nCmpSize = getLong(abBuf, ZIPFCMPS_OFFS);
            uint nOrgSize = getLong(abBuf, ZIPFORGS_OFFS);
 
            uint nExtLen  = getShort(abBuf, ZIPFEXTL_OFFS);
            uint nRemLen  = getShort(abBuf, ZIPFREML_OFFS);
 
            #define ZIPTIME_OFFS ZIPFCRC_OFFS-4
            num nZipDOSTime = getLong (abBuf, ZIPTIME_OFFS);
            num nTimeStamp  = zipTimeToMainTime(nZipDOSTime);
 
            rFileList.addFile(szLineBuf, str(""), nTimeStamp, nOrgSize);
 
            if (nCmpSize) {
               if (fseek(fin, nExtLen+nRemLen, SEEK_CUR))
                  { perr("fseek err #3\n"); break; }
            } else {
               npos1 = (num)(boo+1);
               if (mysetpos(fin, npos1, pszFile))
                  break;
            }
         }
      }
      else {
         if (fseek(fin, -3, SEEK_CUR))
            { perr("fseek err #5\n"); break; }
      }  // endif
 
      rc = fread(&sig, 1, sizeof(sig), fin);
      if (rc < (int)sizeof(sig))
         break;
   }  // endwhile

   fclose(fin);

   return 0;
}
#endif

#ifndef USE_SFK_BASE

int execMetaFileUpdate(char *pszFile)
{
   printf("upd: %s\n", pszFile);
   if (!filedb.updateFile(pszFile))
      cs.files++;
   return 0;
}

int execMetaDirUpdate(char *pszFile)
{
   filedb.updateDir(pszFile);
   return 0;
}

int execMetaFileCheck(char *pszSrc)
{
   cs.files++;

   char szAddInfo[200];
   int nVerOK     = filedb.numberOfVerifies();
   int nVerFailed = filedb.numberOfVerFailed();
   if (nVerFailed > 0)
      sprintf(szAddInfo, "%u files ok, %d failed, %u mb %u kbs", nVerOK, nVerFailed, (uint)(cs.totalbytes/1000000UL), currentKBPerSec());
   else
      sprintf(szAddInfo, "%u files %u mb %u kbs", nVerOK, (uint)(cs.totalbytes/1000000UL), currentKBPerSec());
   info.setProgress(cs.files, filedb.numberOfFiles(), "files");
   info.setStatus("verfy", pszSrc, szAddInfo, eKeepProg);

   int nvrc = filedb.verifyFile(pszSrc);

   if (nvrc >= 9)
      perr("check failed: %s - content modified\n", pszSrc);
   else
   if (nvrc == 8)
      perr("%s - not found in database\n", pszSrc);
   return 0;
}

#endif // USE_SFK_BASE

int execMD5write(Coi *pcoi)
{
   SFKMD5 md5;

   #ifndef SFKPRO
   if (getFileMD5(pcoi->name(), md5))
      return 9;
   #endif

   char *pszRelName = pcoi->name();
   if (bGlblMD5RelNames)
      pszRelName = pcoi->rootRelName();

   unsigned char *pmd5 = md5.digest();
 
   char szMD5[100];

   for (int i=0; i<(cs.crcmd5 ? 4 : 16); i++)
      sprintf(szMD5+i*2,"%02x",pmd5[i]);

   if (fGlblOut) {
      if (cs.tabform)
         fprintf(fGlblOut,"%s\t%s\n",szMD5,pszRelName); // md5sum similar
      else
         fprintf(fGlblOut,"%s *%s\n",szMD5,pszRelName); // md5sum similar
   } else {
      chain.print("%s\t%s\n",szMD5,pszRelName);
   }

   glblFileCount.count();

   if (!cs.quiet) {
      sprintf(szLineBuf, "%u files %u mb %u kbs", glblFileCount.value(), (uint)(cs.totalbytes/1000000UL), currentKBPerSec());
      info.setAddInfoWidth(strlen(szLineBuf));
      info.setStatus("read ", pszRelName, szLineBuf);
   }

   return 0;
}

int execMD5check(char *pIn, char *pszRefDir)
{__
   int nLine=0;
   int nError=0;
   int nNewer=0;
   char *pszLine=pIn;
   char *pszNext=0;
   uint nListSize = strlen(pIn);
   if (nListSize==0) nListSize=1;
   int nSkipCnt = 0;
   int lRC = 0;

   // prerun: determine approx. number of targets
   uint nLF = 0;
   for (uint i=0; i<nListSize; i++)
      if (pIn[i] == '\n')
         nLF++;

   if (nGlblMD5Skip > 0) {
      uint nCover = 100/(1+nGlblMD5Skip);
      if (!cs.quiet)
         printf("spot-checking %02u%% of files (skip=%u).\n", nCover, nGlblMD5Skip);
   }

   // check md5, optionally sped up through skips
   for (;pszLine;pszLine=pszNext)
   {
      pszNext = strchr(pszLine, '\n');
      if (pszNext) *pszNext++ = 0;
      strncpy(szLineBuf, pszLine, sizeof(szLineBuf)-10);
      nLine++;
      if (!strlen(szLineBuf))
         continue;
      if (nGlblMD5Skip > 0) {
         if (nSkipCnt <= 0) {
            nSkipCnt = nGlblMD5Skip;
            // and fall through
         } else {
            nSkipCnt--;
            continue;
         }
      }
      char *psz = strstr(szLineBuf, " *"); // md5sum format
      if (!psz) {
         perr("illegal format in line %d:\n\"%s\"\n",nLine,szLineBuf);
         nError++;
         lRC = 9;
         continue;
      }
      *psz = 0;
      char *pszHex  = szLineBuf;
      if (*pszHex == '\\') pszHex++; // support for md5sum files
      char *pszFile = psz+2;  // skip " *"
      // fix filename ending and path chars
      if ((psz = strchr(pszFile, '\r'))) *psz = 0;
      if ((psz = strchr(pszFile, '\n'))) *psz = 0;
      fixPathChars(pszFile);

      char szAddInfo[200];
      if (nGlblMD5Skip > 0) {
         sprintf(szAddInfo, "%u files %u mb %u kbs skip %u", glblFileCount.value(), (uint)(cs.totalbytes/1000000UL), currentKBPerSec(), nGlblMD5Skip);
      } else {
         sprintf(szAddInfo, "%u files %u mb %u kbs", glblFileCount.value(), (uint)(cs.totalbytes/1000000UL), currentKBPerSec());
      }
      info.setAddInfoWidth(strlen(szAddInfo));
      info.setProgress(nLF, nLine, "files");
      info.setStatus("verfy", pszFile, szAddInfo, eKeepAdd);

      char *pszAbsName = pszFile;
      if (pszRefDir) {
         joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszRefDir, pszFile);
         pszAbsName = szRefNameBuf;
      }

      bool bprocess = 1;
      if (cs.sanecheck)
      {
         num nListTime = cs.sanetime;
         num nFileTime = getFileTime(pszAbsName);
         if (nFileTime > nListTime)
         {
            bprocess = 0;
            nNewer++;
            if (!cs.quiet)
               pinf("skip newer  : %s\n", pszAbsName);
         }
      }

      if (bprocess)
      {
         SFKMD5 md5;      // auto instanciate
         // NOTE: this uses abBuf, so we shouldn't use abBuf here.
         #ifdef SFKINT
         // experimental, bad performance with archives
         Coi *pcoi = new Coi(pszAbsName, 0);
         pcoi->incref("md5c");
         CoiAutoDelete odel(pcoi, 1);
         int isubrc = getFileMD5(pcoi, md5);
         #else
         int isubrc = getFileMD5(pszAbsName, md5);
         #endif
         if (isubrc)
         {
            nError++;   // but continue
            if (lRC < 9) lRC |= 2;
         }
         else
         {
            unsigned char *pmd5 = md5.digest();
            char szBuf2[100];
            for (int i=0; i<(cs.crcmd5 ? 4 : 16); i++)
               sprintf(szBuf2+i*2,"%02x",pmd5[i]);
            if (strcmp(pszHex,szBuf2)) {
               perr("MD5 mismatch: %s\n", pszAbsName); // ,*%s*,*%s*\n", pszFile, pszHex, szBuf2);
               nError++;
               if (lRC < 9) lRC |= 1;
            }
         }
      }

      glblFileCount.count();

      if (userInterrupt())
         break;
   }
   if (cs.sanecheck) {
      info.print("%u newer files were skipped.\n", nNewer);
   }
   if (nError) {
      perr("%u files of %u failed verification.\n", nError, glblFileCount.value());
      info.print("info : %u files checked", glblFileCount.value());
   } else {
      if (cs.quiet < 2)
         info.print("OK. %u files checked", glblFileCount.value());
   }
   if (!cs.quiet)
      info.print(", %u mb, %u sec, %u kb/sec.\n", (uint)(cs.totalbytes/1000000UL), (uint)(currentElapsedMSec()/1000), (uint)currentKBPerSec());
   else if (cs.quiet < 2)
      info.print(".\n");
   fflush(stderr);
   fflush(stdout);
   return lRC;
}

int execJamIndex(char *pszFile)
{
   // strip ".\" at start, if any
   char *psz1 = pszFile;
   if (!strncmp(psz1, glblDotSlash, 2))
         psz1 += 2;
   fprintf(fGlblOut, ":# %s\n", psz1);

   // remember in array of targets
   if (nJamTargets < MAX_JAM_TARGETS-10)
      apJamTargets[nJamTargets++] = strdup(psz1);
   else
      return 9+perr("too many snapfile targets\n");

   return 0;
}

// snapto dump of a single text line
int dumpJamLine(char *pszLine, int nLineLen, bool bAddLF) // len 0: zero-terminated
{
   int lRC = 0;

   if (pGlblJamLineCallBack)
      lRC = pGlblJamLineCallBack(pszLine, nLineLen, bAddLF);
   else
   if (nLineLen > 0)
      fprintf(fGlblOut, "%.*s%s", (int)nLineLen, pszLine, bAddLF?cs.addsnaplf:"");
   else {
      fputs(pszLine, fGlblOut);
      if (bAddLF) fputs(cs.addsnaplf, fGlblOut);
   }

   return lRC;
}

// simple check: if a file contains some nulls, it must be binary.
bool isBinaryFile(char *pszFile)
{
   // using same probe size as Coi::isBinaryFile
   int nCheckLen = MY_GETBUF_MAX - 10;

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 0;

   if (nCheckLen > (int)sizeof(abBuf)-10)
       nCheckLen = (int)sizeof(abBuf)-10;

   int nRead = fread(abBuf, 1, nCheckLen, fin);
   fclose(fin);

   // for (int i=0; i<nRead; i++)
   //    if (abBuf[i] == 0x00)
   //       return 1;
   if (memchr(abBuf, 0, nRead))
      return 1;

   return 0;
}

bool isWhitespace(char *psz, int nlen)
{
   for (int i=0; psz[i] && (i<nlen); i++)
      if (!isspace(psz[i]))
         return 0;
   return 1;
}

bool isEmpty(char *psz)
{
   for (; *psz; psz++)
      if (!isspace(*psz))
         return 0;
   return 1;
}

const char *pGlblBlankBuf160 =
   "                                        "
   "                                        "
   "                                        "
   "                                        ";

#ifdef VFILEBASE
class AutoCacheDrop {
public:
    AutoCacheDrop (Coi *pcoi);
   ~AutoCacheDrop ( );
private:
   Coi *pClCoi;
};

AutoCacheDrop::AutoCacheDrop(Coi *pcoi) {
   pClCoi = pcoi;
}

AutoCacheDrop::~AutoCacheDrop( ) {
   pClCoi->releaseContent(); // IF anything cached
}
#endif // VFILEBASE

void setAddSnapMeta(uint nmask) { cs.addsnapmeta = nmask; }

int (*pGlblCallFileDir)(Coi *pcoi) = 0;

int execCallFileDir(Coi *pcoi)
{
   if (!pGlblCallFileDir) return 9;
   return pGlblCallFileDir(pcoi);
}

int execSnapThrough(Coi *pcoi);

int bGlblPassThroughSnap = 0;

// snapto collect single file
int execJamFile(Coi *pcoi)
{__ _p("sf.jamfile")

   cchar *pPrefix = pszGlblJamPrefix ? pszGlblJamPrefix : ":file:";
   char *pHeadLine = (char*)pPrefix;

   static char szFullName[SFK_MAX_PATH+10];
   static char szArchName[SFK_MAX_PATH+10];
   static char szSubFile[SFK_MAX_PATH+10];

   char szHeadBuf[250];
   mclear(szHeadBuf);
   szFullName[0] = '\0';
   szArchName[0] = '\0';
   szSubFile[0] = '\0';

   #ifdef VFILEBASE
   // when adding file content to a collection,
   // we can always expect that the source data can be
   // dropped from cache afterwards, therefore:
   AutoCacheDrop odrop(pcoi);
   #endif // VFILEBASE

   bool bIsBinary = pcoi->isBinaryFile();
   // also sets: isUTF16, isSnapFile
   bool bIsSnap   = pcoi->isSnapFile();
 
   if (bIsSnap)
   {
      if (!bGlblPassThroughSnap)
      {
         pinf("skipping snap file: %s\n", pcoi->name());
         return 0; // skip
      }
 
      return execSnapThrough(pcoi);
   }

   mtklog(("load: execjam: bin=%d %s", bIsBinary, pcoi->name()));

   strcopy(szFullName, pcoi->name());

   num  nOFileTim = 0;
   num  nOFileSiz = 0;

   #ifdef SFKOFFICE
   // sfk1934: snapto: prepare to add archive meta infos
   if (cs.office && mystrrstr(szFullName, glblDubPathStr))
   {
      strcopy(szArchName, szFullName);
      char *pxsla = mystrrstr(szArchName, glblDubPathStr);
      if (pxsla) {
         *pxsla++ = '\0';
         int b1=0,b2=0,b3=0;
         if (getFileStat(szArchName, b1, b2, b3, nOFileTim, nOFileSiz))
            { nOFileTim=0; nOFileSiz=0; }
         // char *psz = strrchr(pxsla, glblPathChar);
         // if (psz) pxsla = psz;
         // strcopy(szSubFile, pxsla);
         // if (!strbeg(szSubFile+1, "sheet")
         //     && !strbeg(szSubFile+1, "slide"))
         //    szSubFile[0] = '\0';
      }
   }
   #endif // SFKOFFICE

   if (cs.addsnapmeta)
   {
      bool baddtime = (cs.addsnapmeta & (1<<0)) ? 1 : 0;
      bool baddsize = (cs.addsnapmeta & (1<<1)) ? 1 : 0;
      bool baddcode = (cs.addsnapmeta & (1<<2)) ? 1 : 0;

      // prepare subfile header with time etc.     123456789012345678901234567890
      char szTimeInfo[50]; mclear(szTimeInfo);  // time=1234567890
      char szSizeInfo[50]; mclear(szSizeInfo);  // size=1000000000
      char szOTimeInf[50]; mclear(szOTimeInf);  // otime=1234567890
      char szOSizeInf[50]; mclear(szOSizeInf);  // osize=1000000000
      char szCodeInfo[50]; mclear(szCodeInfo);  // code=utf16le
      char szWebInfo[50];  mclear(szWebInfo);   // webrc=404_error_page

      int nMetaLen = 0;

      if (baddtime) {
         num nFileTime = pcoi->getTime();
         strcpy(szTimeInfo, " mtime=");
         numtoa(nFileTime,1,szTimeInfo+7);
         nMetaLen += strlen(szTimeInfo);
      }

      if (baddsize) {
         num nFileSize = pcoi->getSize();
         strcpy(szSizeInfo, " size=");
         numtoa(nFileSize,1,szSizeInfo+6);
         nMetaLen += strlen(szSizeInfo);
      }

      if (baddtime && nOFileTim) { // sfk1934 snapto add outer time
         strcpy(szOTimeInf, " otime=");
         numtoa(nOFileTim,1,szOTimeInf+7);
         nMetaLen += strlen(szOTimeInf);
      }

      if (baddsize && nOFileSiz) { // sfk1934 snapto add outer size
         strcpy(szOSizeInf, " osize=");
         numtoa(nOFileSiz,1,szOSizeInf+7);
         nMetaLen += strlen(szOSizeInf);
      }

      if (baddcode && pcoi->isUTF16()) {
         sprintf(szCodeInfo, " code=utf16%s", (pcoi->isUTF16()==0xFE)?"le":"be");
         nMetaLen += strlen(szCodeInfo);
      }

      #ifdef VFILEBASE
      char *pwebrc = pcoi->header("webrc");
      if (pwebrc) {
         int nwebrc = atol(pwebrc);
         if (nwebrc >= 400) {
            sprintf(szWebInfo, " content=%s_error_page", pwebrc);
            nMetaLen += strlen(szWebInfo);
         }
      }
      #endif // VFILEBASE

      int nPreLen  = strlen(pPrefix);
      if (nPreLen > 50) nPreLen = 50;

      int nPadLen  = 78 - nPreLen - nMetaLen;
      if (nPadLen < 0) nPadLen = 0;

      // construct padded headline with meta informations
      snprintf(szHeadBuf, sizeof(szHeadBuf), "%.50s%.*s%.40s%.40s%.40s%.40s%.40s%.40s",
         pPrefix, (int)nPadLen, pGlblBlankBuf160,  //    tim  siz  otm  osz  cod  web
         szTimeInfo, szSizeInfo, szOTimeInf, szOSizeInf, szCodeInfo, szWebInfo);

      pHeadLine = szHeadBuf;
   }

   int lRC = 0;
   bool bSkipCnt = 0;

   if (cs.addsnapraw)
   {
      // raw mode:

      if (bIsBinary) {
         // skip all binaries
         if (glblFileCount.countSkip(szFullName)) {
            if (pGlblJamStatCallBack) {
               int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(cs.totalbytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog(("%d = jam.stat.callback.5", nrc));
               lRC |= nrc;
            } else {
               info.setAddInfo("%u files, %u lines, %u mb", (uint)glblFileCount.value(), (uint)cs.lines, (uint)(cs.totalbytes/1000000UL));
               info.setStatus("skip", szFullName, 0, eKeepAdd);
            }
         }
         return lRC;
      }

      // add text files 1:1 keeping exactly the same size,
      // and skip all binary files. no conversions whatsoever.
      if (pcoi->open("rb"))
         { pwarn("cannot read: %s%s\n", szFullName,pcoi->lasterr()); return 0; }

      // . write subfile header
      if (!bGlblJamPure)
      {
         lRC |= dumpJamLine(pHeadLine , 0, 1);   // :file: mtime size
         lRC |= dumpJamLine(szFullName, 0, 1);   // actual filename
         if (cs.office && szSubFile[0])
            lRC |= dumpJamLine(szSubFile, 0, 1); // e.g. workbook.xml
      }

      while (true)
      {
         num nRead  = pcoi->read(abBuf, sizeof(abBuf)-1000);
         if (nRead <= 0)
            break;

         if (cs.addsnapraw < 2)
         {
            // replace (unexpected) NULL or EOF characters by '.'
            // also counting the lines
            for (int i=0; i<nRead; i++)
               switch (abBuf[i]) {
                  case 0: case 0x1A: abBuf[i] = '.'; break;
                  case '\n': cs.lines++; break;
               }
         } else {
            // just count the lines
            for (int i=0; i<nRead; i++)
               if (abBuf[i] == '\n')
                  cs.lines++;
         }

         num nWrite = myfwrite(abBuf, nRead, fGlblOut);
         if (nWrite != nRead) {
            perr("failed to fully write %d bytes, possibly disk full\n", (int)nWrite);
            pcoi->close();
            return 9;
         }

         cs.totalbytes += nRead;

         // check per block if stat update is required
         if (glblFileCount.checkTime())
         {
            if (pGlblJamStatCallBack) {
               int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(cs.totalbytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog(("%d = jam.stat.callback.4", nrc));
               lRC |= nrc;
            } else {
               info.setAddInfo("%u files, %u mb", (uint)glblFileCount.value(), (uint)(cs.totalbytes/1000000UL));
               info.setStatus("snap", szFullName, 0, eKeepAdd);
            }
         }
 
         // STOP in-file processing on non-zero rc
         if (lRC) break;
      }

      pcoi->close();

      lRC |= dumpJamLine(str(""), 0, 1);
   }
   else
   if (bIsBinary || cs.rewrap)
   {
      if (cs.rewrap) {
         mtklog(("rewrap file, %d",cs.incbin));
      } else {
         mtklog(("binary file, %d",cs.incbin));
      }

      // should the binary (or forced wrap) file be included?
      bool bProcess = cs.incbin;  // global switch, process all

      bProcess |= cs.infilelist;  // within explicite file list

      // text in forced wrap mode: always include
      if (!bIsBinary && cs.rewrap) bProcess = 1;

      if (!bProcess)
      {
         // binary.whitelist: force binary loading
         //    if listed in a white list file mask.
         int   ilimit = 3; // default: require extension match
         if (cs.incwlbin)
               ilimit = 2; // reduce to file mask white listing
         char *pszRel = pcoi->relName();
         // if (matchesFileMask(pszRel, szFullName, 3) > 1)    // sfk1943 matches by non-wildcard pattern
         if (matchesFileMask(pszRel, szFullName, 3) >= ilimit) // sfk1944 matches by .ext
            bProcess = 1;
      }

      // optional check if target accepts file
      if (bProcess && pGlblJamCheckCallBack) {
         if (pGlblJamCheckCallBack(szFullName))
            bProcess = 0;
      }

      // if not, skip
      if (!bProcess) {
         if (glblFileCount.countSkip(szFullName)) {
            if (pGlblJamStatCallBack) {
               int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(cs.totalbytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog(("%d = jam.stat.callback.1", nrc));
               lRC |= nrc;
            } else {
               info.setAddInfo("%u files, %u lines, %u mb", (uint)glblFileCount.value(), (uint)cs.lines, (uint)(cs.totalbytes/1000000UL));
               info.setStatus("skip", szFullName, 0, eKeepAdd);
            }
         }
         return lRC;
      }

      // open binary for read
      if (pcoi->open("rb"))
         { pwarn("cannot read: %s%s\n", szFullName,pcoi->lasterr()); return 0; }

      // write subfile header
      lRC |= dumpJamLine(pHeadLine   , 0, 1);   // :file: mtime size
      lRC |= dumpJamLine(szFullName, 0, 1);     // actual filename
      if (cs.office && szSubFile[0])
         lRC |= dumpJamLine(szSubFile, 0, 1);   // e.g. workbook.xml
      if (lRC)
         return lRC;

      // convert binary to text
      BinTexter bt(pcoi);
      lRC = bt.process(BinTexter::eBT_JamFile);
      pcoi->close();
      if (lRC)
         return lRC;

      // trailer
      lRC |= dumpJamLine(str(""), 0, 1);
   }
   else
   if (pGlblJamFileCallBack)
   {
      num nLocalBytes = 0;
      num nLocalLines = 0;
      lRC = pGlblJamFileCallBack(szFullName, nLocalLines, nLocalBytes);
      // should include header, trailer generation
      cs.lines   += nLocalLines;
      cs.totalbytes += nLocalBytes;
   }
   else
   {
    // optional check if target accepts file
    if (pGlblJamCheckCallBack) {
       if (pGlblJamCheckCallBack(szFullName))
          return 1; // skipped
    }

    // add file content, check for illegal entries
    if (pcoi->open("rb"))
      { pwarn("cannot read: %s%s\n", szFullName,pcoi->lasterr()); return 0; }

    int nMaxLineLen = sizeof(szLineBuf)-10; // YES, szLineBuf
    memset(abBuf, 0, nMaxLineLen+2); // yes, abBuf is larger by far
    int  nLocalLines = 0;
    bool bWrapMode  = (cs.wrapcol > 0) ? 1 : 0;
    int  nLineLen   = 0;
    bool bPassSnap  = 0;
    bool bNoTrailer = 0;
    bool bEmptyLine = 0;

    while (1)
    {
      nLineLen = pcoi->readLine((char*)abBuf, nMaxLineLen);

      // fix: sfk175: do not completely ignore empty files
      if (nLineLen <= 0)
      {
         // empty line stops reading only if not first line
         bEmptyLine = 1;
         if (nLocalLines > 0)
            break;
      }

      cs.lines++;
      nLocalLines++;

      if (nLineLen == nMaxLineLen)
         pwarn("max line length %d reached, splitting. file %s, line %d\n", nMaxLineLen, szFullName, nLocalLines);

      // safety: escape unexpected (mal-format) headers within content
      if (   startsLikeSnapFile((char*)abBuf)
          || strBegins((char*)abBuf, pPrefix)
         )
      {
         if (nLineLen > nMaxLineLen-10)
            continue; // drop

         memmove(abBuf+1,abBuf+0,nLineLen+1); // with zero terminator
         abBuf[0] = '\'';
         nLineLen++;
      }

      if (nLocalLines == 1)
      {
         // first local line: also write header
         if (!bGlblJamPure)
         {
            lRC |= dumpJamLine(pHeadLine   , 0, 1); // :file: mtime size
            lRC |= dumpJamLine(szFullName, 0, 1);   // actual filename
            if (cs.office && szSubFile[0])
               lRC |= dumpJamLine(szSubFile, 0, 1); // e.g. workbook.xml
         }
      }

      if (bWrapMode && ((int)strlen((char*)abBuf) > cs.wrapcol))
      {
         // auto-wrap input line into many smaller output lines
         char *psz1 = (char*)abBuf;
         char *pszOld = 0;
         while (*psz1)
         {
            pszOld = psz1;
            int icnt = 0;
            char *pszGap = 0;
            // step until overflow or eod, remember last whitespace
            while (*psz1 && (icnt < cs.wrapcol)) {
               char c = *psz1;
               switch (c) {
                  case ' ': case '\t': case ',':
                     pszGap = psz1;
                     break;
               }
               psz1++;
               icnt++;
            }
            // if overflow, go back past whitespace. if no whitespace,
            // make a word break at that point (splitting very long words).
            if (*psz1) {
               if (pszGap)
                  psz1 = pszGap+1;
            }
            int nLen = psz1-pszOld;
            if (nLen < 5 && isWhitespace(pszOld, nLen))
               { } // cut trailing whitespace
            else
               lRC |= dumpJamLine(pszOld, nLen, *psz1 ? 1 : 0);
            // continue past whitespace or word break.
         }
      } else {
         if (nLineLen > 0 && abBuf[nLineLen-1] == '\n')
            lRC |= dumpJamLine((char*)abBuf, 0, 0); // has own LF
         else
            lRC |= dumpJamLine((char*)abBuf, 0, 1);
      }

      cs.totalbytes += nLineLen;
      abBuf[nMaxLineLen] = '\0';

      // check per line if stat update is required
      if (glblFileCount.checkTime())
      {
         if (pGlblJamStatCallBack) {
            int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(cs.totalbytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
            mtklog(("%d = jam.stat.callback.2", nrc));
            lRC |= nrc;
         } else {
            info.setAddInfo("%u files, %u lines, %u mb", (uint)glblFileCount.value(), (uint)cs.lines, (uint)(cs.totalbytes/1000000UL));
            info.setStatus("snap", szFullName, 0, eKeepAdd);
         }
      }

      // STOP in-file processing on non-zero rc
      if (lRC || bEmptyLine)
         break;

    } // endwhile lines

    pcoi->close();

    lRC |= dumpJamLine(str(""), 0, 1);
 
    // FIX 1652: do not count empty text files
    if (nLocalLines <= 0)
      bSkipCnt = 1;
 
   } // endelse binary
 
   // FIX 1652: stop of load within file: don't count last file
   if (lRC >= cs.treeStopRC)
      bSkipCnt = 1;

   if (!bSkipCnt && glblFileCount.count())
   {
      if (pGlblJamStatCallBack) {
         int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(cs.totalbytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
         mtklog(("%d = jam.stat.callback.3", nrc));
         lRC |= nrc;
      } else {
         info.setAddInfo("%u files, %u lines, %u mb", (uint)glblFileCount.value(), (uint)cs.lines, (uint)(cs.totalbytes/1000000UL));
         info.setStatus("snap", szFullName, 0, eKeepAdd);
      }
   }

   return lRC;
}

int execSnapThrough(Coi *pcoi)
{__
   // expecting: auto cache drop is done by caller

   cchar *pPrefix = pszGlblJamPrefix ? pszGlblJamPrefix : ":file:";
   char *pHeadLine = (char*)pPrefix;

   char szHeadBuf[250];
   mclear(szHeadBuf);

   int lRC  = 0;

   // add file content, check for illegal entries
   if (pcoi->open("rb"))
     { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

   int nMaxLineLen = sizeof(szLineBuf)-10; // YES, szLineBuf
   memset(abBuf, 0, nMaxLineLen+2); // yes, abBuf is larger by far
   int nLocalLines = 0;
   bool bWrapMode = (cs.wrapcol > 0) ? 1 : 0;
   int nLineLen  = 0;
   bool bPassSnap = 0;
   bool bNoTrailer = 0;
 
   bool bHeadArea = 1;

   while (pcoi->readLine((char*)abBuf, nMaxLineLen) > 0) // yes, exact len
   {
      cs.lines++;
      nLocalLines++;

      nLineLen = strlen((char*)abBuf);
      if (nLineLen == nMaxLineLen)
         pwarn("max line length %d reached, splitting. file %s, line %d\n", nMaxLineLen, pcoi->name(), nLocalLines);

      // as long as head area, don't pass anything.
      // we do not accept any differing prefix.
      if (bHeadArea)
      {
         if (!strBegins((char*)abBuf, pPrefix))
            continue;
 
         // first :file: reached, end of head area.
         bHeadArea = 0;
      }

      // safety: escape unexpected (mal-format) headers within content
      if (startsLikeSnapFile((char*)abBuf))
      {
         if (nLineLen > nMaxLineLen-10)
            continue; // drop
 
         memmove(abBuf+1,abBuf+0,nLineLen+1); // with zero terminator
         abBuf[0] = '\'';
         nLineLen++;
      }

      // also count subfiles as files, however processing of those
      // headers is done by receiver.
      if (strBegins((char*)abBuf, pPrefix))
      {
         if (glblFileCount.count())
         {
            if (pGlblJamStatCallBack) {
               int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(cs.totalbytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog(("%d = jam.stat.callback.3", nrc));
               lRC |= nrc;
            } else {
               info.setAddInfo("%u files, %u lines, %u mb", (uint)glblFileCount.value(), (uint)cs.lines, (uint)(cs.totalbytes/1000000UL));
               info.setStatus("snap", pcoi->name(), 0, eKeepAdd);
            }
         }
      }

      if (nLineLen > 0 && abBuf[nLineLen-1] == '\n')
         lRC |= dumpJamLine((char*)abBuf, 0, 0); // has own LF
      else
         lRC |= dumpJamLine((char*)abBuf, 0, 1);

      cs.totalbytes += strlen((char*)abBuf);
      abBuf[nMaxLineLen] = '\0';

      // STOP in-file processing on non-zero rc
      if (lRC) break;

   } // endwhile lines

   pcoi->close();

   return lRC;
}

Array glblRefDst("RefDst");
StringTable glblRefSrc;
StringTable glblRefDstNames;
uchar abGlblRefChars[256];   // map of chars used in destination names

int execRefColDst(Coi *pcoi)
{__
   char *pszFile = pcoi->name();

   char szAddInfo[200];
   sprintf(szAddInfo, "%u targets", glblRefDst.numberOfEntries(0)+1);
   info.setStatus("scan", pszFile, szAddInfo);

   if (cs.rootrelname)
      pszFile = pcoi->rootRelName();

   strncpy(szLineBuf, pszFile, sizeof(szLineBuf)-10);
   szLineBuf[sizeof(szLineBuf)-10] = '\0';

   // force path chars to system path char.
   // the same is done in the source contents to ease comparison.
   char *psz2 = szLineBuf;
   while (*psz2) {
      if (*psz2 == glblWrongPChar)
         *psz2 = glblPathChar;
      psz2++;
   }

   #ifdef _WIN32
   // create lowercase filename, we want to compare case-insensitive
   if (!cs.usecase) {
      char *psz1 = szLineBuf;
      while (*psz1) {
         if (sfkisalpha(*psz1))
            *psz1 = sfktolower(*psz1);
         psz1++;
      }
   }
   #endif

   // create map of used chars in dest. names, for search optim
   for (uchar *psz5=(uchar*)szLineBuf; *psz5; psz5++)
      abGlblRefChars[*psz5] = 1;

   // RefDst Array (Table) structure
   // ==============================
   //    0     1     2     3     4     ...
   // dstName1 rcnt  src1  src2 ""     ...
   // dstName2 rcnt  src1  src2 src3   ...
   // dstName3 rcnt  src1  ""   ""     ...

   glblRefDst.addString(0, szLineBuf);
   glblRefDst.addLong(1, 0, __LINE__);
   for (int i=0; i<nGlblRefMaxSrc; i++)
      glblRefDst.addNull(2+i);

   return 0;
}

bool isFileNameChar(char c) {
   if (isalnum(c)) return true;
   switch (c) {
      case glblPathChar: return true;
      case glblWrongPChar: return true;
      case '_': return true;
      case ':': return true;
      case '.': return true;
      case '-': return true;
      case '#': return true;
   }
   return false;
}

int execRefColSrc(char *pszFile)
{__
   cs.refsrccnt++;

   char szAddInfo[200];
   sprintf(szAddInfo, "%u sources", cs.refsrccnt);
   info.setStatus("scan", pszFile, szAddInfo);

   // remember also list of source files
   glblRefSrc.addEntry(pszFile);

   // used when auto-including targets as internal sources
   if (cs.coldstnames)
      glblRefDstNames.addEntry(pszFile);

   return 0;
}

int execRefProcSrc(char *pszFile, char *pszOptRoot, int icur, int ntotal)
{__
   if (userInterrupt())
      return 9;

   info.setAddInfo("%d files of %d",icur,ntotal);
   info.setProgress(ntotal, icur, "files");
   info.setStatus("scan", pszFile, 0, eKeepAdd|eKeepProg);

   if (cs.debug) {
      info.printLine(1<<2);
   }

   num nFileSize = getFileSize(pszFile);
   if (nFileSize <= 0)
      return 0;
   if (nFileSize >= nGlblMemLimit) {
      pwarn("file too large, skipping: %s\n", pszFile);
      return 0;
   }

   // load native file content
   char *pInFile = new char[nFileSize+10];
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      pferr(pszFile, "cannot read: %s\n", pszFile);
      delete [] pInFile;
      return 0;
   }
   unsigned int nRead = fread(pInFile, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      pferr(pszFile, "cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pInFile;
      return 0;
   }
   pInFile[nFileSize] = '\0';

   // convert content to allow strstr.
   // in case of windows prepare case-insensitive comparison.
   // force all path chars to use system path char.
   #ifdef _WIN32
   bool bCase = cs.usecase;
   #endif

   if (cs.refstripsrc)
   {
      // strip source file content from all characters
      // that have not appeared in target filenames.
      uint i1=0, i2=0;
      uint clast = 0xFFFF;
      for (; i1<nFileSize; i1++)
      {
         uchar c = (uchar)pInFile[i1];
 
         #ifdef _WIN32
         if (sfkisalpha((char)c) && !bCase)
            c = (uchar)sfktolower((char)c);
         #endif
 
         if (!abGlblRefChars[c])
         {
            // flatten binary stuff
            c = 0xFF;
            // reduce if possible
            if (c == clast) continue;
            pInFile[i2++] = (char)c;
            clast = c;
            continue;
         }
         clast = 0xFFFF;
 
         // copy-through readable text char
         if (c == (uchar)glblWrongPChar)
            pInFile[i2++] = glblPathChar;
         else
            pInFile[i2++] = (char)c;
      }
      if (i2 > nFileSize) return 9+perr("internal #278242039\n");
      pInFile[i2] = '\0'; // including offset nFileSize, as above
   }
   else
   {
      for (uint i=0; i<nFileSize; i++)
      {
         char c = pInFile[i];
         if (c == '\0')
            pInFile[i] = ' ';
         else
         if (c == glblWrongPChar)
            pInFile[i] = glblPathChar;
         #ifdef _WIN32
         else
         if (sfkisalpha(c) && !bCase)
            pInFile[i] = sfktolower(c);
         #endif
      }
   }

   // for all dst entries
   for (int idst=0; idst<glblRefDst.numberOfEntries(0); idst++)
   {
      char *pszDstRaw = glblRefDst.getString(0, idst);
      char *pszDst    = pszDstRaw;

      // do NOT add our own name as a ref
      if (!strcmp(pszDstRaw, pszFile))
         continue;

      // check for any occurrence of relativized pszDst
      if (bGlblRefRelCmp) {
         char *pszRel = strrchr(pszDst, glblPathChar);
         if (pszRel) pszDst = pszRel+1;
         if (cs.debug) info.print("REL *%s* \n", pszDst);
      }

      // use only basename of pszDst?
      if (bGlblRefBaseCmp) {
         strncpy(szLineBuf, pszDst, sizeof(szLineBuf)-10);
         szLineBuf[sizeof(szLineBuf)-10] = '\0';
         char *pszDot = strrchr(szLineBuf, '.');
         if (pszDot) *pszDot = '\0';
         pszDst = szLineBuf;
         if (cs.debug) info.print("BAS *%s* \n", pszDst);
      }

      char *pszHit = 0;
      if ((pszHit = strstr(pInFile, pszDst)))
      {
         // increment reference count for target
         int iCnt = glblRefDst.getLong(1, idst, __LINE__);
         glblRefDst.setLong(1, idst, iCnt+1, __LINE__);

         // remember (some) source infos referencing this target
         char *pszPre = pszHit;
         while (pszPre > pInFile) {
            #ifdef _WIN32
            bool bColon = (*pszPre == ':');
            #endif
            if (!isFileNameChar(*(pszPre-1)))
               break;
            pszPre--;
            #ifdef _WIN32
            if (bColon)
               break;
            #endif
         }
         char *pszPost = pszHit;
         while (pszPost < pInFile+nFileSize-1) {
            if (!isFileNameChar(*(pszPost+1)))
               break;
            pszPost++;
         }

         // relativize name, to match in later recursive checks
         char *pszRel = pszFile;
         if (cs.rootrelname) {
            pszRel = rootRelativeName(pszRel, pszOptRoot);
            if (!pszRel) return 9;
         }

         int nBruttoLen = pszPost-pszPre+1;
         if (nBruttoLen != (int)strlen(pszDst))
            sprintf(szLineBuf2, "%s\t%s\t[by text \"%s\" within \"%.*s\"]", pszRel, pszDstRaw, pszDst, (int)nBruttoLen, pszPre);
         else
            sprintf(szLineBuf2, "%s\t%s\t[by text \"%.*s\"]", pszRel, pszDstRaw, (int)nBruttoLen, pszPre);

         // we store up to n source infos in the extended rows
         if (iCnt < nGlblRefMaxSrc) {
            if (bGlblRefWideInfo)
               glblRefDst.setString(2+iCnt, idst, szLineBuf2);
            else
               glblRefDst.setString(2+iCnt, idst, pszFile); // pszRel?
         } else {
            bGlblRefLimitReached = 1;
         }
      }
      else {
         // printf("nohit %s: \n", pszFile);
         // sfkmem_hexdump(pInFile, (int)nFileSize);
      }
   }

   delete [] pInFile;

   // printf("rps: %s done\n", pszFile);

   return 0;
}

bool nameListedIn(StringTable &rasrc, char *pszName)
{
   for (int isrcx=0; isrcx<rasrc.numberOfEntries(); isrcx++) {
      char *pszSrcX = rasrc.getEntry(isrcx, __LINE__);
      if (!strcmp(pszName, pszSrcX))
         return true;
   }
   return false;
}

int listDependencies(StringTable &rasrc, char *pszMixed, int nLevel, bool bPrintRoot, bool &rprinted)
{__
   // pszMixed format:
   // EITHER root\tignore\t[remark]
   //     OR root
   char *p1 = pszMixed;
   char *p2 = strchr(p1, '\t');
   char szRoot[200];
   if (p2) {
      int nroot = p2-p1;
      if (nroot > (int)sizeof(szRoot)-4) return 9+perr("buffer overflow #ld01 %d %d\n",sizeof(szRoot)-4,nroot);
      strncpy(szRoot, p1, nroot); szRoot[nroot] = '\0';
   } else {
      strcopy(szRoot, pszMixed);
   }

   if ((nLevel == 0) && (!bPrintRoot))
      { }
   else {
      // if filenames are collected
      if (cs.depsingle && chain.colfiles) {
         Coi ocoi(szRoot, 0);
         chain.addFile(ocoi); // is copied
      } else {
         chain.print(' ', 0, "%s", szRoot);
         rprinted |= 1;
      }
   }

   // remember we don't have to solve this root again
   char *pszRelRoot = szRoot;
   if (nLevel == 0 && cs.rootrelname) {
      pszRelRoot = rootRelativeName(pszRelRoot, 0);
      if (!pszRelRoot) return 9;
   }
   rasrc.addEntry(pszRelRoot);

   char szAnySrc[200];

   // recurse into dependencies of root
   for (int idst=0; idst<glblRefDst.numberOfEntries(0); idst++)
   {
      // scan ANY target
      char *pszDst  = glblRefDst.getString(0, idst);
      int  nRefCnt = glblRefDst.getLong(1, idst, __LINE__);
      if (nRefCnt <= 0) continue;

      int nDump = nRefCnt;
      if (nDump > nGlblRefMaxSrc)
         nDump = nGlblRefMaxSrc;

      // enumerate sources for ANY target
      for (int isrc=0; isrc<nDump; isrc++)
      {
         char *pszMixed = glblRefDst.getString(2+isrc, idst);
         if (!pszMixed) return 9+perr("internal: unexpected NULL in RefDst %d %d %d\n",isrc,idst,nDump);

         // static int ntell=0;
         // while (ntell++ < 100)
         //    printf("mixed: %s\n", pszMixed);

         // holding anySource\ttargetForAnySource\t[remark]
         // INDEPENDENTLY from our current szRoot.
         p1 = pszMixed;
         p2 = strchr(p1, '\t'); if (!p2) return 9;
         int nsrc = p2-p1;
         if (nsrc > (int)sizeof(szAnySrc)-4) return 9+perr("buffer overflow #ld02 %d %d\n",sizeof(szAnySrc)-4,nsrc);
         strncpy(szAnySrc, p1, nsrc); szAnySrc[nsrc] = '\0';

         // now holding szAnySrc -> pszDst dependency.
         // are WE the szAnySrc?
         if (strcmp(pszRelRoot, szAnySrc)) continue; // no

         // yes: found another forward dependency as pszDst
         if (nameListedIn(rasrc, pszDst)) continue; // but done this already

         // found a new dependency as pszDst
         if (rprinted & 1) {
            if (rprinted & 2)
               chain.print(' ', 0, "\t"); // after very first output
            else
               chain.print(' ', 0, " ");  // after all other outputs
            rprinted &= 0xFF - 3;   // clear both flags
         }
         listDependencies(rasrc, pszDst, nLevel+1, bPrintRoot, rprinted);

         break; // DONE with current anySrc
      }
   }

   return 0;
}

int execDeblank(char *pszPath)
{__
   // replace blanks in (last part of) path by '_'
   strncpy(szLineBuf, pszPath, MAX_LINE_LEN);
   szLineBuf[MAX_LINE_LEN] = '\0';

   char *psz1 = strrchr(szLineBuf, glblPathChar);
   if (!psz1)
         psz1 = szLineBuf;

   bool bAny = 0;

   while (*psz1)
   {
      char craw = *psz1;
      char c = craw;

      if (cs.packalnum)
      {
         // alnum reduction mode
         c = sfktolower(c);
         *psz1 = c;
         if (c != craw)
            bAny = 1;
         if (c == '.' || c == glblPathChar)
            { psz1++; continue; }
         if (c >= 'a' && c <= 'z')
            { psz1++; continue; }
         if (c >= '0' && c <= '9')
            { psz1++; continue; }
         // remove char from string
         int nlen = strlen(psz1);
         memmove(psz1,psz1+1,nlen); // INCLUDES zero term
         bAny = 1;
         continue; // staying at same psz1
      }

      // normal deblank mode
      if (c != ' ')
         { psz1++; continue; }
      // replace blank by underscore
      *psz1 = '_';
      psz1++;
      bAny = 1;
   }

   if (!bAny)
      return 0; // nothing to do

   if (!cs.quiet)
      printf("%s -> %s\n", pszPath, szLineBuf);

   if (cs.yes) {
      int nRC = rename(pszPath, szLineBuf);
      if (nRC) return 1+perr("rename failed on %s\n", pszPath);
   }

   return 0;
}

int sendLine(SOCKET hSock, cchar *psz, bool bQuiet=0);
int readLine(SOCKET hSock, char *pszLineBuf = 0, int nMode=0);

#ifdef WITH_TCP

char *skipdot(char *psz) {
   if (strbeg(psz,"./")) return psz+2;
   return psz;
}

int execFTPList(char *pszName)
{__
   // list a single file OR directory.

   if (!strcmp(pszName, "."))
      return 0;

   sfkstat_t ostat;

   int bIsDir    = 0;
   int bCanRead  = 1;
   int bCanWrite = 1;
   num  nFTimePre = 0;
   num  nFileSize = 0;
   getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFTimePre, nFileSize,
               0, &ostat, sizeof(ostat));

   char *pszTail = strrchr(pszName, glblPathChar);
   if (pszTail)
      pszTail++;
   else
      pszTail = pszName;

   char szrwx[20];
   mclear(szrwx);
   strcpy(szrwx, "---------");

   uint nmode = ostat.st_mode;

   if (nmode & (1 << 8)) szrwx[0] = 'r';
   if (nmode & (1 << 7)) szrwx[1] = 'w';
   if (nmode & (1 << 6)) szrwx[2] = 'x';

   if (nmode & (1 << 5)) szrwx[3] = 'r';
   if (nmode & (1 << 4)) szrwx[4] = 'w';
   if (nmode & (1 << 3)) szrwx[5] = 'x';

   if (nmode & (1 << 2)) szrwx[6] = 'r';
   if (nmode & (1 << 1)) szrwx[7] = 'w';
   if (nmode & (1 << 0)) szrwx[8] = 'x';

   // -rw-r--r-- 1 ftp ftp         102808 Nov 20  2005 lslr
   // -rw-r--r-- 1 ftp ftp              4 May 27 23:34 tmp1.dat

   mytime_t nFileTime   = (mytime_t)nFTimePre;   // may be 0xFFFF
   mytime_t nSysTime    = getSystemTime();       // may be 0xFFFF
   struct tm *pSysTime  = 0;
   struct tm *pFileTime = 0;
   uint nSysYear = 0;

   pSysTime  = mylocaltime(&nSysTime);    // may be NULL
   nSysYear  = (pSysTime != 0) ? pSysTime->tm_year : 0;
   pFileTime = mylocaltime(&nFileTime);   // OVERWRITES pSysTime!
   pSysTime  = 0;

   char abTimeStamp[100];
   abTimeStamp[0] = '\0';

   // files of current year get time added on listing, else list year
   if (pFileTime != 0) {
      if (bGlblFTPListAsHTML) {
         char *pszFlat = timeAsString(nFTimePre, 0); // 1: flat
         if (pszFlat) strcopy(abTimeStamp, pszFlat);
      }
      else
      if (bGlblFTPListFlatTS) {
         char *pszFlat = timeAsString(nFTimePre, 1); // 1: flat
         if (pszFlat) strcopy(abTimeStamp, pszFlat);
      }
      else
      if (nSysYear == (uint)pFileTime->tm_year)
         strftime(abTimeStamp, sizeof(abTimeStamp)-10, "%b %d %H:%M", pFileTime);
      else
         strftime(abTimeStamp, sizeof(abTimeStamp)-10, "%b %d %Y", pFileTime);
   } else {
      strcpy(abTimeStamp, "Dez 31 9999");
   }

   // FTPClient::list parses binary info, and hands to Coi
   cchar *pszType = "";
   if (bGlblFTPListTextBin) {
      if (bIsDir)
         pszType = "d";
      else
      if (isBinaryFile(pszName))
         pszType = "b";
      else
         pszType = "t";
   }

   strcopy(szLineBuf3, pszName);
   setNetSlashes(szLineBuf3);

   if (bGlblFTPListAsHTML)
   {
      char *pfil = skipdot(szLineBuf3);

      char *ppre  = str("");
      char *plink = pfil;

      // sfk198 folders list
      if (cs.withdirs)
      {
         if (bIsDir)
            ppre = str("?subdir=");

         if (!strcmp(pfil,"..")) {
            // first row: show current dir.
            snprintf(szLineBuf2, MAX_LINE_LEN,
               "<span class=\"dh\"><a class=\"d\" href=\"/?subdir=..\">%s</a></span>"
               , ansiToUTF(skipdot(cs.webcurdir)));
            sendLine(hGlblTCPOutSocket, szLineBuf2, 1);
            // next will be ".." link.
            pfil = str("[up]");
            nFileSize = 0;
         } else {
            // sub folder files: show local names
            char *pcurdir=skipdot(cs.webcurdir);
            int idirlen=strlen(pcurdir);
            if (idirlen>0 && strncmp(pfil,pcurdir,idirlen)==0) {
                pfil+=idirlen;
                if (*pfil=='/') pfil++;
                // sub folder name itself is now null
                if (!*pfil) return 0;
            }
         }
      }   

      if (cs.webdesklist)
         // desktop compact
         snprintf(szLineBuf2, MAX_LINE_LEN,
            "<span>%s %s</span> "
            "<a %shref=\"%s%s\">%s</a>"
            ,  abTimeStamp, numtoa_blank(nFileSize, 8)
            ,  bIsDir ? "class=\"d\" ":""
            ,  ppre, ansiToUTF(plink), ansiToUTF(pfil)
            );
      else // touch friendly
         snprintf(szLineBuf2, MAX_LINE_LEN,
            "<a %shref=\"%s%s\">%s</a>\n"
            "<span>%s %s %c%.3s%s</span>"
            ,  bIsDir ? "class=\"d\" ":""
            ,  ppre, ansiToUTF(plink), ansiToUTF(pfil)
            ,  numtoa_blank(nFileSize), abTimeStamp
            ,  bIsDir ? 'd' : '-', szrwx, pszType
            );
   }
   else
   {
      // ftp output
      snprintf(szLineBuf2, MAX_LINE_LEN,
         "%c%s%s 1 ftp ftp %s %s ",
         bIsDir ? 'd' : '-',
         szrwx, // bGlblFTPReadWrite ? "rw-rw-rw-":"r--r--r--",
         pszType,
         numtoa_blank(nFileSize), abTimeStamp);
   
      char *pszPart = szLineBuf2+strlen(szLineBuf2);
      if (strlen(szLineBuf2)+strlen(pszTail) < MAX_LINE_LEN)
         strcat(szLineBuf2, pszTail);
      setNetSlashes(pszPart);
   }

   if (cs.debug)
      printf("< %s\n", szLineBuf2);

   if (sendLine(hGlblTCPOutSocket, szLineBuf2, 1)) // uses szLineBuf
      return 9;

   return 0;
}

// .
int execVDirFTPList(char *pszName, char *pszDstName)
{__
   // chg: sfk182: do not return NULL time/size with existing virtual folders
   //      as this always shows the 1970 date.
   int bIsDir     = 0;
   int bCanRead   = 0;
   int bCanWrite  = 0;
   num  nFTimePre = 0;
   num  nFileSize = 0;
   if (getFileStat(pszDstName, bIsDir, bCanRead, bCanWrite, nFTimePre, nFileSize)) {
      nFTimePre   = 0;
      nFileSize   = 0;
   }

   char *pszTail = strrchr(pszName, glblPathChar);
   if (pszTail)
      pszTail++;
   else
      pszTail = pszName;

   char szrwx[20];
   mclear(szrwx);
   strcpy(szrwx, "rwxr-xr-x");

   // -rw-r--r-- 1 ftp ftp         102808 Nov 20  2005 lslr
   // -rw-r--r-- 1 ftp ftp              4 May 27 23:34 tmp1.dat

   mytime_t nFileTime   = (mytime_t)nFTimePre;   // may be 0xFFFF
   mytime_t nSysTime    = getSystemTime();       // may be 0xFFFF
   struct tm *pSysTime  = 0;
   struct tm *pFileTime = 0;
   uint nSysYear = 0;

   pSysTime  = mylocaltime(&nSysTime);    // may be NULL
   nSysYear  = (pSysTime != 0) ? pSysTime->tm_year : 0;
   pFileTime = mylocaltime(&nFileTime);   // OVERWRITES pSysTime!
   pSysTime  = 0;

   char abTimeStamp[100];
   abTimeStamp[0] = '\0';

   // files of current year get time added on listing, else list year
   if (pFileTime != 0) {
      if (bGlblFTPListFlatTS) {
         char *pszFlat = timeAsString(nFTimePre, 1); // 1: flat
         if (pszFlat) strcopy(abTimeStamp, pszFlat);
      }
      else
      if (nSysYear == (uint)pFileTime->tm_year)
         strftime(abTimeStamp, sizeof(abTimeStamp)-10, "%b %d %H:%M", pFileTime);
      else
         strftime(abTimeStamp, sizeof(abTimeStamp)-10, "%b %d %Y", pFileTime);
   } else {
      strcpy(abTimeStamp, "Dez 31 9999");
   }

   // fix: sfk182: -usedir virtual folders wrong rwx attributes,
   //      always followed by 'd' causing clients to show nothing.
   sprintf(szLineBuf2, "%c%s 1 ftp ftp %s %s ",
      'd',
      szrwx, // bGlblFTPReadWrite ? "rw-rw-rw-":"r--r--r--",
      numtoa_blank(nFileSize), abTimeStamp);

   char *pszPart = szLineBuf2+strlen(szLineBuf2);
   if (bGlblFTPListAsHTML) {
      strcat(szLineBuf2, "<a href=\"");
      strcat(szLineBuf2, pszName);
      strcat(szLineBuf2, "\">");
      strcat(szLineBuf2, pszName);
      strcat(szLineBuf2, "</a>");
   } else {
      strcat(szLineBuf2, pszTail);
   }
   for (; *pszPart; pszPart++)
      if (*pszPart=='\\')
         *pszPart='/';

   if (cs.debug)
      printf("< %s\n", szLineBuf2);

   if (sendLine(hGlblTCPOutSocket, szLineBuf2, 1)) // uses szLineBuf
      return 9;

   return 0;
}

int execFTPNList(char *pszFileName)
{
   return sendLine(hGlblTCPOutSocket, pszFileName, 1);
}

StringTable glblFTPRemList;
StringTable glblFTPLocList;

int execFTPLocList(char *pszFileName)
{
   return glblFTPLocList.addEntry(pszFileName);
}

#endif

class ExecFileScope
{
public:
      ExecFileScope  (Coi *pCoiOrNull);
     ~ExecFileScope  ( );

static Coi *pClCoi;
};

Coi *ExecFileScope :: pClCoi = 0;

ExecFileScope::ExecFileScope(Coi *pcoi) { pClCoi=pcoi; }
ExecFileScope::~ExecFileScope( ) { pClCoi=0; }

// Function 1: check command syntax
// Function 2: create output
// RC  0 : OK all done
// RC 10 : invalid parameters
// RC 11 : unknown command
// RC 12 : missing or invalid data, cannot execute command
typedef int (*SFKMatchOutFNCallback_t)(int iFunction, char *pMask, int *pIOMaskLen, uchar **ppOut, int *pOutLen);

int cbSFKMatchOutFN(int iFunction, char *pMask, int *pIOMaskLen, uchar **ppOut, int *pOutLen)
{
   static char szOutBuf[800];

   int iCmd = 0;

   int iMaxLen = SFK_MAX_PATH+100;

   if (!strncmp(pMask, "file.name", 9)) { iCmd=1; *pIOMaskLen=9; } else
   if (!strncmp(pMask, "file.relname", 12)) { iCmd=2; *pIOMaskLen=12; }
   if (!strncmp(pMask, "file.path", 9)) { iCmd=3; *pIOMaskLen=9; }
   if (!strncmp(pMask, "file.base", 9)) { iCmd=4; *pIOMaskLen=9; }
   if (!strncmp(pMask, "file.ext" , 8)) { iCmd=5; *pIOMaskLen=8; }

   if (!iCmd)
      return 11;

   if (iFunction==1) // check syntax
   {
      if (!pOutLen)
         return 10+perr("missing outlen parameter for expression output function");
      *pOutLen = iMaxLen;
      return 0;
   }

   if (!ppOut)
      return 10+perr("invalid parameters for expression output function");

   Coi *pcoi = ExecFileScope::pClCoi;

   if (!pcoi)
      return 12+perr("missing filename data for expression output function");

   char *psz=0;

   switch (iCmd)
   {
      case 1:  // absname
         strcopy(szOutBuf, pcoi->name());
         break;
      case 2:  // relname
         strcopy(szOutBuf, pcoi->relName());
         break;
      case 3:  // path
         strcopy(szOutBuf, pcoi->name());
         if ((psz = strrchr(szOutBuf, glblPathChar)))
            *psz = '\0';
         else
            szOutBuf[0] = '\0';
         break;
      case 4:  // base
         strcopy(szOutBuf, pcoi->relName());
         if ((psz = strrchr(szOutBuf, '.')))
            *psz = '\0';
         break;
      case 5:  // ext
         if ((psz = strrchr(pcoi->relName(), '.')))
            strcopy(szOutBuf, psz+1);
         else
            szOutBuf[0] = '\0';
         break;
   }

   *ppOut = (uchar*)szOutBuf;
   *pOutLen = strlen(szOutBuf);
 
   return 0;
}

#ifdef SFKOSE
int execXFind(Coi *pcoi, char *pszOptOutFile);
#endif

int execSingleFile(Coi *pcoi, int lLevel, int &lFiles, int nDirFileCnt, int &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2)
{__ _p("sf.excfile")

   mtklog(("esf fn=%d %s", nGlblFunc, pcoi->name()));

   if (cs.debug)
      { printf("execSingleFile: %s\n", pcoi->name()); }

   ExecFileScope oscope(pcoi);

   char *pszFile     = pcoi->name();
   char *pszOptRoot  = pcoi->root(1);  // raw, returns 0 if none

   if (userInterrupt())
      return 9;

   if (cs.justevery > 1) // sfk1952 internal
   {
      cs.everycnt++;
      if (cs.everycnt < cs.justevery)
         return 0;
      cs.everycnt = 0;
   }

   #ifdef SFKOFFICE
   // avoid listing the same office name many times on multiple hits
   if (cs.office && pcoi->isOfficeSubEntry()
       && useOfficeBaseNames())
   {
      Coi otmp(pcoi->name(),0);
      otmp.stripOfficeName(); // execSingleFile filter for (x)find
      if (chain.justNamesFilter
          && chain.justNamesFilter->isset(otmp.name()))
         return 0;
   }

   // -crc=x can be used only with office subentries
   if (cs.bjustcrc) {
      if (!cs.office)
         return 19+perr("-crc=x requires office reading mode");
      if (!pcoi->isOfficeSubEntry())
         return 0;
   }
   #endif // SFKOFFICE

   if (cs.walkFileDelay > 0)
      doSleep(cs.walkFileDelay);

   #ifdef VFILEBASE
   if (pcoi->isHttp())
   {
      if (!cs.execweb) { // exec single file
         pwarn("command does not support http. (%d,1)\n", nGlblFunc);
         return 9;
      }

      // functions that may support http read
      switch (nGlblFunc)
      {
         case eFunc_Run:
            // no preload! external process will load, but not us.
            break;

         case eFunc_JamFile:
         case eFunc_CallBack:
         case eFunc_JamIndex:
         case eFunc_SnapAdd:
         case eFunc_FileStat:
         case eFunc_FileTime:
         case eFunc_Find:
         case eFunc_GetPic:
         case eFunc_Filter:
         case eFunc_Load:
         // case eFunc_Hexdump:
         // case eFunc_ReplaceFix:
         case eFunc_ReplaceFix:  // or xfind
         // case eFunc_XHexDemo:
         // case eFunc_Version:
            if (pcoi->preload("esf", 0, 0)) // execSingleFile
               return 9+perr("failed to load: %s\n", pcoi->name());
            break;

         default:
            pwarn("command does not support http. (%d,2)\n", nGlblFunc);
            return 9;
      }
   }
   #endif // VFILEBASE

   // make sure the file really exists.
   // make an exception for "run", as it may use "$text".
   if (nGlblFunc != eFunc_Run) {
      // if no meta info was read yet, do it now.
      if (!pcoi->status())
         pcoi->readStat('e');
      // if meta reading failed, the file cannot be processed.
      if (pcoi->status() >= 9) {
         if (bGlblSFKCreateFiles) {
            uchar *pEmpty = new uchar[100];
            if (!pEmpty)
               return 9+perr("outofmem");
            memset(pEmpty, 0, 100);
            strcpy((char*)pEmpty, "[new file]\r\n");
            pcoi->setContent(pEmpty, strlen((char*)pEmpty), 123);
         } else {
            if (!cs.quiet && !cs.nowarn)
               pferr(pcoi->name(), "[warn] [nopre] cannot read: %s\n",pcoi->name());
            return 0; // do NOT stop dirtree processing
         }
      }
   }

   if (!pszOptRoot && glblFileSet.hasRoot(0))
        pszOptRoot = glblFileSet.getCurrentRoot();
   // optionally supplied root dir can still be NULL.

   info.cycle();

   // skip initial dot slash which might be returned by dir scanning
   if (!strncmp(pszFile, glblDotSlash, 2))
      pszFile += 2;

   // if set, exclude output filename from input fileset,
   // to avoid endless recursions e.g. on snapto function.
   // see also checks for FileCollectionStamp.
   if (pszGlblOutFile)
      if (equalFileName(pszGlblOutFile,pszFile))
         return 0;

   if (cs.minsize > 0 && pcoi->getSize() < cs.minsize) {
      if (nGlblTraceSel & 2) {
         setTextColor(nGlblTraceExcColor);
         info.print("file-exclude: %s too small\n", pszFile);
         setTextColor(-1);
      }
      return 0;
   }

   if (cs.maxsize > 0 && pcoi->getSize() > cs.maxsize) {
      if (nGlblTraceSel & 2) {
         setTextColor(nGlblTraceExcColor);
         info.print("file-exclude: %s too large\n", pszFile);
         setTextColor(-1);
      }
      return 0;
   }

   // -text: process only textfiles
   if (cs.textfiles || cs.binaryfiles)
   {
      bool bbin = pcoi->isBinaryFile();
      bool binc = 1;
      cchar *ptxt1 = "", *ptxt2 = "";

      if (cs.textfiles && bbin)
         { binc=0; ptxt1="binary"; ptxt2="text"; }

      if (cs.binaryfiles && !bbin)
         { binc=0; ptxt1="text"; ptxt2="binary"; }

      if (!binc) {
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceExcColor);
            info.print("file-exclude: %s is %s\n", pszFile, ptxt1);
            setTextColor(-1);
         }
         return 0;
      } else {
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceIncColor);
            info.print("file-include: %s is %s\n", pszFile, ptxt2);
            setTextColor(-1);
         }
      }
   }

   // -since: process only files newer or equal than timestamp
   if (cs.sincetime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get file time: %s\n", pszFile);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime < cs.sincetime)
         return 0; // skip
   }

   // -before: process only files older or equal than timestamp
   if (cs.untiltime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get file time: %s\n", pszFile);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime >= cs.untiltime)
         return 0; // skip
   }

   // -sincedir: process only files newer than in reference dir
   int nSinceReason = 0;
   if (pszGlblSinceDir)
   {
      // build relative name of file to be processed
      char *pszRel = pszFile;
      if (!bGlblSinceDirIncRef)
         pszRel = pcoi->rootRelName();
      if (!pszRel) return 9;
      // proceed with -sincedir processing
      joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszGlblSinceDir, pszRel);
      if (cs.verbose > 1)
         printf("CMP src %s ref %s\n",pszFile,szRefNameBuf);
      mtklog(("CMP src %s ref %s",pszFile,szRefNameBuf));
      // BEWARE OF MIXUP:
      //    sfk list -sincedir foo bar
      //       means for the user: FOO (szRefNameBuf) is the SOURCE.
      // so pszFile provided in here is actually the DESTINATION for compare.
      FileStat ofsSrc, ofsDst;
      if (ofsDst.readFrom(pszFile))       // the tree processing "target"
         return 9+perr("cannot read file time: %s\n",pszFile);
      if (ofsSrc.readFrom(szRefNameBuf))  // the -sincedir "source"
      {
         // file has been added, compared to source
         nSinceReason |= 4; // added
         if (!(nGlblSinceMode & 1)) {
            // added files not included:
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceExcColor);
               info.print("file-exclude: %s is added file, %s does not exist\n", pszFile, szRefNameBuf);
               setTextColor(-1);
            }
            cs.addedFilesSkipped++;
            return 0; // skip added files
         }
         // added files included:
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceIncColor);
            info.print("file-include: %s is added file, %s does not exist\n", pszFile, szRefNameBuf);
            setTextColor(-1);
         }
      }
      else
      {
         // both files exist

         // quick-check the size
         bool bDiffSize = 0;
         if (ofsSrc.getSize() != ofsDst.getSize())
            bDiffSize = 1;

         // compare times
         int nDiffReason = 0;
         if (!bGlblIgnoreTime) {
            if (!(nDiffReason = ofsSrc.differs(ofsDst, 0))) { // NOT same if older src
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s same time as %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               // if (!bDiffSize) // fall through on size mismatch
               return 0;
            } else {
               nSinceReason |= 1;
            }
         }

         // timestamp, attrib or exist difference: check also content
         if (bDiffSize)
            nSinceReason |= 2; // different size
         else
         if (!equalFileContent(szRefNameBuf, pszFile))
            nSinceReason |= 2; // file content difference

         if (nSinceReason & 2)
         {
            // file content is different:
            if (cs.verbose)
               printf("differs by content: %s\n", pszFile);
 
            if (!(nGlblSinceMode & 2)) {
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s differs against %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               return 0; // skip differing files
            }

            // differing files included
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceIncColor);
               info.print("file-include: %s content differs against %s\n", pszFile, szRefNameBuf);
               setTextColor(-1);
            }
         }
         else
         {
            // have no content difference:
            if (!(nGlblSinceMode & 4)) {
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s time but no content diff against %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               return 0; // skip only-time diffs
            }

            // are we interested just in content diffs?
            if (bGlblIgnoreTime) {
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s just time diff against %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               return 0; // no content diff, no processing
            }

            // differing files included
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceIncColor);
               info.print("file-include: %s just time diff against %s\n", pszFile, szRefNameBuf);
               setTextColor(-1);
            }
         }
      }

      // sincedir checks passed: register reference
      pcoi->setRef(szRefNameBuf);

   }  // endif sincedir
 
   // the file is selected for processing.
   int icurfilenum = cs.selfilenum++;
   if (cs.selfilerange > 0)
   {
      // should only process part of selection:
      if (icurfilenum < cs.selfileoff)
         return 0; // before selection start, continue
      if (icurfilenum >= cs.selfileoff + cs.selfilerange) {
         // after selection end: stop silently
         cs.stopfiletree = 1;
         return 0;
      }
   }

   // -tomake specified?
   if (cs.tomake[0])
   {
      int nrc = renderOutMask(szOutNameBuf, pcoi, cs.tomake, cs.curcmd); // -to generic
      // rc 0: done with replacements
      // rc 1: done without replacements
      if (nrc >= 9) return nrc;
      if (nrc > 0)
      {
         perr("-tomake target name did not contain any patterns.\n");
         printx("<time>note : add or insert words like <run>file, <run>relfile, <run>base etc.<def>\n");
         printx("<time>note : type \"sfk run\" for a list of possible patterns.\n");
         return 9;
      }
      // check if output file exists or is older
      FileStat ofsSrc, ofsDst;
      if (ofsSrc.readFrom(pcoi->name()))
         return 9;
      if (!ofsDst.readFrom(szOutNameBuf)) {
         bool bSrcIsOlder = 0;
         bool bSameIOS = cs.syncOlder ? 0 : 1;  // same if older src?
         if (!ofsSrc.differs(ofsDst, bSameIOS, &bSrcIsOlder)) {
            if (cs.verbose)
               pinf("[nopre] skip: %s\n", pcoi->name());
            return 0;
         }
      }
      // tomake check passed: register as reference
      pcoi->setRef(szOutNameBuf);
   }

   // -to specified? if so, build output filename.
   char *pszOutFile = 0;
   if (cs.tomask)
   {
      if (cs.tomaskfile)
         pszOutFile = cs.tomask;
      else
      {
         int nrc = renderOutMask(szOutNameBuf, pcoi, cs.tomask, cs.curcmd); // -to generic
         // rc 0: done with replacements
         // rc 1: done without replacements
         if (nrc >= 9) return nrc;
         // if (nrc > 0)
         // {
         //    perr("-to target name did not contain any patterns.\n");
         //    printx("<time>note : add or insert words like <run>file, <run>relfile, <run>base etc.<def>\n");
         //    printx("<time>note : type \"sfk run\" for a list of possible patterns.\n");
         //    return 9;
         // }
         if (nrc > 0 && cs.verbose > 0) {
            printf("to single output file: %s\n", szOutNameBuf);
         }
         if ((nrc > 0) && !cs.nowarn && !strcmp(szOutNameRecent, szOutNameBuf)) {
            if (!bGlblToldAboutRecent) {
               bGlblToldAboutRecent = 1;
               pwarn("same output used twice: %s\n", szOutNameBuf);
               pinf("specify -tofile filename or -nowarn to avoid this warning.\n");
            }
         }
         strcopy(szOutNameRecent, szOutNameBuf);
         pszOutFile = szOutNameBuf;
      }
   }

   switch (nGlblFunc)
   {
      case eFunc_MD5Write  : return execMD5write(pcoi); break;
      case eFunc_JamFile   : return execJamFile(pcoi);  break;
      case eFunc_CallBack  : return execCallFileDir(pcoi);  break;
      case eFunc_Detab     : return execDetab(pszFile, pszOutFile); break;
      case eFunc_Scantab   : return execScantab(pszFile);    break;
      case eFunc_Entab     : return execEntab(pszFile, pszOutFile); break;
      case eFunc_JamIndex  : return execJamIndex(pszFile);   break;
      case eFunc_FileStat  : return execFileStat(pcoi, lLevel, lFiles, lDirs, lBytes, nLocalMaxTime, ntime2, nSinceReason);  break;
      case eFunc_SumFiles  : return execSumFiles(pcoi, lLevel, lFiles, lDirs, lBytes, nLocalMaxTime, ntime2);  break;
      case eFunc_FileTime  : return execFileTime(pszFile);   break;
      case eFunc_Touch     : return execTouch(pszFile, 0);   break;
      case eFunc_Find      : return execFind(pcoi);          break;
      case eFunc_Run       : return execRunFile(pcoi, pszOutFile, lLevel, lFiles, lDirs, lBytes);  break;
      #ifndef USE_SFK_BASE
      case eFunc_FormConv  : return execFormConv(pszFile, pszOutFile);   break;
      #endif // USE_SFK_BASE
      #ifdef WITH_FN_INST
      case eFunc_Inst      : return execInst(pszFile, lLevel, lFiles, lDirs, lBytes);  break;
      #endif
      case eFunc_RefColSrc : return execRefColSrc(pszFile);  break;
      case eFunc_RefColDst : return execRefColDst(pcoi);     break;
      case eFunc_Deblank   : return execDeblank(pszFile);    break;
      #ifdef WITH_TCP
      case eFunc_FTPList   : return execFTPList(pszFile);    break;
      case eFunc_FTPNList  : return execFTPNList(pszFile);   break;
      case eFunc_FTPLocList: return execFTPLocList(pszFile); break;
      #endif
      case eFunc_Hexdump   : return execHexdump(pcoi, 0, 0); break;
      case eFunc_AliasList : return execAliasList(pszFile);  break;
      #ifndef SFKXEREP
      case eFunc_ReplaceFix: return execReplaceFix(pcoi);    break;
      case eFunc_ReplaceVar: return execReplaceVar(pcoi);    break;
      #endif
      case eFunc_Filter    : return execFilter(pcoi, 0, 0, -1, pszOutFile); break;
      case eFunc_Load      : return execLoad(pcoi);          break;
      case eFunc_Delete    : return execDelFile(pszFile);    break;
      #ifndef USE_SFK_BASE
      #ifdef SFKOSE
      case eFunc_XFind     : return execXFind(pcoi, pszOutFile);   break;
      #endif
      case eFunc_Copy      : return execFileCopy(pcoi);      break;
      case eFunc_Move      : return execFileMove(pcoi);      break;
      case eFunc_Cleanup   : return execFileCleanup(pszFile);     break;
      case eFunc_MetaUpd   : return execMetaFileUpdate(pszFile); break;
      case eFunc_MetaCheck : return execMetaFileCheck(pszFile); break;
      case eFunc_DupScan   : return execDupScan(pcoi);    break;
      case eFunc_Rename    : return execRename(pcoi);        break;
      case eFunc_XRename   : return execXRename(pcoi);       break;
      case eFunc_Media     : return execMedia(pszFile, pszOutFile); break;
      #if defined(SFKPACK)
      case eFunc_ZipTo     : return execZipFile(pcoi, 0, 0); break;
      #endif
      case eFunc_UUEncode  : return execUUEncode(pcoi); break;
      #endif // USE_SFK_BASE
      case eFunc_Version   : return execVersion(pcoi); break;
      #ifdef SFKPIC
       #ifndef USE_SFK_BASE
      case eFunc_Pic       : return execPic(pcoi, pszOutFile);   break;
       #endif
      #endif // SFKPIC
      default:
         break;
   }

   return 0;
}

char szMirStatBuf[200];
void showMirrorStatus(const char *pszAction, const char *pszStatus,
   char *pszObject, bool bIsFile, int nCount, bool bLF=0)
{
   // if pszObject is a filename with path, show just path.

   int nLen = strlen(pszObject);
   if (bIsFile) {
      char *psz1 = strrchr(pszObject, glblPathChar);
      if (psz1) nLen = psz1-pszObject;
   }
   if (nLen > 40) { pszObject += (nLen-40); nLen = 40; }

   sprintf(szMirStatBuf, "%04u %4.4s %4.4s %03u %.*s ",
      glblFileCount.value(),
      pszAction, pszStatus,
      nCount, nLen, pszObject
      );

   // fill up with blanks to 76 chars
   nLen = strlen(szMirStatBuf);
   while (nLen < 76)
      szMirStatBuf[nLen++] = ' ';
   szMirStatBuf[nLen] = '\0';

   if ((cs.verbose==2) && strcmp(pszAction, "scan") && strcmp(pszStatus, "----"))
      bLF = 1;

   printf("%s%c", szMirStatBuf, bLF ? '\n' : '\r');
   fflush(stdout);
}

#ifdef SFK_CCDIRTIME
StringTable glblCreatedDirs;
#endif

bool isNetDriveRoot(char *psz)
{
   #ifdef _WIN32
   if (strncmp(psz, "\\\\", 2)) return 0;
   #else
   if (strncmp(psz, "//", 2)) return 0;
   #endif
   // jump past \\, check if further dir is appended
   char *psz2 = strchr(psz+2, glblPathChar);
   if (!psz2) return 1;   // yes: e.g. \\foomachine
   // is it JUST a slash or something more?
   psz2++;
   if (!strlen(psz2)) return 1; // just the slash
   return 0; // no: e.g. \\foomachine\c$
}

int sfkmkdir(char *pszName, bool braw)
{
   int irc=0;

   #ifdef _WIN32
   if (braw==0 && vname()!=0) {
      sfkname oname(pszName);
      irc = _wmkdir((const wchar_t *)oname.wname());
   } else {
      irc = _mkdir(pszName);
   }
   #else
   irc = mkdir(pszName, S_IREAD | S_IWRITE | S_IEXEC);
   #endif

   return irc;   
}

// uses szLineBuf, abBuf
int createSubDirTree(char *pszDstRoot, char *pszDirTree, char *pszRefRoot)
{
   // create all needed target directories
   joinPath(szLineBuf, MAX_LINE_LEN, pszDstRoot, pszDirTree);

   char *psz1 = szLineBuf;
   char *psz2 = 0;
   if (strlen(psz1))
      psz2 = strchr(psz1+1, glblPathChar);
   while (psz2)
   {
      strncpy((char*)abBuf, psz1, psz2-psz1);
      abBuf[psz2-psz1] = 0;
      char *pszDir = (char*)abBuf;

      #ifdef _WIN32
      if (strlen(pszDir)==2 && pszDir[1]==':')
      { } // don't create "c:"
      else
      #endif
      if (isNetDriveRoot(pszDir))
      { }
      else
      if (!isDir(pszDir))
      {
         if (cs.verbose)
            printf("mkdir.1: %s\n", pszDir);
         #ifdef _WIN32
         if (_mkdir(pszDir))
         #else
         if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
         #endif
         {
            perr("cannot create dir: %s\n", pszDir);
            return 9;
         }
         // if ref root is given, copy its timestamp
         // doesn't work here: file created afterwards updates the dir timestamp
         // trace created dir in global list
         #ifdef SFK_CCDIRTIME
         glblCreatedDirs.addEntry(pszDir);
         #endif
         // count created dir
         cs.dirs++;
      }
      psz2 = strchr(psz2+1, glblPathChar);
   }

   char *pszDir = szLineBuf;

   #ifdef _WIN32
   if (strlen(pszDir)==2 && pszDir[1]==':')
   { } // don't create "c:"
   else
   #endif
   if (isNetDriveRoot(pszDir))
   { }
   else
   if (!isDir(pszDir))
   {
      if (cs.verbose)
         printf("mkdir.2: %s\n", pszDir);
      #ifdef _WIN32
      if (_mkdir(pszDir))
      #else
      if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
      #endif
      {
         perr("cannot create dir: %s\n", pszDir);
         return 9;
      }
      #ifdef SFK_CCDIRTIME
      glblCreatedDirs.addEntry(pszDir);
      #endif
      cs.dirs++;
   }
   return 0;
}

// create dir tree required to write the specified filename.
// uses: szLineBuf, abBuf
// note: does NOT add to glblCreatedDirs
//       does not count created dirs.
int createOutDirTree(char *pszOutFile, KeyMap *pOptMap, bool bForDir)
{
   if (cs.debug)
      printf("createOutDirTree for: %s\n", pszOutFile);

   // isolate path from filename
   // c:\foo\bar.txt -> c:\foo
   // c:foo\bar.txt -> c:\foo
   // c:bar.txt -> skip
   strcopy(szLineBuf, pszOutFile);

   if (!bForDir) {
      char *psz = strrchr(szLineBuf, glblPathChar);
      if (!psz) return 0; // nothing to do
      *psz = '\0';
   }

   char *psz1 = szLineBuf;
   char *psz2 = 0;
   if (strlen(psz1))
      psz2 = strchr(psz1+1, glblPathChar);
   while (psz2)
   {
      strncpy((char*)abBuf, psz1, psz2-psz1);
      abBuf[psz2-psz1] = 0;
      char *pszDir = (char*)abBuf;
      #ifdef _WIN32
      if (strlen(pszDir)==2 && pszDir[1]==':')
      { } // don't create "c:"
      else
      #endif
      if (isNetDriveRoot(pszDir))
      { }
      else
      if (!isDir(pszDir))
      {
         if (cs.verbose)
            printf("mkdir.3: %s\n", pszDir);
         #ifdef _WIN32
         if (_mkdir(pszDir))
         #else
         if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
         #endif
         {
            perr("cannot create dir: %s\n", pszDir);
            return 9;
         }
         if (pOptMap != 0)
            pOptMap->put(pszDir, 0);
      }
      psz2 = strchr(psz2+1, glblPathChar);
   }

   char *pszDir = szLineBuf;

   #ifdef _WIN32
   if (strlen(pszDir)==2 && pszDir[1]==':')
   { } // don't create "c:"
   else
   #endif
   if (isNetDriveRoot(pszDir))
   { }
   else
   if (!isDir(pszDir))
   {
      if (cs.verbose)
      printf("mkdir.4: %s\n", pszDir);
      #ifdef _WIN32
      if (_mkdir(pszDir))
      #else
      if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
      #endif
      {
         perr("cannot create dir: %s\n", pszDir);
         return 9;
      }
      if (pOptMap != 0)
         pOptMap->put(pszDir, 0);
   }
   return 0;
}

#ifdef WINFULL
bool isNetDriveRootW(ushort *psz)
{
   if (psz[0]!='\\' || psz[1]!='\\') return 0;

   wchar_t *psz2 = wstrchr((wchar_t*)psz+2, (wchar_t)glblPathChar);
   if (!psz2) return 1;

   psz2++;
   if (!wstrlen((wchar_t*)psz2)) return 1;

   return 0;
}
int isDirW(ushort *pszName)
{
   DWORD nAttrib = GetFileAttributesW((wchar_t*)pszName);
   if (nAttrib == 0xFFFFFFFF) // "INVALID_FILE_ATTRIBUTES"
      return 0;
   if (nAttrib & FILE_ATTRIBUTE_DIRECTORY)
      return 1;
   return 0;
}
int createOutDirTreeW(char *pszOutFile, KeyMap *pOptMap, bool bForDir)
{
   strcopy(szLineBuf, pszOutFile);

   if (!bForDir) {
      char *psz = strrchr(szLineBuf, glblPathChar);
      if (!psz) return 0; // nothing to do
      *psz = '\0';
   }

   char *psz1 = szLineBuf;
   char *psz2 = 0;
   if (strlen(psz1))
      psz2 = strchr(psz1+1, glblPathChar);
   while (psz2)
   {
      strncpy((char*)abBuf, psz1, psz2-psz1);
      abBuf[psz2-psz1] = 0;
      char *pszDirA = (char*)abBuf;

      sfkname oname(pszDirA);
      ushort *pDir = oname.wname();

      if (wstrlen((wchar_t*)pDir)==2 && pDir[1]==':')
      { } // don't create "c:"
      else
      if (isNetDriveRootW(pDir))
      { }
      else
      if (!isDirW(pDir))
      {
         if (_wmkdir((wchar_t*)pDir))
         {
            perr("cannot create dir: %s\n", pszDirA);
            pinf("... trying wmkdir: %s\n", dataAsTrace(pDir,wcslen((wchar_t*)pDir)*2));
            return 9;
         }
         if (pOptMap != 0)
            pOptMap->put(pszDirA, 0);
      }
      psz2 = strchr(psz2+1, glblPathChar);
   }

   char *pszDirA = szLineBuf;

   sfkname oname(pszDirA);
   ushort *pDir = oname.wname();

   if (wstrlen((wchar_t*)pDir)==2 && pDir[1]==':')
   { } // don't create "c:"
   else
   if (isNetDriveRootW(pDir))
   { }
   else
   if (!isDirW(pDir))
   {
      if (_wmkdir((wchar_t*)pDir))
      {
         perr("cannot create dir: %s\n", pszDirA);
         pinf("... trying wmkdir: %s\n", dataAsTrace(pDir,wcslen((wchar_t*)pDir)*2));
         return 9;
      }
      if (pOptMap != 0)
         pOptMap->put(pszDirA, 0);
   }
   return 0;
}

#endif

int execSingleDir(Coi *pcoi, int lLevel, int &nTreeFiles, FileList &oDirFiles, int &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2)
{__ _p("sf.execdir")

   char *pszName     = pcoi->name();
   char *pszOptRoot  = pcoi->root(1);  // raw, returns 0 if none

   if (cs.debug) printf("]  esdir: %s files=%d\n", pszName, nTreeFiles);

   if (userInterrupt())
      return 9;

   if (cs.withdirs || cs.justdirs)
   {
      // -justdirs: if a path mask is given, we still have
      // to traverse all subfolders, but we don't list
      // or process non matching subfolders.
      // ,1 : take full path, is a directory name
      // ,1 : apply also white masks (?)
      if (!matchesDirMask(pszName, 1, 1, 102)) // on subdir
      {
         if (cs.debug) printf("]  esdir: path mask mismatch\n");
         return 0; // filter from output
      }

      // -justdirs: IF any non-"*" file mask is set,
      if (glblFileSet.anyFileMasks())
      {
         if (cs.debug) printf("]  esdir: using file masks\n");
         //  process dir only if any files within match
         if (!nTreeFiles) return 0; // skip
         // -justdirs: make sure the next-higher dir is not listed again
         if (cs.justdirs)  // FIX: 167: stat mydir .mask always "0 files"
            nTreeFiles = 0;
      } else {
         if (cs.debug) printf("]  esdir: no file masks, process all\n");
      }
   }

   if (cs.walkDirDelay > 0) doSleep(cs.walkDirDelay);

   // skip initial dot slash which might be returned by dir scanning
   if (!strncmp(pszName, glblDotSlash, 2))
      pszName += 2;

   if (pszGlblSinceDir)
   {
      // build relative name of file to be processed
      char *pszRel = pszName;
      if (!bGlblSinceDirIncRef)
            pszRel = rootRelativeName(pszName, pszOptRoot);
      if (!pszRel) return 9;

      // check if dirs for comparison both exist
      joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszGlblSinceDir, pszRel);
      if (!isDir(szRefNameBuf)) {
         // this is often a user error
         if (cs.verbose) {
            setTextColor(nGlblWarnColor);
            info.print("no reference dir: %s\n", szRefNameBuf);
            setTextColor(-1);
         }
         nGlblMissingRefDirs++;
      } else {
         nGlblMatchingRefDirs++;
      }
   }

   // -since: process only dirs newer or equal than timestamp,
   // relevant only on commands like list -withdirs -since ...
   if (cs.sincetime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get dir time: %s\n", pszName);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime < cs.sincetime)
         return 0; // skip
   }

   // -before: process only dirs older or equal than timestamp
   if (cs.untiltime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get dir time: %s\n", pszName);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime >= cs.untiltime)
         return 0; // skip
   }

   int lRC = 0;
   switch (nGlblFunc)
   {
      case eFunc_FileStat:
           lRC = execDirStat(pcoi, lLevel, nTreeFiles, lDirs, lBytes, nLocalMaxTime, ntime2);
           break;
      case eFunc_FileTime:
           lRC = execDirTime(pszName);
           break;
      case eFunc_CallBack:
           lRC = execCallFileDir(pcoi);
           break;
      case eFunc_Run     :
           if (cs.justdirs)
              lRC = execRunDir(pcoi, lLevel, nTreeFiles, lDirs, lBytes);
           break;
      case eFunc_Deblank :
           return execDeblank(pszName);
           break;
      #ifndef USE_SFK_BASE
      case eFunc_Copy    :
           return execDirCopy(pszName, oDirFiles);
      case eFunc_Cleanup :
           return execDirCleanup(pszName, oDirFiles);
      case eFunc_Move    :
           return execDirMove(pszName, oDirFiles);
      case eFunc_MetaUpd: execMetaDirUpdate(pszName); break;
      #if defined(SFKPACK)
      case eFunc_ZipTo:  return execZipFile(pcoi, 1, 0); break;
      #endif
      #endif // USE_SFK_BASE

      case eFunc_Find:
           if (cs.subdirs) {
              info.setAddInfo("%u files, %u dirs", cs.filesScanned, cs.dirsScanned);
              info.setStatus("scan ", pszName, 0, eKeepAdd);
              cs.dirsScanned++;
           }
           break;

      case eFunc_Delete:
            lRC = execDelDir(pszName, lLevel, nTreeFiles, oDirFiles, lDirs, lBytes, nLocalMaxTime, ntime2);
            break;

      #ifdef WITH_TCP
      case eFunc_FTPList :
            if (!bGlblFTPListAsHTML || cs.withdirs)
               return execFTPList(pszName);
            break;
      #endif

      #ifndef USE_SFK_BASE
      case eFunc_XRename: 
         if (cs.withdirs || cs.justdirs)
            return execXRename(pcoi);
         break;
      #endif

      default:
           break;
   }

   // localMaxTime was used w/in above methods, reset now
   // to avoid potential further use in other dir trees.
   nLocalMaxTime = 0;

   return lRC;
}

int execTextJoinLines(char *pIn) {
   // join a text file with lines broken by mailing

   // 1. pre-scan for line length maximum
   char *psz = pIn;
   int nLineChars = 0;
   int nLineCharMax = 0;
   while (*psz)
   {
      char c = *psz++;
      if (c == '\r')
         continue;
      if (c == '\n') {
         if (nLineChars > nLineCharMax)
            nLineCharMax = nLineChars;
         nLineChars = 0;
         continue;
      }
      nLineChars++;
   }

   if (!cs.quiet)
      printf("[line break near %d]\n", nLineCharMax);

   // 2. join lines which are broken, pass-through others
   psz = pIn;
   nLineChars = 0;
   while (*psz)
   {
      char c = *psz++;

      if (c == '\r') // drop CR. LF-mapping is done by runtime.
         continue;

      if (c == '\n') {
         // line collected. what to do?
         if (   (nLineChars < nLineCharMax-1)
             || (nLineChars > nLineCharMax)
            )
         {
            fputc(c, fGlblOut);  // not near threshold: do not join
         }
         nLineChars = 0;
         continue;
      } else {
         fputc(c, fGlblOut);
      }

      nLineChars++;
   }
 
   return 0;
}

int hexToBin(char *pszHex, uchar *pBin, uint nBinLen)
{
   int nBinRem = (int)nBinLen; // remaining out buffer
   char szBuf[10];
   memset(szBuf, 0, sizeof(szBuf));
   while (*pszHex && (nBinRem > 0)) {
      szBuf[0] = *pszHex++;
      if (!*pszHex) return 1;
      szBuf[1] = *pszHex++;
      if (!isxdigit(szBuf[0])) return 2;
      if (!isxdigit(szBuf[1])) return 2;
      *pBin++ = (uchar)strtol(szBuf, 0, 0x10);
      nBinRem--;
   }
   if (*pszHex || nBinRem)
      return 3;
   return 0;
}

uchar *memFind(uchar *pNeedle, num nNeedleSize, uchar *pHayStack, num nHaySize)
{
   uchar *pCur = pHayStack;
   uchar *pMax = pHayStack + nHaySize - nNeedleSize; // inclusive
   uchar c1    = *pNeedle;
   while (pCur <= pMax)
   {
      uchar *p1 = pCur;
      // seek to next potential start
      // while ((p1 <= pMax) && (*p1 != c1))
      //   p1++;
      p1 = (uchar*)memchr(p1, c1, pMax - p1 + 1); // +1: pMax is inclusive
      if (!p1 || (p1 > pMax))
         return 0;
      // compare
      if ((p1 <= pMax) && !memcmp(p1, pNeedle, nNeedleSize))
         return p1;  // hit
      // no hit, proceed
      pCur = p1+1;
   }
   return 0;
}

int provideExtractOutFile(char *pszFilename)
{
   if (cs.sim)
      return 0;
   if (cs.extractOutFile)
      return 0; // OK
   if (createOutDirTree(pszFilename))
      return 9;
   if ((cs.extractOutFile = fopen(pszFilename, "wb"))) {
      if (cs.quiet < 2)
         printf("write: %s\n", pszFilename); // sfk190
      return 0;
   }
   return 9+perr("cannot write output file: %s", pszFilename);
}

int addToExtractOutFile(uchar *pData, int iSize)
{
   if (cs.sim) // sfk1914
      return 0;
   if (!cs.extractOutFile)
      return 9;
   if (fwrite(pData, 1, iSize, cs.extractOutFile) != iSize)
      return 9+perr("cannot fully write output file, probably disk full");
   return 0;
}

void perFileExtractOutCleanup( )
{
   if (!cs.tomaskfile && cs.extractOutFile) {
      fclose(cs.extractOutFile);
      cs.extractOutFile = 0;
   }
}

void globalExtractOutCleanup( )
{
   if (cs.extractOutFile) {
      fclose(cs.extractOutFile);
      cs.extractOutFile = 0;
   }
}

class SFKMatch;
SFKMatch *apRepObj  = 0;

int  nGlblDumpCtx   = 0; // additional context bytes for dump
int  nBinRepExp     = 0; // no. of replacement expressions
uchar **apRepSrcExp = 0; // source expressions
int  *apRepSrcLen   = 0; // length of source expressions
uchar **apRepDstExp = 0; // dest. expressions
int  *apRepDstLen   = 0; // length of dest. expressions
int  *apRepFlags    = 0; // 0:is it text or binary, 1:was it found,
                         // 2:use case, 3:dump totext
num   *apRepOffs    = 0; // current offset in file to continue search
#ifdef WITH_CASE_XNN
uchar **apRepSrcBit = 0; // bit flags per char
#endif

// note: default record size is 100000
#define SFK_CTX_SIZE 32768
#define SFK_CTX_MASK 32767

#ifndef USE_SFK_BASE
void copySFKMatchOptions()
{
   SFKMatch::bClUseCase = cs.usecase;
   SFKMatch::bClXChars  = cs.xchars;
   SFKMatch::bClExtract = cs.extract;
   SFKMatch::bClXText   = cs.xtext;
   SFKMatch::cClLitAttr = cs.litattr;
   SFKMatch::iClTrace   = cs.verbose >= 3 ? 1 : 0; // sfk194
}
#include "sfkmatch.cpp" // sfkmatch.mod
#endif // USE_SFK_BASE

#define SFK_JUST_OSE
#include "sfkext.cpp"

int execReplaceFix(Coi *pcoi)
{__
   char *pszFile = pcoi->name();

   if (cs.debug)
      { printf("execReplaceFix: %s\n", pszFile); }

   if (!pcoi->existsFile())
      return 1+pwarn("unable to read: %s - skipping\n", pszFile);

   num nFileSize = pcoi->getSize();
   if (nFileSize < 0 ) return 1+pwarn("unable to read: %s - skipping\n", pszFile);
   if (nFileSize == 0) return 0+pwarn("empty file: %s - skipping\n", pszFile);

   FileInfo finf;
   if (finf.init(pszFile, 56, nFileSize)) return 9;

   int lRC = 0;

   if (cs.sim) {  // with hexfind, sim MUST be set
      if (pcoi->open("rb"))
         return 1+perr("failed to read: %s - skipping%s\n", pcoi->name(),pcoi->lasterr());
   } else {
      if (cs.keeptime)
         pcoi->setKeepTime(pcoi);
      if (pcoi->open("r+b"))
         return 1+perr("failed to read+write: %s - skipping\n", pcoi->name(),pcoi->lasterr());
   }

   cs.files++; // no. of files read

   bool bFileChanged = 0;

   // reset hit flags etc.
   for (int i5=0; i5<nBinRepExp; i5++) {
      apRepFlags[i5] &= (0xFF ^ (1 << 1));
      apRepOffs[i5] = 0;
   }

   num nBlockPos  =  0;
   num nBlockSize =  0;
   num nReplaced  =  0;
   bool bTold     =  0;
   int nPerc      =  0;
   int nLastPerc  =  0;
   num  nLastOff  = -1;
   bool bbail     =  0;
   bool bLastRecord = 0;

   while (!bbail)
   {
      if (userInterrupt())
         { lRC=2; break; }

      nPerc = (int)(nBlockPos * 100 / nFileSize);

      if (pcoi->seek(nBlockPos, SEEK_SET))
      {
         pcoi->close();
         if (bTold) printf("\n");
         perr("failed to seek within %s%s\n", pszFile, cs.sim ? "" : " - stopping write. file may be damaged.");
         lRC=1; break;
      }

      num nRead = pcoi->read(abBuf, sizeof(abBuf)-1000);

      // printf("erf: read %d from %d\n",(int)nRead,(int)nBlockPos);

      if (nRead <= 0) {
         if (nBlockPos == nFileSize)
            break; // OK, EOF reached
         pcoi->close();
         if (bTold) printf("\n");

         #ifdef VFILEBASE
          #ifndef VFILEMAX
         if (pcoi->isZipSubEntry()) {
            setTextColor(nGlblWarnColor);
            printf("... stopped reading at %d bytes (demo limit).\n",(int)(nBlockPos-54));
            setTextColor(-1);
         }
         else
          #endif
         #endif // VFILEBASE
         perr("failed to fully read %s%s\n", pszFile, cs.sim ? "" : " - stopping write. file may be damaged.");

         lRC=1; break;
      }

      nBlockSize = nRead;
      bool bTouched = 0;

      // over all search expressions
      for (int iexp=0; iexp<nBinRepExp; iexp++)
      {
         uchar *pExp     = apRepSrcExp[iexp];
         int   nExpLen   = apRepSrcLen[iexp];
         int   nExpFlags = apRepFlags[iexp];
         #ifdef WITH_CASE_XNN
         uchar *pBit     = apRepSrcBit[iexp];
         #endif

         // decide if comparison shall be done case-insensitive.
         bool   bBinary  = (nExpFlags & (1<<0)) ? 1 : 0;
         bool   bUseCase = bBinary || cs.usecase;
         if (cs.nocase) bUseCase = 0; // forced nocase on everything

         // is expression (repeatedly) contained in current block?
         // NOTE: blocks are read with overlapping areas, to avoid patterns
         //       getting lost on block boundaries. therefore nOffs is needed
         //       to avoid repeated hits on the same target, esp. in sim mode.
         num    nOffs = apRepOffs[iexp];
         num    nRel  = nOffs - nBlockPos; // last continue pos, w/in current block
         uchar *pSubCur = abBuf;
         if (nRel > 0) pSubCur += nRel; // don't rescan from start
         uchar *pSubMax = abBuf + nBlockSize - nExpLen;
         while (pSubCur <= pSubMax)
         {
            num nRemain = nBlockSize - (pSubCur - abBuf);

            uchar *pHit = 0;
            if (bUseCase) {
               pHit = memFind(pExp, nExpLen, pSubCur, nRemain);
            } else {
               #ifdef WITH_CASE_XNN
               pHit = memIFind(pExp, nExpLen, pSubCur, nRemain, pBit);
               #else
               pHit = memIFind(pExp, nExpLen, pSubCur, nRemain);
               #endif
            }
            if (!pHit)
               break;

            bool bDumpToText  = (cs.dumpfrom==0 && (nExpFlags & (1 << 3))!=0);
            bool bDumpSingle  = (nExpFlags & (1 << 4)) ? 1 : 0;
            bool bDumpFromText= cs.dumpboth || (bDumpToText ? 0 : 1);

            // in case of rep simulation or hexfind, the destination
            // expression length is NOT the same as ExpLen, but ZERO.
            uchar *pDstText = apRepDstExp[iexp];
            int   nDstLen   = apRepDstLen[iexp];

            if ((cs.verbose >= 2) && !(apRepFlags[iexp] & (1<<0))) {
               int nslen = (int)nExpLen;
               printf("replace @%s: %.*s -> %.*s\n",numtohex(nBlockPos+(pHit-abBuf),10),nslen,pHit,nslen,apRepDstExp[iexp]);
            }

            if (cs.repDump || bDumpSingle)
            {
               num nctx    = nGlblDumpCtx;
               num nAlign0 = bGlblHexDumpWide ? 16 :  8;
               num nAlign1 = bGlblHexDumpWide ? 32+nctx : 16+nctx;
               num nAlign2 = bGlblHexDumpWide ? 48+nctx : 18+nctx;
               num nHitRaw = pHit - abBuf;
               num nHitLow = nHitRaw;
               num nHitHi  = nHitLow + nExpLen;
               if (nHitLow > nAlign1) nHitLow -= nAlign1; else nHitLow = 0;
               if (nHitHi  < (nBlockSize - nAlign2)) {
                  nHitHi += nAlign2;
                  // align dump size to multiples of 16 or 32
                  num nDiff = nHitHi-nHitLow;
                  nDiff = ((num)(nDiff / nAlign0)) * nAlign0; // floor
                  nHitHi = nHitLow + nDiff;
               } else {
                  // near end of file: make sure to dump all bytes
                  nHitHi = nBlockSize;
               }
               num nDumpLen = nHitHi-nHitLow;
               if (nDumpLen < MAX_LINE_LEN) {
                  int iHiOff=-1,iHiLen=-1;
                  memcpy(szRefNameBuf, abBuf+nHitLow, nDumpLen);
                  // this is redundant to cpy below, but doesn't matter
                  if (nExpLen == nDstLen) // else hexfind or sim
                     memcpy(pHit, pDstText, nExpLen);
                  else
                  {
                     // hexfind or sim MUST have cs.sim set.
                     if (!cs.sim) return 9+perr("int. #58281821");
                     // calc hilite area for diffdump below
                     iHiOff = (int)(nHitRaw - nHitLow);
                     iHiLen = nExpLen;
                  }
                  num nListOff = nBlockPos + nHitLow;
                  if (bTold) { bTold=0; finf.printBlankLine(78); }
                  // setTextColor(nGlblFileColor);
                  char szOffBuf1[60]; szOffBuf1[0] = '\0';
                  char szOffBuf5[60]; szOffBuf5[0] = '\0';
                  char szOffBuf2[60]; szOffBuf2[0] = '\0';
                  num nAbsOff = nHitRaw+nBlockPos;
                  if (!cs.fullheader) {
                     // sfk181 default
                     sprintf(szOffBuf1, "at offset 0x%s", numtohex(nAbsOff));
                  } else {
                     // sfk1812 default
                     sprintf(szOffBuf1, "at offset %s (0x%s)", numtoa(nAbsOff), numtohex(nAbsOff,1,szOffBuf5));
                  }
                  if (cs.reldist && nLastOff >= 0) {
                     int nRelOff = (int)(nAbsOff - nLastOff);
                     sprintf(szOffBuf2, " reldist %u (0x%x)", nRelOff, nRelOff);
                  }
                  chain.print('f', 1, "%s : %s %s%s",pszFile,cs.sim?"hit":"change",szOffBuf1,szOffBuf2);
                  // setTextColor(-1);
                  if (nExpLen == nDstLen)
                     diffDump((uchar*)szRefNameBuf, abBuf+nHitLow, nDumpLen, nListOff, iHiOff, iHiLen);
                  else
                  {
                     if (bDumpFromText)
                        execHexdump(0, abBuf+nHitLow, nDumpLen, iHiOff, iHiLen, 0, nListOff);
                     if (cs.dumpboth)
                        dumpFromToSeparator();
                     if (bDumpToText)
                        dumpRepOut(abBuf+nHitLow, nDumpLen, iHiOff, iHiLen, pDstText, nDstLen, nListOff);
                  }
                  nLastOff = nAbsOff;
               }
            }  // endif dump
 
            // this cpy is done always, no matter if RepDump or not:
            if (nExpLen == nDstLen) // else hexfind or sim
               memcpy(pHit, pDstText, nExpLen);
            bTouched = 1;
            nReplaced++;
            apRepFlags[iexp] |= (1 << 1); // local hit mark
            // proceed within block, after hit
            pSubCur = pHit + nExpLen;
            // also remember this position to avoid redundant hits, esp. on sim
            nOffs = nBlockPos + (pSubCur - abBuf);
            apRepOffs[iexp] = nOffs;

            if (cs.useFirstHitOnly)
               { iexp = nBinRepExp; bbail = 1; break; }

         }  // endwhile pSubCur

      }  // endfor patterns

      // need to write block back?
      if (bTouched)
      {
         bFileChanged = 1;

         if (chain.colfiles)
            chain.addFile(*pcoi);
 
         if (cs.sim) {
            if (finf.timeToTell()) {
               printf("%02d%% %s%s : %s hits \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
               fflush(stdout);
               bTold = 1;
            }
         } else {
            if (pcoi->seek(nBlockPos, SEEK_SET)) {
               pcoi->close();
               if (bTold) printf("\n");
               esys("fseek", "failed to seek within %s - stopping write. file may be damaged.\n", pszFile);
               lRC=1; break;
            }
            num nWrite = pcoi->write(abBuf, nBlockSize);
            if (nWrite != nBlockSize) {
               pcoi->close();
               if (bTold) printf("\n");
               esys("fwrite", "failed to write to %s - stopping write. file may be damaged.\n", pszFile);
               lRC=1; break;
            }
            if (!cs.quiet) {
               printf("%02d%% %s%s : %s changes \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
               fflush(stdout);
               bTold = 1;
            }
         }
      }

      // proceed with overlap, to catch expressions on block boundaries
      nBlockPos += nBlockSize;
      if (nBlockPos < nFileSize)
          nBlockPos -= (nBlockSize / 4);

      if (cs.maxscan != 0 && nBlockPos >= cs.maxscan)
         { bbail = 1; break; }

      if (!cs.quiet && (nPerc != nLastPerc)) {
         printf("%02d%% %s%s : %s %s \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced),cs.sim?"hits":"changes");
         bTold = 1;
      }
      nLastPerc = nPerc;

   }  // endwhile input

   if (bFileChanged)
      cs.filesChg++; // replace

   if (lRC) {
      pcoi->close();
      return lRC;
   }

   // collect stats: all patterns found?
   int nTotPats = nBinRepExp;
   int nHitPats = 0;
   for (int i2=0; i2<nBinRepExp; i2++)
   {
      if (apRepFlags[i2] & (1 << 1))
         nHitPats++;
      else
      if (cs.verbose) {
         printf("%s : pattern not found: ",pszFile);
         if (apRepFlags[i2] & (1 << 0)) {
            uchar *pBin = apRepSrcExp[i2];
            for (int i9=0; i9<apRepSrcLen[i2]; i9++)
               printf("%02X",pBin[i9]);
            printf(" [binary]\n");
         } else {
            printf("%s\n",apRepSrcExp[i2]);
         }
      }
   }
   int nNotPats = nTotPats - nHitPats;

   if (bTold)
      finf.printBlankLine(78);

   if (cs.dostat || cs.verbose)
   {
      if (!nHitPats && !cs.verbose)
      { } // don't list files we wouldn't change
      else
      {
         cchar *pszPre   = finf.prefix();
         cchar *pszShort = finf.shortName();
         char szNumBuf[100];
         chain.print(' ', 1, "[%s/%d/%d] %s%s", // FIX: 160R2: nReplaced with >2G
            numtoa(nReplaced,3,szNumBuf),
            (int)nHitPats,(int)nNotPats,pszPre,pszShort);
      }
   }

   pcoi->close();

   return 0;
}

void tellMemLimitInfo() {
   static bool btold = 0;
   if (!btold) { btold = 1;
      pinf("some file(s) are larger than the memory limit (%d mb). see option -memlimit under \"sfk help opt\"\n",
         nGlblMemLimit / 1048576);
   }
}

int execReplaceVar(Coi *pcoi)
{__
   char *pszFile = pcoi->name();

   if (cs.debug)
      { printf("execReplaceVar: %s\n", pszFile); }

   if (!pcoi->existsFile())
      return 1+perr("unable to read: %s - skipping\n", pszFile);

   num nFileSize = pcoi->getSize();
   if (nFileSize < 0 ) return 1+perr("unable to read: %s - skipping\n", pszFile);
   if (nFileSize == 0) return 0+pwarn("empty file: %s - skipping\n", pszFile);

   if (!cs.sim && cs.keeptime)
      pcoi->setKeepTime(pcoi);

   FileInfo finf;
   if (finf.init(pszFile, 56)) return 9;

   int lRC = 0;

   if (nFileSize > nGlblMemLimit) {
      perr("file too large to load: %s, %s mbytes", pszFile, numtoa(nFileSize/1000000));
      tellMemLimitInfo();
      return 9;
   }

   num nFileSize2 = 0;
   uchar *praw = loadBinaryFile(pszFile, nFileSize2);
   if (!praw) return 9+pferr(pszFile, "cannot load: %s\n", pszFile);
   if (nFileSize2 != nFileSize) {
      delete [] praw;
      return 9+pferr(pszFile, "cannot load (2): %s\n", pszFile);
   }

   cs.files++; // no. of files read

   bool bFileChanged = 0;

   // reset hit flags etc.
   for (int i5=0; i5<nBinRepExp; i5++) {
      apRepFlags[i5] &= (0xFF ^ (1 << 1));
      apRepOffs[i5] = 0;
   }

   num nReplaced  = 0;
   bool bTold     = 0;
   int nPerc      = 0;
   int nLastPerc  = 0;
   bool bTouched  = 0;

   num nMaxSizeCur  = nFileSize; // temporary output buffer used size
   num nMaxSizePeak = 0;         // largest expansion reached by output buffer
   uchar *pMaxDat   = 0;         // alloc'ed using MaxSizePeak
   uchar *pMem      = praw;
   num    nMemSize  = nFileSize;
   bool   bGlobalExpand = 0;  // overall memory
   bool   bLocalExpand  = 0;  // current expression

   // NO RETURN W/O DELETE FROM HERE

   int npasses = cs.sim ? 1 : 2;

   for (int npass=0; npass<npasses; npass++)
   {
      if (userInterrupt())
         { lRC=2; break; }

      if (npass == 1) {
         if (nMaxSizePeak > nFileSize) {
            num nTotalUsage = nFileSize + nMaxSizePeak;
            if (nTotalUsage > nGlblMemLimit) {
               perr("memory limit exceeded: %s requires %s mbytes for processing\n", pszFile, numtoa(nTotalUsage/1000000));
               pinf("say \"sfk -memlimit=500m replace ...\" to change the limit to 500 mbytes.\n");
               delete [] praw;
               return 9;
            }
            pMaxDat = new uchar[nMaxSizePeak+1024];
            memset(pMaxDat, 0, nMaxSizePeak+1024);
            memcpy(pMaxDat, praw, nFileSize);
            pMaxDat[nMaxSizePeak] = 0xEE;
            bGlobalExpand = 1;
         } else {
            pMaxDat = praw;
            pMaxDat[nFileSize] = 0xEE; // extended bytes provided by loadBinaryFile
         }
         pMem    = pMaxDat;
         nMemSize= nFileSize; // initially, changes with replacements.
      }

      // over all search expressions
      for (int iexp=0; iexp<nBinRepExp; iexp++)
      {
         if (userInterrupt())
            { lRC=2; break; }

         // get source pattern
         uchar *pSrc     = apRepSrcExp[iexp];
         int   nSrcLen   = apRepSrcLen[iexp];
         int   nSrcFlags = apRepFlags[iexp];
         #ifdef WITH_CASE_XNN
         uchar *pBit     = apRepSrcBit[iexp];
         #endif

         // decide if comparison shall be done case-insensitive.
         bool   bBinary  = (nSrcFlags & (1<<0)) ? 1 : 0;
         bool   bUseCase = bBinary || cs.usecase;
         if (cs.nocase) bUseCase = 0; // forced nocase on everything

         // get destination pattern
         uchar *pDst    = apRepDstExp[iexp];
         int   nDstLen  = apRepDstLen[iexp];

         // get size diff for current pattern
         int   nSizeDiff = nDstLen - nSrcLen;

         bLocalExpand = (nSizeDiff > 0) ? 1 : 0;

         // scan whole data with current pattern
         uchar *pInCur  = pMem;
         uchar *pInMax  = pMem + nMemSize;

         while (pInCur < pInMax)
         {
            if (userInterrupt())
               { lRC=2; break; }

            num nRemain = nMemSize - (pInCur - pMem);
            uchar *pHit = 0;

            if (bUseCase) {
               pHit = memFind(pSrc, nSrcLen, pInCur, nRemain);
            } else {
               #ifdef WITH_CASE_XNN
               pHit = memIFind(pSrc, nSrcLen, pInCur, nRemain, pBit);
               #else
               pHit = memIFind(pSrc, nSrcLen, pInCur, nRemain);
               #endif
            }
            if (!pHit)
               break;

            // process hit
            if (npass < 1) {
               // first pass: calc target size.
               nMaxSizeCur += nSizeDiff;
               // find the global maximum size for pass2 allocation.
               if (nMaxSizeCur > nMaxSizePeak)
                   nMaxSizePeak = nMaxSizeCur;
               // else do NOT shrink the output size.
            } else {
               // 2nd pass: apply replacement
               num nHitRem = nMemSize - (pHit - pMem);
               // printf("apply replace, %d\n", nSizeDiff);
               // printf("old: %.20s delta %d size %d\n", pHit, nSizeDiff, (int)(nHitRem-nSizeDiff));
               // sfkmem_hexdump(pHit-10, 32);
               if (bLocalExpand)
                  memmove(pHit+nSizeDiff, pHit, nHitRem+0); // memory EXPANDS by nSizeDiff.
               else
                  memmove(pHit, pHit-nSizeDiff, nHitRem+nSizeDiff);
               // printf("     move %p %p %u bytes\n",pHit+nSizeDiff, pHit, (int)(nHitRem-nSizeDiff));
               if (nDstLen) memcpy(pHit, pDst, nDstLen);
               // printf("new: %.20s\n", pHit);
               // sfkmem_hexdump(pHit-10, 32);

               // overall size of memory changes:
               nMemSize += nSizeDiff;
            }

            if (   ( cs.sim && npass==0)
                || (!cs.sim && npass==1)
               )
            {
               bTouched = 1;
               nReplaced++;
               apRepFlags[iexp] |= (1 << 1); // local hit mark
            }

            // proceed within block, after hit
            if (npass == 0)
               pInCur = pHit + nSrcLen;   // there is no replace yet, skip hit
            else
               pInCur = pHit + nDstLen;   // continue search after replaced area

            // recalc max:
            pInMax = pMem + nMemSize;

            // tell progress:
            if (nMemSize) nPerc = (int)((pInCur-pMem) * 100 / nMemSize);
            if (!cs.quiet && (nPerc != nLastPerc) && finf.timeToTell()) {
               printf("%02d%% %s%s : %s %s \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced),cs.sim?"hits":"changes");
               bTold = 1;
               nLastPerc = nPerc;
            }

            if (cs.useFirstHitOnly)
               { iexp = nBinRepExp; break; }

         }  // endwhile pcur < pmax

      }  // endfor patterns

   }  // endfor pass

   // need to write everything back?
   if (!lRC && bTouched)
   do
   {
      bFileChanged = 1;

      if (chain.colfiles)
         chain.addFile(*pcoi);
 
      if (cs.sim) {
         if (finf.timeToTell()) {
            printf("%02d%% %s%s : %s hits \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
            fflush(stdout);
            bTold = 1;
         }
      } else {
         // whole content is written in one go.
         // coi::write takes care of big block writing.
         if (pcoi->open("wb")) {
            perr("cannot rewrite file: %s%s\n", pcoi->name(),pcoi->lasterr());
            lRC=9;
            break;
         }
         num nWrite = pcoi->write(pMaxDat, nMemSize);
         pcoi->close();
         if (nWrite != nMemSize) {
            if (bTold) printf("\n");
            esys("fwrite", "failed to write to %s - stopping write. file may be damaged.\n", pszFile);
            lRC=1;
         }
         if (!cs.quiet) {
            printf("%02d%% %s%s : %s changes \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
            fflush(stdout);
            bTold = 1;
         }
      }
   }
   while (0);

   // red zone check
   if (!cs.sim && pMaxDat) {
      if (bGlobalExpand) {
         if (pMaxDat[nMaxSizePeak] != 0xEE)
            perr("internal: memory overwrite past target block, on expand\n");
      } else {
         if (pMaxDat[nFileSize] != 0xEE)
            perr("internal: memory overwrite past target block, on shrink\n");
      }
   }

   // NO RETURN W/O DELETE UNTIL HERE

   if (pMaxDat && (pMaxDat != praw))
      delete [] pMaxDat;

   delete [] praw;

   if (bFileChanged)
      cs.filesChg++; // replace

   if (lRC) return lRC;

   // collect stats: all patterns found?
   int nTotPats = nBinRepExp;
   int nHitPats = 0;
   for (int i2=0; i2<nBinRepExp; i2++)
   {
      if (apRepFlags[i2] & (1 << 1))
         nHitPats++;
      else
      if (cs.verbose) {
         printf("%s : pattern not found: ",pszFile);
         if (apRepFlags[i2] & (1 << 0)) {
            uchar *pBin = apRepSrcExp[i2];
            for (int i9=0; i9<apRepSrcLen[i2]; i9++)
               printf("%02X",pBin[i9]);
            printf(" [binary]\n");
         } else {
            printf("%s\n",apRepSrcExp[i2]);
         }
      }
   }
   int nNotPats = nTotPats - nHitPats;

   if (bTold)
      finf.printBlankLine(78);

   if (cs.dostat || cs.verbose)
   {
      if (!nHitPats && !cs.verbose)
      { } // don't list files we wouldn't change
      else
      {
         cchar *pszPre   = finf.prefix();
         cchar *pszShort = finf.shortName();
         num   nSizeDiff = nMemSize - nFileSize;
         const char *pszSign = (nSizeDiff > 0) ? "+":"";
         char szNumBuf[100];
         printf("[%s/%d/%d] %s%s",  // FIX: 160R2: nReplaced with >2G
            numtoa(nReplaced,3,szNumBuf),
            (int)nHitPats,(int)nNotPats,pszPre,pszShort);
         if (nSizeDiff) {
            setTextColor(nGlblTimeColor);
            printf("   %s%s bytes\n",pszSign,numtoa(nSizeDiff));
            setTextColor(-1);
         } else {
            printf("\n");
         }
      }
   }

   return 0;
}

int testReplace(int iTestCaseNumber)
{
   int irc = 0;

   srand((unsigned)time(NULL)); // testreplace

   SFKMD5 md5src;
   SFKMD5 md5dst;

   uchar abSrcPat[10][200];
   int   aSrcLen[10];

   uchar abDstPat[10][200];
   int   aDstLen[10];
 
   int   aPatNum[10];
 
   char szPatFile[200];
   sprintf(szPatFile, "tmp%crep%03dpat.txt" , glblPathChar, iTestCaseNumber);

   FILE *fpat = fopen(szPatFile, "w");
   if (!fpat) return 9+perr("cannot write: %s\n", szPatFile);
   fprintf(fpat, ":binary\n");

   // create search/replace test patterns
   for (int ipat=0; ipat<10; ipat++)
   {
      int isrclen = rand() % 180 + 5;
      int idstlen = rand() % 180 + 5;
 
      fprintf(fpat, "/");

      for (int i=0; i<isrclen; i++)
      {
         while ((abSrcPat[ipat][i] = (uchar)rand()) == '.');
         fprintf(fpat, "%02X", abSrcPat[ipat][i]);
      }
      aSrcLen[ipat] = isrclen;
 
      fprintf(fpat, "/");

      for (int i=0; i<idstlen; i++)
      {
         while ((abDstPat[ipat][i] = (uchar)rand()) == '.');
         fprintf(fpat, "%02X", abDstPat[ipat][i]);
      }
      aDstLen[ipat] = idstlen;
 
      fprintf(fpat, "/\n");
   }
   fclose(fpat);

   mclear(aPatNum);
 
   // create before/after replace data
   char szName1[200];
   char szName2[200];
   char szName3[200];
 
   sprintf(szName1, "tmp%srep%03dsrc.dat" , glblPathStr, iTestCaseNumber);
   sprintf(szName2, "tmp%srep%03ddst.dat" , glblPathStr, iTestCaseNumber);
   sprintf(szName3, "tmp%srep%03ddst2.dat", glblPathStr, iTestCaseNumber);

   FILE *f1 = fopen(szName1, "wb");
   if (!f1) return 9+perr("cannot write: %s\n", szName1);

   FILE *f2 = fopen(szName2, "wb");
   if (!f2) return 9+perr("cannot write: %s\n", szName2);

   int iTotalSizeMB = rand() % 10 + 5;
   int iTotalSize   = iTotalSizeMB * 1000000;
   int iTotalSrc=0, iTotalDst=0;

   char abText[1024];
   memset(abText, '.', 1024);
 
   uchar *psrc=0,*pdst=0;
   int    nsrc=0, ndst=0;
 
   while (iTotalSrc < iTotalSize)
   {
      // write another text string, or a pattern?
      if ((rand() & 127) < 10)
      {
         // another pattern
         int ipat = rand() % 10;
 
         psrc = abSrcPat[ipat];
         nsrc = aSrcLen[ipat];
 
         pdst = abDstPat[ipat];
         ndst = aDstLen[ipat];
 
         aPatNum[ipat]++;
      }
      else
      {
         int ilen = (rand() % 50) + 5;

         psrc = (uchar*)abText;
         nsrc = ilen;

         pdst = psrc;
         ndst = nsrc;
      }

      if (fwrite(psrc, 1, nsrc, f1) != nsrc)
         return 9+perr("cannot fully write, disk full: %s\n", szName1);
      md5src.update(psrc,nsrc);
      iTotalSrc += nsrc;

      if (fwrite(pdst, 1, ndst, f2) != ndst)
         return 9+perr("cannot fully write, disk full: %s\n", szName2);
      md5dst.update(pdst,ndst);
      iTotalDst += ndst;
   }
 
   fclose(f2);
   fclose(f1);

   uchar *pdigsrc = md5src.digest();
   uchar *pdigdst = md5dst.digest();

   // run replace command
   char szCmd[500];
   sprintf(szCmd, ".%csfk replace -quiet=2 -yes -bylist %s %s -to %s",
      glblPathChar, szPatFile, szName1, szName3);
   int isysrc = system(szCmd);
 
   // verify replace output
   SFKMD5 md5dst2;
   if (getFileMD5(szName3, md5dst2))
      return 9+perr("cannot read checksum\n");
   uchar *pdigdst2 = md5dst2.digest();
 
   if (memcmp(pdigdst, pdigdst2, 16))
   {
      perr("Replace result mismatch:\n");
      perr("   %d = %s\n", isysrc, szCmd);
      perr("   %02X%02X%02X%02X : %s\n", pdigdst[0],pdigdst[1],pdigdst[2],pdigdst[3], szName2);
      perr("   %02X%02X%02X%02X : %s\n", pdigdst2[0],pdigdst2[1],pdigdst2[2],pdigdst2[3], szName3);
      irc = 10;
   }
 
   return irc;
}

int aGlblIndentStats[10];

int execScantab(char *pszFile)
{__
   cs.files++;

   int i=0;

   int aind[100];
   memset(aind, 0, sizeof(aind));

   int amul[10]; // multiples of n counters
   memset(amul, 0, sizeof(amul));

   int nMaxMulIndex = 0;
   int nMaxMulCnt   = 0;
   bool bHaveTabs    = 0;
 
   // collect indent stats
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+pferr(pszFile, "cannot read: %s\n", pszFile);

   bool bBinary = 0;

   myfgets_init();
   while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin, &bBinary))
   {
      // binary file detected?
      if (bBinary) {
         fclose(fin);
         if (cs.verbose)
            oprintf("binary  : %s\n", pszFile);
         return 0;
      }

      szLineBuf[sizeof(szLineBuf)-10] = '\0';
      removeCRLF(szLineBuf);
      int nLen = (int)strlen(szLineBuf);

      // any tabs contained?
      if (!bHaveTabs && strchr(szLineBuf, '\t')) {
         bHaveTabs = 1;
         if (!cs.scanIndent)
            break;
      }

      // analyze single line
      int nBlanks = 0;
      for (i=0; i<nLen; i++) {
         if (szLineBuf[i] == ' ') {
            if (++nBlanks >= 60)
               break;
         }
         else
            break;
      }

      // have no. of blanks at line start.
      aind[nBlanks]++;

      // nBlanks is a multiple of ...
      if (nBlanks)
      for (i=3; i<=8; i++) {
         if ( ((nBlanks / i) * i) == nBlanks ) {
            // create sorted stats
            amul[i]++;
            if (amul[i] > nMaxMulCnt) {
               nMaxMulCnt   = amul[i];
               nMaxMulIndex = i;
            }
         }
      }
   }
   fclose(fin);

   if (nMaxMulIndex >= 0 && nMaxMulIndex < 10)
      aGlblIndentStats[nMaxMulIndex]++;

   if (bHaveTabs)
      cs.tabFiles++;

   if (cs.indentFilt) {
      if (nMaxMulIndex != 0 && cs.indentFilt == nMaxMulIndex)
         oprintf("%s\n", pszFile);
      return 0;
   }

   if (bHaveTabs) {
      if (!cs.verbose && !cs.quiet) {
         if (cs.tabFiles==1 && !cs.pure)
            printf("list of files containing tabs:\n");
         if (!strncmp(pszFile, glblDotSlash, 2))
            pszFile += 2;
         setTextColor(nGlblFileColor);
         oprintf("%s\n", pszFile);
         setTextColor(-1);
      }
      if (chain.colfiles) {
         // chain mode: collect (new) filename list
         Coi ocoi(pszFile, glblFileSet.root());
         chain.addFile(ocoi); // is copied
      }
   }

   if (cs.verbose)
      oprintf("indent %d: %s\n", nMaxMulIndex, pszFile);

   // dump indent stats
   if (cs.verbose >= 2)
   {
      // for (i=1; i<100; i++)
      //   if (aind[i] > 0)
      //      printf("%2.2d : %3.3d times\n", i, aind[i]);
      // printf("\n");
 
      printf("   ");
      for (i=3; i<=8; i++)
         printf("%2.2d/%3.3d ", i, amul[i]);
      printf("\n");
   }

   return 0;
}

int execDelFile(char *pszName)
{__
   cs.filesScanned++;
   bool bwaswp = 0;
   if (!cs.sim) {
      if (remove(pszName)) {
         // file is probably write protected
         if (setWriteEnabled(pszName)) {
            cs.filesDelFailed++;
            return 1+pwarn("cannot delete: %s\n", pszName);
         }
         if (remove(pszName)) {
            cs.filesDelFailed++;
            return 1+pwarn("cannot delete: %s\n", pszName);
         }
         bwaswp = 1;
         cs.filesDeletedWP++;
      }
   }
   if (!cs.quiet) {
      if (bwaswp) {
         oprintf("DEL : %s", pszName);
         printx("   <time>(was write protected)<def>\n");
      } else {
         oprintf("DEL : %s\n",pszName);
      }
   }
   cs.filesDeleted++;
   return 0;
}

int execDelDir(char *pszName, int lLevel, int &lGlobFiles, FileList &oDirFiles, int &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2)
{__
   if (!cs.withdirs)
      return 0;

   cs.dirsScanned++;

   // every execDelFile with RC==0 (deleted successfully)
   // lead to an entry in the oDirFiles list.
   int nNumberOfDeletedFiles = oDirFiles.clNames.numberOfEntries();

   // alternatively, if the user supplied "*" as file mask,
   // delete all empty dirs.
   char *pfmask  = glblFileSet.firstFileMask();
   bool  bdelall = !strcmp(pfmask, "*") ? 1 : 0;
 
   // FIX: 166: "0 dirs" statistics on rmtree simulation
   bool bsimdelall = (cs.sim && bdelall) ? 1 : 0;

   // if this number is >0 AND the directory is NOW empty,
   // then it became empty due to a delete action.
   if (bdelall || nNumberOfDeletedFiles > 0)
   {
      if (bsimdelall || (cs.force || isEmptyDir(pszName))) // sfk193: -force
      {
         // todo: delete of readonly dirs
         bool bwaswp = 0;
         if (!cs.sim) {
            if (rmdir(pszName)) {
               // dir is probably write protected
               if (setWriteEnabled(pszName)) {
                  cs.dirsDelFailed++;
                  return 1+pwarn("cannot delete: %s\n", pszName);
               }
               if (rmdir(pszName)) {
                  cs.dirsDelFailed++;
                  return 1+pwarn("cannot delete: %s\n", pszName);
               }
               bwaswp = 1;
               cs.dirsDeletedWP++;
            }
         }
         if (!cs.quiet) {
            if (bwaswp) {
               oprintf("DEL : %s", pszName);
               printx("   <time>(was write protected)<def>\n");
            } else {
               oprintf("DEL : %s\n",pszName);
            }
         }
         cs.dirsDeleted++;
      } else {
         if (bdelall && !cs.sim) {
            pinf("dir not empty, cannot delete: %s\n", pszName);
            cs.dirsDelFailed++;
            return 1;
         }
      }
   }

   return 0;
}

int execVersion(Coi *pcoi)
{__
   int nrc = 0;

   #ifdef VFILEBASE
   if (pcoi->preload("ver", 0, 0, 1)) // execVersion
      return 9+perr("cannot get version from: %s", pcoi->name());
   #endif // VFILEBASE

   uchar *pdata = pcoi->data().src.data;
   num    nsize = pcoi->data().src.size;
   if (!pdata)
      return 9+perr("cannot get version from: %s", pcoi->name());

   char szVerID[50];
   sprintf(szVerID, "$%s:", "version");

   /*
   56004500 52005300 49004F00 4E005F00 49004E00 46004F00 00000000 BD04EFFE< V.E.R.S.I.O.N._.I.N.F.O.........
   00000100 00003800 57006C0B 00003800 57006C0B 17000000 00000000 04000000< ......8.W.l...8.W.l.............
   0x5045 0000 6486 == windows-64
   0x5045 0000 4C01 == windows-32
   */
   uchar abVerID2[100];
   uchar abVerIDWin32[50];
   uchar abVerIDWin64[50];
   {
      mclear(abVerID2);
      mclear(abVerIDWin32); mclear(abVerIDWin64);
      cchar *pverid21 = "VS_VERSION_INFO";
      uchar abverid22[4] = { 0xBD,0x04,0xEF,0xFE };
      int i=0;
      for (i=0; pverid21[i]; i++)
         abVerID2[i*2+0]=(uchar)pverid21[i];
      int nid2=i*2;
      memcpy(abVerID2+34, abverid22, 4);
      uchar *p=abVerIDWin32;
         p[0]=0x50;p[1]=0x45;p[4]=0x4c;p[5]=0x01;
      p=abVerIDWin64;
         p[0]=0x50;p[1]=0x45;p[4]=0x64;p[5]=0x86;
   }

   // find version string within binary data
   uchar *ppat = (uchar*)szVerID;
   num    nlen = strlen((char*)ppat);
   uchar *pver = memFind(ppat,nlen, pdata,nsize);

   char *pnam = str("");
   char *ptyp = str("");
   char *pos  = str("");
   char *pnum = str("");
   char *pfix = str("");
   char *ptit = str("");
   char *pdat = str("");
   char *pinf = str("");
   char  szver[100];  mclear(szver);
   char  szver2[100]; mclear(szver2);
   char  sztime[100]; mclear(sztime);

   StringMap omap; // fix sfk1853

   if (pver)
   {
      // calc max parse range
      num nmax = nsize - (pver - pdata);
      if (nmax <= 0) return 9+perr("int. #28281250");

      if (parseVersion((char*)pver, (int)nmax, omap)) return -1;

      pnam = omap.get(str("name"  ), str(""));
      ptyp = omap.get(str("type"  ), str(""));
      pos  = omap.get(str("os"    ), str(""));
      pnum = omap.get(str("vernum"), str(""));
      pfix = omap.get(str("fix"   ), str(""));
      ptit = omap.get(str("title" ), str(""));
      pdat = omap.get(str("date"  ), str(""));
      pinf = omap.get(str("info"  ), str(""));

      if (cs.winver) {
         num ntime=pcoi->getTime();
         char *ptime=timeAsString(ntime,0);
         strcopy(sztime,ptime);
         pdat=ptime;
      }
   }
   else if ((pver = memFind(abVerID2,36, pdata,nsize)))
   {
      if (pver > pdata+nsize-100)
         return 1;

      pos = str("windows");

      uchar *p = pver+42;
      //  0    1    2    3    4     5    6   7
      // 0000 3800 5700 6C0B 0000 3800 5700 6C0B
      ushort aval[20];
      for (int i=0; i<8; i++)
         aval[i] =      (((ushort)p[i*2+1]) << 8)
                     |  (((ushort)p[i*2+0]) << 0);

      snprintf(szver,sizeof(szver)-10,"%u.%u.%u.%u",aval[1],aval[0],aval[3],aval[2]);
      snprintf(szver2,sizeof(szver2)-10,"%u.%u.%u.%u",aval[4+1],aval[4+0],aval[4+3],aval[4+2]);
      pnum=szver;

      // if product version ever differs, show it
      if (strcmp(szver2,szver))
         pinf=szver2;

      num ntime=pcoi->getTime();
      char *ptime=timeAsString(ntime,0);
      strcopy(sztime,ptime);
      pdat=ptime;

      if (memFind(abVerIDWin64,6, pdata,mymin(nsize,1024)))
         pos=str("windows-64");
      else
         pos=str("windows-32");
   }

   if (pver)
   {
      if (cs.justvernum)
      {
         if (!pnum)
            return 9+perr("no version number found.");
         char szFull[50];
         strcopy(szFull, pnum);
         if (pfix && *pfix) {
            int ilen = strlen(szFull);
            if (ilen > 0 && szFull[ilen-1] != '.') {
               strcat(szFull, ".");
               ilen++;
            }
            strcat(szFull, pfix);
         }
         chain.print("%s\n", szFull);
      }
      else
      {
         // create integer from version string
         char *psz1 = pnum;
         int nVer = 0;
         int nDot = 3;
         while (*psz1) {
            char c = *psz1++;
            if (c == '.')
               { nVer = nVer * 10; nDot--; }
            else
               nVer = nVer + (c - '0');
         }
         while (nDot-- > 0)
            nVer = nVer * 10;
 
         if (cs.winver)
            chain.print("%s\t%s\t%s\t%s\t%s\n",
               pcoi->name(),pos,pnum,pdat,pinf);
         else
            chain.print("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
               pcoi->name(),pnam,ptyp,pos,pnum,pfix,ptit,pdat,pinf);
      }
   }
   else 
   {
      if (cs.verbose)
         pwarn("no version found within: %s", pcoi->name());
      nrc = 1;
   }

   // TODO: not sure if to postpone this
   pcoi->releaseContent();

   return nrc;
}

void detabLine(char *pszIn, char *pszOut, uint lMaxOut, int nTabSize)
{
   uint nInsert=0, iout=0;
   for (int icol=0; (pszIn[icol]!=0) && (iout<lMaxOut-1); icol++)
   {
      char c1 = pszIn[icol];
      if (c1 == '\t') {
         nInsert = nTabSize - (iout % nTabSize);
         for (uint i2=0; i2<nInsert; i2++)
            pszOut[iout++] = ' ';
      } else {
         pszOut[iout++] = c1;
      }
   }
   pszOut[iout] = '\0';
}

int execDetab(char *pszFile, char *pszOutFile)
{__
   bool bHaveOut = (pszOutFile != 0);
   if (!bHaveOut) pszOutFile = pszFile;

   // load file, take care of global mem limit
   num nFileSize = getFileSize(pszFile);
   if (nFileSize <= 0)
      return 5;
   if (nFileSize >= nGlblMemLimit) {
      pwarn("[nopre] skip: %s - file too large\n", pszFile);
      cs.anyFileTooLarge = 1;
      return 5;
   }

   char *pInFile = new char[nFileSize+10];

   // NO RETURN W/O DELETE FROM HERE

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      pwarn("cannot read: %s\n", pszFile);
      delete [] pInFile;
      return 5;
   }
   num nRead = (num)fread(pInFile, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      pwarn("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pInFile;
      return 5;
   }
   pInFile[nFileSize] = '\0';

   // scan for unexpected NULL bytes
   if (memchr(pInFile, 0, nFileSize) != 0) {
      pwarn("[nopre] skip: %s - text contains null byte(s)\n", pszFile);
      delete [] pInFile;
      return 5;
   }

   cs.files++;

   // any tabs at all contained?
   if (!strchr(pInFile, '\t')) {
      delete [] pInFile;
      return 0;
   }

   cs.tabFiles++;

   if (cs.scanTabs) {
      if (cs.tabFiles==1)
         printf("list of files containing tabs:\n");
      if (!strncmp(pszFile, glblDotSlash, 2))
         pszFile += 2;
      printx("<file>%s<def>\n", pszFile);
      delete [] pInFile;
      return 0;
   }

   // write output file:
   //   if different output is specified, also create directory structure.
   if (bHaveOut) {
      if (cs.yes && createOutDirTree(pszOutFile))
         return 9;
      info.setStatus("detab", pszOutFile);
   } else {
      info.setStatus("detab", pszFile);
   }

   FILE *fOut = 0;
   if (cs.yes) {
      if (!(fOut = fopen(pszOutFile, "w"))) {
         delete [] pInFile;
         return 9+perr("cannot %swrite %s\n", bHaveOut?"":"over", pszOutFile);
      }
   }

   char *pCur     = pInFile;
   int bBail      = 0;
   int nTabsDone = 0;
   while (!bBail && *pCur)
   {
      char *pNext = strchr(pCur, '\n');

      if (pNext)
         *pNext++ = 0; // remove LF on current line
      else
          bBail   = 1; // last line

      // truncate CR on current line, if any
      char *psz   = strchr(pCur, '\r');
      if (psz) *psz = 0;

      // detab a single line
      int nInsert=0, iout=0;
      for (int icol=0; pCur[icol]; icol++)
      {
         char c1 = pCur[icol];
         if (c1 == '\t')
         {
            nInsert = cs.tabSize - (iout % cs.tabSize);
            for (int i2=0; i2<nInsert; i2++) {
               if (cs.yes) fputc(' ', fOut);
               iout++;
            }
            nTabsDone++;
            cs.tabsDone++;
         }
         else
         {
            if (cs.yes) fputc(c1, fOut);
            iout++;
         }
      }

      if (cs.yes) fputc('\n', fOut);

      pCur = pNext;
   }

   if (cs.yes) fclose(fOut);

   // NO RETURN W/O DELETE UNTIL HERE

   delete [] pInFile;

   info.setAddInfo("%5d tabs", nTabsDone);
   info.printLine(1<<2);

   return 0;
}

int execEntab(char *pszFile, char *pszOutFile)
{__
   bool bHaveOut = (pszOutFile != 0);
   if (!bHaveOut) pszOutFile = pszFile;

   // load file, take care of global mem limit
   num nFileSize = getFileSize(pszFile);
   if (nFileSize <= 0)
      return 5;
   if (nFileSize >= nGlblMemLimit) {
      pwarn("[nopre] skip: %s - file too large\n", pszFile);
      cs.anyFileTooLarge = 1;
      return 5;
   }

   char *pInFile = new char[nFileSize+10];

   // NO RETURN W/O DELETE FROM HERE

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      pwarn("cannot read: %s\n", pszFile);
      delete [] pInFile;
      return 5;
   }
   num nRead = (num)fread(pInFile, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      pwarn("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pInFile;
      return 5;
   }
   pInFile[nFileSize] = '\0';

   // scan for unexpected NULL bytes
   if (memchr(pInFile, 0, nFileSize) != 0) {
      pwarn("[nopre] skip: %s - text contains null byte(s)\n", pszFile);
      delete [] pInFile;
      return 5;
   }

   CharAutoDel odel(pInFile);

   cs.files++;

   int nTabsDone = 0;

   FILE *fout = 0;

   for (int ipass=0; ipass<2; ipass++)
   {
      if (ipass)
      {
         // count files that would be changed
         if (nTabsDone > 0)
            cs.tabFiles++;

         // run a write pass?
         if (!nTabsDone)
            break;   // nothing to do

         // write output file:
         //   if different output is specified, also create directory structure.
         if (bHaveOut) {
            if (cs.yes && createOutDirTree(pszOutFile))
               return 9;
            info.setStatus("entab", pszOutFile);
         } else {
            info.setStatus("entab", pszOutFile);
         }

         if (!cs.yes)
            break;   // write not allowed

         if (!(fout = fopen(pszOutFile, "w")))
            return 9+perr("cannot overwrite %s\n", pszOutFile);
      }
 
      char *pCur = pInFile;

      while (*pCur)
      {
         // entab a single line
         int i=0,icol=0;
         for (; pCur[icol]!=0 && pCur[icol]!='\r' && pCur[icol]!='\n'; icol++)
         {
            char c1 = pCur[icol];
            if (c1 != ' ') {
               if (fout) fputc(c1, fout);
               continue;
            }
            // calc posn of next tab stop
            int itab  = ((icol / cs.tabSize) + 1) * cs.tabSize;
            // calc distance to this next tab stop
            int ndist = itab-icol;
            // if this distance is >= 2 chars
            if (ndist >= 1)
            {
               // and completely filled with blanks
               for (i=0; i<ndist; i++)
                  if (!pCur[icol+i] || pCur[icol+i]!=' ')
                     break;
               if (i==ndist) {
                  // then replace blanks by tab
                  if (fout) fputc('\t', fout);
                  icol += ndist-1; // MIND icol++
                  nTabsDone++;
                  if (!ipass) cs.tabsDone++;
                  continue;
               }
               // else fall through
            }
            // else copy-through current char
            if (fout) fputc(c1, fout);
         }
         if (pCur[icol]=='\r')
            icol++;
         if (pCur[icol]=='\n')
            icol++;
 
         if (fout) fputc('\n', fout);
 
         pCur = pCur+icol;
      }
 
      if (fout)
      {
         fclose(fout);
         fout = 0;
      }
   }

   if (nTabsDone)
   {
      info.setAddInfo("%5d tabs", nTabsDone);
      info.printLine(1<<2);
   }

   return 0;
}

int diffDump(uchar *p1, uchar *p2, num nlen, num nListOffset, int iHiOff, int iHiLen)
{__
   num nSubOff = 0, iCurOff = 0;
   num nRemain = nlen;

   char cframe = 'h';

   mclear(szAttrBuf);

   while (nRemain > 0)
   {
      num nBlockLen = nRemain;
      int *appos = 0;

      if (bGlblHexDumpWide)
      {
      strcpy(szLineBuf,
      //  1                                    38               55                73                                   110
      //">00112233 44556677 00112233 44556677< 0123456789ABCDEF 0123456789ABCDEF >00112233 44556677 00112233 44556677< 0123456789ABCDEF");
        ">                                   <                                   >                                   <                 ");
      sprintf(szAttrBuf,
        "%c                                   %c                                   %c                                   %c                 ",
        cframe,cframe,cframe,cframe);
      //                          0  1   2   3   4
      static int aPosWide[] = {  1, 38, 55, 73, 110 };
      appos = aPosWide;
      if (nBlockLen > 16) nBlockLen = 16;
      }
      else
      {
      strcpy(szLineBuf,
      //  1                  20       29        39                 58
      //">00112233 44556677< 01234567 01234567 >00112233 44556677< 0123456789ABCDEF");
        ">                 <                   >                 <                 ");
      sprintf(szAttrBuf,
        "%c                 %c                   %c                 %c                 ",
        cframe,cframe,cframe,cframe);
      //                          0  1   2   3   4
      static int aPosBase[] = {  1, 20, 29, 39, 58 };
      appos = aPosBase;
      if (nBlockLen > 8) nBlockLen = 8;
      }

      // create offset info
      char *pszHexOff = numtohex(nListOffset+nSubOff, 8);
      strcpy(szLineBuf+appos[4], pszHexOff); // ipos
      int iofflen = strlen(pszHexOff);
      memset(szAttrBuf+appos[4], cframe, iofflen);

      for (num i=0; i<nBlockLen; i++)
      {
         iCurOff = nSubOff+i;

         // create hex info
         uchar uc1 = p1[nSubOff+i];
         uchar uc2 = p2[nSubOff+i];
         int iof1 = appos[0] + i * 2 + ((i>=4)?1:0) + ((i>=8)?1:0) + ((i>=12)?1:0);
         int iof2 = appos[3] + i * 2 + ((i>=4)?1:0) + ((i>=8)?1:0) + ((i>=12)?1:0);
         sprintf(szLineBuf+iof1, "%02X", uc1);
         sprintf(szLineBuf+iof2, "%02X", uc2);
         szLineBuf[iof1+2] = ' ';
         szLineBuf[iof2+2] = ' ';

         // create printable info
         int iof3 = appos[1] + i;  // ipos
         int iof4 = appos[2] + i;  // ipos

         if(isprint(uc1)) {
            szLineBuf[iof3] = (char)uc1;
            // szAttrBuf[iof3] = 'i';
         } else
            szLineBuf[iof3] = '.';

         if(isprint(uc2)) {
            szLineBuf[iof4] = (char)uc2;
            // szAttrBuf[iof4] = 'i';
         } else
            szLineBuf[iof4] = '.';

         // highlight different bytes
         if (   (iHiOff >= 0 && iCurOff >= iHiOff && iCurOff < iHiOff+iHiLen)
             || (uc1 != uc2)
            )
         {
            szAttrBuf[iof1+0] = 'a';
            szAttrBuf[iof1+1] = 'a';
            szAttrBuf[iof2+0] = 'a';
            szAttrBuf[iof2+1] = 'a';
            szAttrBuf[iof3]   = 'a';
            szAttrBuf[iof4]   = 'a';
         }
      }
      szLineBuf[appos[1]-2] = '<'; // ipos
      szLineBuf[appos[4]-2] = '<'; // ipos

      // if in binfind mode, show just left part, appending offset
      if (cs.repDumpHalve)
      {
         int iofm = appos[2];
         int iofo = appos[4];
         strcpy(szLineBuf+iofm, szLineBuf+iofo);
         strcpy(szAttrBuf+iofm, szAttrBuf+iofo);
      }

      if (chain.coldata) {
         chain.addLine(szLineBuf, szAttrBuf);
      } else {
         printColorText(szLineBuf, szAttrBuf);
      }

      nSubOff += nBlockLen;
      nRemain -= nBlockLen;
   }
   return 0;
}

int execHexdump(Coi *pcoi, uchar *pBuf, uint nBufSize, int iHighOff, int iHighLen, FILE *foutopt, num nListOffset)
{__
   FILE *fout = stdout;
 
   if (foutopt)
         fout = foutopt;

   char cframe = 'h';

   num ntotal = 0;

   uchar *pBufCur = pBuf;
   int nBufRem = (int)nBufSize;

   num nHexDumpOff = nGlblHexDumpOff;

   if (nHexDumpOff < 0) {
      if (!pcoi) return 9;
      num nInFileSize = pcoi->getSize();
      nHexDumpOff = nInFileSize + nHexDumpOff;
      if (nHexDumpOff < 0)
         nHexDumpOff = 0;
   }

   if (pBuf)
   {
      if (nHexDumpOff >= nBufSize)
         return 5;
      pBufCur += nHexDumpOff;
      nBufRem -= nHexDumpOff;
   }
   else
   {
      // sfk1840: automatic set of leattr
      if (cs.leauto) {
         if (!pcoi->isBinaryFile())
            cs.leattr = 'e';
      }

      if (pcoi->open("rb")) {
         // non-fatal, continue with other files
         return 1+pwarn("%s : cannot read - skipping\n", pcoi->name());
      }

      const char *pszPrefix = (nGlblHexDumpForm>=5) ? "    ":"";

      if (!cs.nonames) {
         if (chain.coldata) {
            sprintf(szLineBuf2, "%s:file %s", pszPrefix, pcoi->name());
            // note: +view scans extended end of attribute line
            //       to identify 'f'ile header lines, therefore +2:
            setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
            chain.addLine(szLineBuf2, szAttrBuf2);
         } else {
            setTextColor(nGlblFileColor);
            if (cs.rawfilename)
               fprintf(fout, "%s :\n", pcoi->name());
            else
               fprintf(fout, "%s:file %s\n", pszPrefix, pcoi->name());
            setTextColor(-1);
         }
      }

      if (nHexDumpOff) {
         if (pcoi->seek(nHexDumpOff, SEEK_SET)) {
            pcoi->close();
            return 1+pwarn("%s : cannot seek - skipping\n", pcoi->name());
         }
         ntotal = nHexDumpOff;
      }
   }

   int lOutLen2=0, lIndex=0, lIndex2=0;
   int lRelPos=0;
   uchar *pTmp = 0;
   uchar ucTmp;
   uchar abBlockBuf[2500]; // sfk1952 up to 2000 input bytes

   int nbpl  = bGlblHexDumpWide ?  32 : 16; // bytes per line
   int itext = bGlblHexDumpWide ?  75 : 39; // text begin
   int ioffs = bGlblHexDumpWide ? 108 : 56; // offset begin
   int ieol  = ioffs + 20;
 
   if (nGlblHexDumpForm && cs.bytesperline)
       nbpl = cs.bytesperline;

   num  nTotalMax = 0;
   if (nGlblHexDumpLen > 0)
        nTotalMax = nHexDumpOff + nGlblHexDumpLen;

   if (cs.verbose) {
      fprintf(fout, "dump from %s ",numtoa(nHexDumpOff));
      fprintf(fout, "to %s ",numtoa(nTotalMax));
      fprintf(fout, "a total of %s bytes\n",numtoa(nGlblHexDumpLen));
   }

   bool bNoBlockTrail = (cs.dumptrail & 1) ? 1 : 0;
   bool bNoLineTrail  = (cs.dumptrail & 2) ? 1 : 0;

   uint uiCharPos = 0;

   while (!userInterrupt()) // sfk1914
   {
      int nread = 0;
      if (pBuf) {
         if (nBufRem <= 0)
            break;
         if (nbpl < nBufRem) nread = nbpl;
         else                nread = nBufRem;
         memcpy(abBlockBuf, pBufCur, nread);
         pBufCur += nread;
         nBufRem -= nread;
      } else {
         nread = pcoi->read(abBlockBuf, nbpl);
      }
      if (nread <= 0) break;
      pTmp = abBlockBuf;

      int lOutLen = nread;
 
      // dump a full or partial output line?
      if (nTotalMax > 0) {
         num nTotalRemain = nTotalMax - ntotal;
         if (lOutLen > nTotalRemain)
            lOutLen = nTotalRemain;
         if (lOutLen <= 0)
            break;
      }

      szLineBuf[0] = '\0';
      bool bshort  = 0;
      bool bEOD    = 0;
 
      // last record?
      if (nTotalMax > 0)
         if (ntotal + nread >= nTotalMax)
            bEOD = 1;

      switch (nGlblHexDumpForm)
      {
         case 0:
            break; // fall through

         case 1: { // pure
            for (int i=0; i<lOutLen; i++)
               mystrcatf(szLineBuf,MAX_LINE_LEN,"%02X",pTmp[i]);
            if (!cs.nolf)
               strcat(szLineBuf,"\n");
            bshort = 1;
            break;
         }

         case 2: { // source, hex
            for (int i=0; i<lOutLen; i++)
               mystrcatf(szLineBuf,MAX_LINE_LEN,"0x%02X,",pTmp[i]);
            int iLen = strlen(szLineBuf);
            if (bNoLineTrail || (bEOD && bNoBlockTrail))
               if (iLen > 0 && szLineBuf[iLen-1] == ',')
                  szLineBuf[iLen-1] = '\0';
            if (!cs.nolf)
               strcat(szLineBuf,"\n");
            bshort = 1;
            break;
         }

         case 3: { // source, dec
            for (int i=0; i<lOutLen; i++)
               mystrcatf(szLineBuf,MAX_LINE_LEN,"%u,",(uint)pTmp[i]);
            int iLen = strlen(szLineBuf);
            if (bNoLineTrail || (bEOD && bNoBlockTrail))
               if (iLen > 0 && szLineBuf[iLen-1] == ',')
                  szLineBuf[iLen-1] = '\0';
            if (!cs.nolf)
               strcat(szLineBuf,"\n");
            bshort = 1;
            break;
         }

         case 4: { // flat, filtering control characters, skipping binary
            for (int i=0; i<lOutLen; i++) {
               uchar c = pTmp[i];
               if (!c) {
                  int nRemain = lOutLen - i;
                  mystrcatf(szLineBuf,MAX_LINE_LEN," [binary, skipping %u bytes]\n", nRemain);
                  break;
               }
               else
               if (c < 0x20 && (c != '\r' && c != '\n' && c != '\t'))
                  continue; // skip control characters except LF, TAB
               else
                  mystrcatf(szLineBuf,MAX_LINE_LEN,"%c",(char)c);
            }
            bshort = 1;
            break;
         }

         case 5: // forum
         case 6: // minimal
         {
         // strcpy(szLineBuf, "    -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- # ---------------- ----");
            strcpy(szLineBuf, "                                                    #                      ");
                           //  01234567890123456789012345678901234567890123456789012345678901234567890123456789
                           //            1         2         3          4        5         6         7
            for (int i=0; i<lOutLen; i++) {
               uchar c = pTmp[i];
               mystrplot(szLineBuf+4+i*3, 2, "%02X", c);
               if (   (nGlblHexDumpForm==5 && isprint(c)!=0)
                   || (nGlblHexDumpForm==6 && isalnum(c)!=0)
                  )
                  szLineBuf[54+i] = c;
               else
                  szLineBuf[54+i] = '.';
            }
            sprintf(szLineBuf+71, "%04X\n", (int)ntotal);
            bshort = 1;
            break;
         };
      }

      if (bshort)
      {
         // dump short form created above
         if (chain.coldata) {
            removeCRLF(szLineBuf); // FIX 169
            if (cs.nolf && chain.colbinary) { // sfk1882
               if (chain.addBinary((uchar*)szLineBuf, strlen(szLineBuf)))
                  return 9;
            } else {
               chain.addLine(szLineBuf, str(""), 0);
            }
         } else {
            fprintf(fout,"%s",szLineBuf);
         }
      }
      else
      {
         // dump full hex format with offset and ascii
         memset(szLineBuf, ' ', ieol);
         memset(szAttrBuf, ' ', ieol);
         szLineBuf[ieol] = '\0';
         szAttrBuf[ieol] = '\0';
 
         szLineBuf[1] = '>';
         szAttrBuf[1] = cframe;

         char *pszHexOff = numtohex(ntotal+nListOffset, 8);
         strcpy(&szLineBuf[ioffs], pszHexOff);
         // adds zero terminator after offset info!
         int iofflen = strlen(pszHexOff);
         memset(szAttrBuf+ioffs, cframe, iofflen);
         int ieol = strlen(szLineBuf);
         szAttrBuf[ieol] = '\0';
 
         lOutLen2 = lOutLen;
 
         for(lIndex = 2, lIndex2 = itext, lRelPos = 0;
             lOutLen2;
             lOutLen2--, lIndex += 2, lIndex2++
            )
         {
            ucTmp = *pTmp++;
 
            sprintf(szLineBuf + lIndex, "%02X ", (unsigned short)ucTmp);
 
            // optional: highlight CR and LF characters
            if (cs.leattr)
               if (ucTmp == '\r' || ucTmp == '\n') {
                  szAttrBuf[lIndex+0] = cs.leattr;
                  szAttrBuf[lIndex+1] = cs.leattr;
                  szAttrBuf[lIndex2 ] = cs.leattr;
               }

            if(isprint(ucTmp))
               szAttrBuf[lIndex2] = ' ';  // mark printable text
            else
               ucTmp = '.'; // nonprintable char

            // optional: highlight given area
            if (iHighOff != -1) {
               uiCharPos = ntotal + lRelPos;
               if (uiCharPos >= iHighOff && uiCharPos < iHighOff+iHighLen) {
                  szAttrBuf[lIndex+0] = 'i';
                  szAttrBuf[lIndex+1] = 'i';
                  szAttrBuf[lIndex2 ] = 'i';
               }
            }

            szLineBuf[lIndex2] = ucTmp;

            if (!(++lRelPos & 3))     // extra blank after 4 bytes
            {  lIndex++; szLineBuf[lIndex+2] = ' '; }
         }
 
         if (!(lRelPos & 3)) lIndex--;
 
         szLineBuf[lIndex  ]   = '<';
         szLineBuf[lIndex+1]   = ' ';
         szAttrBuf[lIndex ]    = cframe;
 
         if (chain.coldata) {
            chain.addLine(szLineBuf, szAttrBuf);
         }
         else if (foutopt) {
            fprintf(fout, "%s\n", szLineBuf);
         }
         else {
            printColorText(szLineBuf, szAttrBuf);
         }
      }

      ntotal += (num)nread;

      if (bEOD)
         break;
   }

   if (foutopt)
      fflush(fout);

   if (!pBuf)
      pcoi->close();

   return 0;
}

int termHexdump(uchar *pBuf, uint nBufSize)
{__
   char cframe = 'h';

   num ntotal = 0;

   uchar *pBufCur = pBuf;
   int nBufRem = (int)nBufSize;

   int lOutLen2=0, lIndex=0, lIndex2=0;
   int lRelPos=0;
   uchar *pTmp = 0;
   uchar ucTmp;
   uchar abBlockBuf[1000];

   int nbpl  = bGlblHexDumpWide ?  32 : 16; // bytes per line
   int itext = bGlblHexDumpWide ?  75 : 39; // text begin
   int ioffs = bGlblHexDumpWide ? 108 : 56; // offset begin
   int ieol  = ioffs + 20;
 
   uint uiCharPos = 0;

   while (1)
   {
      int nread = 0;
      if (nBufRem <= 0)
         break;
      if (nbpl < nBufRem) nread = nbpl;
      else                nread = nBufRem;
      memcpy(abBlockBuf, pBufCur, nread);
      pBufCur += nread;
      nBufRem -= nread;
      if (nread <= 0) break;
      pTmp = abBlockBuf;

      int lOutLen = nread;
 
      szLineBuf[0] = '\0';
      bool bshort  = 0;
      bool bEOD    = 0;
 
      strcpy(szLineBuf, "                                                    #                      ");
      for (int i=0; i<lOutLen; i++) {
         uchar c = pTmp[i];
         mystrplot(szLineBuf+4+i*3, 2, "%02X", c);
         if (   (nGlblHexDumpForm==5 && isprint(c)!=0)
             || (nGlblHexDumpForm==6 && isalnum(c)!=0)
            )
            szLineBuf[54+i] = c;
         else
            szLineBuf[54+i] = '.';
      }
      sprintf(szLineBuf+71, "%04X\n", (int)ntotal);

      {
         // dump full hex format with offset and ascii
         memset(szLineBuf, ' ', ieol);
         memset(szAttrBuf, ' ', ieol);
         szLineBuf[ieol] = '\0';
         szAttrBuf[ieol] = '\0';
 
         szLineBuf[1] = '>';
         szAttrBuf[1] = cframe;

         char *pszHexOff = numtohex(ntotal, 8);
         strcpy(&szLineBuf[ioffs], pszHexOff);
         // adds zero terminator after offset info!
         int iofflen = strlen(pszHexOff);
         memset(szAttrBuf+ioffs, cframe, iofflen);
         int ieol = strlen(szLineBuf);
         szAttrBuf[ieol] = '\0';
 
         lOutLen2 = lOutLen;
 
         for(lIndex = 2, lIndex2 = itext, lRelPos = 0;
             lOutLen2;
             lOutLen2--, lIndex += 2, lIndex2++
            )
         {
            ucTmp = *pTmp++;
 
            sprintf(szLineBuf + lIndex, "%02X ", (unsigned short)ucTmp);
 
            if (ucTmp == '\r' || ucTmp == '\n') {
               szAttrBuf[lIndex+0] = 'e';
               szAttrBuf[lIndex+1] = 'e';
               szAttrBuf[lIndex2 ] = 'e';
            }

            if(isprint(ucTmp))
               szAttrBuf[lIndex2] = ' ';  // mark printable text
            else
               ucTmp = '.'; // nonprintable char

            szLineBuf[lIndex2] = ucTmp;

            if (!(++lRelPos & 3))     // extra blank after 4 bytes
            {  lIndex++; szLineBuf[lIndex+2] = ' '; }
         }
 
         if (!(lRelPos & 3)) lIndex--;
 
         szLineBuf[lIndex  ]   = '<';
         szLineBuf[lIndex+1]   = ' ';
         szAttrBuf[lIndex ]    = cframe;
 
         printColorText(szLineBuf, szAttrBuf);
      }

      ntotal += (num)nread;

      if (bEOD)
         break;
   }

   return 0;
}

// original src : thedir
// have now     : thedir/subdir/thefile.txt
// need relative:        subdir/thefile.txt
char *relName(char *pszRoot, char *pszAbs)
{
   bool bisurl = 0;
   // FIX: 163R5: crash on sfk sel ... +copy due to missing null ptr check
   if (!pszRoot || !strlen(pszRoot))
       return pszAbs;
   #ifdef VFILEBASE
   bisurl =    !strncmp(pszRoot, "ftp://", 6)
            || !strncmp(pszRoot, "http://", 7)
            || !strncmp(pszRoot, "https://", 7);
   // TODO: for now, block relativazation of all http: urls
   if (!strncmp(pszRoot, "http://", 7))
      return pszAbs;
   if (!strncmp(pszRoot, "https://", 8))
      return pszAbs;
   #endif // VFILEBASE
   int nsrclen = strlen(pszRoot);
   if (!strcmp(pszRoot, "."))
       return pszAbs;
   if (!strcmp(pszRoot, pszAbs))
       return pszAbs + nsrclen;
   // have to compare copysrc WITH path separator char!
   if (endsWithPathChar(pszRoot, bisurl))
       nsrclen--;
   // first check name part
   if (strncmp(pszRoot, pszAbs, nsrclen)) {
       pwarn("%s not relative to %s (1)\n",pszAbs,pszRoot);
       return pszAbs; // no match
   }
   // then also path char
   #ifdef _WIN32
   // IF dir is not ending with ':'
   if (endsWithColon(pszRoot))
       return pszAbs + nsrclen;
   #endif
   if (bisurl && pszAbs[nsrclen] == '/')
     { }
   else
   if (pszAbs[nsrclen] != glblPathChar) {
       pwarn("%s not relative to \"%s\" (2) %c\n",pszAbs,pszRoot,pszAbs[nsrclen]);
       return pszAbs; // no match
   }
   char *pszRel = pszAbs + nsrclen + 1; // past separator
   // printf("REL %s => %s\n", pszAbs, pszRel);
   return pszRel;
}

// c:the\foo\bar.txt -> bar.txt
// c:bar.txt -> bar.txt
char *relativeFilename(char *pszPath)
{
   char *pszRel = strrchr(pszPath, glblPathChar);
   if (pszRel) return pszRel+1;

   #ifdef _WIN32
   pszRel = strrchr(pszPath, ':');
   if (pszRel) return pszRel+1;
   #endif

   return pszPath;
}

// returns NULL in case of error.
// returns same name if root doesn't match.
char *rootRelativeName(char *pszFileName, char *pszOptRoot)
{
   if (pszOptRoot)
      return relName(pszOptRoot, pszFileName);

   if (!glblFileSet.hasRoot(0))
      return pszFileName;

   char *pszRoot = glblFileSet.getCurrentRoot();
   if (!pszRoot) { perr("internal 812063\n"); return 0; }

   return relName(pszRoot, pszFileName);
}

int checkArgCnt(int argc, int lMinCnt) {
   if (argc < lMinCnt)
      return 9+perr("missing arguments. type \"sfk\" without parms for help.\n");
   return 0;
}

bool isWriteable(char *pszTmpFile)
{
   FILE *fout = fopen(pszTmpFile, "w");
   if (!fout) return 0;
   fclose(fout);
   remove(pszTmpFile); // cleanup zero-length trash file
   return 1;
}

// uses szLineBuf2, and szLineBuf indirectly, for result.
// RC: number of hits
int listPathAny(char *pszCmd, bool bSilent)
{
   int nhits = 0;

   #ifdef _WIN32

   // check PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH
   char *pszExt = getenv("PATHEXT");
   if (!pszExt) {
      char *psz = findPathLocation(pszCmd, 0);
      if (psz) { nhits++; if (!bSilent) chain.print("%s\n", psz); }
   } else {
      pszExt = strdup(pszExt);
      char *psz1 = pszExt;
      bool beod = 0;
      while (*psz1 && !beod) {
         // recombine base string with any extension like .exe, .cmd
         char *psz2 = psz1;
         while (*psz2 && *psz2 != ';')
            { *psz2 = sfktolower(*psz2); psz2++; }
         if (*psz2) *psz2++ = '\0';
         else beod = 1;
         // check is such a file is in path. if so, list it.
         sprintf(szLineBuf2, "%s%s", pszCmd, psz1);
         char *psz = findPathLocation(szLineBuf2, 0);
         if (psz) { nhits++; if (!bSilent) chain.print("%s\n", psz); }
         psz1 = psz2;
      }
      delete [] pszExt;
   }

   #else

   char *psz = findPathLocation(pszCmd, 0);
   if (psz) { nhits++; if (!bSilent) chain.print("%s\n", psz); }

   #endif

   return nhits;
}

char *getWritePath(int &rerr)
{
   char *pszSFKPath=getenv("SFK_PATH");
   if (!pszSFKPath) return 0;

   char *pszPath = getenv("PATH");
   if (!pszPath) return 0;

   char *psz1 = pszPath;
   while (*psz1)
   {
      char *psz2 = psz1;
      #ifdef _WIN32
      while (*psz2 && (*psz2 != ';'))
         psz2++;
      #else
      while (*psz2 && (*psz2 != ':'))
         psz2++;
      #endif

      // isolate single directory from path.
      int nLen = psz2-psz1;
      strncpy(szLineBuf, psz1, nLen);
      szLineBuf[nLen] = '\0';

      // now holding single dir in szLineBuf.
      stripTrailingBackSlashes(szLineBuf);
      if (!strcmp(pszSFKPath, szLineBuf))
         return pszSFKPath;

      // step to next subpath
      if (*psz2)
         psz2++;
      psz1 = psz2;
   }

   perr("SFK_PATH folder '%s' not found in PATH", pszSFKPath);
   pinf("set the SFK_PATH environment variable only\n");
   pinf("to a folder which is present in the PATH.\n");
   rerr = 9;

   return 0;
}

// uses szLineBuf, also for result!
char *findPathLocation(cchar *pszCmd, bool bExcludeWorkDir)
{
   #ifdef _WIN32
   if (!bExcludeWorkDir) {
      // win only: check current dir first (implicite path inclusion)
      szLineBuf[0] = '\0';
      if (getcwd(szLineBuf,MAX_LINE_LEN-10)) { }
      strcat(szLineBuf,glblPathStr);
      strcat(szLineBuf,pszCmd);
      if (fileExists(szLineBuf)) {
         if (cs.debug)
            printf("hit: %s [cwd]\n", szLineBuf);
         return szLineBuf;
      }
   }
   #endif

   char *pszPath = getenv("PATH");
   if (!pszPath) { perr("no PATH variable found.\n"); return 0; }
   char *psz1 = pszPath;
   while (*psz1)
   {
      char *psz2 = psz1;
      #ifdef _WIN32
      while (*psz2 && (*psz2 != ';'))
         psz2++;
      #else
      while (*psz2 && (*psz2 != ':'))
         psz2++;
      #endif
      // isolate single directory from path.
      int nLen = psz2-psz1;
      strncpy(szLineBuf, psz1, nLen);
      szLineBuf[nLen] = '\0';
      // now holding single dir in szLineBuf.
      if (!strcmp(szLineBuf, ".") && bExcludeWorkDir) {
         if (cs.debug)
            printf("skip: %s\n", szLineBuf);
      } else {
         if (cs.debug)
            printf("probe: %s\n", szLineBuf);
         stripTrailingBackSlashes(szLineBuf);
         strcat(szLineBuf, glblPathStr);
         strcat(szLineBuf, pszCmd);
         if (fileExists(szLineBuf)) {
            if (cs.debug)
               printf("hit: %s\n", szLineBuf);
            return szLineBuf;
         }
      }
      // step to next subpath
      if (*psz2)
         psz2++;
      psz1 = psz2;
   }
   return 0;
}

char *localPath(char *pAbsFile)
{
   static char szPath[SFK_MAX_PATH+10];
   strcopy(szPath, pAbsFile);
   if (cs.test == 0) { // sfk1840 ftp -test support
      for (char *p=szPath; *p; p++) {
         if (*p == glblWrongPChar)
             *p = glblPathChar;
      }
   }
   return szPath;
}

char *remoteStandardPath(char *pAbsFile)
{
   static char szPath[1024];
   strcopy(szPath, pAbsFile);
   for (char *p=szPath; *p; p++) {
      if (*p == '\\')
          *p = '/';
   }
   return szPath;
}

// sfk184: complete rework of traversal check
//         to detect /..\ and C:\foo.txt
bool isPathTraversal(char *pszFileIn, bool bDeep)
{
   if (strlen(pszFileIn) > SFK_MAX_PATH) return 1;

   char szBuf[SFK_MAX_PATH+100];

   strcopy(szBuf, pszFileIn);
   char *pszFile = szBuf;

   // for normalized check using only '/'
   for (int i=0; szBuf[i]; i++)
      if (szBuf[i]=='\\')
         szBuf[i]='/';

   if (!strlen(pszFile)) return 1;

   int ilen = strlen(pszFile);

   if (pszFile[0] == '/') return 1;
   if (!strcmp(pszFile, ".")) return 1;
   if (!strcmp(pszFile, "./")) return 1;
   if (!strcmp(pszFile, "/")) return 1;
   if (!strcmp(pszFile, ".."))  return 1;
   if (!strncmp(pszFile, "../", 3)) return 1;
   if (strstr(pszFile, "/../")) return 1;
   if (ilen >= 3 && !strcmp(pszFile + ilen - 3, "/.."))
      return 1;

   #ifdef _WIN32
   // sfk184: block ALL C:\... access
   if (isalpha(pszFile[0])!=0 && pszFile[1]==':') return 1; // sfk1840
   #endif

   if (!bDeep)
   {
      if (strstr(pszFile, "/")) return 1;
   }

   return 0;
}

#ifdef SFKINT
void traversalTest()
{
   bool bdeep = 1;

   printf("expect 0:\n");
   printf("%d\n", isPathTraversal("mydir/foo/bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir/foo ../bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir/foo.../bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir/foo...\\bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir../bar.txt",bdeep));
   printf("%d\n", isPathTraversal("...",bdeep));
   printf("%d\n", isPathTraversal(".cfg",bdeep));
   printf("%d\n", isPathTraversal("foo..\\test.txt",bdeep));

   printf("expect 1:\n");
   printf("%d\n", isPathTraversal(".",bdeep));
   printf("%d\n", isPathTraversal("mydir/../bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir/..\\bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir/..",bdeep));
   printf("%d\n", isPathTraversal("mydir\\..",bdeep));
   printf("%d\n", isPathTraversal("..",bdeep));
   printf("%d\n", isPathTraversal("..\\",bdeep));
   printf("%d\n", isPathTraversal("C:\\foo.txt",bdeep));
   printf("%d\n", isPathTraversal("C:/foo.txt",bdeep));
   printf("%d\n", isPathTraversal("C:\\foo\\bar.txt",bdeep));
   printf("%d\n", isPathTraversal("C:/foo/bar.txt",bdeep));
}
#endif

#ifdef WITH_TCP

enum ESFKFTPReturnCodes
{
   FTPRC_Stopped        = 500,
   FTPRC_OutOfDiskSpace = 552,
   FTPRC_WriteFailed    = 550
};

void setBlocking(SOCKET hSock, bool bYesNo);

bool hasData(SOCKET &hSock, int lTimeoutMS, bool bOnConnect);

int myconnect(SOCKET hSock, struct sockaddr *paddr, int naddr, int iMaxWait, char *pszVerboseHostInfo, int iPortInfo);

// by default, recv() returns as much bytes as there are.
// this function forces receival of full length block.
int receiveBlock(SOCKET hSock, uchar *pBlock, uint nLen, cchar *pszInfo)
{
   int nRemain = nLen;
   int nCursor = 0;
   while (nRemain > 0) {
      int nRead = recv(hSock, (char*)pBlock+nCursor, nRemain, 0);
      if (nRead <= 0) {
         if (pszInfo) // else silent mode
            perr("failed to receive %s, %s\n", pszInfo, netErrStr());
         return -1;
      }
      nRemain -= nRead;
      nCursor += nRead;
   }
   return 0;
}

// uses szLineBuf
int sendLine(SOCKET hSock, cchar *psz, bool bQuiet)
{
   strncpy(szLineBuf, psz, MAX_LINE_LEN-10);
   szLineBuf[MAX_LINE_LEN-10] = '\0';
   strcat(szLineBuf, "\r\n");
   // if (!bQuiet && !cs.quiet) printf("< %s", szLineBuf);
   if (cs.verbose) printf("< %s", szLineBuf);
   int nSent = send(hSock, szLineBuf, strlen(szLineBuf), 0);
   if (nSent != (int)strlen(szLineBuf)) return 9;
   return 0;
}

int readLineRaw(SOCKET hSock, char *pszLineBuf, int &rReadLen)
{
   rReadLen = 0;
   int nCursor = 0;
   int nRemain = MAX_LINE_LEN;
   pszLineBuf[0] = '\0';
   while (nRemain > 10)
   {
      int nRead = recv(hSock, pszLineBuf+nCursor, 1, 0);
      if (nRead == 0) return 1; // eod
      if (nRead < 0)  return 9; // connection close
      nCursor += nRead;
      nRemain -= nRead;
      pszLineBuf[nCursor] = '\0';
      if (nCursor > 0 && pszLineBuf[nCursor-1] == '\n')
         break;
   }
   rReadLen = nCursor;
   return 0;
}

int readLineSub(SOCKET hSock, char *pszLineBuf, int nMode)
{
   bool bAddToRemList = (nMode & 1) ? 1 : 0;
   bool bDirListMode  = (nMode & 4) ? 1 : 0;
   bool bAnyListMode  = bDirListMode || bAddToRemList;
   bool bVerbose      = (nMode & 8) || cs.verbose;

   int  iReplyLineNum  = 0;
   int  iMultiLineCode = 0;
   bool bStop = 0;

  while (!bGlblEscape && !bStop)
  {
   int nCursor = 0;
   int nRemain = MAX_LINE_LEN;
   memset(pszLineBuf, 0, 10);
   // switching from readLine mode to readBinary is tricky,
   // therefore read char by char to exactly get the point
   // of CRLF, from which on we may switch to binary.
   num tStart = getCurrentTime();
   while (nRemain > 10) 
   {
      // sfk193: ftp timeout option
      if (cs.maxftpwait > 0) {
         struct timeval tv;
         fd_set fdvar;
         tv.tv_sec  = 0;
         tv.tv_usec = 20 * 1000; // 200 msec slice
         FD_ZERO(&fdvar);
         FD_SET(hSock, &fdvar);
         if (select(hSock+1, &fdvar, 0, 0, &tv) <= 0) {
            if (getCurrentTime() - tStart > cs.maxftpwait) {
               if (!cs.nowarn)
                  printx("<warn>[timeout while reading control line.]\n");
               return 0;
            }
            continue;
         }
      }
      // recv blocks until at least 1 byte is available.
      int nRead = recv(hSock, pszLineBuf+nCursor, 1, 0);
      if (nRead <= 0) {
         // perr("readLine failed %d %d", nCursor, nRead);
         return 9;
      }
      nCursor += nRead;
      nRemain -= nRead;
      pszLineBuf[nCursor] = '\0';
      if (nCursor > 0 && pszLineBuf[nCursor-1] == '\n')
         break;
   }
   iReplyLineNum++;
   // reading a block of continued lines?
   if (  (bAnyListMode && !isdigit(pszLineBuf[0]))
       || pszLineBuf[3] == '-' || pszLineBuf[0] == '-'
       || (iMultiLineCode>0 && pszLineBuf[0]==' ')
      )
   {
      removeCRLF(pszLineBuf);
      // detect multi line interactive reply.
      // does not apply with directory listings.
      if (!bAnyListMode) {
         char *psz=pszLineBuf;
         if (  !bAnyListMode
             && isdigit(psz[0]) && isdigit(psz[1]) && isdigit(psz[2])
             && (pszLineBuf[3]=='-')
            )
            iMultiLineCode = atoi(pszLineBuf);
         else
         if(    iMultiLineCode>0
             && atoi(pszLineBuf)==iMultiLineCode
             && pszLineBuf[3]==' ')
            bStop = 1;
      }
      // on replies to SLST: store list replies, don't print
      if (bAddToRemList) {
         // if (cs.debug)
         //   printf("> [store] %s\n", pszLineBuf);
         glblFTPRemList.addEntry(pszLineBuf);
      } else {
         if (bDirListMode || bVerbose)
            printf("%s\n", pszLineBuf);
      }
      // and continue reading lines
   }
   else
   {
      // any other record: print printable parts
      bool bskiprec = !strncmp(pszLineBuf, "SKIP ", 5);  // FIX: v160: used szLineBuf
      // dump only if verbose, or on some error codes.
      int ncode = atol(pszLineBuf);                      // FIX: v160: used szLineBuf
      // dump all error codes from 500, except:
      bool blistcode = (ncode >= 500);
      switch (ncode) {
      // case 331: blistcode = 1; break; // pass required
         case 550: blistcode = 0; break; // no such file
      }
      if (!bskiprec && (bVerbose || blistcode))
      {
         int nLen = strlen(pszLineBuf);                  // FIX: v160: used szLineBuf
         for (int i=0; i<nLen; i++)
            if (isprint(pszLineBuf[i]))
               printf("%c", pszLineBuf[i]);
         printf("\n");
         fflush(stdout);
      }
      // and stop reading, return record
      break;
   }
  }
   return 0;
}

// see also forward decl. for default parms
int readLine(SOCKET hSock, char *pszLineBuf, int nMode)
{
   if (!pszLineBuf)
      pszLineBuf = szLineBuf;

   int lRC = readLineSub(hSock, pszLineBuf, nMode);

   // sft101: optional skip records to enforce socket flushing
   if (!strncmp(szLineBuf, "SKIP ", 5))
   {
      // read intermediate skip record
      uint nLen = (uint)atol(szLineBuf+5);
      if (nLen > sizeof(abBuf)-10) nLen = sizeof(abBuf)-10;
      if (nLen) receiveBlock(hSock, abBuf, nLen, "SKIP");

      // now read the actual record
      lRC = readLineSub(hSock, pszLineBuf, nMode);
   }

   return lRC;
}

// uses abBuf
int readLong(SOCKET hSock, uint &rOut, cchar *pszInfo)
{
   if (receiveBlock(hSock, abBuf, 4, pszInfo)) return 9;
   uint nLen =   (((uint)abBuf[3])<<24)
                | (((uint)abBuf[2])<<16)
                | (((uint)abBuf[1])<< 8)
                | (((uint)abBuf[0])<< 0);
   rOut = nLen;
   return 0;
}

// uses abBuf
int sendLong(SOCKET hSock, uint nOut, cchar *pszInfo)
{
   abBuf[3] = ((uchar)(nOut >> 24));
   abBuf[2] = ((uchar)(nOut >> 16));
   abBuf[1] = ((uchar)(nOut >>  8));
   abBuf[0] = ((uchar)(nOut >>  0));
   int nSent = send(hSock, (char*)abBuf, 4, 0);
   if (nSent != 4) return 9+perr("failed to send %s, %s\n", pszInfo, netErrStr());
   return 0;
}

// uses abBuf
int readNum(SOCKET hSock, num &rOut, cchar *pszInfo)
{
   if (receiveBlock(hSock, abBuf, 8, pszInfo)) return 9;
   num nOut = 0;
   for (int i=0; i<8; i++) {
      nOut <<= 8;
      nOut |= (uint)abBuf[i];
   }
   rOut = nOut;
   return 0;
}

int readNum(uchar *pbuf, int &roff, num &rOut, cchar *pszInfo)
{
   num nOut = 0;
   for (int i=0; i<8; i++) {
      nOut <<= 8;
      nOut |= (uint)pbuf[roff+i];
   }
   roff += 8;
   rOut = nOut;
   return 0;
}

// uses abBuf
int sendNum(SOCKET hSock, num nOut, cchar *pszInfo)
{
   // this may fail with num's >= 2 up 63.
   for (int i=7; i>=0; i--) {
      abBuf[i] = (uchar)(nOut & 0xFF);
      nOut >>= 8;
   }
   int nSent = send(hSock, (char*)abBuf, 8, 0);
   if (nSent != 8) return 9+perr("failed to send %s, %s\n", pszInfo, netErrStr());
   return 0;
}

// Note: caller must set info.status
int sendFileRaw(cchar *pszProto, SOCKET hSock, char *pszFile,
   bool bSentStdPath=0, uchar *pmd5=0,
   char *pszRemoteNameInfo=0, cchar *pszExtInfo="")
{__
   char *pszSrcFile = pszFile;
   char *pszDstName = pszSrcFile;
   if (pszRemoteNameInfo)
         pszDstName = pszRemoteNameInfo;

   num nLen = getFileSize(pszSrcFile);
   if (nLen < 0) return 9+perr("cannot get size of %s\n", pszSrcFile);

   SFKMD5 md5;
 
   info.setStatus("send", pszDstName);

   FILE *fin = fopen(pszSrcFile, "rb");
   if (!fin) return 9+perr("cannot read %s\n", pszSrcFile);

   num nLen2 = 0;
   num nTellStep = 10;
   num nTellNext = 0;
   while ((nLen2 < nLen) && !bGlblEscape)
   {
      int nRead = fread(abBuf, 1, sizeof(abBuf)-10, fin);
      if (nRead <= 0) return 9+perr("cannot fully read %s (1)\n", pszSrcFile);

      int nSentTotal = 0;
 
      // actually send() should block until the whole block is sent.
      // this loop is just in case it unexpectedly sends only part of the message.
      while (nSentTotal < nRead)
      {
         int nSentCur = send(hSock, (char*)abBuf+nSentTotal, nRead-nSentTotal, 0);
 
         if (nSentCur <= 0)
         {
            perr("%s connection closed while sending %s %s\n", pszProto, pszDstName, netErrStr());
            if (netErrno() == 10053 && strcmp(pszProto,"sft") == 0)
               perr("transfer may be blocked by firewall.\n"); // sfk185
            else
               perr("the file cannot be written at receiver.\n");
            fclose(fin);
            return 9;
         }
 
         nSentTotal += nSentCur;
 
         // in case of VM transfer on same PC
         if (nSentTotal < nRead)
            doSleep(10);
         else
            doYield(); // sfk198
      }
 
      if (pmd5) md5.update(abBuf, nRead);

      nLen2 += nRead;

      info.setProgress(nLen/1000,nLen2/1000,"kb");
   }
   fclose(fin);

   if (pmd5) memcpy(pmd5, md5.digest(), 16);
 
   if (bGlblEscape) {
      pwarn("send stopped by user.\n");
      return 9;
   }

   char szBuf1[100], szBuf2[100];

   char szProtInfo[100];
   szProtInfo[0] = '\0';
   if (cs.showprotocol) // sfk1852
      sprintf(szProtInfo, " by %s", pszProto);

   if (nLen2 != nLen) {
      perr("> send incomplete: %s (%s/%s)\n",
         pszDstName,
         numtoa(nLen2,1,szBuf1), numtoa(nLen,1,szBuf2)
         );
   }
   else
   if (cs.quiet < 2) {
      if (bSentStdPath)
         info.print("< %s sent%s, %s bytes.%s       \n", 
            remoteStandardPath(pszDstName), szProtInfo, numtoa(nLen2), pszExtInfo);
      else
         info.print("< %s sent%s, %s bytes.%s       \n", 
            pszDstName, szProtInfo, numtoa(nLen2), pszExtInfo);
   }

   return 0;
}

// send SKIP record to force socket flush on linux systems.
int sendSkipBlock(SOCKET hSock)
{
   // so far, no extra dummy data is appended.
   int nSkipSize = 0;
   if (nSkipSize) {
      if ((int)sizeof(abBuf) < (nSkipSize+10000))
         return 9+perr("internal #201\n");
      memset(abBuf, 0xEE, nSkipSize);
      abBuf[nSkipSize-1] = '\n';
   }
   // the LF at the end of record should flush the socket.
   sprintf((char*)abBuf, "SKIP %d\r\n", nSkipSize);
   int nLen = strlen((char*)abBuf)+nSkipSize;
   int rc = send(hSock, (char*)abBuf, nLen, 0);
   if (rc != nLen)
      pinf("failed to send skip record\n");
   return 0;
}

int preScanFile(char *pszFile, uchar *pmd5out, uint &nattrout)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;

   bool bbinary = 0;

   SFKMD5 md5;
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      if (!bbinary && memchr(abBuf, '\0', nRead))
         bbinary = 1;
      cs.totalbytes += nRead;
   }

   fclose(fin);

   uchar *pmd5 = md5.digest();
   for (uint k=0; k<16; k++)
      pmd5out[k] = pmd5[k];

   uint nattrib = bbinary ? 1 : 0;

   nattrout = nattrib;

   return 0;
}

bool bdebug = 0;

int sendRaw(char *pszFile, FILE *fin, SOCKET hSock, num nLen, SFKMD5 *pmd5)
{
   num nLen2 = 0;
   while (nLen2 < nLen)
   {
      int nrem = nLen - nLen2;

      int nreqlen = sizeof(abBuf)-10;
      if (nreqlen > nrem) nreqlen = nrem;

      int nRead = fread(abBuf, 1, nreqlen, fin);
      if (nRead <= 0) return 9+perr("cannot fully read %s (2)\n", pszFile);

      int nSentTotal = 0;

      // actually send() should block until the whole block is sent.
      // this loop is just in case it unexpectedly sends only part of the message.
      while (nSentTotal < nRead)
      {
         int nSentCur = send(hSock, (char*)abBuf+nSentTotal, nRead-nSentTotal, 0);

         if (nSentCur <= 0)
         {
            perr("connection closed while sending %s %s\n", pszFile, netErrStr());
            perr("the file cannot be written at receiver.\n");
            return 9;
         }

         nSentTotal += nSentCur;

         // in case of VM transfer on same PC
         if (nSentTotal < nRead)
            doSleep(10);
      }

      if (pmd5) pmd5->update(abBuf, nRead);

      nLen2 += nRead;
   }
   return 0;
}

// INCLUDES ackReceive past file send.
// USES: szLineBuf3 temporarily.
int putFileBySFT(SOCKET hSock, Coi *pcoi, int nSFTVer,
   bool bQuiet=0, bool bIgnoreAck=0, bool bBlockMode=0,
   char *pszRemoteNameInfo=0)
{__
   char *pszSrcFile = pcoi->name();
   char *pszDstName = pszSrcFile;
   if (pszRemoteNameInfo)
         pszDstName = pszRemoteNameInfo;

   num nLen   = pcoi->getSize();
   if (nLen < 0) return 9+perr("cannot read %s\n", pszSrcFile);
   num nTime  = pcoi->getTime();
   num nFlags = 0;

   char *pszExtInfo = str(""); // for -setexec

   // sft <= 101: 8_size 16_md5_pre
   uint nMetaSize = 8+16;

   // sft >= 102: 8_size 8_time 8_flags NO md5_pre
   if (nSFTVer >= 102) nMetaSize = 24;

   uchar abmd5[20]; mclear(abmd5);

   // build md5 before sending the file?
   if (nSFTVer < 102)
      if (getFileMD5(pszSrcFile, abmd5))
         return 9;

   if (nSFTVer < 105)
   {
      // old flags, never written by getFile
      nFlags = (1 << 0);  // readable
      if (pcoi->isWriteable())   nFlags |= (1 << 1);
      if (pcoi->rawIsDir   ())   nFlags |= (1 << 3);
      if (pcoi->isLink     ())   nFlags |= (1 << 4);
      if (pcoi->isHidden   ())   nFlags |= (1 << 5);
   }
   else
   {
      // since SFT 105:
      //    bits 0...31: linux flags with sfk extension
      //    bit  32    : force full preserve by client
      nFlags = pcoi->getAttr();
      if (cs.preserve)
         nFlags |= (((num)1UL) << 32);
      if (cs.setxmask[0])
      {
         if (normalizePath(pcoi->name(), szLineBuf3, sizeof(szLineBuf3)) == 0)
         {
          if (isWildStr(cs.setxmask) || matchesNormName(szLineBuf3, cs.setxmask, 0, 1)) // setexec
          {
            pszExtInfo = str(" [+x]");
            if (cs.verbose >= 2)
               printf("- SETX %s\n", pszDstName);
            // sfk197 -setexec=sh, yet internal, no regular mask comparison.
            nFlags |= 0755UL; // rwx.owner rx.group rx.any
            #ifdef _WIN32
            nFlags |= (((num)1UL) << 30); // fake linux
            #endif
            nFlags |= (((num)1UL) << 31); // valid attribs
          } else {
            if (cs.verbose >= 4)
               printf("- NO-X %s\n", pszDstName);
          }
         }
      }
   }

   if (sendLong(hSock, nMetaSize, "metalen")) return 9;

   // meta 1: filesize, timestamp, flags
   if (sendNum(hSock, nLen, "size")) return 9;

   if (nSFTVer >= 102) {
      if (sendNum(hSock, nTime , "time" )) return 9;
      if (sendNum(hSock, nFlags, "flags")) return 9;
   } else {
      if (cs.verbose > 2)
         info.print("[using sft101 for compatibility.]\n");
   }

   info.setStatus("send", pszSrcFile);

   if (nSFTVer < 102) {
      // meta 2: 16 bytes md5 BEFORE content
      int nSent = send(hSock, (char*)abmd5, 16, 0);
      if (nSent != 16) return 9+perr("failed to send md5, %s\n", netErrStr());
   }

   if (nSFTVer < 102) {
      // if receiver can't write file, this will fail.
      if (sendFileRaw("sft", hSock, pszSrcFile, 0, abmd5, pszDstName))
         return 9;
   }
   else
   if (!bBlockMode) {
      // sft 102 bulk transfer, send all in one
      if (sendFileRaw("sft", hSock, pszSrcFile, 0, cs.verify ? abmd5 : 0, pszDstName, pszExtInfo))
         return 9;
      if (cs.verify) {
         // 16 bytes md5 AFTER content
         int nSent = send(hSock, (char*)abmd5, 16, 0);
         if (nSent != 16)
            return 9+perr("failed to send md5, %s\n", netErrStr());
      }
   }
   else
   {
      // sft 102 block transfer, triggered by peer

      FILE *fin = fopen(pszSrcFile, "rb");
      if (!fin) return 9+perr("cannot read %s\n", pszSrcFile);

      SFKMD5 md5;

      num nLen2 = 0;
      num nTellStep = 10;
      num nTellNext = 0;

      char szCmd[200];

      while (1)
      {
         if (bdebug) printf("> waiting for i/o commands.\n");

         // wait for SREAD, SSUM or SCLOSE.
         mclear(szCmd);
         int nRead = recv(hSock, szCmd, sizeof(szCmd)-10, 0);
         if (nRead <= 0) {
            fclose(fin);
            return 9+perr("unexpected EOD or close, %s\n", netErrStr());
         }

         if (bdebug) printf("> got cmd: %s", szCmd);

         if (strBegins(szCmd, "SREAD "))
         {
            num nsendreq = atonum(&szCmd[6]);

            if (sendRaw(pszSrcFile, fin, hSock, nsendreq, cs.verify ? &md5 : 0)) {
               fclose(fin);
               return 9+perr("failed to send requested %d bytes\n",(int)nsendreq);
            }

            if (bdebug) printf("< sent %d\n", (int)nsendreq);

            nLen2 += nsendreq;

            info.setProgress(nLen/1000000,nLen2/1000000,"mb");

            continue;
         }

         if (strBegins(szCmd, "SSUM"))
         {
            if (!cs.verify) {
               fclose(fin);
               return 9+perr("unexpected verify request\n");
            }
            // 16 bytes md5 AFTER content
            if (bdebug) printf("< sending sum\n");
            int nSent = send(hSock, (char*)md5.digest(), 16, 0);
            if (nSent != 16) {
               fclose(fin);
               return 9+perr("failed to send md5, %s\n", netErrStr());
            }
            continue;
         }

         if (strBegins(szCmd, "SCLOSE"))
            break;

      }  // endwhile content transfer

      fclose(fin);

      if (cs.quiet < 2)
         info.print("< %s sent, %s bytes.       \n",
            pszDstName, numtoa(nLen2));
   }

   bool bSentSkip = 0;
   if (nSFTVer >= 101) {
      // flush the socket through an extra record.
      if (bdebug) printf("< send skip\n");
      sendSkipBlock(hSock);
      bSentSkip = 1;
   }

   // wait until receival of ack, to avoid transmission break by premature close.
   #ifndef _WIN32
   // known issue: bytes sent from linux may sometimes not receive other side
   //              until connection is closed, e.g. through CTRL+C.
   if (!cs.quiet) {
      info.setStatus("send", "waiting for ack. if this blocks, try CTRL+C.", 0, eKeepProg);
      info.print();
   }
   #endif

   if (bdebug) printf("> wait for ack\n");

   memset(abBuf, 0, 10);
   receiveBlock(hSock, abBuf, 4, 0); // 0 == silent mode

   if (bIgnoreAck) {
      // do not verify, receiver may have closed connection already.
      #ifndef _WIN32
      if (cs.quiet < 2)
         info.clear();
      #endif
   } else {
      // possible replies:
      //    OK\n\n   ok\n\n (older sft)
      //    EE\n\n
      if (   tolower((char)abBuf[0]) == 'o'
          && tolower((char)abBuf[1]) == 'k') {
      #ifndef _WIN32
      if (cs.quiet < 2)
         info.clear();
      #endif
      } else {
         info.clear();
         perr("transfer or write of file failed: %s    (%s)\n", pszDstName, abBuf);
      }
   }

   return 0;
}

// MODE 1: receive until END OF DATA (nMaxBytes < 0)
// MODE 2: receive until nMaxBytes   (nMaxBytes > 0)
// Note: caller must set info.status
int receiveFileRaw(cchar *pszProto, SOCKET hSock, char *pszFile, num nMaxBytes,
   bool bQuiet, uchar *pmd5, num nFlags, num nDiskFree=-1)
{__
   int iRC = 0;

   info.setStatus("recv", pszFile);

   FILE *fout = fopen(pszFile, "wb");
   if (!fout)
      return FTPRC_WriteFailed+perr("cannot write to \"%s\"\n", pszFile);

   if (nFlags & (1UL << 31))
   {
      bool bPreserve = (nFlags & (((num)1) << 32)) ? 1 : 0;
      if (cs.debug)
         printf("> set attr=%s for %s\n", numtohex(nFlags), pszFile);
      Coi::writeAttrRaw(pszFile, (uint)nFlags, bPreserve, 1); // recv.file.raw
   }

   SFKMD5 md5;
 
   num nLen2 = 0;
   num nTellStep = 10;
   num nTellNext = 0;
   num nRemain = nMaxBytes;
   int nRead = 0;
   bool bCleanup = 0;

   // raw ftp uses variable length mode
   bool bvarmode = (nMaxBytes < 0);

   while (bvarmode || (nRemain > 0))
   {
      if (bGlblEscape)
         break;

      if (!bvarmode && (nLen2 >= nMaxBytes))
         break;
 
      int nBlockLen = sizeof(abBuf)-10;
      if (!bvarmode && (nBlockLen > nRemain))
         nBlockLen = nRemain;
 
      if ((nRead = recv(hSock, (char*)abBuf, nBlockLen, 0)) <= 0)
         break; // EOD

      if (bGlblEscape) {
         bCleanup = 1;
         iRC = FTPRC_Stopped;
         break;
      }

      if (    cs.diskspace > 0 && nDiskFree >= 0
          && (nDiskFree - (nLen2+nRead) < cs.diskspace)
         )
      {
         esys("fwrite", "out of disk space: %s\n", pszFile);
         bCleanup = 1;
         iRC = FTPRC_OutOfDiskSpace;
         break;
      }

      if ((int)myfwrite(abBuf, nRead, fout) != nRead) {
         esys("fwrite", "failed to write %s (disk full?)\n", pszFile);
         bCleanup = 1;
         iRC = FTPRC_WriteFailed;
         // but no special rc, continue with other files.
         break;
      }

      nLen2 += nRead;
      nRemain -= nRead;

      if (pmd5) md5.update(abBuf, nRead);

      info.setProgress(nMaxBytes/1000,nLen2/1000,"kb");
   }
   fclose(fout);

   if (pmd5) memcpy(pmd5, md5.digest(), 16);
 
   char szBuf1[100], szBuf2[100];

   char szProtInfo[100];
   szProtInfo[0] = '\0';
   if (cs.showprotocol) // sfk1852
      sprintf(szProtInfo, " by %s", pszProto);

   if (nMaxBytes >= 0 && nLen2 != nMaxBytes)
      bCleanup = 1;
 
   if (bCleanup)
   {
      info.print("> incomplete file, cleaning up: %s (%s/%s)\n",
         pszFile,
         numtoa(nLen2,1,szBuf1), numtoa(nMaxBytes,1,szBuf2)
         );
      remove(pszFile);
   }
   else
   if (cs.quiet < 2)
      info.print("> %s received%s, %s bytes.       \n", 
         pszFile, szProtInfo, numtoa(nLen2));
 
   return iRC;
}

// INCLUDES ack send past file transfer
int getFileBySFT(SOCKET hSock, char *pszFile, int nSFTVer,
   bool bQuiet=0, bool bBlockMode=0, num nDiskFree=-1)
{__
   // read variable-length header with meta info
   uchar abHead[512+10]; mclear(abHead);

   uint nMetaSize = 0;
   if (readLong(hSock, nMetaSize, "metalen")) return 9;
   if (nMetaSize > sizeof(abHead)-10)
      return 9+perr("unsupported SFT protocol version\n");
   if (receiveBlock(hSock, abHead, nMetaSize, "head")) return 9;

   // take from header what we need
   int ioff = 0;

   // meta 1: 8bytes_size [time flags]
   num nLen = 0, nTime = 0, nFlags = 0;
   if (readNum(abHead, ioff, nLen, "size")) return 9;

   if (nGlblTCPMaxSizeMB)
      if (nLen > (num)nGlblTCPMaxSizeMB * (num)1000000)
         return 9+perr("illegal length received (%s). use -maxsize to change limit.\n", numtoa(nLen));

   if (    cs.diskspace > 0 && nDiskFree >= 0
       && (nDiskFree - nLen < cs.diskspace)
      )
      return 9+perr("out of disk space: %s\n", pszFile);

   if (nSFTVer >= 102) {
      if (readNum(abHead, ioff, nTime , "time" )) return 9;
      if (readNum(abHead, ioff, nFlags, "flags")) return 9;
   }

   uchar abMD5Remote[20]; mclear(abMD5Remote);
   uchar abMD5Local[20];  mclear(abMD5Local);

   if (nSFTVer < 102) {
      // meta 2: 16 bytes md5 BEFORE content
      if (nSFTVer == 105) ioff += 20;
      memcpy(abMD5Remote, abHead+ioff, 16);
      ioff += 16;
   }

   // since SFT 105: write file attributes
   if (nSFTVer >= 105 && (nFlags & (1UL << 31)))
   {
      // server side preserve option
      if (cs.preserve)
         nFlags |= (((num)1) << 32);

      bool bPreserve = (nFlags & (((num)1) << 32)) ? 1 : 0;
 
      if (!bPreserve)
      {
         // never allow sender to clear "rw" for owner,
         // as this would block future re-transfers.
         nFlags |= (((num)1) << 8); // readable by owner
         nFlags |= (((num)1) << 7); // writeable by owner
      }
   }
   else
   {
      // make sure no unwanted attribs are set
      nFlags = 0;
   }

   info.setStatus("recv", pszFile);

   if (nSFTVer < 102) {
      // if this fails, return w/o ack, connection will be dropped.
      if (receiveFileRaw("sft", hSock, pszFile, nLen, bQuiet, abMD5Local, nFlags, nDiskFree)) // sft
         return 9;
   }
   else
   if (!bBlockMode) {
      // sft 102 bulk transfer, receive all in one.
      // do NOT build checksum of received data, as we will
      // re-read the whole file anyway in verify case.
      if (receiveFileRaw("sft", hSock, pszFile, nLen, bQuiet, 0, nFlags, nDiskFree)) // sft
         return 9;
      if (cs.verify)
         if (receiveBlock(hSock, abMD5Remote, 16, "md5"))
            return 9;
   }
   else
   {
      // sft 102 block transfer, we trigger the peer

      FILE *fout = fopen(pszFile, "wb");
      if (!fout) return 9+perr("cannot write to \"%s\"\n", pszFile);

      if (nFlags & (1UL << 31))
      {
         if (cs.debug)
            printf("> set attr=%s for %s\n", numtohex(nFlags), pszFile);
         bool bPreserve = (nFlags & (((num)1) << 32)) ? 1 : 0;
         Coi::writeAttrRaw(pszFile, (uint)nFlags, bPreserve, 1); // getfile.sft
      }
 
      // sft receive file

      // SFKMD5 md5;

      num nLen2      =    0;
      num nRemain    = nLen;
      num nMaxBytes  = nLen;
      num nTellStep  =   10;
      num nTellNext  =    0;
      int nRead      =    0;

      char szCmd[200];

      while (nRemain > 0)
      {
         // request next block from server
         int nBlockLen = sizeof(abBuf)-10;

         if (nBlockLen > nRemain)
            nBlockLen = nRemain;

         if (bdebug) printf("< sread %d, remain=%d\n",nBlockLen,(int)nRemain);

         sprintf(szCmd, "SREAD %d\n", nBlockLen);
         int nsent = send(hSock, szCmd, strlen(szCmd), 0);
         if (nsent != (int)strlen(szCmd)) {
            fclose(fout);
            remove(pszFile);
            return 9+perr("failed to send SREAD for \"%s\" %s\n", pszFile, netErrStr());
         }

         if (receiveBlock(hSock, abBuf, nBlockLen, "data")) {
            fclose(fout);
            remove(pszFile);
            return 9+perr("failed to fully receive \"%s\"\n", pszFile);
         }
         nRead = nBlockLen;

         if (    cs.diskspace > 0 && nDiskFree >= 0
             && (nDiskFree - (nLen2+nRead) < cs.diskspace)
            )
         {
            fclose(fout);
            remove(pszFile);
            return 9+perr("out of disk space: %s\n", pszFile);
         }

         nLen2 += nRead;
         nRemain -= nRead;

         if ((int)myfwrite(abBuf, nRead, fout) != nRead) {
            fclose(fout);
            remove(pszFile);
            return 9+perr("failed to fully write, probably disk full: \"%s\"\n", pszFile);
         }

         // if (cs.verify) md5.update(abBuf, nRead);
 
         info.setProgress(nMaxBytes/1000000,nLen2/1000000,"mb");
      }

      fclose(fout);

      if (cs.quiet < 2)
         printf("> %s received, %s bytes.       \n", pszFile, numtoa(nLen2));

      sprintf(szCmd, "SSUM\n");
      int nsent = send(hSock, szCmd, strlen(szCmd), 0);
      if (nsent != (int)strlen(szCmd))
         return 9+perr("failed to receive checksum, %s\n", netErrStr());

      if (cs.verify) {
         if (bdebug) printf("> wait for sum\n");
         if (receiveBlock(hSock, abMD5Remote, 16, "md5")) return 9;
      }
 
      if (bdebug) printf("send close\n");

      sprintf(szCmd, "SCLOSE\n");
      nsent = send(hSock, szCmd, strlen(szCmd), 0);
      if (nsent != (int)strlen(szCmd))
         return 9+perr("failed to send close, %s\n", netErrStr());

   }  // endif nSFTVer

   if (bdebug) printf("wait for skip\n");

   // expect and receive SKIP record of any length
   // FIX: v160: occasional transfer interrupt recv() may get only partial record
   //      recv(hSock, (char*)abBuf, sizeof(abBuf)-100, 0);
   abBuf[0] = '\0';
   readLineSub(hSock, (char*)abBuf, 0); // should be "SKIP 0\r\n"
 
   // since SFT 103, we check for the word "SKIP"
   if (strncmp((char*)abBuf, "SKIP", 4)) {
      info.clear();
      if (send(hSock, (char*)"EE01\n\n", 4, 0) != 4)
         pinf("failed to send error record\n");
      perr("unexpected data received, transfer broken.\n");
      return 9;
   }

   if (nSFTVer >= 102 && !cs.noclone)
   {
      mySetFileTime(pszFile, nTime);
   }

   // sender will wait now until we confirm successful transfer.

   if (cs.verify)
   {
      // default: re-read the local file after write,
      // to be sure it was written completely.
      info.setStatus("verfy", pszFile);
      SFKMD5 md5;
      if (getFileMD5(pszFile, md5, 0, 1)) {
         if (send(hSock, (char*)"EE\n\n", 4, 0) != 4)
            pinf("failed to send error record\n");
         return 9;
      }
      memcpy(abMD5Local, md5.digest(), 16);

      if (memcmp(abMD5Local, abMD5Remote, 16)) {
         info.clear();
         if (send(hSock, (char*)"EE\n\n", 4, 0) != 4)
            pinf("failed to send error record\n");
         perr("md5 mismatch - transfered file corrupted.\n");
         if (cs.verbose) {
            printf("local: %02X %02X %02X %02X\n",abMD5Local[0],abMD5Local[1],abMD5Local[2],abMD5Local[3]);
            printf("remot: %02X %02X %02X %02X\n",abMD5Remote[0],abMD5Remote[1],abMD5Remote[2],abMD5Remote[3]);
         }
         pinf("check if the file is in use by another process.\n");
         return 9;
      }

      if (cs.verbose)
         info.print("> %s verified, ok.\n", pszFile); // sfk185
   }

   info.clear();

   // send short confirmation, so client can safely close socket.
   int nSent = send(hSock, (char*)"OK\n\n", 4, 0);
   if (nSent != 4) return 9+perr("failed to send reply, %d, %s\n", nSent, netErrStr());

   return 0;
}

int ftpLogin(char *pszHost, uint nPort, SOCKET &hSock, bool &bSFT, int &nOutSFTVer, char *pszUser, char *pszPW)
{__
   prepareTCP();

   int nSFTVer  = 105;  // sfk185, may be downgraded below
   int nServVer = 0;    // yet unknown
 
   hSock = socket(AF_INET, SOCK_STREAM, 0);
   if (hSock == INVALID_SOCKET) return 9+perr("cannot create socket (1,%d)\n",netErrno());

   struct sockaddr_in oaddr;
   oaddr.sin_family = AF_INET;
   oaddr.sin_port = htons((unsigned short)nPort);
   if (setaddr(&oaddr, pszHost))
      return 9;

   if ((connect(hSock, (struct sockaddr *)&oaddr, sizeof(oaddr))) == -1) {
      perr("cannot connect to host '%s' port %u, %s\n", pszHost, nPort, netErrStr());
      return 9;
   }

   char szBuf1[200];

   // SFT: first handle FTP handshake
   if (readLine(hSock)) return 9; // 220
   char *psz1 = strstr(szLineBuf, ". sft ");
   if (cs.nosft==0 && psz1!=0) {  // sfk185
      nServVer = atol(psz1+6);
      if (nServVer >= 100) {
         #ifdef _WIN32
         if (nPort==21 && cs.allowsft==0) // sfk185
         {
            if (cs.verbose) {
               printf("> server speaks sft %d but using ftp due to port 21.\n", nServVer);
               printf("> add option -sft if no firewall requires ftp.\n");
            }
         } 
         else
         #endif
         {
            bSFT = 1;
            if (cs.verbose)
               printf("> server speaks sft %d.\n", nServVer);
            nOutSFTVer = nServVer;
         }
      } else {
         printf("> unexpected sft info \"%s\"\n", psz1);
      }
   }

   snprintf(szBuf1, sizeof(szBuf1)-10, "USER %s", pszUser);
   if (sendLine(hSock, szBuf1)) return 9;
   if (readLine(hSock)) return 9; // 331

   if (bSFT) {
      // login at sfk ftpserv: password after '@'
      if (!pszPW) pszPW = str("");
      snprintf(szBuf1, sizeof(szBuf1)-10, "PASS sft%d@%s", nSFTVer, pszPW);
      if (sendLine(hSock, szBuf1)) return 9;
   } else {
      // login at any ftp server: either password or dummy info
      if (pszPW)
         snprintf(szBuf1, sizeof(szBuf1)-10, "PASS %s", pszPW);
      else
         snprintf(szBuf1, sizeof(szBuf1)-10, "PASS sft%d@", nSFTVer);
      if (sendLine(hSock, szBuf1)) return 9;
   }
   if (readLine(hSock)) return 9; // 230 login done
   if (strBegins(szLineBuf, "500 ")) return 9;

   if (sendLine(hSock, "TYPE I")) return 9;
   if (readLine(hSock)) return 9; // 200 OK
 
   if (bSFT && cs.verify && (nServVer >= 103))
   {
      // have to enable verify explicitely with new server.
      // it was default with older servers.
      if (sendLine(hSock, "SCHK 1")) return 9;
      if (readLine(hSock)) return 9; // 200 OK
   }

   return 0;
}

int connectSocket(char *pszHost, uint nPort, struct sockaddr_in &ClntAdr, SOCKET &hSock, cchar *pszInfo);

int setPassive(SOCKET &hSock, struct sockaddr_in &SoAdr, SOCKET &hData)
{
   if (hData != INVALID_SOCKET)
      return 0; // already done, reuse hData

   if (sendLine(hSock, "PASV")) return 9;
   if (readLine(hSock)) return 9;
   // 227 Entering Passive Mode (127,0,0,1,117,246)
   char *psz = strchr(szLineBuf, '(');
   if (!psz) return 9;
   psz++;
   uchar n[6];
   for (int i=0; i<6; i++) {
      n[i] = (uchar)atol(psz);
      psz = strchr(psz+1, ',');
      if (psz) psz++; else break;
   }
   char szIP[50];
   sprintf(szIP, "%d.%d.%d.%d",n[0],n[1],n[2],n[3]);
   uint nPort = (((uint)n[4])<<8)|((uint)n[5]);
   if (connectSocket(szIP, nPort, SoAdr, hData, "pasv data")) return 9;

   return 0;
}

bool canSkipFile(SOCKET hSock, char *pszFileName, num ndsttime, bool bput, int nSFTVer)
{
   bool bskip = 0;

   // check if target file at server has different time.
   sprintf(szLineBuf2, "MDTM %s", pszFileName);

   if (sendLine(hSock, szLineBuf2)) return 0;
   if (readLine(hSock)) return 0; // 213 TimeString, 500 Error

   // may return: 550 no such file
   if (!strncmp(szLineBuf, "213 ", 4))
   {
      // sft: MDTM returns local time
      // ftp: MDTM returns UTC time
      char *ptime = szLineBuf+4;
      num   nfartime = 0;
      removeCRLF(ptime);
      bool bUTC=0;
      if (!timeFromString(ptime, nfartime, 0, bUTC)) { // skip file by time
         num nowntime = ndsttime;
         num ndiff = bput ? (nfartime - nowntime) : (nowntime - nfartime);
         if (cs.verbose)
            printf("time: local=%u far=%u diff=%d %s\n",
               (uint)nowntime,(uint)nfartime,(int)ndiff,bUTC?"utc":"local");
         if (ndiff >= 0)
            bskip = 1;
      }
   }
   return bskip;
}

static bool showFtpError(char *pszFor)
{
   int icode = atoi(szLineBuf);
   if (icode<500 || icode>=600)
      return 0;
   if (cs.noerr) return 1; // sfk197
   strcopy(szLineBuf3,szLineBuf);
   removeCRLF(szLineBuf3);
   printx("<err>%s: %s\n", szLineBuf3, pszFor); // has CRLF
   return 1;
}

int udpSend(char *phost, int ndstport,
   int nlisten, int nownport,
   uchar *abMsg, int nMsg,
   num nTimeout, uint nMode
 );

void sendNotifyStatus(char *pszto, int iwhat)
{
   // .
   // local:2nd/1+2+3
   char szhost[100+10];  szhost[0]='\0';
   char szport[100+10];  szport[0]='\0';
   char szslots[100+10]; szslots[0]='\0';

   char *pszs = pszto;
   char *psze = pszto;
   while (*psze!=0 && *psze!=':' && *psze!='/')
      psze++;
   mystrcopy(szhost,pszs,mymin(100,(psze-pszs)+1));

   if (!strcmp(szhost, "local"))
      strcpy(szhost, "localhost");

   pszs = psze;
   if (*psze==':') {
      psze++;
      pszs=psze;
      while (*psze!=0 && *psze!='/')
         psze++;
      mystrcopy(szport,pszs,mymin(100,(psze-pszs)+1));
   }

   if (!strcmp(szport, "2nd")) strcpy(szport, "21344");
   if (!strcmp(szport, "3rd")) strcpy(szport, "21345");

   if (*psze=='/') {
      psze++;
      pszs=psze;
      while (*psze!=0 && *psze!='/')
         psze++;
      mystrcopy(szslots,pszs,mymin(100,(psze-pszs)+1));
   }

   int ndstport = 21343;
   if (szport[0])
       ndstport = atoi(szport);

   char szmsg[200];

   if (szslots[0]) // user defined slot(s)
   {
      char aslots[20]; memset(aslots,0,sizeof(aslots));
   
      pszs = szslots;
      while (*pszs) {
         char c = *pszs++;
         if (c >= '0' && c <= '9')
            aslots[c-'0'] = 1;
      }
   
      for (int i=0; i<20; i++)
      {
         if (aslots[i])
         {
            sprintf(szmsg, ":status v1 slot=%d color=yellow blink=fast timeout=5,gray", i);
            udpSend(szhost, ndstport, 0, -1, (uchar*)szmsg, strlen(szmsg), 0, 1);
         }
      }
   }
   else // default patterns
   {
      switch (iwhat) 
      {
         case 1: strcpy(szslots,"up"); break;
         case 2: strcpy(szslots,"down"); break;
      }

      sprintf(szmsg, ":status v1 pat=%s color=yellow blink=fast timeout=5,gray", szslots);
      udpSend(szhost, ndstport, 0, -1, (uchar*)szmsg, strlen(szmsg), 0, 1);
   }
}

// returns strduped buffer containing also DstName.
// calller must free only returned SrcName.
char *dupFtpSrcDst(char *pszBuf, char **ppDstName)
{
   // bothfilt.txt
   // remotefile.txt localfile.txt
   // "the remote dir/remote file.txt" localfile.txt
   // "the remote dir/remote file.txt" "local file.txt"

   char *psz = pszBuf;
   char cend = ' ';
   if (*psz == '\"')
      cend = *psz++;   

   char *pszCopy = strdup(psz);
   if (!pszCopy) return 0;

   psz = pszCopy;

   char *pend = psz;
   while (*pend != 0 && *pend != cend)
      pend++;

   if (*pend == cend)
      *pend++ = '\0';
   while (*pend != 0 && *pend == ' ')
      pend++;

   if (*pend == 0) {
      // single name, no dst name
      *ppDstName = pszCopy;
      if (cs.verbose) printf("SrcName: '%s'\nDstName: '%s'\n", pszCopy, pszCopy);
      return pszCopy;
   }

   // handle localfile.txt or "local file.txt"
   psz = pend;
   cend = ' ';
   while (*psz != 0 && *psz == ' ')
      psz++;

   if (*psz == '\"')
      cend = *psz++;

   *ppDstName = psz;

   pend = psz;
   while (*pend != 0 && *pend != cend)
      pend++;

   if (*pend == cend)
      *pend++ = '\0';

   // detect unwanted parms
   while (*pend != 0 && *pend == ' ')
      pend++;
   if (*pend != 0) {
      perr("unexpected parameter: %s", pend);
      delete [] pszCopy;
      return 0;
   }

   if (cs.verbose) printf("SrcName: '%s'\nDstName: '%s'\n", pszCopy, *ppDstName);

   return pszCopy;
}

int ftpClient(char *pszHost, uint nPort, char *pszCmd, char *pszUser, char *pszAuthPW, bool bChained)
{__
   SOCKET hSock = 0;
   bool bSFT = 0;
   int nSFTVer = 0;
   if (ftpLogin(pszHost, nPort, hSock, bSFT, nSFTVer, pszUser, pszAuthPW)) return 9;

   // select features dependent on protocol version
   if (!cs.verify && bSFT && (nSFTVer < 103))
   {
      // old SFT server, MUST use md5 checksums
      if (cs.verbose)
         pinf("Old SFT server, verify enforced.\n");
      cs.verify = 1;
   }

   struct sockaddr_in DataAdr;
   SOCKET hData = INVALID_SOCKET;
   bool   bfail = 0;

   for (bool bLoop=1; bLoop && !userInterrupt();)
   {
      num tstart = getCurrentTime();
 
      if (pszCmd) {
         strcpy(szLineBuf, pszCmd);
         bLoop = 0;
      } else {
         printf("> ");
         fflush(stdout);
         if (!(fgets(szLineBuf, sizeof(szLineBuf)-10, stdin)))
            break;
         removeCRLF(szLineBuf);
         // parse interactive options, MUST be at line end.
         cs.yes = 0;
         int ilen = strlen(szLineBuf);
         if (ilen > 5 && !strcmp(szLineBuf+ilen-5, " -yes")) {
            szLineBuf[ilen-5] = '\0';
            cs.yes = 1;
         }
         // strip possible trailing spaces
         myrtrim(szLineBuf);
      }

      if (   !strcmp(szLineBuf, "?")
          || !strcmp(szLineBuf, "h")
          || !strcmp(szLineBuf, "help")
         )
      {
         printf("client commands:\n");
         printf("   cd lcd dir !dir put get mput mget bye\n");
         printf("   run (with sft only)\n");
         printf("\n");
         printf("server commands:\n");
         sprintf(szLineBuf2, "HELP");
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock, 0, 8)) break; // 200 OK
      }
      else
      if (!strcmp(szLineBuf, "cd")) {
         // sfk ftp client: auto pwd on "cd"
         sprintf(szLineBuf2, "PWD");
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock, 0, 8)) break; // 200 OK
      }
      else
      if (!strncmp(szLineBuf, "cd ", 3)) {
         char *pszDir = strdup(szLineBuf+3);
         CharAutoDel odel(pszDir);
         sprintf(szLineBuf2, "CWD %s", pszDir);
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock, 0, 8)) break; // 200 OK
      }
      else
      if (!strncmp(szLineBuf, "lcd ", 4)) {
         char *pszDir = strdup(szLineBuf+4);
         CharAutoDel odel(pszDir);
         if (chdir(pszDir))
            printf("cannot cd to %s\n", pszDir);
         if (!getcwd(szLineBuf2,sizeof(szLineBuf2)-10))
            szLineBuf2[0]='\0';
         printf("%s\n", szLineBuf2);
      }
      else
      if (!strncmp(szLineBuf, "ccd ", 4)) {
         char *pszDir = strdup(szLineBuf+4);
         CharAutoDel odel(pszDir);
         // check if local dir exists
         if (!isDir(pszDir)) {
            printf("no such local dir: %s\n", pszDir);
            continue;
         }
         // try remote cd
         sprintf(szLineBuf2, "CWD %s", pszDir);
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock, 0, 8)) break; // 200 OK
         if (szLineBuf[0] != '2') {
            printf("ccd stopped, no such remote dir: %s\n", pszDir);
            continue;
         }
         // remote cd ok, also do local
         if (chdir(pszDir))
            printf("cannot cd local to %s\n", pszDir);
         if (!getcwd(szLineBuf2,sizeof(szLineBuf2)-10))
            szLineBuf2[0]='\0';
         printf("%s\n", szLineBuf2);
      }
      else
      if (strBegins(szLineBuf, "dir")) {
         if (!bSFT) {
            // szLineBuf is reused in setPassive
            snprintf(szLineBuf2, sizeof(szLineBuf2)-10,
               "LIST%s", szLineBuf+3);
            // either create pasv connection or reuse existing
            if (setPassive(hSock, DataAdr, hData)) break;
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 150 Listing
            while (readLine(hData, szLineBuf, 4) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
            closesocket(hData); hData = INVALID_SOCKET; // fix sfk193: close here
            if (readLine(hSock)) break; // 226 Closing
         } else {
            snprintf(szLineBuf2, sizeof(szLineBuf2)-10,
               "SLST%s", szLineBuf+3);
            if (sendLine(hSock, szLineBuf2)) break;
            while (readLine(hSock, szLineBuf, 4) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
         }
      }
      else
      if (strBegins(szLineBuf, "mlsd")) { // sfk185 client
         // just for info with plain ftp.
         // szLineBuf is reused in setPassive.
         snprintf(szLineBuf2, sizeof(szLineBuf2)-10,
            "MLSD%s", szLineBuf+4);
         // either create pasv connection or reuse existing
         if (setPassive(hSock, DataAdr, hData)) break;
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock)) break; // 150 Listing
         while (readLine(hData, szLineBuf, 4) == 0)
            if (!strncmp(szLineBuf, "226 ", 4))
               break;
         closesocket(hData); hData = INVALID_SOCKET; // fix sfk193: close here
         if (readLine(hSock)) break; // 226 Closing
      }
      else
      if (strBegins(szLineBuf, "ls")) {
         if (!bSFT) {
            // szLineBuf is reused in setPassive
            snprintf(szLineBuf2, sizeof(szLineBuf2)-10,
               "NLST%s", szLineBuf+2);
            // either create pasv connection or reuse existing
            if (setPassive(hSock, DataAdr, hData)) break;
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 150 Listing
            while (readLine(hData, szLineBuf, 4) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
            closesocket(hData); hData = INVALID_SOCKET; // fix sfk193: close here
            if (readLine(hSock)) break; // 226 Closing
         } else {
            snprintf(szLineBuf2, sizeof(szLineBuf2)-10,
               "NLST%s", szLineBuf+2);
            if (sendLine(hSock, szLineBuf2)) break;
            while (readLine(hSock, szLineBuf, 4) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
         }
      }
      else
      if (!strncmp(szLineBuf, "!", 1)) {
         // run local command
         int iRC = system(szLineBuf+1);
         if (iRC)
            printf("RC: %d\n", iRC);
      }
      else
      if (!strncmp(szLineBuf, "run ", 4)) {
         char *pszCmd = strdup(szLineBuf+4);
         CharAutoDel odel(pszCmd);
         // try to run remote command. requires -run option set at server.
         if (!bSFT) {
            printf("cannot run, remote server speaks no SFT.\n");
         } else {
            sprintf(szLineBuf2, "SRUN %s", pszCmd);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock, 0, 8)) break; // 200 OK, 500 Error
            // keep socket open.
         }
      }
      else
      if (!strncmp(szLineBuf, "rerun ", 6)) { // sft client
         char *pszCmd = strdup(szLineBuf+6);
         CharAutoDel odel(pszCmd);
         if (!bSFT) {
            printf("cannot run, remote server speaks no SFT.\n");
         } else {
            sprintf(szLineBuf2, "RERUN %s", pszCmd); // sft client
            if (sendLine(hSock, szLineBuf2)) break;
            if (chain.coldata) chain.addStreamAsLines(1,0,0);
            while (!userInterrupt())
            {
               // loop while no data
               if (!hasData(hSock,20))
                  continue;
               // read control record
               if (readLine(hSock)) break;
               // 199 PRINT 04000\r\n
               if (strncmp(szLineBuf, "199 PRINT ", 10)) {
                  // any other code like 200 stops.
                  if (strncmp(szLineBuf, "200 ", 4))
                     printf("%s\n", szLineBuf);
                  break;
               }
               int iPrintLen = atoi(szLineBuf+10);
               if (iPrintLen < 1 || iPrintLen > MAX_ABBUF_SIZE) {
                  printf("invalid print length: %d\n", iPrintLen);
                  break;
               }
               // read data record
               int iRemain = iPrintLen;
               while (iRemain > 0)
               {
                  int iread = recv(hSock, (char*)abBuf, iRemain, 0);
                  if (iread <= 0) {
                     printf("incomplete reply (%d/%d)\n",iRemain,iPrintLen);
                     break;
                  }
                  if (iread >= 0 && iread <= MAX_ABBUF_SIZE)
                     abBuf[iread] = '\0';
                  if (cs.verbose)
                     printf("> ----- recv %04d: \"%.30s\" -----\n",iread,abBuf);
                  if (chain.coldata)
                     chain.addStreamAsLines(2,(char*)abBuf,iread);
                  else
                     myfwrite((uchar*)abBuf,iread,stdout);
                  iRemain -= iread;
               }
            }
            if (chain.coldata) chain.addStreamAsLines(3,0,0);
            // keep socket open.
         }
      }
      else
      if (strBegins(szLineBuf, "put "))
      {
         DisableCtrlCProcessExit(); // ftp.client

         // char *pszFileName = strdup(szLineBuf+4);

         // sfk197 sft put enquote and remote name support
         char *pszDstName = 0; // same buffer as SrcName.
         char *pszSrcName = dupFtpSrcDst(szLineBuf+4, &pszDstName);
         if (!pszSrcName || !pszDstName) break; // should not occur

         CharAutoDel odel1(pszSrcName);

         Coi *pcoi = new Coi(localPath(pszSrcName), 0);
         CoiAutoDelete odel2(pcoi, 0); // no decref

         if (cs.test == 0 && pcoi->getSize() < 0) { // sfk1840: sft -test support
            perr("cannot read %s\n", pcoi->name());
            if (!cs.force) break;
         }
         else
         if (!bSFT) {
            if (setPassive(hSock, DataAdr, hData)) break;
            sprintf(szLineBuf2, "STOR %s", remoteStandardPath(pszDstName));
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 150 Receiving
            showFtpError(pcoi->name()); // sfk185 put
            if (sendFileRaw("ftp", hData, localPath(pszSrcName), 1, 0, pszDstName)) break;
            closesocket(hData); hData = INVALID_SOCKET;
            if (readLine(hSock)) break; // 226 Closing
            // if (setFtpModTime(pcoi, pszFileName, hSock)) break;
            if (cs.notifyto) // sft.put.single
               sendNotifyStatus(cs.notifyto, 1); // up
         } else {
            sprintf(szLineBuf2, "SPUT %s", pszDstName); // put
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 200 OK, 500 Error
            showFtpError(pcoi->name()); // sfk1840 put
            if (!strncmp(szLineBuf, "200", 3))
               if (putFileBySFT(hSock, pcoi, nSFTVer, 0,0,0, pszDstName))
                  break;
            // ack receive was done above. keep socket open.
            if (cs.notifyto) // sft.put.single
               sendNotifyStatus(cs.notifyto, 1); // up
         }
      }
      else
      if (   !bChained
          && (strBegins(szLineBuf, "mput") || strBegins(szLineBuf, "cput"))
         )
      {
         DisableCtrlCProcessExit(); // ftp.client

         // direct multi file put (not chained)
         char szParmBuf[300]; mclear(szParmBuf);

         bool bupdate = strBegins(szLineBuf, "cput") ? 1 : 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;
         if (!bSFT       ) bupdate = 0; // sfk185 no cput/cget w/o SFT

         char *pparms = szLineBuf+strlen("mput");
         skipWhite(&pparms);
         strcopy(szParmBuf, pparms);
         cs.sim = !cs.yes;

         char *pszMask = szParmBuf;
         if (!*pszMask) {
            perr("missing mask. supply a name fragment or just \"*\"\n");
            continue;
         }
         if (cs.debug)
            printf("mask: \"%s\"\n", pszMask);

         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         int lFiles=0, lDirs=0;
         num nBytes=0;
         glblFTPLocList.resetEntries();
         walkAllTrees(eFunc_FTPLocList, lFiles, lDirs, nBytes);

         int nfiles = glblFTPLocList.numberOfEntries();

         // now ALL local files are listed in glblFTPLocList
         int ifile=0, nSent=0, nSkipped=0, nFailed=0;
         num nFileSize=0, nTotalSize=0;
         for (ifile=0; ifile<nfiles; ifile++)
         {
            char *pszFile = glblFTPLocList.getEntry(ifile, __LINE__);
 
            // normalize name, temporary for comparison
            if (normalizePath(pszFile, szLineBuf2, sizeof(szLineBuf2)))
               continue;

            // sfk197 fix sft mput: /foo did not work
            if (isWildStr(pszMask) || matchesNormName(szLineBuf2, pszMask, 0, 1)) // mput
            {
               Coi *pcoi = new Coi(pszFile, 0);
               CoiAutoDelete odel(pcoi, 0); // no decref

               nFileSize = pcoi->getSize();
               if (nFileSize < 0) { // FIX 1654: missing check on mput.nochain
                  perr("cannot read %s\n", pcoi->name());
                  if (!cs.force) break;
                  nFailed++;
                  continue;
               }

               num ndsttime = getFileTime(pszFile);

               if (   bupdate && (ndsttime > 0)
                   && canSkipFile(hSock, pszFile, ndsttime, 1, nSFTVer)) // ftp cput
               {
                  if (cs.verbose)
                     printf("skip: %s - unchanged. (or use -all)\n", pszFile);
                  nSkipped++;
                  continue;
               }

               nTotalSize += nFileSize;

               if (cs.sim) {
                  if (!cs.quiet)
                     printf("< %s\n", pszFile);
                  nSent++;
                  continue;
               }

               do {
                  bfail = 1;
                  if (!bSFT) {
                     if (setPassive(hSock, DataAdr, hData)) break;
                     sprintf(szLineBuf2, "STOR %s", remoteStandardPath(pszFile));
                     if (sendLine(hSock, szLineBuf2)) break;
                     if (readLine(hSock)) break; // 150 Receiving
                     showFtpError(pcoi->name()); // sfk185 mput
                     if (sendFileRaw("ftp", hData, localPath(pszFile), 1)) break;
                     closesocket(hData); hData = INVALID_SOCKET;
                     if (readLine(hSock)) break; // 226 Closing
                     nSent++;
                     bfail = 0;
                     // if (setFtpModTime(pcoi, pszFile, hSock)) break;
                  } else {
                     sprintf(szLineBuf2, "SPUT %s", pszFile); // mput.nochain
                     if (sendLine(hSock, szLineBuf2, 1)) break;
                     if (readLine(hSock, szLineBuf , 2)) break; // 200 OK, 500 Error
                     showFtpError(pcoi->name()); // sfk1840 mput
                     if (strncmp(szLineBuf, "200", 3)) break;
                     if (putFileBySFT(hSock, pcoi, nSFTVer, 1)) break;
                     nSent++;
                     bfail = 0;
                     // ack receive was done above. keep socket open.
                  }
               } while (0);
               if (hData != INVALID_SOCKET)
                  { closesocket(hData); hData = INVALID_SOCKET; }
               if (bfail) {
                  perr("cannot send: %s", pszFile);
                  nFailed++;
                  if (!cs.force) break;
               }
            } else {
               nSkipped++;
            }
         }

         cs.files = nSent; // sfk193

         int nelaps   = (int)(getCurrentTime() - tstart)/1000;
         int nTotalMB = (int)(nTotalSize / 1000000);

         if (nFailed > 0) {
            printf("%d files of %d %ssent, %d failed. %d mb, %d sec.\n", nSent, nfiles, cs.sim?"would be ":"", nFailed, nTotalMB, nelaps);
            if (!cs.force)
               pinf("add option -force to continue transfer after errors.\n");
         } else if (cs.sim || nSent>0 || cs.quiet==0) { // sfk193 -quiet and no files
            printf("%d files of %d %ssent. %d mb, %d sec.\n", nSent, nfiles, cs.sim?"would be ":"", nTotalMB, nelaps);
         }

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");

         if (cs.yes && cs.notifyto && nSent) // sft.mput.direct
            sendNotifyStatus(cs.notifyto, 1); // up

         if (ifile < glblFTPLocList.numberOfEntries())
            bLoop = 0; // fatal, server probably closed connection
      }
      else
      if (    bChained
          && (strBegins(szLineBuf, "mput") || strBegins(szLineBuf, "cput"))
         )
      {
         DisableCtrlCProcessExit(); // ftp.client

         // chained multi file put (after select)

         // with FTP, update isn't supported.
         // simulate is always default.
 
         bool bupdate = strBegins(szLineBuf, "cput") ? 1 : 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;
         if (!bSFT       ) bupdate = 0; // sfk185 no cput/cget w/o SFT

         char *pparms = szLineBuf+strlen("mput");
         skipWhite(&pparms);
         cs.sim = !cs.yes;

         int nfiles = chain.numberOfInFiles();

         if (nfiles < 1) {
            if (!cs.quiet) // sfk1934
               printf("ftp: have no filenames from previous commands.\n");
            break;
         }

         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         int ifile=0, nSent=0, nSkipped=0, nFailed=0;
         num nFileSize=0, nTotalSize=0;
         for (ifile=0; ifile<nfiles; ifile++)
         {
            Coi *pcoi = chain.getFile(ifile);
            if (!pcoi) return 9+perr("int. #204292351\n");

            nFileSize = pcoi->getSize();
            if (nFileSize < 0) { // FIX 1654: missing check
               perr("cannot read %s\n", pcoi->name());
               nFailed++;
               if (!cs.force) break;
               continue;
            }

            char *pszFileName = pcoi->name();
            num ndsttime = pcoi->getTime();

            if (   bupdate && (ndsttime > 0) // sfk185 NOT "&& bSFT"
                && canSkipFile(hSock, pszFileName, ndsttime, 1, nSFTVer)) // sel +ftp cput
            {
               if (cs.verbose)
                  printf("skip: %s - unchanged. (or use -all)\n", pszFileName);
               nSkipped++;
               continue;
            }

            nTotalSize += nFileSize;

            if (cs.sim) {
               if (!cs.quiet)
                  printf("< %s\n", pszFileName);
               nSent++;
               continue;
            }

            do {
               bfail = 1;
               if (!bSFT) {
                  if (setPassive(hSock, DataAdr, hData)) break;
                  sprintf(szLineBuf2, "STOR %s", remoteStandardPath(pszFileName));
                  if (sendLine(hSock, szLineBuf2)) break;
                  if (readLine(hSock)) break; // 150 Receiving
                  showFtpError(pcoi->name()); // sfk185 mput
                  if (sendFileRaw("ftp", hData, localPath(pszFileName), 1)) break;
                  closesocket(hData); hData = INVALID_SOCKET;
                  if (readLine(hSock)) break; // 226 Closing
                  nSent++;
                  bfail = 0;
                  // if (setFtpModTime(pcoi, pszFileName, hSock)) break;
               } else {
                  // FIX 1654: redundant pcoi for file access
                  sprintf(szLineBuf2, "SPUT %s", pszFileName); // mput.chain
                  if (sendLine(hSock, szLineBuf2)) break;
                  if (readLine(hSock)) break; // 200 OK, 500 Error
                  showFtpError(pcoi->name()); // sfk1840 mput
                  if (strncmp(szLineBuf, "200", 3)) break;
                  if (putFileBySFT(hSock, pcoi, nSFTVer)) break;
                  nSent++;
                  bfail = 0;
                  // ack receive was done above. keep socket open.
               }
            } while (0);
            if (hData != INVALID_SOCKET)
               { closesocket(hData); hData = INVALID_SOCKET; }
            if (bfail) {
               perr("cannot send: %s", pszFileName);
               nFailed++;
               if (!cs.force) break;
            }
         }  // endfor files

         cs.files = nSent; // sfk193

         int nelaps   = (int)(getCurrentTime() - tstart)/1000;
         int nTotalMB = (int)(nTotalSize / 1000000);

         if (nFailed > 0) {
            printf("%d files of %d %ssent, %d failed. %d mb, %d sec.\n", nSent, nfiles, cs.sim?"would be ":"", nFailed, nTotalMB, nelaps);
            if (!cs.force)
               pinf("add option -force to continue transfer after errors.\n");
         } else if (cs.sim || nSent>0 || cs.quiet==0) { // sfk193 -quiet and no files
            printf("%d files of %d %ssent. %d mb, %d sec.\n", nSent, nfiles, cs.sim?"would be ":"", nTotalMB, nelaps);
         }

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");

         if (cs.yes && cs.notifyto && nSent) // sft.mput.chain
            sendNotifyStatus(cs.notifyto, 1); // up

         if (ifile < nfiles)
            break;
      }
      else
      if (!strncmp(szLineBuf, "get ", 4))
      {
         DisableCtrlCProcessExit(); // ftp.client

         // sfk197 sft get enquote and local name support
         char *pszDstName = 0; // same buffer as SrcName.
         char *pszSrcName = dupFtpSrcDst(szLineBuf+4, &pszDstName);
         if (!pszSrcName || !pszDstName) break; // should not occur
         CharAutoDel odel(pszSrcName);

         if (!bSFT) {
            if (setPassive(hSock, DataAdr, hData)) break;
            sprintf(szLineBuf2, "RETR %s", pszSrcName);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 150 Sending
            showFtpError(pszSrcName); // sfk197 get
            if (strBegins(szLineBuf, "150")) {
               createOutDirTree(localPath(pszDstName));
               if (receiveFileRaw("ftp", hData, localPath(pszDstName), -1, 0,0,0)) // client
                  break;
               closesocket(hData); hData = INVALID_SOCKET; // fix sfk193: close here
               if (cs.notifyto) // sft.get.single
                  sendNotifyStatus(cs.notifyto, 2); // down
               if (readLine(hSock)) break; // 226 Closing
            }
            if (hData != INVALID_SOCKET)
               { closesocket(hData); hData = INVALID_SOCKET; }
         } else {
            sprintf(szLineBuf2, "SGET %s", pszSrcName);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 200 OK
            showFtpError(pszSrcName); // sfk197 get
            if (!strncmp(szLineBuf, "200", 3)) {
               createOutDirTree(localPath(pszDstName));
               if (getFileBySFT(hSock, localPath(pszDstName), nSFTVer))
                  break;
               if (cs.notifyto) // sft.get.single
                  sendNotifyStatus(cs.notifyto, 2); // down
            }
            // ack send was done above. keep socket open.
         }
      }
      else
      if (   !bChained
          && (strBegins(szLineBuf, "mget") || strBegins(szLineBuf, "cget"))
         )
      {
         DisableCtrlCProcessExit(); // ftp.client

         // direct multi file get (not chained)
         char szParmBuf[300]; mclear(szParmBuf);

         bool bupdate = strBegins(szLineBuf, "cget") ? 1 : 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;
         if (!bSFT       ) bupdate = 0; // sfk185 no cput/cget w/o SFT

         char *pparms = szLineBuf+strlen("mget");
         skipWhite(&pparms);
         strcopy(szParmBuf, pparms);
         cs.sim = !cs.yes;

         char *pszMask = szParmBuf;
         if (!*pszMask) {
            perr("missing mask. supply a name fragment (without *), or just \"*\"\n");
            continue;
         }
         if (cs.debug)
            printf("mask: \"%s\"\n", pszMask);

         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         glblFTPRemList.resetEntries();
         if (!bSFT) {
            if (setPassive(hSock, DataAdr, hData)) break;
            if (sendLine(hSock, "LIST")) break;
            if (readLine(hSock)) break; // 150 Listing
            while (readLine(hData, szLineBuf, 1) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
            closesocket(hData); hData = INVALID_SOCKET; // fix sfk193: close here
            if (readLine(hSock)) break; // 226 Closing
         } else {
            sendLine(hSock, "SLST");
            while (readLine(hSock, szLineBuf, 1) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
         }

         if (cs.debug)
            printf("> received %d filenames\n",glblFTPRemList.numberOfEntries());

         char *apcol[20];
         memset(apcol, 0, sizeof(apcol));

         // now ALL remote files are listed in glblFTPRemList
         // in a RAW format:
         // -rw-rw-rw- 1 ftp ftp        30353 Sep 08 13:47   readme.txt
         //    0       1  2   3          4    5   6   7      8
         // -rw-rw-rw- 1 ftp ftp        30353 20061231235959 readme.txt
         //    0       1  2   3          4    5              6
         // drwxr-xr-x 1 ftp ftp              0 Apr 06 09:23 thedir01
         int i=0, nRecv=0, nSkipped=0, nFailed=0, nskip=0;
         for (; i<glblFTPRemList.numberOfEntries(); i++)
         {
            char *pszFileRaw = glblFTPRemList.getEntry(i, __LINE__);

            // parse raw line
            int ncol = 0;
            strcopy(szRefNameBuf, pszFileRaw);
            char *psz1 = szRefNameBuf;
            while (ncol < 15) {
               // store column start
               apcol[ncol++] = psz1;
               // find end of column
               skipToWhite(&psz1);
               if (!*psz1) break;
               *psz1++ = '\0';
               // find start of next column
               skipWhite(&psz1);
               if (!*psz1) break;
            }

            char *pattr = apcol[0];
 
            // skip directories
            if (pattr && (pattr[0] == 'd'))
                 continue;

            char *pszMonTS = apcol[5]; // month or timestamp
            bool bHaveFlatTime = 0;
            if (pszMonTS && isdigit(*pszMonTS))
                 bHaveFlatTime = 1;

            int iName = 8;
            if (bHaveFlatTime) {
               if (ncol < 7)
                  {  pwarn("wrong format: %s - skipping\n", pszFileRaw); continue; }
               iName = 6;
            }
            else
            if (ncol < 9)
               {  pwarn("wrong format: %s - skipping\n", pszFileRaw); continue; }

            // always take filename from original buffer,
            // blanks may have been replaced by zeros in RefNameBuf.
            char *pszFile = pszFileRaw + (apcol[iName]-szRefNameBuf);
            char *pszSize = apcol[4];

            num nFileSize = atonum(pszSize);
            if (nFileSize <= 0) {
               printf("] skip, size=%s: %s\n", pszSize, pszFile);
               continue;
            }

            // normalize name, temporary for comparison
            if (normalizePath(pszFile, szLineBuf2, sizeof(szLineBuf2)))
               continue;

            // sfk197 fix sft mget: /foo did not work
            if (isWildStr(pszMask) || matchesNormName(szLineBuf2, pszMask, 0, 1)) // mget
            {
               num ndsttime = getFileTime(pszFile);

               if (   bupdate && (ndsttime > 0)
                   && canSkipFile(hSock, pszFile, ndsttime, 0, nSFTVer)) // ftp cget
               {
                  if (cs.verbose)
                     printf("skip: %s - unchanged. (or use -all)\n", pszFile);
                  nskip++;
                  continue;
               }
               if (cs.sim) {
                  if (!cs.quiet)
                     printf("> %s, %s bytes.\n", pszFile, numtoa(nFileSize));
                  nRecv++;
                  continue;
               }

               if (!isWriteable(pszFile)) {
                  perr("cannot write: %s\n", pszFile);
                  nFailed++;
                  continue;
               }

               if (!bSFT) {
                  if (setPassive(hSock, DataAdr, hData)) break;
                  sprintf(szLineBuf2, "RETR %s", pszFile);
                  if (sendLine(hSock, szLineBuf2)) break;
                  if (readLine(hSock)) break; // 150 Sending
                  createOutDirTree(localPath(pszFile));
                  if (receiveFileRaw("ftp", hData, localPath(pszFile), -1, 0,0,0)) // client
                     break;
                  closesocket(hData); hData = INVALID_SOCKET; // fix sfk193: close here
                  if (readLine(hSock)) break; // 226 Closing
               } else {
                  sprintf(szLineBuf2, "SGET %s", pszFile);
                  if (sendLine(hSock, szLineBuf2, 1)) break;
                  if (readLine(hSock, szLineBuf , 2)) break; // 200 OK
                  if (strncmp(szLineBuf, "200", 3)) {
                     printf("\n");
                     perr("%s", szLineBuf); // no LF. readLine was QUIET
                  } else {
                     if (getFileBySFT(hSock, pszFile, nSFTVer, 1))
                        break;
                  }
               }

               // ack receive was done above. keep socket open.
               nRecv++;
            } else {
               nSkipped++;
            }
         }

         int nelaps = (int)(getCurrentTime() - tstart)/1000;

         if (i < glblFTPRemList.numberOfEntries())
            bLoop = 0; // fatal, server probably closed connection
         if (nFailed > 0)
            printf("%d files received, %d failed, %d sec.\n", nRecv, nFailed, nelaps);
         else
            printf("%d files %sreceived, %d sec.\n", nRecv, cs.sim?"would be ":"", nelaps);

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");

         if (cs.yes && cs.notifyto && nRecv) // sft.mget
            sendNotifyStatus(cs.notifyto, 2); // down
      }
      else
      if (   bChained
          && (strBegins(szLineBuf, "mget") || strBegins(szLineBuf, "cget"))
         )
      {
         DisableCtrlCProcessExit(); // ftp.client

         // chained multi file get (after select)

         // with FTP, update isn't supported.
         // simulate is always default.
         char szParmBuf[300]; mclear(szParmBuf);
         char szDstBuf[400];  mclear(szDstBuf);

         bool bupdate = strBegins(szLineBuf, "cget") ? 1 : 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;
         if (!bSFT       ) bupdate = 0; // sfk185 no cput/cget w/o SFT

         char *pparms = szLineBuf+strlen("mget");
         skipWhite(&pparms);
         strcopy(szParmBuf, pparms);
         cs.sim = !cs.yes;

         if (!szParmBuf[0])
         {
            // SFK 169: simply use '.' as target
            strcpy(szParmBuf, ".");
         }

         int nfiles = chain.numberOfInFiles();
         int ifile  = 0;

         if (nfiles < 1) {
            if (!cs.quiet) // sfk1934
               printf("ftp: have no filenames from previous commands.\n"); 
            break;
         }
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         int nskip = 0;
         int ndone = 0;
         for (ifile=0; ifile<nfiles; ifile++)
         {
            // the reference coi, e.g. mydir/foo.txt
            Coi *pcoi = chain.getFile(ifile);
            if (!pcoi) return 9+perr("int. #204292352\n");

            char *pszFileName = pcoi->name();
            char *pszLocFile  = localPath(pszFileName);
            snprintf(szDstBuf, sizeof(szDstBuf), "%s%c%s", szParmBuf, glblPathChar, pszLocFile);

            // the destination coi, e.g. dstdir/mydir/foo.txt
            // this coi's time is checked against the remote time.
            Coi *pcoidst = new Coi(szDstBuf, 0);
            CoiAutoDelete odel(pcoidst, 0); // no decref
            num  ndsttime = pcoidst->getTime(); // if any

            if (   bupdate && (ndsttime > 0) // sfk185 NOT "&& bSFT"
                && canSkipFile(hSock, pszFileName, ndsttime, 0, nSFTVer)) // sel +ftp cget
            {
               if (cs.verbose)
                  printf("skip: %s - unchanged. (or use -all)\n", pszFileName);
               nskip++;
               continue;
            }
            if (cs.sim) {
               if (!cs.quiet)
                  printf("> %s\n", szDstBuf);
               ndone++;
               continue;
            }

            if (!bSFT) {
               if (setPassive(hSock, DataAdr, hData)) break;
               sprintf(szLineBuf2, "RETR %s", pszFileName);
               if (sendLine(hSock, szLineBuf2)) break;
               if (readLine(hSock)) break; // 150 Sending
               createOutDirTree(szDstBuf);
               if (receiveFileRaw("ftp", hData, szDstBuf, -1, 0,0,0)) // client
                  break;
               closesocket(hData); hData = INVALID_SOCKET; // fix sfk193: close here
               if (readLine(hSock)) break; // 226 Closing
               ndone++;
            } else {
               sprintf(szLineBuf2, "SGET %s", pszFileName);
               if (sendLine(hSock, szLineBuf2)) break;
               if (readLine(hSock)) break; // 200 OK
               if (!strncmp(szLineBuf, "200", 3)) {
                  createOutDirTree(szDstBuf);
                  if (getFileBySFT(hSock, szDstBuf, nSFTVer))
                     break;
                  ndone++;
               }
               // ack send was done above. keep socket open.
            }
         }
 
         int nelaps = (int)(getCurrentTime() - tstart)/1000;
 
         if (!cs.quiet) {
            if (cs.sim) {
               if (bupdate)
                  printf("would receive %d files, skip %d unchanged.\n", ndone, nskip);
               else
                  printf("would receive %d files.\n", ndone);
            }
            else
            if (nskip)
               printf("%d files received, %d unchanged skipped, %d sec.\n", ndone, nskip, nelaps);
            else
               printf("%d files received, %d sec.\n", ndone, nelaps);
         }

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");

         if (cs.yes && cs.notifyto && ndone) // sft.mget
            sendNotifyStatus(cs.notifyto, 2); // down

         if (ifile<nfiles)
            break;
      }
      else
      if (!strcmp(szLineBuf, "bye")) {
         break;
      }
      else
      {
         // any other command: apply simple alias remapping
         static const char *pszmap[] = {
            "del ", "DELE ",
            "mkdir ", "MKD ",
            "md ", "MKD ",
            "rmdir ", "RMD ",
            0, 0 // eot
         };
         strcopy(szLineBuf2, szLineBuf);
         for (int i=0; pszmap[i]; i+=2) {
            if (stribeg(szLineBuf,pszmap[i+0])) {
               int ilen=strlen(pszmap[i+0]);
               snprintf(szLineBuf2,sizeof(szLineBuf2)-10,
                  "%s%s", pszmap[i+1], szLineBuf+ilen);
               break;
            }
         }
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock, 0, 8)) break; // 200 OK, 500 Error
      }
   }

   if (!pszCmd)
      printf("connection closed.\n");

   closesocket(hSock);

   #ifdef _WIN32
   // WSACleanup(); // sfk1840 only on process exit
   #endif

   return 0;
}

int makeServerSocket(
   uint  &nNewPort,                 // i/o parm
   struct sockaddr_in &ServerAdr,   // i/o parm
   SOCKET &hServSock,
   cchar  *pszInfo,
   uint  nAltPort=0                 // e.g. 2121 for ftp
   )
{
   uint nPort = nNewPort;

   socklen_t nSockAdrSize = sizeof(sockaddr_in);

   ServerAdr.sin_family      = AF_INET;
   ServerAdr.sin_addr.s_addr = htonl(INADDR_ANY);
   ServerAdr.sin_port        = htons((unsigned short)nPort);

   hServSock = socket(AF_INET, SOCK_STREAM, 0);
   if (hServSock == INVALID_SOCKET)
      return 9+perr("cannot create %s (%u)\n", pszInfo, nPort);

   int nOnVal = 1;
   setsockopt(hServSock, SOL_SOCKET, SO_REUSEADDR, (char *)&nOnVal, sizeof(nOnVal));

   int nrc = bind(hServSock, (struct sockaddr *)&ServerAdr, sizeof(sockaddr_in));

   if (nrc == SOCKET_ERROR && nAltPort > 0)
   {
      pinf("cannot bind on port %u, using alternative port %d.\n", nPort, nAltPort);
      nPort = nAltPort;
      ServerAdr.sin_port = htons((unsigned short)nPort);
      nrc = bind(hServSock, (struct sockaddr *)&ServerAdr, sizeof(sockaddr_in));
   }

   if (nrc == SOCKET_ERROR)
   {
      perr("cannot bind %s (%u)\n", pszInfo, nPort);
      fprintf(stderr, "info : maybe a different app is running, or firewall blocks access.\n");
      fprintf(stderr, "info : you may retry with a different port, e.g. -port=30199.\n");
      return 9;
   }

   int nerr = getsockname(hServSock, (struct sockaddr *)&ServerAdr, &nSockAdrSize);
   if (nerr == SOCKET_ERROR)
      return 9+perr("getsockname failed, %d\n", netErrno());

   bool bTell = (nPort == 0);
   if (pszInfo && !strcmp(pszInfo, "passive server port"))
        bTell = 1;
   nPort    = (uint)ntohs(ServerAdr.sin_port);
   nNewPort = nPort;
   if (bTell)
      printf("- local port %u (%u, %u)\n", nPort, (nPort>>8), nPort&0xFF);

   // make accept non-blocking:
   setBlocking(hServSock, 0);

   if (listen(hServSock, 4) == SOCKET_ERROR)
      return 9+perr("cannot listen on %s (%u)\n", pszInfo, nPort);

   return 0;
}

int connectSocket(char *pszHost, uint nPort, struct sockaddr_in &ClntAdr, SOCKET &hSock, cchar *pszInfo)
{
   hSock = socket(AF_INET, SOCK_STREAM, 0);
   if (hSock == INVALID_SOCKET)
      return 9+perr("cannot create %s\n", pszInfo);

   ClntAdr.sin_family = AF_INET;
   ClntAdr.sin_port = htons((unsigned short)nPort);
   if (setaddr(&ClntAdr, pszHost))
      return 9;

   if (cs.verbose)
      printf("< connect to %s:%u\n", pszHost, nPort);
   if ((connect(hSock, (struct sockaddr *)&ClntAdr, sizeof(struct sockaddr_in))) == -1)
      return 9+perr("cannot establish connection for %s\n", pszInfo);

   return 0;
}

int makeKnxReq(uchar cmd[], int ga1, int ga2, int ga3, uint nlen, uchar data[], bool breply)
{
   uchar nKnxDA0=1, nKnxDA1=1, nKnxDA2=199;

   uint nbytelen = 0;

   switch (nlen)
   {
      case  1:
      case  4: nbytelen =  0; break;
      case  8: nbytelen =  1; break;
      case 16: nbytelen =  2; break;
      case 14: nbytelen = 14; break;
   }

   cmd[0] = 6;
   cmd[1] = 0x10;
   cmd[2] = 0x05;
   cmd[3] = 0x30;
   cmd[4] = 0x00;
   cmd[5] = 11+6+nbytelen;

   uchar *pcemi = &cmd[6];

   pcemi[0] = 0x29; // L_DATA_CON
   pcemi[1] = 0x00;
   pcemi[2] = 0x8c;
   pcemi[3] = 0xbc; // normal prio, no repeat
   pcemi[4] = (nKnxDA0<<4) | nKnxDA1;
   pcemi[5] = nKnxDA2;

   uchar *pga = pcemi + 6;
 
   pga[0] =    ((ga2 & 0x07) << 0)
            |  ((ga1 & 0x1F) << 3);
   pga[1] =    ga3;

   pcemi[8]  = 0x01 + nbytelen;
   pcemi[9]  = 0x00;
   pcemi[10] = breply ? 0x40 : 0x80; // 0x80=write, 0x40=reply, 0x00=read
 
   // data size dependent
   switch (nlen)
   {
      case 1:
      case 4:
         pcemi[10] = 0x80 | (data[0] & 0x3F);
         break;
      case 8:
         cmd[17] = data[0];
         break;
      case 14:
         memcpy(&cmd[17], &data[0], 14);
         break;
      case 16:
         pcemi[11] = data[0];
         pcemi[12] = data[1];
         break;
   }
 
   return cmd[5];
}

int makeKnxSearchReq(uchar cmd[])
{
   cmd[0] = 6;
   cmd[1] = 0x10;
   cmd[2] = 0x02;
   cmd[3] = 0x01;
   cmd[4] = 0x00;
   cmd[5] = 14;

   cmd[6]  = 8;
   cmd[7]  = 0x01;
   cmd[8]  = 224;
   cmd[9]  = 0;
   cmd[10] = 23;
   cmd[11] = 12;
   cmd[12] = 0x0E;
   cmd[13] = 0x57;

   return cmd[5];
}

int parseKnxReq(uchar cmd[], char *psz)
{
   if (!strcmp(psz, "search"))
   {
      return makeKnxSearchReq(cmd);
   }

   bool breply = 0;

   // "1 4 200 1 0"
   // "1 4 200 14 test string"
   int ga1,ga2,ga3,nlen,nval1,nval2;

   if (!isdigit(*psz)) return -1+perr("first GA part must be a number: \"%s\"", psz);
   ga1 = atoi(psz); skipToWhite(&psz); skipWhite(&psz);

   if (!isdigit(*psz)) return -1+perr("2nd GA part must be a number: \"%s\"", psz);
   ga2 = atoi(psz); skipToWhite(&psz); skipWhite(&psz);

   if (!isdigit(*psz)) return -1+perr("3rd GA part must be a number: \"%s\"", psz);
   ga3 = atoi(psz); skipToWhite(&psz); skipWhite(&psz);

   if (!isdigit(*psz)) return -1+perr("data length must be a number: \"%s\"", psz);
   nlen= atoi(psz); skipToWhite(&psz); skipWhite(&psz);

   uchar abdata[20];
   mclear(abdata);

   if (nlen < 14 || nlen == 16) {
      if (!isdigit(*psz)) return -1+perr("missing number data value: \"%s\"", psz);
      bool bhex = strbeg(psz, "0x");
      nval1 = myatonum(psz);
      if (nlen == 16) {
         skipToWhite(&psz); skipWhite(&psz);
         if (strbeg(psz, "0x") || isdigit(*psz)) {
            nval2 = (uchar)myatonum(psz);
            abdata[0] = nval1;
            abdata[1] = nval2;
            printf("KNX: %d/%d/%d len=%d data=0x%02X%02X\n", ga1,ga2,ga3,nlen,nval1,nval2);
         } else if (bhex) {
            // large raw hex value
            abdata[0] = (nval1 >> 8) & 0xFF;
            abdata[1] = (nval1 & 0xFF);
            printf("KNX: %d/%d/%d len=%d data=0x%02X%02X\n", ga1,ga2,ga3,nlen,abdata[0],abdata[1]);
         } else {
            // large int value: apply conversion
            int mantisse1 = abs(nval1);
            int exponent1 = 0;
            while (mantisse1 >= 2048) {
               mantisse1 /= 2;
               exponent1++;
            }
            if (nval1 < 0)
               mantisse1 = 0 - mantisse1;
            unsigned char b1 = ((mantisse1&0x0700)>>8);
            b1 |= exponent1 << 3;
            if (nval1 < 0)
               b1 |= 0x80;
            unsigned char b2 = mantisse1&0x00ff;
            abdata[0] = b1;
            abdata[1] = b2;
            printf("KNX: %d/%d/%d len=%d data=0x%02X%02X (from %u)\n",
               ga1,ga2,ga3, nlen, b1,b2, nval1);
         }
      } else {
         abdata[0] = nval1;
         printf("KNX: %d/%d/%d len=%d data=0x%02X\n", ga1,ga2,ga3,nlen,nval1);
      }
   } else {
      nval1 = 0;
      strncpy((char*)abdata, psz, 14);
      printf("KNX: %d/%d/%d len=%d data=\"%s\"\n", ga1,ga2,ga3,nlen,abdata);
   }

   return makeKnxReq(cmd,ga1,ga2,ga3,nlen,abdata,breply);
}

void dumpKnxInfo(uchar *pData, int iSize, char *pBuf, int iMaxBuf)
{__
   pBuf[0] = '\0';

   if (iSize < 2) return;

   uint    nservice =   ((uint)pData[2] << 8)
                      | ((uint)pData[3] << 0);
   uint    ioffset  = 0;
   cchar  *pszType  = 0;

   char szga[30];
   memset(szga, 0, sizeof(szga));

   switch (nservice)
   {
      case 0x0420: // tunneling request
         ioffset = 4;
         pszType = "tunnel";
         // and fall through
      case 0x0530: // routing indication
      {
         uchar *pCemi   = pData + 6 + ioffset;
         if (!pszType)
             pszType    = "route";

         uchar  nmc     = pCemi[0];
         uchar  naddil  = pCemi[1];

         uchar  nctl1   = pCemi[2];
         uchar  nctl2   = pCemi[3];

         uchar  nsrc1   = pCemi[4];
         uchar  nsrc2   = pCemi[5];

         uchar  ndest1  = pCemi[6];
         uchar  ndest2  = pCemi[7];

         uchar  b5      = pCemi[8];
         uchar  b6      = pCemi[9];
         uchar  b7      = pCemi[10];

         uchar  nga2    = (ndest1 >> 0) & 0x07;
         uchar  nga1    = (ndest1 >> 3) & 0x1F; // sfk1822 i/o 0x0F
         uchar  nga3    = (ndest2 >> 0) & 0xFF;
         uchar  nlen    = b5; // V1732: use full length, not "& 0x0F"
         uchar  ndata6  = b7 & 0x3F;
         uchar  ndata0  = pCemi[11];
         uchar  ndata1  = pCemi[12];
 
         // uchar  dsttype = (b5 >> 7) & 0x01; // destination type
         // uchar  rcount  = (b5 >> 6) & 0x07; // routing count
 
         uchar  tcpi    = (b6 >> 6) & 0x03;
         uchar  ncount  = (b6 >> 2) & 0x0F;
         uchar  acpitype=(((b6 >> 0) & 0x03) << 2)
                         |((b7 >> 6) & 0x03);
         uchar  acpidata= (b7 >> 0) & 0x3F;

         // 15/1/123
         snprintf(szga, sizeof(szga)-1, "%u/%u/%u", nga1,nga2,nga3);
         while (strlen(szga) < 8)
            strcat(szga, " ");

         if (nlen == 1)
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s bit(s): %X\n", pszType, szga, ndata6);
         else
         if (nlen == 2)
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s byte  : %03u (0x%02X)\n", pszType, szga, ndata0, ndata0);
         else
         if (nlen == 3) {
            uint nraw = (((uint)ndata0) << 8) | ndata1;
            uchar b1 = ndata0;
            uchar b2 = ndata1;
            ushort mantisse =  b1 & 0x07;
            ushort exponent = (b1 & 0x78) >> 3;
            ushort isign    = (b1 & 0x80) >> 7;
            ushort result16 = 0;
            if (isign)
               mantisse = 0xF8 | mantisse;
            mantisse <<= 8;
            mantisse |= b2;
            result16  = mantisse * (1 << exponent);
            int result = (int)result16;
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s 16bit : 0x%02X%02X val=%d (%d.%02d)\n",
               pszType, szga, ndata0, ndata1, result, result/100, result%100);
         }
         /*
         else
         if (nlen == 14 || nlen == 15)
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s text%u: \"%.*s\"\n", pszType, szga, nlen, (int)nlen, (char*)pCemi+11);
         else
         if (nlen >= 14 || iSize >= 32)
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s vartxt: \"%s\"\n", pszType, szga, dataAsTrace((char*)pCemi+11, iSize-17));
         */
         else
         if (iSize >= 17)
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s data%02u: \"%s\"\n", pszType, szga, nlen, dataAsTrace((char*)pCemi+11, iSize-17));
         else
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s data%02u: %03u (0x%02X) total=%d\n", pszType, szga, nlen, ndata0, ndata0, iSize);

         if (cs.knx != 2)
         {
            mystrcatf(pBuf,iMaxBuf, " KNX: nmc=%X addil=%X ctl1=%02X ctl2=%02X src1/2=%02X%02X dest1/2=%02X%02X\n",
               nmc, naddil, nctl1, nctl2, nsrc1,nsrc2, ndest1,ndest2);
            mystrcatf(pBuf,iMaxBuf, " KNX: tcpi=%u ncnt=%u acpitype=%u acpidata=%u\n",
               tcpi, ncount, acpitype, acpidata);
         }

         break;
      }

      case 0x0201:
         mystrcatf(pBuf,iMaxBuf, " KNX: search request\n");
         break;

      case 0x0202:
      {
         mystrcatf(pBuf,iMaxBuf, " KNX: search response\n");
         if (cs.verbose) {
            uchar *psrccur = pData;
            uchar *psrcmax = psrccur + iSize;
            char  *pdstcur = pBuf + strlen(pBuf);
            char  *pdstmax = pdstcur + iMaxBuf;
            while (psrccur<psrcmax && pdstcur+80<pdstmax)
            {
               memset(pdstcur, ' ', 80);
               pdstcur += 2;
               for (int i=0; i<22; i++) {
                  uchar uc = 0;
                  if (psrccur+i>=psrcmax)
                     break;
                  sprintf(pdstcur+(i*2), "%02X", psrccur[i]);
                  pdstcur[i*2+2] = ' ';
                  char c = (char)psrccur[i];
                  pdstcur[44+2+i] = isprint(c) ? c : '.';
               }
               psrccur += 22;
               pdstcur += 44+2+22;
               *pdstcur++ = '\n';
            }
            *pdstcur = '\0';
         }
         break;
      }

      default:
         mystrcatf(pBuf,iMaxBuf, " KNX: service %04X\n", nservice);
         break;
   }
}

bool validFromIPMask(char *pszmask)
{
   char *psz=pszmask;
   for (;*psz;psz++) {
      if (isdigit(*psz)) continue;
      if (*psz=='.') continue;
      if (*psz==',') continue;
      if (*psz=='/') continue;
      if (*psz==' ') continue;
      pwarn("invalid \"%c\" in ip mask: %s\n",*psz,pszmask);
      return 0;
   }
   return 1;
}

bool matchesFromIPMask(char *pszip, char *pszmask)
{
   char szIP[100];
   char szPart[100];

   // 192.168.1.10 -> /192.168.1.10/
   snprintf(szIP,sizeof(szIP)-10,"/%s/",pszip);
   // allows mask like: .10/,.11/

   char *pszcur=pszmask;
   while (pszcur && *pszcur)
   {
      char *psznext=pszcur;
      while (*psznext!=0 && *psznext!=',' && *psznext!=' ') // sfk185
         psznext++;
      int ilen=psznext-pszcur;
      if (ilen>sizeof(szPart)-10)
         { perr("mask part too long: %s",pszcur); return 0; }

      memcpy(szPart,pszcur,ilen);
      szPart[ilen]='\0';

      if (strstr(szIP,szPart))
         return 1;

      pszcur=psznext;
      while (*pszcur==',' || *pszcur==' ') // sfk185
         pszcur++;
   }

   return 0;
}

// .
int udpAnyServ(uint nPort, char *pszForward, int nForward, char *pszGroup, bool bEcho,
   char *pszFromMask, char *pszNotFromMask, int iMinSize, int iMaxSize,
   uchar *pPat, int nPat, uint nFlags, SOCKET hRev)
{__
   char szTime[100];
   char szKNX[512];

   // optional -tofile support
   FILE *fout = stdout;
   bool btofile = 0;
   if (cs.tomask && cs.tomaskfile) {
      // if (nGlblHexDumpForm != 4)
      //   return 9+perr("-tofile requires -flat output option\n");
      if (!(fout = fopen(cs.tomask, "wb")))
         return 9+perr("cannot write: %s\n", cs.tomaskfile);
      btofile = 1;
   }

   prepareTCP();

   struct sockaddr_in oOwnAddr; mclear(oOwnAddr);
   struct sockaddr_in FrontAdr; mclear(FrontAdr);
   oOwnAddr.sin_family      = AF_INET;
   oOwnAddr.sin_addr.s_addr = htonl(INADDR_ANY);
   oOwnAddr.sin_port        = htons(nPort);

   SOCKET nsock = socket(AF_INET, SOCK_DGRAM, 0);

   int nOnVal = 1;
   setsockopt(nsock, SOL_SOCKET, SO_REUSEADDR, (const char *)&nOnVal, sizeof(nOnVal));

   bool bBroadcast = (nFlags & 4) != 0 ? 1 : 0;
   if (bBroadcast) {
      int ibroadcast = 1;
      setsockopt(nsock, SOL_SOCKET, SO_BROADCAST, (const char*)&ibroadcast, sizeof(ibroadcast));
      if (pszGroup) {
         pinf("group address is ignored with broadcast: %s\n", pszGroup);
         pszGroup = 0;
      }
   }

   int iPackets = 0;

   // when passing on chain data to another command,
   // do this by default on every single received package.
   if (chain.coldata && !cs.stopcnt)
      cs.stopcnt = 1;

   // for multicast
   struct ip_mreq mreq;
   memset(&mreq, 0, sizeof(mreq));
   mreq.imr_interface.s_addr = htonl(INADDR_ANY);
   bool bCleanupMCast = 0;

   // show just a single line info w/o dump?
   bool bOneLine = (cs.knx == 2) ? 1 : 0;

   char szExtInfo[100]; szExtInfo[0] = '\0';

   do
   {
      if (bind(nsock, (struct sockaddr *)&oOwnAddr, sizeof(oOwnAddr)) != 0)
      {
         perr("cannot bind UDP socket to port %d (%d %s).\n", nPort, netErrno(), netErrStr());
         break;
      }

      if (pszGroup)
      {
         // multicast receive
 
         #if defined(MAC_OS_X) || defined(SOLARIS)
            #define SOL_IP IPPROTO_IP
         #endif
 
         #ifdef _WIN32
 
         char name[512];
         PHOSTENT hostinfo;
         mclear(name);
         mclear(hostinfo);

         if (gethostname(name, sizeof(name)))
            { perr("gethostname failed\n"); break; }
 
         if (!(hostinfo=gethostbyname(name)))
            { perr("get ownhost failed (%s) (1)\n", name); break; }

         int iRC = 0;
         int ndone = 0;
         for (int i=0; hostinfo->h_addr_list[i]; i++) // sfk1962 mcast receive
         {
            struct in_addr *pin_addr = (struct in_addr *)hostinfo->h_addr_list[i];
   
            mreq.imr_interface.s_addr = pin_addr->s_addr;
            mreq.imr_multiaddr.s_addr = inet_addr(pszGroup);
    
            // force IP_ADD_MEMBERSHIP of ws2tcpip.h
            #define MY_IP_ADD_MEMBERSHIP 12
   
            if (iRC = setsockopt(nsock, IPPROTO_IP, MY_IP_ADD_MEMBERSHIP, (char *)&mreq, sizeof(mreq))) {
               perr("cannot join multicast: rc=%d %s", iRC, netErrStr());
               perr("host=%s sock=%d group=%s",name,nsock,pszGroup);
               break;
               // in case of error 10042 see
               //    http://support.microsoft.com/kb/257460
               // wrong winsock header, runtime linkage etc.
            }
            ndone++;
         }
         if (iRC) break;
         if (ndone > 1)
            sprintf(szExtInfo, ", on %d interfaces", ndone);
 
         #else
 
         if (inet_aton(pszGroup, &mreq.imr_multiaddr) == 0)
            { perr("bad address: %s", pszGroup); break; }
 
         if (setsockopt(nsock, SOL_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) != 0 ) {
            perr("no default route to support multicast.");
            perr("try 'route add -net 224.000 netmask 240.000 eth0'");
            break;
         }
 
         #endif

         bCleanupMCast = 1;
      }

      listen(nsock, 10);

      if (!cs.quiet) {
         if (pszGroup)
            printf("[waiting on %s port %d for data%s.]\n", pszGroup, nPort, szExtInfo);
         else
            printf("[waiting on port %d for data.]\n", nPort);
      }

      struct timeval tv;
      fd_set fdvar;

      uchar *pHit=0;
      int    iHit=0,nHit=0;

      while (!userInterrupt())
      {
         tv.tv_sec  = 0;
         tv.tv_usec = 0;
 
         FD_ZERO(&fdvar);
         FD_SET(nsock, &fdvar);
 
         if (select(nsock+1, &fdvar, 0, 0, &tv) > 0)
         {
            struct sockaddr_in inAddr;

            socklen_t nadrlen = sizeof(inAddr);

            int nRead = recvfrom(nsock, (char*)abBuf, sizeof(abBuf)-100, 0, (struct sockaddr *)&inAddr, &nadrlen);

            // nsock is also used to send forwards, and gets ECONNRESET
            // if forward sending fails.
            if (nRead == SOCKET_ERROR) {
               if (!cs.quiet)
                  printf("[socket error %d: %s]\n", netErrno(), netErrStr());
               continue;
            }

            struct in_addr addr;
            memcpy(&addr,&inAddr.sin_addr,sizeof(struct in_addr));
            char *premip = inet_ntoa(addr);
            uint  uremport = ntohs(inAddr.sin_port);

            // apply ip filter?
            if (pszFromMask && !matchesFromIPMask(premip, pszFromMask))
               continue;
            if (pszNotFromMask && matchesFromIPMask(premip, pszNotFromMask))
               continue;
            if (iMinSize != -1 && nRead < iMinSize)
               continue;
            if (iMaxSize != -1 && nRead > iMaxSize)
               continue;

            iHit=-1; nHit=0;
            if (nPat > 0) {
               if ((pHit = memFind(pPat, nPat, abBuf, nRead))) {
                  iHit = pHit - abBuf;
                  nHit = nPat;
               } else {
                  if (!(nFlags & 1))
                     continue;
               }
            }

            if (cs.knx) {
               dumpKnxInfo(abBuf,nRead,szKNX,sizeof(szKNX));
               int ioff=0,ilen=0;
               if (cs.knxtext && !matchstr(szKNX, cs.knxtext, 0, ioff, ilen))
                  continue;
            }

            iPackets++;

            if (cs.separator && !bOneLine)
            {
               mytime_t nTime = (mytime_t)time(NULL);
               struct tm *pLocTime = mylocaltime(&nTime);      // may be NULL
               szTime[0] = '\0';
               if (pLocTime)
                  strftime(szTime, sizeof(szTime)-10, "%d.%m.%Y %H:%M:%S", pLocTime);
               fprintf(fout, "%s----- #%03d from %s at %s (%d bytes) -----\n",
                  cs.nolf ? "":"\n", iPackets, premip, szTime, nRead);
            }

            if (cs.knx) {
               if (bOneLine) {
                  if (btofile)
                     fprintf(fout, "%-15.15s%s", premip, szKNX);
                  else
                     printx("$%-15.15s<def>%s", premip, szKNX);
               } else {
                  fprintf(fout, "%s", szKNX);
               }
            }

            if (btofile && !cs.nohead && !cs.quiet) {
               // optical feedback although writing to file
               printf("[#%03d received %03d bytes from %s port %u]   \r",iPackets,nRead,premip,uremport);
               fflush(stdout);
            }
            if (btofile!=0 && nGlblHexDumpForm==4)
               { } // -tofile -flat : no received info
            else
            if (!cs.nohead && !cs.quiet && !cs.separator)
               fprintf(fout, "[#%03d received %03d bytes from %s port %u]\n",iPackets,nRead,premip,uremport);

            if (!bOneLine && !cs.nodump) {
               if (btofile!=0 && nGlblHexDumpForm==4 && cs.separator==0) // flat w/o separators
                  fwrite(abBuf, 1, nRead, fout);
               else
                  execHexdump(0, abBuf, cs.maxdump?mymin(cs.maxdump,nRead):nRead, iHit, nHit, btofile ? fout : 0);
            }
 
            if (!chain.coldata)
               fflush(stdout);

            if (bEcho)
            {
               if (!cs.nohead && !cs.quiet)
                  printf("[echoing back]\n");
               sendto(nsock, (char*)abBuf, nRead, 0, (struct sockaddr*)&inAddr, nadrlen);
            }

            if (pszForward !=0 || hRev != INVALID_SOCKET)
            {
               // prefix data by sender ip, port,
               // but only if not prefixed already.
               uchar *pData = abBuf;
               int    nData = nRead;
               uint   nSrcAddr = 0;
               uint   nSrcPort = 0;
               uint  nFromAddr = htonl(inAddr.sin_addr.s_addr);
               uint  nFromPort = htons(inAddr.sin_port);

               // SFK{0}FW4{6}{ip4be}{port}data
               // 0           8      12    14

               // read prefix if present
               if (   cs.prefix > 0 && nData >= 14
                   && memcmp(pData, "SFK\0FW4", 7) == 0
                  )
               {
                  uint nHeader = pData[7];
                  if (nHeader >= 6)
                  {
                     nSrcAddr =     (((uint)pData[8])  << 24)
                                 |  (((uint)pData[9])  << 16)
                                 |  (((uint)pData[10]) <<  8)
                                 |  (((uint)pData[11]) <<  0);
                     nSrcPort =     (((uint)pData[12]) <<  8)
                                 |  (((uint)pData[13]) <<  0);
                  }

                  if (cs.prefix == 2)
                  {
                     // drop prefix
                     uint  nhead = 8+nHeader;
                     uchar *psrc = pData+nhead;
                     uchar *pmax = pData+nRead;
                     uchar *pdst = pData;
                     uint  ncopy = nRead-nhead;
                     if (psrc+ncopy <= pmax)
                     {
                        memmove(pdst,psrc,ncopy);
                        nRead -= nhead;
                        nData -= nhead;
                     }
                  }
               }

               // add prefix if not present
               if (   cs.prefix == 1 && nData < MAX_LINE_LEN-100
                   && memcmp(pData, "SFK\0FW4", 7) != 0
                  )
               {
                  uint nPrefixPort = nFromPort;
                  if (nFlags & 2)
                       nPrefixPort = nPort;

                  int nPrefix = 10;
                  uchar *pExt = (uchar *)szLineBuf;
                  memcpy(pExt, "SFK\0FW4", 7);
                  pExt[7] = 6;
                  pExt[8]  = (nFromAddr >> 24);
                  pExt[9]  = (nFromAddr >> 16);
                  pExt[10] = (nFromAddr >>  8);
                  pExt[11] = (nFromAddr >>  0);
                  pExt[12] = (nPrefixPort >>  8);
                  pExt[13] = (nPrefixPort >>  0);
                  memcpy(pExt+14, pData, nData);
                  pData = pExt;
                  nData = nData + 14;
               }

               if (hRev != INVALID_SOCKET)
               {
                  // forward message to tcp reverse proxy
                  uchar ablen[2];
                  ablen[0] = (uchar)(nData >> 8);
                  ablen[1] = (uchar)(nData >> 0);
                  if (send(hRev, (char*)ablen, 2, 0) != 2)
                     pinf("failed to send length record\n");
                  int isubrc = send(hRev, (char*)pData, nData, 0);
                  if (isubrc < nData) {
                     pinf("failed to send backward message\n");
                     // printf("Backend connection lost (%d/%d)\n", isubrc, nData);
                     break;
                  }
                  continue;
               }

               if (nForward == 0)
               do
               {
                  // forward to list file
                  static char *pszList = 0;
                  static num  nRecentFileTime = 0, nRecentFileSize = 0;
                  // (re)load list?
                  int bIsDir=0,bCanRead=0,bCanWrite=0;
                  num nFileTime=0,nFileSize=0;
                  if (getFileStat(pszForward, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize)) {
                     // temporarily not available, e.g. during edit
                     pwarn("cannot read forward file, skipping: %s\n", pszForward);
                     break;
                  }
                  if (pszList == 0 || nFileTime != nRecentFileTime && nFileSize != nRecentFileSize) {
                     if (pszList)
                        delete [] pszList;
                     pszList = loadFile(pszForward, 0);
                     if (!pszList) {
                        nRecentFileTime = 0;
                        nRecentFileSize = 0;
                        pwarn("cannot load forward file, skipping: %s\n", pszForward);
                        break;
                     }
                     nRecentFileTime = nFileTime;
                     nRecentFileSize = nFileSize;
                     if (cs.quiet<2)
                        printf("(re)loaded forward file: %s\n", pszForward);
                  }
                  // apply current loaded list: host1:port1\nhost2:port2\n...
                  char *psz = pszList;
                  while (psz && *psz)
                  {
                     // get next host:port or # line
                     char *psz2 = strchr(psz, '\n');
                     if (psz2)
                        psz2++;
                     else
                        psz2 = psz + strlen(psz);
                     // prepare for parse
                     int ilen=psz2-psz;
                     if (ilen > MAX_LINE_LEN)
                        return 9+perr("line too long in forward file: %.100s\n", psz);
                     memcpy(szLineBuf2, psz, ilen);
                     szLineBuf2[ilen] = '\0';
                     // remark or empty line?
                     if (strlen(szLineBuf2) < 3 || szLineBuf2[0]=='#' || !strncmp(szLineBuf2, "// ", 3)) {
                        psz=psz2;
                        continue;
                     }
                     // isolate host,port
                     char *pszPort=strchr(szLineBuf2,':');
                     if (!pszPort)
                        return 9+perr("missing :port : %s\n", szLineBuf2);
                     *pszPort++ = '\0';
                     int iFWPort = atoi(pszPort);
                     if (!iFWPort)
                        return 9+perr("invalid :port : %s\n", szLineBuf2);
                     // send
                     FrontAdr.sin_family = AF_INET;
                     FrontAdr.sin_port = htons((unsigned short)iFWPort);
                     if (!setaddr(&FrontAdr, szLineBuf2, 1)) {
                        if (cs.verbose)
                           printf("[forwarding to %s:%d]\n", szLineBuf2, iFWPort);
                        sendto(nsock, (char*)pData, nData, 0, (struct sockaddr*)&FrontAdr, sizeof(FrontAdr));
                     } else {
                        pwarn("cannot forward to %s, net error %d\n", szLineBuf2, netErrno());
                     }
                     // continue
                     psz = psz2; // or null
                  }
               }
               while (0);
 
               if (nForward != 0)
               {
                  // forward message to single host, port
                  FrontAdr.sin_family = AF_INET;
                  FrontAdr.sin_port = htons((unsigned short)nForward);

                  static int iResolveStatus = 0;
                  if (iResolveStatus == 0) {
                     if (setaddr(&FrontAdr,pszForward,1)) {
                        iResolveStatus = 2;
                        return 9+perr("cannot get forward host: %s\n", pszForward);
                     }
                     iResolveStatus = 1;
                  }
                  if (iResolveStatus == 2)
                     return 9+perr("cannot get forward host: %s\n", pszForward);

                  if (nSrcAddr == ntohl(FrontAdr.sin_addr.s_addr) && nSrcPort == nForward) {
                     if (cs.verbose>=2)
                        printf("[filtering looped message (1) %x:%u %x:%u]\n", nSrcAddr, nSrcPort, ntohl(FrontAdr.sin_addr.s_addr), nForward);
                  }
                  else
                  if (nFromAddr == ntohl(FrontAdr.sin_addr.s_addr) && nFromPort == nForward) {
                     if (cs.verbose>=2)
                        printf("[filtering looped message (2) %x:%u %x:%u]\n", nFromAddr, nFromPort, ntohl(FrontAdr.sin_addr.s_addr), nForward);
                  } else {
                     if (cs.verbose)
                        printf("[forwarding to %s:%d]\n", pszForward, nForward);
                     // printf("src=%x:%u from=%x:%u to=%x:%u\n",nSrcAddr,nSrcPort,nFromAddr,nFromPort,ntohl(FrontAdr.sin_addr.s_addr),nForward);
                     sendto(nsock, (char*)pData, nData, 0, (struct sockaddr*)&FrontAdr, sizeof(FrontAdr));
                  }
               }
            }

            if (cs.stopcnt > 0 && iPackets >= cs.stopcnt)
               break;

            if (btofile)
               fflush(fout);
         }
         else
         {
            doSleep(1);
         }
      }

      if (bCleanupMCast)
      {
         #ifdef _WIN32
 
         // force IP_DROP_MEMBERSHIP of ws2tcpip.h
         #define MY_IP_DROP_MEMBERSHIP 13

         int iRC = 0;
         if (iRC = setsockopt(nsock, IPPROTO_IP, MY_IP_DROP_MEMBERSHIP, (char *)&mreq, sizeof(mreq)))
            perr("cannot drop multicast membership: rc=%d %s", iRC, netErrStr());
 
         #else
 
         if (setsockopt(nsock, SOL_IP, IP_DROP_MEMBERSHIP, &mreq, sizeof(mreq)) != 0)
            perr("cannot drop multicast membership.");
 
         #endif
      }

      closesocket(nsock);
   }
   while (0);

   return 0;
}

int udpRevServ(uint nServerPort, uint nPort, char *pszGroup,
   char *pszFromMask, char *pszNotFromMask, int iMinSize, int iMaxSize,
   uchar *pPat, int nPat, uint nFlags)
{
   prepareTCP();

   struct sockaddr_in ServerAdr;
   struct sockaddr_in ClientAdr;
   socklen_t nSoLen = sizeof(sockaddr_in);
   SOCKET hServer   = INVALID_SOCKET;
   SOCKET hBack     = INVALID_SOCKET;
   if (makeServerSocket(nServerPort, ServerAdr, hServer, "server main port")) return 9;

   if (pszGroup)
      printf("waiting for client on %u to forward %s:%u\n", nServerPort, pszGroup, nPort);
   else
      printf("waiting for client on %u to forward port %u\n", nServerPort, nPort);

   cs.prefix = 1;

   int lRC = 0;
   while (!userInterrupt())
   {
      hBack = accept(hServer, (struct sockaddr *)&ClientAdr, &nSoLen);
      if (hBack == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(50); continue; }
         perr("accept on server main port failed\n");
         lRC = 9;
         break;
      }

      struct in_addr addr;
      memcpy(&addr,&ClientAdr.sin_addr,sizeof(struct in_addr));
      char *premip = inet_ntoa(addr);
      num nnow = time(0);

      printf("client connected on %s %s\n", premip ? premip : "-", timeAsString(nnow,0));

      udpAnyServ(nPort, 0, 0,
         pszGroup, 0, pszFromMask, pszNotFromMask, 
         iMinSize, iMaxSize, pPat, nPat, nFlags,
         hBack);

      printf("client disconnected.\n");
      closesocket(hBack);
   }

   closesocket(hServer);

   return lRC;
}

void dumpNTPInfo(uchar *pData, int iSize, char *pszIP)
{
   if (iSize < 48) return;

   /*
      uint rootDelay          00
      uint rootDispersion     04
      uint refIdentifier      08
      uint refTimeFrac        12
      uint refTimeSec         16
      uint origTimeFrac       20
      uint origTimeSec        24
      uint recvTimeFrac       28
      uint recvTimeSec        32
      uint trxTimeFrac        36
      uint trxTimeSec         40
      uint keyIdentifier      44
   */
   ulong ntime1 =
         ((ulong)pData[40] << 24)
      |  ((ulong)pData[41] << 16)
      |  ((ulong)pData[42] <<  8)
      |  ((ulong)pData[43] <<  0);

   ntime1 -= 2208988800UL;

   mytime_t nTime2 = (mytime_t)ntime1;

   struct tm *pLocTime = mylocaltime(&nTime2);    // may be NULL

   strftime(szLineBuf , MAX_LINE_LEN, "%Y%m%d%H%M%S", pLocTime);
   strftime(szLineBuf2, MAX_LINE_LEN, "%d.%m.%Y %H:%M:%S", pLocTime);

   chain.print("%sNTP-time %s %s from %s\n", cs.quiet ? "":" ", szLineBuf, szLineBuf2, pszIP);
}

int udpSend(char *phost, int ndstport,
   int nlisten, int nownport,
   uchar *abMsg, int nMsg,
   num nTimeout, uint nMode
 )
{__
   UDPIO sfkNetIO; // fix sfk183 send to multiple targets

   bool bQuiet  = (nMode & 1) ? 1 : 0;
   bool bTextIO = (nMode & 2) ? 1 : 0;
   bool bBroadcast = (nMode & 4) ? 1 : 0;

   prepareTCP();

   uint uiFlags = 0;
 
   if (cs.multicast) uiFlags |= 1;
   if (bBroadcast)   uiFlags |= 8;

   int isubrc = 0;

   if (!sfkNetIO.isOpen())
   {
      isubrc = sfkNetIO.initSendReceive("udpsend", nownport, ndstport, phost, uiFlags);
 
      if (isubrc)
         return isubrc;
   }
 
   if (bTextIO) {
      isubrc = sfkNetIO.addOrSendText((char*)abMsg, nMsg, 0);
      if (nlisten > 0)
         isubrc |= sfkNetIO.flushSend(0);
   } else {
      isubrc = sfkNetIO.sendData(abMsg, nMsg);
   }
 
   if (isubrc)
      return isubrc+perr("failed to send data (%d)", isubrc);

   if (!bQuiet && !cs.nohead && !cs.quiet)
   {
      char szFullIP[200];
      szFullIP[0] = '\0';
      int ierr = netErrno();
      if (sfkNetIO.bClIPWasExpanded || cs.showip)
         ipAsString(&sfkNetIO.clTargetAddr, szFullIP, sizeof(szFullIP)-10, 0);
      chain.print("[sent %d bytes to %s:%d%s%s]\n", nMsg, 
         szFullIP[0] ? szFullIP : phost, ndstport,
         ierr ? ", ":"", ierr ? netErrStr():"");
   }

   if (!bQuiet && !cs.quiet)
      execHexdump(0, abMsg, nMsg);

   // receive and dump replies

   if (nlisten > 0)
   {
      uchar abBuffer[2000+100];

      struct sockaddr_in inAddr;

      socklen_t clilen = sizeof(inAddr);

      num nstart = getCurrentTime();

      for (int ndone=0; ndone<nlisten;)
      {
         if (sfkNetIO.isDataAvailable())
         do
         {
            memset(abBuffer, 0, sizeof(abBuffer));

            int iBytes = sfkNetIO.receiveData(abBuffer, sizeof(abBuffer), &inAddr, clilen);
 
            if (iBytes < 0)
               break; // no data, wait

            struct in_addr addr;
            memcpy(&addr,&inAddr.sin_addr,sizeof(struct in_addr));
            char *premip = inet_ntoa(addr);
 
            if (!cs.nohead && !cs.quiet)
              chain.print("[received %d bytes from %s %s]\n", iBytes, premip, netErrStr());
 
            if (cs.ntp && cs.quiet)
               { }
            else
               execHexdump(0, abBuffer, iBytes);
 
            if (cs.ntp)
               dumpNTPInfo(abBuffer, iBytes, premip);

            ndone++;
            continue;
         }
         while (0);

         num nelaps = getCurrentTime() - nstart;

         if (nTimeout > 0 && nelaps >= nTimeout)
         {
            chain.print("[timeout]\n");
            break;
         }

         doSleep(10);
      }
   }

   return 0;
}

int tcpClient(char *phost, int ndstport, int nlisten, int nownport, uchar *abMsg, int nMsg, num nTimeout)
{__
   prepareTCP();

   int nsocket = socket(AF_INET, SOCK_STREAM, 0);

   struct sockaddr_in oTargetAddr;
   memset((char *)&oTargetAddr, 0,sizeof(oTargetAddr));

   // send data to target server
   oTargetAddr.sin_family      = AF_INET;
   oTargetAddr.sin_port        = htons((int)ndstport);
   if (setaddr(&oTargetAddr,phost))
      return 9;

   if ((connect(nsocket, (struct sockaddr *)&oTargetAddr, sizeof(oTargetAddr))) == -1) {
      perr("cannot connect to %s:%u, %s\n", phost, ndstport, netErrStr());
      return 9;
   }

   int n = 0;

   if (nMsg > 0)
      n = send(nsocket, (char*)abMsg, nMsg, 0);

   if (!cs.quiet && nMsg) {
      // execHexdump(0, abMsg, nMsg);
      printf("< %s\n", dataAsTrace(abMsg, nMsg));
   }

   // receive and dump replies

   if (nTimeout > 0) {
      setBlocking(nsocket, 0);  // sfk1972
      nlisten = 1;
   }

   num nstart = getCurrentTime();

   // if (nlisten)
   do
   {
      int nRead = recv(nsocket, (char*)abBuf, sizeof(abBuf)-10, 0);

      int iElapsed = (int)(getCurrentTime() - nstart);

      if (nTimeout > 0 && nRead <= 0 && iElapsed < (int)nTimeout) {
         doSleep(50);
         continue;
      }

      if (nRead <= 0)
         break;

      abBuf[nRead] = '\0';

      if (nGlblHexDumpForm == 4 && memchr(abBuf, '\0', nRead)) {
         // pure form: dump start of binary, but not all
         int nHexLimit = 1000;
         if (nRead > nHexLimit) {
            if (!cs.nohead && !cs.quiet)
               printf("[received reply with binary, %d bytes. dumping first %d:]\n", nRead, nHexLimit);
            int nCurForm = nGlblHexDumpForm;
            nGlblHexDumpForm = 0;
            execHexdump(0, abBuf, nHexLimit);
            nGlblHexDumpForm = nCurForm;
         } else {
            if (!cs.nohead && !cs.quiet)
               printf("[received reply with binary, %d bytes:]\n", nRead);
            execHexdump(0, abBuf, nRead);
         }
      } else {
         // if (!cs.nohead && !cs.quiet)
         //    printf("[received reply, %d bytes:]\n", nRead);
         // execHexdump(0, abBuf, nRead);
         if (nRead>0 && abBuf[nRead-1]=='\n')
            printf("%s", (char*)abBuf);
         else
            printf("%s\n", (char*)abBuf);
      }
   }
   while (nlisten);
 
   closesocket(nsocket);

   return 0;
}

int tcpAnyServ(uint nPort, char *pszForward, int nForward)
{__
   prepareTCP();

   struct sockaddr_in ServerAdr;
   struct sockaddr_in ClientAdr;
   struct sockaddr_in FrontAdr;
   socklen_t nSoLen = sizeof(sockaddr_in);
   SOCKET hServer   = INVALID_SOCKET;
   SOCKET hBack     = INVALID_SOCKET;
   SOCKET hFront    = INVALID_SOCKET;
   if (makeServerSocket(nPort, ServerAdr, hServer, "server main port")) return 9;

   printf("waiting on port %u for connections", nPort);
   if (pszForward) printf(", to forward to %s:%d", pszForward, nForward);
   if (cs.timeOutAutoSelect)
      printf(".\n");
   else
      printf(". timeout is %d milliseconds.\n", cs.timeOutMSec);

   // http autodetect:
   bool bFirstReq = 1;
   bool bHttp     = 0;

   int lRC = 0;
   while (!userInterrupt())
   {
      hBack = accept(hServer, (struct sockaddr *)&ClientAdr, &nSoLen);
      if (hBack == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(50); continue; }
         perr("accept on server main port failed\n");
         lRC = 9;
         break;
      }
      setBlocking(hBack, 0);

      // forward-connect
      if (pszForward) {
         if (!cs.quiet) {
            printf("[got connection, trying forward-connect]\r");
            fflush(stdout);
         }
         hFront = socket(AF_INET, SOCK_STREAM, 0);
         if (hFront == INVALID_SOCKET) return 9+perr("cannot create forward socket\n");

         FrontAdr.sin_family = AF_INET;
         FrontAdr.sin_port = htons((unsigned short)nForward);
         if (setaddr(&FrontAdr,pszForward))
            return 9;

         if ((connect(hFront, (struct sockaddr *)&FrontAdr, sizeof(FrontAdr))) == -1) {
            perr("cannot connect to %s:%u, %s\n", pszForward, nForward, netErrStr());
            return 9;
         }
         printf("[forward-connected to %s:%d]       \n",pszForward,nForward);
         setBlocking(hFront, 0);
      } else {
         printf("[got connection]\n");
      }

      num nLastTime = getCurrentTime();

      // outer loop: try to repeat data forwarding for 30 secs
      while (!userInterrupt())
      {
         // any data from back?
         int nRead = recv(hBack, (char*)abBuf, sizeof(abBuf)-10, 0);
         // NOTE: non-blocking receives may return -1 inbetween,
         //       but the connection stays open.
         if (nRead > 0)
         {
            // autodetect http protocol on first request
            abBuf[nRead] = '\0';
            if (bFirstReq) {
               bFirstReq = 0;
               // isolate first line of first request
               char *psz = strchr((char*)abBuf, '\n');
               if (psz) {
                  int nlen = psz-(char*)abBuf;
                  memcpy(szLineBuf, abBuf, nlen);
                  szLineBuf[nlen] = '\0';
                  if (   (!strncmp(szLineBuf, "GET ", 4) || !strncmp(szLineBuf, "POST ", 5))
                      && (strstr(szLineBuf, "HTTP") != 0)
                     )
                  {
                     bHttp = 1;
                     if (cs.timeOutAutoSelect)
                         cs.timeOutMSec = 10000;
                  }
               }
            }
            if (nGlblHexDumpForm == 4 && memchr(abBuf, '\0', nRead)) {
               // pure form: skip binary record
               printf("[received request from back: binary, %d bytes]\n",nRead);
            } else {
               printf("[received request from back with %d bytes:]\n",nRead);
               execHexdump(0, abBuf, cs.maxdump?mymin(cs.maxdump,nRead):nRead);
            }
            nLastTime = getCurrentTime();
            // forward to front
            if (pszForward) {
               int nSend = send(hFront, (char*)abBuf, nRead, 0);
               // ignore no. of actually sent bytes
               if (nSend == nRead)
                  printf("[forwarded %d bytes]\n", nSend);
               else
                  pwarn("[forwarded %d bytes of %d - incomplete]\n", nSend, nRead);
            }
         }

         // any data from front?
         if (pszForward)
         {
            int nRead = recv(hFront, (char*)abBuf, sizeof(abBuf)-10, 0);
            if (nRead > 0) {
               if (nGlblHexDumpForm == 4 && memchr(abBuf, '\0', nRead)) {
                  // pure form: dump start of binary, but not all
                  int nHexLimit = 1000;
                  if (nRead > nHexLimit) {
                     printf("[received reply from front with binary, %d bytes. dumping first %d:]\n", nRead, nHexLimit);
                     int nCurForm = nGlblHexDumpForm;
                     nGlblHexDumpForm = 0;
                     execHexdump(0, abBuf, cs.maxdump?mymin(cs.maxdump,nHexLimit):nHexLimit);
                     nGlblHexDumpForm = nCurForm;
                  } else {
                     printf("[received reply from front with binary, %d bytes:]\n", nRead);
                     execHexdump(0, abBuf, cs.maxdump?mymin(cs.maxdump,nRead):nRead);
                  }
               } else {
                  printf("[received reply from front:]\n");
                  execHexdump(0, abBuf, cs.maxdump?mymin(cs.maxdump,nRead):nRead);
               }
               nLastTime = getCurrentTime();
               // backward reply
               int nSend = send(hBack, (char*)abBuf, nRead, 0);
               if (nSend == nRead)
                  printf("[backwarded %d bytes]\n", nSend);
               else
                  pwarn("[backwarded %d bytes of %d - incomplete]\n", nSend, nRead);
            }
         }

         // no data at all over timeout?
         if (getCurrentTime() > nLastTime + cs.timeOutMSec) {
            printf("[timeout, no data over %d msec]\n", cs.timeOutMSec);
            break;
         }

         {
            doSleep(500);
            cchar *pszCircle = ". ";
            static int nCircle = 0;
            num nElapse = getCurrentTime() - nLastTime;
            if (!cs.quiet) {
               printf("[%c waiting for input, %d/%d sec]\r",pszCircle[(nCircle++)%2],(int)(nElapse/1000),cs.timeOutMSec/1000);
               fflush(stdout);
            }
         }

      } // end outer loop

      if (pszForward) {
         printf("[closing forward connection]\n");
         closesocket(hFront);
      }

      printf("[client disconnected]\n");
      closesocket(hBack);
   }

   closesocket(hServer);

   #ifdef _WIN32
   // WSACleanup(); // sfk1840 only on process exit
   #endif

   return 0;
}

const char *glblMimeExt =
".aac audio/aac"
".avi video/x-msvideo"
".bmp image/bmp"
".bz application/x-bzip"
".bz2 application/x-bzip2"
".css text/css"
".csv text/csv"
".doc application/msword"
".gz application/gzip"
".gif image/gif"
".htm text/html"
".html text/html"
".ico image/x-icon"
".ics text/calendar"
".jar application/java-archive"
".jpeg image/jpeg"
".jpg image/jpeg"
".js application/json"
".json application/json"
".mjs text/javascript"
".mp3 audio/mpeg"
".mp4 video/mp4"
".mpeg video/mpeg"
".odp application/vnd.oasis.opendocument.presentation"
".ods application/vnd.oasis.opendocument.spreadsheet"
".odt application/vnd.oasis.opendocument.text"
".oga audio/ogg"
".ogv video/ogg"
".ogx application/ogg"
".otf font/otf"
".png image/png"
".pdf application/pdf"
".php application/x-httpd-php"
".ppt application/vnd.ms-powerpoint"
".pptx application/vnd.openxmlformats-officedocument.presentationml.presentation"
".rar application/vnd.rar"
".rtf application/rtf"
".sh application/x-sh"
".svg image/svg+xml"
".swf application/x-shockwave-flash"
".tar application/x-tar"
".tif image/tiff"
".tiff image/tiff"
".ts video/mp2t"
".ttf font/ttf"
".txt text/plain"
".wav audio/wav"
".xhtml application/xhtml+xml"
".xls application/vnd.ms-excel"
".xlsx application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
".xml application/xml"
".zip application/zip"
".3gp video/3gpp"
"." // eot
;

cchar *getMimeExt(cchar *pszFilename)
{
   char szLowerExt[SFK_MAX_PATH+10];
   static char szResult[200];

   cchar *pszExt = strrchr(pszFilename, '.');
   if (!pszExt) return 0;

   int i=0;
   for (i=0; pszExt[i]!=0 && i<SFK_MAX_PATH; i++)
      szLowerExt[i] = pszExt[i];
   szLowerExt[i] = 0;

   const char *psz = strstr(glblMimeExt, szLowerExt);
   if (!psz) return 0;

   while (*psz!=0 && *psz!=' ') psz++;
   while (*psz==' ') psz++;

   cchar *psz2 = strchr(psz, '.');
   if (!psz2) return 0;
   int ilen = psz2-psz;
   if (ilen+10 > sizeof(szResult)) return 0;

   memcpy(szResult, psz, ilen);
   szResult[ilen] = '\0';
   return szResult;
}

int changeLine(int nRead, cchar *pszPat, cchar *pszNew)
{
   bool bwithlf = (pszNew[0] ? 0 : 1);

   char *pszLine=mystrstri((char*)abBuf, pszPat);
   if (!pszLine) return 0;

   char *psz=pszLine;
   while (*psz!=0 && *psz!='\n') psz++;
   if (*psz!='\n') return 0;

   if (bwithlf)
      psz++;

   int isrclen=psz-pszLine;
   int idstlen=(int)strlen(pszNew);
   int idelta=idstlen-isrclen;
   int itailpos=psz-(char*)abBuf;
   int itaillen=nRead-itailpos;

   // Connection: keep
   // Connection: close
   memmove(pszLine+idstlen, pszLine+isrclen, itaillen+1);

   memcpy(pszLine, pszNew, idstlen);

   return idelta;
}

int execHttpLog(uint nPort, char *pszForward, int nForward)
{__
   prepareTCP();

   struct sockaddr_in ServerAdr;
   struct sockaddr_in ClientAdr;
   struct sockaddr_in FrontAdr;
   socklen_t nSoLen = sizeof(sockaddr_in);
   SOCKET hServer   = INVALID_SOCKET;
   SOCKET hBack     = INVALID_SOCKET;
   SOCKET hFront    = INVALID_SOCKET;
   if (makeServerSocket(nPort, ServerAdr, hServer, "server main port")) return 9;

   if (pszForward)
      printf("[waiting on port %d, forward to %s port %d]\n", nPort, pszForward, nForward);
   else
      printf("[waiting on port %d]\n", nPort);

   int lRC = 0;
   while (!userInterrupt())
   {
      hBack = accept(hServer, (struct sockaddr *)&ClientAdr, &nSoLen);
      if (hBack == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(50); continue; }
         perr("accept on server main port failed\n");
         lRC = 9;
         break;
      }
      setBlocking(hBack, 0);

      if (pszForward) 
      {
         hFront = socket(AF_INET, SOCK_STREAM, 0);
         if (hFront == INVALID_SOCKET) return 9+perr("cannot create forward socket\n");

         FrontAdr.sin_family = AF_INET;
         FrontAdr.sin_port = htons((unsigned short)nForward);
         if (setaddr(&FrontAdr,pszForward))
            return 9;

         if ((connect(hFront, (struct sockaddr *)&FrontAdr, sizeof(FrontAdr))) == -1) {
            perr("cannot connect to %s:%u, %s\n", pszForward, nForward, netErrStr());
            return 9;
         }
         setBlocking(hFront, 0);
      }

      num nLastTime = getCurrentTime();

      int iReplyBlock = 0;
      int iReplyBytes = 0;
      int iContentLength = 0;
      int iHeadLen = 0;
      int iRemain = 0;

      char *pbuf=(char*)abBuf;

      // outer loop: try to repeat data forwarding for 30 secs
      while (!userInterrupt())
      {
         // any data from back?
         int nRead = recv(hBack, (char*)abBuf, sizeof(abBuf)-10, 0);
         if (nRead > 0)
         {
            nLastTime = getCurrentTime();

            abBuf[nRead] = '\0';
            strcopy(szLineBuf, (char*)abBuf);

            char *pszCall = szLineBuf;
            if (strBegins(pszCall, "GET "))
               pszCall += 4;
            else if (strBegins(pszCall, "POST "))
               pszCall += 5;

            char *pszTail = strstr(szLineBuf, " HTTP/");
            if (pszTail) *pszTail = '\0';

            nRead += changeLine(nRead, "connection:", "Connection: close");
            nRead += changeLine(nRead, "Upgrade-Insecure-Requests:", "");
            nRead += changeLine(nRead, "Accept-Encoding:","");

            snprintf(szLineBuf2, MAX_LINE_LEN, "Host: %s",pszForward);
            nRead += changeLine(nRead, "Host:",szLineBuf2);

            if (cs.verbose)
               printf("%s\n", (char*)abBuf);
            else
               printf("%s\n", szLineBuf);

            if (pszForward) {
               int nSend = send(hFront, (char*)abBuf, nRead, 0);
               if (nSend < nRead && cs.verbose > 0)
                  pwarn("[forwarded %d bytes of %d - incomplete]\n", nSend, nRead);
            }
         }

         // any data from front?
         if (pszForward)
         {
            int nRead = recv(hFront, (char*)abBuf, sizeof(abBuf)-10, 0);
            // if (cs.verbose)
            //   printf("[%d recv %d]\n", nRead, netErrno());
            if (nRead > 0) {
               abBuf[nRead] = '\0';
               nLastTime = getCurrentTime();
               int nSend = send(hBack, (char*)abBuf, nRead, 0);
               if (nSend < nRead && cs.verbose > 0)
                  pwarn("[backwarded %d bytes of %d - incomplete]\n", nSend, nRead);
               if (iReplyBlock == 0) {
                  // parse reply header
                  char *psz = mystrstri((char*)abBuf, "content-length:");
                  if (psz) {
                     psz += strlen("content-length:");
                     while (*psz==' ') psz++;
                     iContentLength = atoi(psz);
                     iRemain = iContentLength;
                     printf("clen: %d\n",iContentLength);
                  }
                  psz = strstr((char*)abBuf, "\r\n\r\n");
                  if (psz) {
                     if (cs.verbose)
                        printf("---\n%.*s\n",psz-(char*)abBuf,(char*)abBuf);
                     psz += 4;
                     iHeadLen = (int)(psz-(char*)abBuf);
                     int iRest = nRead - iHeadLen;
                     iRemain -= iRest;
                  }
               } else {
                  iRemain -= nRead;
               }
               if (iContentLength > 0) {
                  printf("[%d/%d]   \r",iRemain,iContentLength);
                  fflush(stdout);
               }
            }
         }

         if (iContentLength > 0 && iRemain <= 0) {
            if (cs.verbose)
               printf("[close by clen]\n");
            break;
         }

         // no data at all over timeout?
         if (getCurrentTime() > nLastTime + cs.timeOutMSec) {
            if (cs.verbose)
               printf("[timeout, no data over %d msec]\n", cs.timeOutMSec);
            break;
         }

      } // end outer loop

      if (pszForward)
         closesocket(hFront);

      closesocket(hBack);
   }

   closesocket(hServer);

   return 0;
}

cchar *pUploadForm =
   "<p>"
   "<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/\">\n"
   "<table><tr><td>\n"
   "<input type=\"file\" name=\"filename\"/>\n"
   "</td><td>\n"
   "<input type=\"submit\" value=\"upload\"/>\n"
   "</td></tr></table>\n"
   "</form>\n";

int recvHead(SOCKET hBack, char *pbuf, int nrem)
{
   bool bbail = 0;
   int nhead = 0;
   while (nhead+100 < nrem) // fix: 1742: missing check
   {
      int nread = recv(hBack, pbuf+nhead, 1, 0);
      if (nread <= 0) { bbail=1; break; }
      nhead++;
      // scan for \r\n\r\n
      if (nhead > 4 && !strncmp(pbuf+nhead-4, "\r\n\r\n", 4))
         break;
      // scan for \n\n
      if (nhead > 2 && !strncmp(pbuf+nhead-2, "\n\n", 2))
         break;
   }
   pbuf[nhead] = '\0';
   if (cs.showhdr) {
      char *pcur=pbuf;
      while (*pcur!=0) {
         char *pnex=pcur;
         while (*pnex!=0 && *pnex!='\r' && *pnex!='\n') pnex++;
         int ilen=pnex-pcur;
         printx("<head>> %.*s\n", ilen, pcur);
         while (*pnex!=0 && (*pnex=='\r' || *pnex=='\n')) pnex++;
         pcur=pnex;
      }
   }
   return bbail ? -1 : nhead;
}

// used mainly by file upload of http server
int senderr(SOCKET hSock, cchar *pszFormat, ...)
{__
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   strcat(szErrBuf, "\r\n");

   sendLine(hSock, "HTTP/1.1 500 server error");
   sendLine(hSock, "Server: Swiss File Knife " SFK_VERSION " " VER_STR_OS);
   sendLine(hSock, "Content-Type: text/html");
   sendLine(hSock, "");

   sendLine(hSock, "<html><body>");
   send(hSock, szErrBuf, strlen(szErrBuf), 0);
   sendLine(hSock, "</body></html>");

   num nstart = getCurrentTime();

   // browser tries to upload data, so we have to dummy-receive
   // them for a while, otherwise it will show a connection abort
   // instead of the error message.

   setBlocking(hSock, 0);
   int nread = 0;
   while ((nread = recv(hSock, (char*)abBuf, sizeof(abBuf)-10, 0)) > 0)
      if (getCurrentTime() - nstart > 3000)
         break;
   setBlocking(hSock, 1);

   if (cs.quiet < 2)
      printf("< ERROR: %.80s\n", szErrBuf);

   return 0;
}

// tested code, just for httpserv
int decodeUrl(char *pszInOut, int *pChg=0)
{
    char *psz = pszInOut;
    while (*psz) {
        if (    *psz == '%'
            &&  isxdigit(*(psz+1))  // also catches terminator
            &&  isxdigit(*(psz+2))  // also catches terminator
           )
        {
            char ahex[10];
            ahex[0] = *(psz+1);
            ahex[1] = *(psz+2);
            ahex[2] = '\0';
            uchar abin[10];
            if (hexToBin(ahex, abin, 1)) {
                if (!cs.quiet)
                    pwarn("invalid hex code: %%%s\n", ahex);
                psz++;
            } else {
                *psz = (char)abin[0];
                psz++;
                memmove(psz, psz+2, strlen(psz+2)+1); // incl. terminator
            }
            if (pChg) (*pChg)++;
        }
        else
            psz++;
    }
    return 0;
}

// RC 0   : ok modified
// RC 5-8 : ok nothing to do
// RC 9   : error / not allowed
int maphtaccess(char *szOut, char *szFile) // both SFK_MAX_PATH size
{
   /*
      pic/.htaccess
         RewriteEngine on
         Options +FollowSymLinks
         RewriteBase /pic
         RewriteRule ^the-long-image-name.jpg$ 01.jpg

      FROM  pic/the-long-image-name.jpg
      TO    pic/01.jpg
   */

   int imaxlen = SFK_MAX_PATH;

   char szBaseDir[SFK_MAX_PATH+10]; // 'pic' from pic/the-long-image-name.jpg
   char szRelFile[SFK_MAX_PATH+10]; // the-long-image-name.jpg
   char szMapFile[SFK_MAX_PATH+10]; // pic/.htaccess
   char szPat[SFK_MAX_PATH+10];
   char szLine[SFK_MAX_PATH+10];
   char szRebase[SFK_MAX_PATH+10];

   // isolate pic
   strcopy(szBaseDir, localPath(szFile));
   char *p = strrchr(szBaseDir, glblPathChar);
   if (!p) {
      szBaseDir[0] = '\0';
      strcopy(szRelFile, szFile);
   } else {
      *p++ = '\0';
      strcopy(szRelFile, p);
   }

   // make pic/.htaccess
   strcopy(szMapFile, szBaseDir);
   if (strlen(szMapFile)+20 > imaxlen) return 9;
   strcat(szMapFile, glblPathStr);
   strcat(szMapFile, ".htaccess");

   if (cs.verbose >= 2)
      printf("abspath: %s\nbasedir: %s\nrelfile: %s\nmapfile: %s\n",
         szFile, szBaseDir, szRelFile, szMapFile);

   char *pszMap = loadFile(szMapFile, 1);
   if (!pszMap) {
      if (cs.verbose >= 2) printf("miss   : %s (rc 5)\n", szMapFile);
      return 5;
   }
   CharAutoDel odel(pszMap);

   // check rewritebase
   p = strstr(pszMap, "RewriteBase");
   if (!p) {
      if (cs.verbose >= 2) printf("miss   : RewriteBase\n");
      return 6;
   }
   p += strlen("RewriteBase");
   while (*p && isws(*p)) p++;
   strcopy(szLine, p);
   removeCRLF(szLine);  // e.g. /de/pic or /pic
   strcopy(szRebase, szLine);
   if (cs.verbose >= 2) printf("rebase : %s\n", szRebase);

   // search for pic/the-long-image-name.jpg
   snprintf(szPat, imaxlen, "RewriteRule ^%s$", szRelFile);
   p = strstr(pszMap, szPat);
   if (!p) {
      if (cs.verbose >= 2) printf("miss   : %s (rc 7)\n", szPat);
      return 7;
   }
   p += strlen(szPat);
   while (*p && isws(*p)) p++;

   // copy remainder: 01.jpg\nblabla
   mystrcopy(szRelFile, p, imaxlen);
   removeCRLF(szRelFile);
   // if (cs.verbose >= 2) printf("use    : %s\n", szRelFile);

   // make: pic/01.jpg
   snprintf(szOut, imaxlen, "%s%c%s", szBaseDir, glblPathChar, szRelFile);

   if (cs.verbose)
      printf("# %s -> %s\n", szFile, szOut);

   return 0;
}

char *webSubDirParm() {
   static char szparm[SFK_MAX_PATH+100];
   if (!cs.withdirs) return str("");
   if (!strcmp(cs.webcurdir,".") && !cs.pwebstartdir) return str("");
   snprintf(szparm,SFK_MAX_PATH,"?subdir=%s",ansiToUTF(skipdot(cs.webcurdir)));
   return szparm;
}

int httpServ(uint nPort, uint nPort2, bool bDeep, bool bNoList, bool bRW, bool bRaw)
{__
   prepareTCP();

   struct sockaddr_in ServerAdr;
   struct sockaddr_in ClientAdr;
   socklen_t nSoLen = sizeof(sockaddr_in);
   SOCKET hServer   = INVALID_SOCKET;
   SOCKET hBack     = INVALID_SOCKET;
   if (makeServerSocket(nPort, ServerAdr, hServer, "server main port", nPort2)) return 9;

   printf("SFK Instant HTTP Server. For help, type \"sfk httpserv -help\".\n");

   // get own ip
   int   namount = 0;
   char *pownip  = ownIPList(namount, (nPort==80) ? 0 : nPort, " or http://", 0); // httpserv
   struct in_addr addr;

   if (strlen(pownip)) {
      if (namount == 1) {
         printf("Waiting on port %u. Try http://%s/ in your browser.\n", nPort, pownip, nPort);
      } else {
         printf("Waiting on port %u. Try http://%s in your browser.\n", nPort, pownip, nPort);
      }
   } else {
      printf("Waiting on port %u.\n", nPort);
   }

   // sfk198: variable single root dir
   cs.webbasedir[0] = '\0';
   cs.webcurdir[0] = '\0';
   if (cs.withdirs && glblFileSet.rootDirs().numberOfEntries() == 1) {
      char *pszRoot = glblFileSet.getCurrentRoot();
      if (!pszRoot) return 9+perr("missing root dir");
      strcopy(cs.webbasedir,pszRoot);
      strcopy(cs.webcurdir,pszRoot);
      printf("Single base dir: %s\n", cs.webbasedir);
   } else {
      printf("Using %d root dirs.\n", glblFileSet.rootDirs().numberOfEntries());
      cs.withdirs = 0; // for file list
      cs.justdirs = 0;
   }
 
   char szClientIP[50]; mclear(szClientIP);
   char szStatus[200];  mclear(szStatus);

   int iListMode = 0;
   bool bMultiFile = 1;

   int lRC = 0;
   while (!userInterrupt())
   {
      hBack = accept(hServer, (struct sockaddr *)&ClientAdr, &nSoLen);
      if (hBack == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(50); continue; }
         perr("accept on server main port failed\n");
         lRC = 9;
         break;
      }
      setBlocking(hBack, 1);

      // list IP of client machine whenever it changes
      memcpy(&addr,&ClientAdr.sin_addr,sizeof(struct in_addr));
      char *premip = inet_ntoa(addr);
      if (strcmp(szClientIP, premip)) 
      {
         strcopy(szClientIP, premip);
         num ntime=time(0);
         printf("> connect from %s on %s\n", premip, timeAsString(ntime,0));
      }

      char szReq[SFK_MAX_PATH+50]; mclear(szReq);
      char szFile[SFK_MAX_PATH+50]; mclear(szFile);
      char szDir[SFK_MAX_PATH+50]; mclear(szDir);
      char szMap[SFK_MAX_PATH+50]; mclear(szMap);

      mclear(szStatus);

      do
      {
         // read header line by line
         int nhead = recvHead(hBack, (char*)abBuf, sizeof(abBuf)-10);
         if (nhead < 0) break;

         // GET /favicon.ico HTTP/1.1
         char *preq = (char*)abBuf;

         char *pagent = mystrstri(preq, "User-Agent:");
         szLineBuf[0] = '\0';
         if (pagent)
            { strcopy(szLineBuf, pagent); removeCRLF(szLineBuf); }

         // auto decide list mode on first access
         if (iListMode == 0) {
            printf("> first user-agent: %s\n", szLineBuf);
            if (mystrstri(szLineBuf, " mobile "))
               iListMode = 2;
            else
               iListMode = 1;
            printf("- select list mode: %d\n", iListMode);
         }

         // ----- get first line and basic parms begin -----

         bool bget=0, bhead=0, bpost=0;
         szReq[0] = '\0';
         char *ppath = 0;
         do
         {
            char *plf = strchr(preq, '\r');
            if (!plf) plf = strchr(preq, '\n');
            if (!plf) break;
            int ilen = plf-preq;
            if (ilen>=SFK_MAX_PATH) break;
            memcpy(szReq, preq, ilen);
            szReq[ilen]='\0';

            if (strBegins(szReq, "GET "))
               { bget=1; ppath=szReq+4; }
            if (strBegins(szReq, "HEAD "))
               { bhead=1; ppath=szReq+5; }
            if (strBegins(szReq, "POST "))
               { bpost=1; ppath=szReq+5; }
         }
         while (0);

         if (!ppath)
            { senderr(hBack, "500 unsupported command: %.200s", preq); break; }

         // sfk198 skip proxy url prefix
         if (strBegins(ppath, "http://")) {
            ppath += 7;
            while (*ppath!=0 && *ppath!='/') ppath++;
         }
         if (*ppath=='/') ppath++;
         // zeroterm the path
         char *pend=ppath+strlen(ppath);
         while (pend>ppath && stribeg(pend," HTTP/")==0)
            pend--;
         if (!stribeg(pend," HTTP/"))
            { senderr(hBack, "500 unsupported format: %.200s", preq); break; }
         *pend='\0';

         // have now: reqtype, ppath, preq = raw request
         strcopy(szFile, ppath);
         // decode %20 etc.
         decodeUrl(szFile);
         // sfk198 utf/ansi support
         char *pansi = utfToAnsi(szFile);
         strcopy(szFile, pansi);

         // sfk198 folders select
         if (cs.withdirs)
         {
            bool bcd = 0;

            if (strbeg(szFile, "?subdir=")) {
               do {
                  char *pszsub = szFile+8;
                  bcd = 1;
                  if (!strcmp(pszsub, "..")) {
                     char *psla=strrchr(cs.webcurdir,'/');
                     if (psla) *psla='\0';
                  } else {
                     if (isPathTraversal(pszsub, 1)
                         || strstr(pszsub, "//")) {
                        pinf("blocking path traversal: %s\n",pszsub);
                        pszsub=str("");
                        bcd = 0;
                     } else {
                        if (strlen(cs.webcurdir)+strlen(pszsub)+20 >= sizeof(cs.webcurdir))
                           { printf("ignoring too long dir parm\n"); break; }
                        snprintf(cs.webcurdir, sizeof(cs.webcurdir)-10,
                           "%s/%s", cs.webbasedir, pszsub);
                     }
                  }
               } while(0);
               szFile[0]='\0';
            }
            else if ((szFile[0]==0 || strcmp(szFile,"/")==0)
                     && cs.pwebstartdir) 
            {
               /*
                  if startdir is set, redirect any access to "/" without parms.
                  to view "/" itself "/?subdir=.." must be given.
               */
               sendLine(hBack, "HTTP/1.1 303 StartDir");
               snprintf(szLineBuf2, MAX_LINE_LEN, "Location: /?subdir=%s", cs.pwebstartdir);
               sendLine(hBack, szLineBuf2);
               sendLine(hBack, ""); // plus added \r\n
            } else {
               strcopy(cs.webcurdir, cs.webbasedir);
               bcd = 1;
            }

            if (bcd) {
               int n = glblFileSet.changeSingleRoot(cs.webcurdir);
               if (n)
                  printf("Changing Root Dir: %s (rc=%d)\n",cs.webcurdir,n);
            }
         }

         // ----- get first line and basic parms end -----

         if (bpost)
         {
            if (!bRW)
               { senderr(hBack, "writing not allowed"); break; }

            int iError = 0;

            // separate content from header
            char *pcont = strstr(preq, "\r\n\r\n");
            if (!pcont) pcont = strstr(preq, "\n\n");
            if (!pcont) { senderr(hBack, "wrong POST format"); break; }
            *pcont = '\0';
            pcont += 4;

            // parse header lines:

            // szLineBuf3 contains boundary.
            mclear(szLineBuf3);
            num nContLen = -1;

            bool bfirst = 1;
            char *psz1 = preq;
            while (psz1 && *psz1)
            {
               char *psz2 = strchr(psz1, '\n');
               if (psz2) *psz2++ = '\0';
               removeCRLF(psz1);
               if (bfirst)
                  { bfirst=0; printf("> %s\n",psz1); }

               mtklog(("http: post.head: %s", psz1));

               if (   striBegins(psz1, "content-type")
                   && mystrstri(psz1, "multipart/form-data")
                  )
               {
                  char *psz3 = strstr(psz1, "boundary=");
                  if (!psz3)
                     { senderr(hBack, "wrong content-type: %s",psz1); break; }
                  psz3 += strlen("boundary=");
                  char *psz4 = psz3;
                  skipToWhite(&psz4);
                  int nlen = psz4-psz3;
                  if (nlen > MAX_LINE_LEN-100)
                     { senderr(hBack, "content-boundary too long"); break; }
                  snprintf(szLineBuf3, MAX_LINE_LEN, "\r\n--%.*s--\r\n", (int)nlen, psz3);
               }
               if (striBegins(psz1, "content-length")) {
                  num nlen = -1;
                  char *psz3 = strchr(psz1, ':');
                  if (psz3) {
                     psz3++;
                     skipWhite(&psz3);
                     nlen = atonum(psz3);
                  }
                  if (nlen < 0) { senderr(hBack, "wrong content-length: %s",psz1); break; }
                  nContLen = nlen;
               }
               psz1 = psz2;
            }

            if (!szLineBuf3[0]) { senderr(hBack, "missing boundary header"); break; }
            if (nContLen < 0)   { senderr(hBack, "missing content length"); break; }

            mtklog(("http: post.bound \"%s\"", szLineBuf3));
            mtklog(("http: post.clen %d", (int)nContLen));

            if (bMultiFile)
            {
               if (nContLen > nGlblMemLimit)
                  { senderr(hBack, "content too large. keep below %d mb.",(int)(nGlblMemLimit/1000000)); break; }

               // multi file support from one large buffer
               /*
                  Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryPHB1kYfX7ml5PKl0
                  ------WebKitFormBoundaryPHB1kYfX7ml5PKl0[CRLF]
                  Content-Disposition: form-data; name="filename"; filename="file1.txt"
                  Content-Type: text/plain[CRLFCRLF]
                  {DATA}
                  [CRLF]------WebKitFormBoundaryPHB1kYfX7ml5PKl0[CRLF]
                  Content-Disposition: form-data; name="filename"; filename="file2.txt"
                  Content-Type: text/plain[CRLFCRLF]
                  {DATA}CRLF
                  [CRLF]------WebKitFormBoundaryPHB1kYfX7ml5PKl0--
               */
               printf("> multi file store of %d bytes\n", (int)nContLen);
               // create sub boundary without trailing "--"
               //    from "--CRLF" to "CRLF"
               strcopy(szAttrBuf3, szLineBuf3);
               if (strlen(szAttrBuf3) >= 10)
                  strcpy(szAttrBuf3+strlen(szAttrBuf3)-4, "\r\n");
               char *psubbnd = szAttrBuf3;
               int   nsubbnd = strlen(psubbnd);
               // read all in one block
               uchar *pbuf = new uchar[nContLen+100];
               if (!pbuf)
                  { perr("outofmem"); break; }
               num iread=0,itotal=0,itold=0;
               while (itotal < nContLen) {
                  num iBlockLen = nContLen-itotal;
                  // if (iBlockLen > 5000000) iBlockLen = 5000000;
                  if (iBlockLen > 100000) iBlockLen = 100000;
                  iread = recv(hBack, (char*)pbuf+itotal, iBlockLen, 0);
                  if (iread <= 0) {
                     perr("read error %d at %d/%d total bytes\n",(int)iread,(int)itotal,(int)nContLen);
                     delete [] pbuf; pbuf = 0; break; 
                  }
                  itotal += iread;
                  doYield(); // sfk198
                  if (cs.quiet==0 && itotal-itold>=100000) {
                     itold=itotal;
                     printf("> received %1.1f/%1.1f mb\r", // sfk198
                        itotal  /1000000.0,
                        nContLen/1000000.0
                        );
                     fflush(stdout);
                  }
               }
               printf("> received %d/%d mb - %s (rc=%d)\n",
                  (int)(itotal/1000000),(int)(nContLen/1000000),
                  itotal >= nContLen ? "complete":"error",
                  netErrno());
               if (!pbuf)
                  break;
               pbuf[itotal] = '\0'; // safety
               // fprintf(stdout, "RECV: '%s'\n",(char*)pbuf);
               // extract sub files using sub boundary.
               // CONTENT MAY CONTAIN BINARY.
               int    nfiles = 0;
               num    icur  = 0, inew = 0;
               uchar *pdata = 0;
               char  *pszFile = 0, *pszFirst = 0;
               // first seek must search pattern without prefix CRLF
               uchar *phead = memFind((uchar*)psubbnd+2,nsubbnd-2, pbuf+icur,itotal-icur);
               while (phead) {
                  inew = phead - pbuf;
                  if (icur > 0) {
                     // save a sub file
                     num ilen = inew - icur;
                     char *pname = pszFile;
                     // c:\the\dir\foo.txt -> foo.txt
                     if (strrchr(pname, '/'))  pname = strrchr(pname, '/') + 1;
                     if (strrchr(pname, '\\')) pname = strrchr(pname, '\\') + 1;
                     strcopy(szFile, localPath(pname));
                     decodeUrl(szFile);
                     // sfk198 utf/ansi support
                     char *pansi = utfToAnsi(szFile);
                     strcopy(szFile, pansi);
                     // sfk198 multi file post to subdir
                     if (cs.withdirs && cs.webcurdir[0]) {
                        joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, skipdot(cs.webcurdir), szFile);
                        strcopy(szFile, szRefNameBuf);
                     }
                     printf("subfile: off=%04dk len=%04dk name='%s'\n",(int)ilen/1000,(int)icur/1000,szFile);
                     if (isPathTraversal(szFile, cs.withdirs))
                        senderr(hBack, "path traversal not allowed: %s", szFile);
                     else {
                        if (!saveFile(szFile,pbuf+icur,ilen,"wb"))
                           nfiles++;
                     }
                  }
                  // ------WebKitFormBoundaryPHB1kYfX7ml5PKl0[CRLF]
                  // Content-Disposition: form-data; name="filename"; filename="file1.txt"
                  // Content-Type: text/plain[CRLFCRLF]
                  // OR:
                  // ------WebKitFormBoundaryPHB1kYfX7ml5PKl0--[EOD]
                  pszFile = mystrstri((char*)phead, "; filename=\"");
                  if (!pszFile) break;
                  pszFile += 12;
                  char *pnext = strchr(pszFile, '\"');
                  if (!pnext) break;
                  *pnext++ = '\0';
                  pnext = strstr(pnext, "\r\n\r\n");
                  if (!pnext) break;
                  pnext += 4;
                  icur = (uchar*)pnext-pbuf;
                  phead = memFind((uchar*)psubbnd,nsubbnd, pbuf+icur,itotal-icur);
                  if (!phead)
                     phead = memFind((uchar*)szLineBuf3,strlen(szLineBuf3), pbuf+icur,itotal-icur);
                  if (!pszFirst)
                     pszFirst = pszFile;
               }
               if (nfiles > 1)
                  snprintf(szStatus, sizeof(szStatus)-10, "saved %d files %s ...\n", nfiles, pszFirst);
               else
                  snprintf(szStatus, sizeof(szStatus)-10, "saved %s\n", pszFirst);
               delete [] pbuf;

               // fall through to GET
               bget = 1;
               szFile[0] = '\0';
            }
            else
            {
               // single large file upload

               // get first part header
               int nhead2 = recvHead(hBack, (char*)abBuf, sizeof(abBuf)-10);
               if (nhead2 < 0) break;
               abBuf[nhead2] = '\0';
   
               mtklog(("http: post.firsthead: \"%.300s\"", abBuf));
   
               char *pname = strstr(preq, "filename=\"");
               if (!pname) { senderr(hBack, "missing filename"); break; }
               pname += strlen("filename=\"");
               char *psz3 = strchr(pname, '\"');
               if (!psz3) { senderr(hBack, "missing quote"); break; }
               *psz3 = '\0';
   
               mtklog(("http: post.filename \"%s\"", pname));
   
               // c:\the\dir\foo.txt -> foo.txt
               if (strrchr(pname, '/'))  pname = strrchr(pname, '/') + 1;
               if (strrchr(pname, '\\')) pname = strrchr(pname, '\\') + 1;
               strcopy(szFile, localPath(pname));
    
               // FIX: 163R5: decode POST URLs with blanks or special chars
               decodeUrl(szFile);
               // remember input utf-8 name for status reply
               strcopy(szRefNameBuf2,szFile);
               // sfk198 utf/ansi support
               char *pansi = utfToAnsi(szFile);
               strcopy(szFile, pansi);

               // sfk198 single file post to subdir
               if (cs.withdirs && cs.webcurdir[0]) {
                  joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, skipdot(cs.webcurdir), szFile);
                  strcopy(szFile, szRefNameBuf);
               }

               // receive file data
               if (isPathTraversal(szFile, cs.withdirs))
                  { senderr(hBack, "path traversal not allowed: %s", szFile); break; }
   
               FILE *fout = fopen(szFile, "wb");
               if (!fout)
                  { senderr(hBack, "cannot write: %s",szFile); break; }
   
               char *pbnd = szLineBuf3;
               int  nbnd = strlen(pbnd);
   
               // mtkdump("http: post.bnd: ",pbnd,nbnd);
   
               num nTotal  = 0;
   
               // requires overlapping read with boundary search
               char *pbuf    = (char*)abBuf;
               int  nused   = 0;
               int  nbufmax = sizeof(abBuf)-10;
    
               bool bCompleted = 0;
   
               SFKMD5 md5;
   
               while (nTotal < nContLen)
               {
                  int nbufrem =  nbufmax  - nused;
                  num  ntotrem = (nContLen - nTotal) - nused;
   
                  if (ntotrem < 0) {
                     senderr(hBack, "int. error during POST read, %d %d %d",(int)nContLen,(int)nTotal,(int)nused);
                     break;
                  }
   
                  if (nbufrem > ntotrem) nbufrem = (int)ntotrem;
   
                  // if (nbufrem < 1000) { mtkdump("http: buf: ", pbuf, nused); }
   
                  mtklog(("http: post.wait: rem=%d used=%d total=%d clen=%d", nbufrem, nused, (int)nTotal, (int)nContLen));
   
                  int nread = recv(hBack, pbuf+nused, nbufrem, 0);
                  if (nread <= 0) break;
   
                  nused += nread;
                  pbuf[nused] = '\0'; // safety
   
                  mtklog(("http:  post.read: len=%d used=%d total=%d", nread, nused, (int)nTotal));
   
                  // another boundary?
                  char *phit = 0;
   
                  if (nused >= nbnd)
                     if (!strncmp(pbuf+nused-nbnd, pbnd, nbnd))
                         phit = pbuf+nused-nbnd;
   
                  if (phit)
                  {
                     int nlen = phit - pbuf;
                     if (myfwrite((uchar*)pbuf, nlen, fout) != nlen) {
                        perr("cannot fully write (disk full?): %s", szFile);
                        iError = 1;
                        break;
                     }
                     md5.update((uchar*)pbuf, nlen);
                     nTotal += nlen;
                     char *ppost = phit + nbnd;
                     char *pend  = strstr(ppost, "\r\n\r\n");
                     if (!pend) pend = ppost;
                     // printf("sub: \"%s\"\n", phit);
                     ppost = pend;
                     int nlen2 = ppost - pbuf;
                     int nrem2 = nused - nlen2;
                     memmove(pbuf, ppost, nrem2);
                     nused = nrem2;
                     mtklog(("http:  post.hitblock: take %d, move %d",nlen,nused));
                     bCompleted = 1;
                     break;
                  }
   
                  // normal processing: write halve of buffer
                  int nlen = nused / 2;
   
                  mtklog(("http:  post.nblk: take %d",nlen));
   
                  if (myfwrite((uchar*)pbuf, nlen, fout) != nlen) {
                     perr("cannot fully write (disk full?): %s", szFile);
                     iError = 2;
                     break;
                  }
                  md5.update((uchar*)pbuf, nlen);
                  nTotal += nlen;
                  char *ppost = pbuf + nlen;
                  int nrem2 = nused - nlen;
                  memmove(pbuf, ppost, nrem2);
                  nused = nrem2;
               }
   
               fclose(fout);
    
               if (!bCompleted && !iError)
                  iError = 3;
   
               char szmd5[100];
               uchar *pmd5 = md5.digest();
               for (int i=0; i<16; i++)
                  sprintf(szmd5+i*2, "%02x", pmd5[i]);
    
               if (iError) {
                  remove(szFile);
                  snprintf(szStatus, sizeof(szStatus)-10,
                     "failed: %s (error %d)",szRefNameBuf2,iError);
               } else {
                  snprintf(szStatus, sizeof(szStatus)-10,
                     "saved: %s (%s bytes)\n"
                     "<span>md5sum = %s</span>"
                     , szRefNameBuf2
                     , numtoa(nTotal),szmd5);
               }
               printf("> %s\n", szStatus);
    
               mtklog(("http: post: %s", szStatus));
            }

            // fall through to GET
            bget = 1;
            szFile[0] = '\0';

         }  // endif POST

         // requested file is now in szFile
         int iListNow = 0;

         if (bNoList) {
            if (!strcmp(szFile, ""))
               strcpy(szFile, "index.html");
         } else {
            if (!strcmp(szFile, ""))           iListNow = 1;
            if (!strcmp(szFile, "?desk"))    { iListNow = 1; iListMode = 1; }
            if (!strcmp(szFile, "?mobile"))  { iListNow = 1; iListMode = 2; }
            if (!strcmp(szFile, "?large"))   { iListNow = 1; bMultiFile = 0; }
            if (!strcmp(szFile, "?multi"))   { iListNow = 1; bMultiFile = 1; }
         }

         if (iListNow)
         {
            // list files of current dir
            hGlblTCPOutSocket = hBack;

            if (!bRaw) {
               sendLine(hBack, "HTTP/1.1 200 OK");
               sendLine(hBack, "Server: Swiss File Knife " SFK_VERSION " " VER_STR_OS);
               sendLine(hBack, "Content-Type: text/html");
               sendLine(hBack, "Cache-Control: no-cache");
               sendLine(hBack, ""); // plus added \r\n
            }

            if (bget)
            {
               cs.webdesklist = (iListMode == 1) ? 1 : 0;
               int iFontSize  = cs.webdesklist ? 30 : 70;
               int iFontSize2 = (int)(iFontSize * 0.80);
               int iFontSize3 = (int)(iFontSize * 1.40);
               int iFontSize4 = (int)(iFontSize * 0.70);
               snprintf(szLineBuf, MAX_LINE_LEN,
                  "<html><head>\n"
                  "<meta charset=\"utf-8\"/>\n"
                  "<title>SFK HTTP</title>\n"
                  "<style type=\"text/css\">\n"
                  "   body     { font: %dpx verdana,arial; }\n"
                  "   table    { font: %dpx verdana,arial; }\n"
                  "   h1       { font: %dpx verdana,arial; font-weight: bold;\n"
                  "              padding: 10px 10px 30px 0px; }\n"
                  "   a        { text-decoration: none; }\n"
                  "   a.d      { text-decoration: none; color: #0a0; }\n"
                  "   a.ref    { border: 2px solid #aaa;\n"
                  "              background: #e1e2e4; text-decoration: none;\n"
                  "              padding: 20px 200px 20px 200px; line-height: 1.5em; }\n"
                  "   a.lyo    { border: 2px solid #aaa;\n"
                  "              background: #e1e2e4; text-decoration: none;\n"
                  "              padding: 20px 20px 20px 20px; line-height: 1.5em; }\n"
                  "   a.mul    { border: 2px solid #aaa;\n"
                  "              background: #e1e2e4; text-decoration: none;\n"
                  "              padding: 10px 20px 10px 20px; line-height: 1.5em; }\n"
                  "   span     { font-size: %dpx; color: #aaa;\n"
                  "              line-height: 1.5em; }\n"
                  "   span.dh  { font-size: %dpx; line-height: 1.5em; }\n"
                  "   td       { padding: 10px 20px 10px 0px; }\n"
                  "   input.f  { font: %dpx verdana,arial;\n"
                  "              padding: 0px 0px %dpx %dpx; }\n"
                  "   input.u  { font: %dpx verdana,arial;\n"
                  "              padding: 10px 150px %dpx 150px; }\n"
                  "   td.hint  { font: %dpx verdana,arial; font-style: italic; "
                  "              text-align: center; color: #aaa; }\n"
                  "</style>\n"
                  "</head><body>\n"
                  "<h1>SFK&nbsp;Instant&nbsp;Web&nbsp;Server&nbsp;" SFK_VERSION "</h1>\n"
                  "<table><tr><td>"
                  "<a href=\"/%s\" class=\"ref\">Refresh&nbsp;Content&nbsp;List</a>\n"
                  "</td><td>"
                  "<a href=\"%s\" class=\"lyo\" title=\"%s\">%s</a>"
                  "</td></tr></table>\n"
                  ,  iFontSize, iFontSize, iFontSize2
                  ,  iFontSize2, iFontSize3
                  ,  iFontSize3
                  ,  cs.webdesklist ? 10 :  60
                  ,  cs.webdesklist ?  0 : 100
                  ,  iFontSize
                  ,  cs.webdesklist ? 10 :  30
                  ,  iFontSize4
                  ,  webSubDirParm()
                  ,  cs.webdesklist ? "?mobile" : "?desk"
                  ,  cs.webdesklist ? "Switch to mobile layout" : "Switch to desktop layout"
                  ,  cs.webdesklist ? "Mobile"  : "Wide"
                  );
               send(hBack, szLineBuf, strlen(szLineBuf), 0);

               if (bRW) {
               char szHint[200];
               snprintf(szHint, sizeof(szHint)-10,
                  "<tr><td colspan=\"2\" class=\"hint\">Use long press on your mobile for multi file selection."
                  "<br/>Keep total size below %d mb.</td></tr>\n",
                  (int)(nGlblMemLimit/1000000));
               snprintf(szLineBuf, MAX_LINE_LEN,
                  "%s"
                  "<form method=\"POST\" enctype=\"multipart/form-data\" "
                  "action=\"/%s\">\n"
                  "<table><tr><td colspan=\"2\">\n"
                  "<input class=\"f\" type=\"file\" name=\"filename\"%s>\n"
                  "</td></tr><tr><td align=\"center\">\n"
                  "<input class=\"u\" type=\"submit\" value=\"Upload %s\">\n"
                  "&nbsp;<a href=\"%s\" class=\"mul\">%s</a>"
                  "</td><td>\n"
                  "</td></tr>\n"
                  "%s"
                  "</table>\n"
                  "</form>\n"
                  "\n"
                  ,  cs.webdesklist ? "<p/>" : "<p>Select file to upload:</p>\n"
                  ,  webSubDirParm()
                  ,  bMultiFile ? " multiple" : ""
                  ,  bMultiFile ? "multiple files" : "large file"
                  ,  bMultiFile ? "?large" : "?multi"
                  ,  bMultiFile ? "large" : "multi"
                  ,  bMultiFile ? szHint : ""
                  );
                  send(hBack, szLineBuf, strlen(szLineBuf), 0);
               }

               snprintf(szLineBuf, MAX_LINE_LEN,
                  "\n"
                  "<p>Click&nbsp;on&nbsp;files&nbsp;to&nbsp;download.</p>\n"
                  "\n"
                  );
                  send(hBack, szLineBuf, strlen(szLineBuf), 0);

               if (szStatus[0]) {
                  snprintf(szLineBuf2, MAX_LINE_LEN, "<pre>%s\n", szStatus);
                  sendLine(hBack, szLineBuf2);
               } else {
                  sendLine(hBack, "<pre>");
               }
 
               bGlblFTPListFlatTS = 1;
               bGlblFTPListAsHTML = 1;

               if (cs.withdirs!=0 && strlen(cs.webcurdir)>strlen(cs.webbasedir))
                  execFTPList(str(".."));

               int lFiles=0,lDirs=0;
               num  nBytes=0;
               lRC = walkAllTrees(eFunc_FTPList, lFiles, lDirs, nBytes);
 
               sendLine(hBack, "</pre></body></html>");
               // if (!cs.quiet) printf("< sent content listing.\n");
            }
            break;
         }

         // block any ".." etc.
         if (isPathTraversal(szFile, bDeep)) {
            senderr(hBack, "path traversal not allowed: %s", szFile);
            break;
         }

         // optional htaccess path rename
         if (cs.usehta) {
            if (maphtaccess(szMap, szFile) == 0) {
               strcopy(szFile, szMap);
            }
         }

         // sfk1973 drop "?parm1=foo&parm2=bar" from filename
         // sfk1973 drop "#bookmark" from filename
         for (int i=0; szFile[i]; i++)
            if (szFile[i] == '?' || szFile[i] == '#')
               { szFile[i] = '\0'; break; }

         // all other files
         Coi *pcoi = new Coi(localPath(szFile), 0);
         CoiAutoDelete odel(pcoi, 0); // no decref

         if (!pcoi->existsFile()) {
            if (!bRaw) {
               sendLine(hBack, "HTTP/1.1 404 no such file");
               sendLine(hBack, "");
            }
            sprintf(szLineBuf2, "404 no such file: %.200s", szFile);
            sendLine(hBack, szLineBuf2);
            break;
         }

         bool bbin  = pcoi->isBinaryFile();
         num  nsize = pcoi->getSize();

         // default mime types 
         cchar *pctype = "application/octet-stream";
         if (!bbin) {
            pctype = "text/plain";
            if (mystrstri(szFile, ".htm"))
               pctype = "text/html";
         }
         // sfk1973 more extended mime types
         cchar *pctype2 = getMimeExt(szFile);
         if (pctype2) pctype = pctype2;

         if (!bRaw)
         {
            sendLine(hBack, "HTTP/1.1 200 OK");

            sprintf(szLineBuf2, "Content-Type: %s", pctype);
            sendLine(hBack, szLineBuf2);
 
            sprintf(szLineBuf2, "Content-Length: %s", numtoa(nsize));
            sendLine(hBack, szLineBuf2);
 
            sendLine(hBack, "");
         }

         if (bget)
         {
            if (pcoi->open("rb")) {
               if (mystricmp(szFile, "favicon.ico"))
                  senderr(hBack, "failed to open: \"%s\"", pcoi->name());
               break;
            }
 
            int nread = 0;
            num  ndone = 0;
            while ((nread = pcoi->read(abBuf, sizeof(abBuf)-1000)) > 0)
            {
               if (cs.verbose>1) printf("< [%d bytes data]\n", (int)nread);
               int nsent = send(hBack, (char*)abBuf, nread, 0);
               ndone += nsent;
               if (nsent != nread)
                  { perr("failed to send data (%d/%d) %s\n",nsent,nread,netErrStr()); break; }
            }
 
            pcoi->close();
 
            if (!cs.quiet) {
               if (ndone == nsize)
                  printf("< sent %s bytes, content-type: %s\n",numtoa(ndone),pctype);
               else
                  printf("< transfer incomplete.\n");
            }
         }

         // connection close after every request
      }
      while (0);

      // sfk198 don't wait 500 msec after every request
      doYield();

      closesocket(hBack);

   }  // endwhile accept loop

   closesocket(hServer);

   #ifdef _WIN32
   // WSACleanup(); // sfk1840 only on process exit
   #endif

   return 0;
}

bool getFTPVar(cchar *pname, cchar *pprefix, char *pszBuf, int iMaxBuf, char *pinfobuf)
{
   char szName[100];

   sprintf(szName, "SFK_FTP_%s%s", pprefix, pname);

   char *psz = getenv(szName);
   if (!psz) {
      pprefix = "";
      sprintf(szName, "SFK_FTP_%s", pname);
      psz = getenv(szName);
      if (!psz)
         return 0;
   }

   mystrcopy(pszBuf, psz, iMaxBuf);

   if (pinfobuf[0])
      strcat(pinfobuf, "/");

   strcat(pinfobuf, pprefix);
   strcat(pinfobuf, pname);

   return 1;
}

bool startsLikeHttpCommand(char *psz)
{
   if (strBegins(psz, "GET "))  return 1;
   if (strBegins(psz, "POST ")) return 1;
   if (strBegins(psz, "HEAD ")) return 1;
   return 0;
}

FTPServer::FTPServer( )
{
   memset(this, 0, sizeof(*this));

   getFTPVar("USER" ,"S",szClAuthUser,sizeof(szClAuthUser)-10,szClEnvInfoUser);
   getFTPVar("PW"   ,"S",szClAuthPW,sizeof(szClAuthPW)-10,szClEnvInfoPW);
   getFTPVar("RUNPW","S",szClRunPW,sizeof(szClRunPW)-10,szClEnvInfoRunPW);
}

FTPServer::~FTPServer( )
{
}

int FTPServer::copyNormalized(char *pdst, int imaxdst, char *psrc)
{
   char *pdstmax = pdst+imaxdst-10;

   strcpy(pdst, "/");
   pdst++;
   if (*psrc=='/') psrc++;

   if (pdst+strlen(psrc)>pdstmax)
      return 9+perr("string too long: %s\n", psrc);

   strcat(pdst,psrc);
   pdst += strlen(pdst);

   int ilen = strlen(pdst);
   if (pdst[ilen-1]!='/')
      strcat(pdst, "/");

   return 0;
}

int FTPServer::setFixDir(char *psz)
{
   if (iClVDir > 0)
      return 9+perr("work dir parameter cannot be combined with -usedir: %s\n", psz);

   strcopy(szClFixSysDir, psz);

   return 0;
}

int FTPServer::addUseDir(char *psz)
{
   if (szClFixSysDir[0])
      return 9+perr("-usedir cannot be combined with work dir parameter: %s", szClFixSysDir);

   if (iClVDir >= MAX_FTP_VDIR)
      return 9+perr("too many -usedir statements\n");

   // make psz writeable
   mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
   psz = szLineBuf;

   #ifdef WITH_FTP_LIMITS
   // ringtones:deep:200m
   // website/imgs=img:flat:200m:10m:200f
   char *pszLimit = strstr(psz, ":deep:");
   if (!pszLimit)
      pszLimit = strstr(psz, ":flat:");
   if (pszLimit)
      *pszLimit++ = '\0';
   // psz: website/imgs=img
   #endif

   // FROM /Musik/audiofiles=audio
   // TO   /Musik/audiofiles/=/audio/
   // FROM thedir
   // TO   thedir/=/thedir/
   char *pszCur = psz;
   while (pszCur && *pszCur)
   {
      char *pszRawSrc = pszCur;
      char *pszRawDst = 0;

      while (*pszCur!=0 && *pszCur!='=')
         pszCur++;

      if (*pszCur=='=') {
         // take right side after "="
         *pszCur++ = '\0';
         pszRawDst = pszCur;
         while (*pszCur!=0 && *pszCur!=',')
            pszCur++;
         if (*pszCur)
            *pszCur++ = '\0';
      } else {
         // take (relative part of) single parameter
         pszRawDst = pszRawSrc;
         char *psz = strrchr(pszRawSrc, glblPathChar);
         // FROM foo/bar to just bar
         if (psz!=0 && psz[1]!=0)
            pszRawDst = psz+1;
      }

      // now have one pair of src/dst
      if (copyNormalized(aClVDirSrc[iClVDir], sizeof(aClVDirSrc[iClVDir]), pszRawDst))
         return 9;

      strcopy(aClVDirDst[iClVDir], pszRawSrc);
      if (strlen(aClVDirDst[iClVDir]) >= sizeof(aClVDirDst[iClVDir])-10)
         continue;
      strcat(aClVDirDst[iClVDir], glblPathStr);

      if (cs.verbose)
         printf("FROM %s TO %s\n", aClVDirSrc[iClVDir], aClVDirDst[iClVDir]);

      #ifdef WITH_FTP_LIMITS
      // deep:200m or flat:200m:10m:200f
      if (pszLimit) 
      do
      {
         // mode
         if (strBegins(pszLimit, "deep:")) aClVDirLimMode[iClVDir]='d';
         else if (strBegins(pszLimit, "flat:")) aClVDirLimMode[iClVDir]='f';
         else return 9+perr("invalid limit: %s\n", pszLimit);
         pszLimit += 5;
         // free disk space mb
         aClVDirLimFreeMB[iClVDir] = atoi(pszLimit);
         while (isdigit(*pszLimit)) pszLimit++;
         if (aClVDirLimFreeMB[iClVDir] < 1 || *pszLimit!='m')
            return 9+perr("invalid freedisk limit: %s", pszLimit);
         pszLimit++;
         if (aClVDirLimMode[iClVDir]=='d') {
            if (*pszLimit!=0)
               return 9+perr("deep limit does not support: %s", pszLimit);
            if (cs.verbose)
               printf("  limits: %d mb freesys\n", aClVDirLimFreeMB[iClVDir]);
            break;            
         }

         if (*pszLimit++!=':')
            return 9+perr("wrong limit syntax: %s",pszLimit);
         // folder max size mb
         aClVDirLimUsedMB[iClVDir] = atoi(pszLimit);
         while (isdigit(*pszLimit)) pszLimit++;
         if (aClVDirLimUsedMB[iClVDir] < 1 || *pszLimit!='m')
            return 9+perr("invalid dirsize limit: %s", pszLimit);
         pszLimit++;
         if (*pszLimit++!=':')
            return 9+perr("wrong limit syntax: %s",pszLimit);
         // folder max files mb
         aClVDirLimUsedFil[iClVDir] = atoi(pszLimit);
         while (isdigit(*pszLimit)) pszLimit++;
         if (aClVDirLimUsedMB[iClVDir] < 1 || *pszLimit!='f')
            return 9+perr("invalid dirfiles limit: \"%s\"", pszLimit);
         if (cs.verbose)
            printf("  limits: %d mb freesys, %d mb dirsize, %d dirfiles\n",
               aClVDirLimFreeMB[iClVDir], aClVDirLimUsedMB[iClVDir], aClVDirLimUsedFil[iClVDir]);
      }
      while (0);
      #endif

      iClVDir++;

      break;   // sfk1832 safety
   }
 
   return 0;
}

void  FTPServer::setStart ( )
{
   nClStart = getCurrentTime();
   bClTimeout = 0;
}

int   FTPServer::isTimeout(int iTimeout)
{
   int iElapsed = getCurrentTime() - nClStart;
   if (iElapsed > iTimeout) {
      bClTimeout = 1;
      return 1;
   }
   return 0;
}

// IF input file name starts absolute "/"
//    THEN returns that name, without leading slash
// ELSE
//    returns workdir+that name, without leading slash
char *FTPServer::absPath(char *pszFilePath)
{
   if (!pszFilePath)
      return szClAbsPathBuf;

   szClAbsPathBuf[0] = '\0';

   int nMaxDst = sizeof(szClAbsPathBuf)-10;
 
   if (*pszFilePath == '/')
   {
      strcopy(szClAbsPathBuf, pszFilePath);
   }
   else
   {
      strcopy(szClAbsPathBuf, szClWorkDir);
 
      // append "/" on demand
      int iWorkLen = strlen(szClAbsPathBuf);
      if (iWorkLen > 0) {
         char clast = szClAbsPathBuf[iWorkLen-1];
         if (clast != '/') {
            strcat(szClAbsPathBuf, "/");
            iWorkLen++;
         }
      }
 
      int iAddLen = strlen(pszFilePath);
 
      if (iWorkLen+iAddLen < nMaxDst)
         strcpy(szClAbsPathBuf+iWorkLen, pszFilePath);
   }

   return szClAbsPathBuf;
}

char *FTPServer::sysPath(char *pszFilePath, int *piVDir)
{
   if (!pszFilePath)
      return szClSysPathBuf;

   szClSysPathBuf[0] = '\0';

   strcopy(szClTmpPathBuf, pszFilePath);
   strcopy(szClCmpPathBuf, pszFilePath);

   szClSysPathBuf[0] = '\0'; // safety

   // 2. replace virtual dir mappings, if any
   if (iClVDir > 0)
   {
      addTrailSlash(szClCmpPathBuf, sizeof(szClCmpPathBuf));

      // -mapdir /audio/=/Musik/audiofiles
      bool bMapped=0;
      char *pTail=0;
      for (int i=0; i<iClVDir; i++)
      {
         if (stribeg(szClCmpPathBuf, aClVDirSrc[i]))
         {
            int iSrcLen = strlen(aClVDirSrc[i]);
            strcpy(szClSysPathBuf, aClVDirDst[i]);
            pTail = szClSysPathBuf+strlen(szClSysPathBuf);
            strcat(szClSysPathBuf, szClTmpPathBuf+iSrcLen);
            bMapped=1;
            if (piVDir)
               *piVDir = i;
            break;
         }
         if (cs.verbose)
            printf("miss: %s - %s\n",szClCmpPathBuf,aClVDirSrc[i]);
      }
      if (!bMapped) {
         if (cs.verbose)
            printf("no mapping for: %s\n", pszFilePath);
         return 0;
      }
   }
   else if (szClFixSysDir[0])
   {
      // "/thedir/foo.txt" -> docs/thedir/foo.txt
      char *pszRel = szClTmpPathBuf;
      if (*pszRel=='/')
            pszRel++;
      joinPath(szClSysPathBuf, sizeof(szClSysPathBuf), szClFixSysDir, pszRel);
      // expand "" to "."
      if (!szClSysPathBuf[0])
         strcpy(szClSysPathBuf, ".");
   }
   else
   {
      // "/thedir/foo.txt" actually means "thedir/foo.txt"
      if (szClTmpPathBuf[0] == '/')
         strcopy(szClSysPathBuf, szClTmpPathBuf+1);
      else
         strcopy(szClSysPathBuf, szClTmpPathBuf);
      // expand "" to "."
      if (!szClSysPathBuf[0])
         strcpy(szClSysPathBuf, ".");
   }

   // 3. convert to OS FS
   for (char *p=szClSysPathBuf; *p; p++)
      if (*p == glblWrongPChar)
          *p = glblPathChar;

   if (cs.verbose>=2)
      printf("map.sys: %s\n", szClSysPathBuf);

   // return normalized OS FS path
   return szClSysPathBuf;
}

// RC 1: any error
// RC 2: unallowed root path
int FTPServer::mapPath(char *pszRelPath, bool bAllowRoot, bool bCheckDiskSpace)
{
   int irc = mapPathInt(pszRelPath,bAllowRoot,bCheckDiskSpace);
   if (irc && cs.verbose) { // sfk1934 ftpserv invalid path info
      printf("- path: \"%s\"\n",dataAsTrace(pszRelPath,strlen(pszRelPath)));
   }
   return irc;
}

int FTPServer::mapPathInt(char *pszRelPath, bool bAllowRoot, bool bCheckDiskSpace)
{
   // fix sfk184: check incoming path immediately before mapping.
   // FIX sfk185: must accept /mydir/ by checking just mydir/
   char *pszCheck = pszRelPath;
   if (*pszCheck=='/' || *pszCheck=='\\') // FIX sfk185 ftp folders
      pszCheck++;
   if (isPathTraversal(pszCheck, bClDeep))
      { reply("550 Invalid path (1)"); return 1; }

   nClDiskFree = -1;

   char *pszAbsPath = absPath(pszRelPath);
   // must now be /workdir/thepath/
 
   if (cs.verbose>=2)
      printf("use.abs: %s\n", pszAbsPath);

   if (pszAbsPath[0]!='/')
      { reply("550 Invalid path (2)"); return 1; }

   if (pszAbsPath[1] && isPathTraversal(pszAbsPath+1, bClDeep))
      { reply("550 Invalid path (3)"); return 1; }

   int iVDir = -1;

   char *pszSysPath = sysPath(pszAbsPath, &iVDir);
   if (!pszSysPath)
      { reply("550 Invalid path (4)"); return 1; }

   if (cs.verbose>=2)
      printf("use.sys: %s\n", pszSysPath);

   if (iClVDir > 0 && !strcmp(pszRelPath, "/")) {
      if (!bAllowRoot)
         reply("550 forbidden path");
      return 2;
   }

   num  nTotal=0;
   char szFSName[200];
   char szVolID[200];
   uint nVolID=0;

   #ifdef WITH_FTP_LIMITS
   if (bCheckDiskSpace != 0 && iVDir >= 0 && aClVDirLimMode[iVDir] != 0)
   {
      // check -usedir folder limit deep:200m.
      // also checked with flat.
      if (getFileSystemInfo(sysPath(), nTotal, nClDiskFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10, nVolID)) {
         reply("552 No disk space info");
         return 1;
      }
      int iDiskFreeMB = (int)(nClDiskFree / 1000000);
      if (iDiskFreeMB < aClVDirLimFreeMB[iVDir]) {
         if (cs.quiet < 2)
            printf("# out of disk space. free=%d mb, limit=%d mb\n",
               iDiskFreeMB, aClVDirLimFreeMB[iVDir]);
         reply("552 Out of disk space");
         return 1;
      }

      // check flat:200m:10m:30f
      if (aClVDirLimMode[iVDir]=='f') {
         // collect current folder size and files
         char *pszSysDir = aClVDirDst[iVDir];
         if (setLocalWalkDir(pszSysDir))
            { reply("550 Invalid path (5)"); return 1; }
         int iDirFiles=0, iSubDirs=0; num nDirBytes=0;
         walkAllTrees(eFunc_SumFiles, iDirFiles, iSubDirs, nDirBytes);
         if (iSubDirs>0) iSubDirs--; // uncount root dir
         int iDirMB = (int)(nDirBytes / 1000000);
         if (cs.verbose)
            printf("%d/%d free, %d/%d used, %d/%d files, %d subdirs in %s\n", 
               iDiskFreeMB, aClVDirLimFreeMB[iVDir],
               (int)iDirMB, aClVDirLimUsedMB[iVDir],
               (int)iDirFiles, aClVDirLimUsedFil[iVDir],
               iSubDirs, pszSysDir);
         if (iSubDirs > 0)
            { reply("552 Sub folders found in flat dir"); return 1; }
         if (iDirMB > aClVDirLimUsedMB[iVDir])
            { reply("552 Folder size limit reached"); return 1; }
         if (iDirFiles > aClVDirLimUsedFil[iVDir])
            { reply("552 Folder file limit reached"); return 1; }
      }
   }
   #endif

   if (bCheckDiskSpace && cs.diskspace)
   {
      if (getFileSystemInfo(sysPath(), nTotal, nClDiskFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10, nVolID)) {
         reply("552 No disk space info");
         return 1;
      }
      if (nClDiskFree < cs.diskspace) {
         char szBuf1[100],szBuf2[100];
         if (cs.quiet < 2)
            printf("# out of disk space. free=%s mb, limit=%s mb\n",
               numtoa(nClDiskFree/1000000,0,szBuf1), numtoa(cs.diskspace/1000000,0,szBuf2));
         reply("552 Out of disk space");
         return 1;
      }
   }

   return 0;
}

int FTPServer::addTrailSlash(char *pszBuf, int iMaxBuf)
{
   int iLen = strlen(pszBuf);
   if (iLen < 1) {
      strcpy(pszBuf, "/");
      return 0;
   }
   if (pszBuf[iLen-1] == '/')
      return 0;
   if (iLen >= iMaxBuf-10)
      return 0;
   strcat(pszBuf, "/");
   return 0;
}

void FTPServer::stripTrailSlash(char *pszPath, char cSlash)
{
   char *psz = strrchr(pszPath, cSlash);
   if (psz!=0 && psz>pszPath)
      *psz = '\0';
}

char *FTPServer::notslash(char *pszPath)
{
   strcopy(szClTmpPathBuf, pszPath);
   char *psz = strrchr(szClTmpPathBuf, '/');
   if (psz!=0 && psz>szClTmpPathBuf)
      *psz = '\0';
   return szClTmpPathBuf;
}

int FTPServer::checkPath(char *pszPath, bool bDeep)
{
   if (isPathTraversal(pszPath, bDeep)) {
      reply("550 invalid path (6)");
      if (!cs.verbose && !cs.quiet)
         printf("] invalid path: %s\n", pszPath);
      return 9;
   }
   return 0;
}

// default: no subdirs, include root dir, no hidden files
int FTPServer::setLocalWalkDir(char *pszDir)
{
   glblFileSet.reset();
   if (glblFileSet.beginLayer(false, __LINE__))
      { reply("500 internal error"); return 9; }
   glblFileSet.addRootDir(pszDir, __LINE__, false, false); // sfk193 fix ftp dir x.zip
   glblFileSet.autoCompleteFileMasks(3);
   glblFileSet.setBaseLayer();

   cs.subdirs = 0;
   cs.withrootdirs = 1;
   cs.hidden = 0;

   return 0;
}

int FTPServer::reply(cchar *pszMask, ...)
{
   va_list argList;
   va_start(argList, pszMask);
   ::vsnprintf(szClReplyBuf, sizeof(szClReplyBuf)-10, pszMask, argList);
   szClReplyBuf[sizeof(szClReplyBuf)-10] = '\0';

   strcat(szClReplyBuf, "\r\n");

   int iReplyCode = atoi(szClReplyBuf);

   // sfk1852: print errors only with option -showerr[or]
   if (    cs.showerr != 0 && iReplyCode != 550
       && iReplyCode >= 500 && iReplyCode < 600
      )
      printx("<err>< %s", szClReplyBuf);
   else if (cs.verbose)
      printf("< %s", szClReplyBuf);

   int nSent = send(hClClient, szClReplyBuf, strlen(szClReplyBuf), 0);

   if (nSent != (int)strlen(szClReplyBuf)) {
      bClSendFailed = 1;
      return 9;
   }

   return 0;
}

int FTPServer::replyFromRC(int iSubRC)
{
   cchar *info = "unknown error";

   switch (iSubRC)
   {
      case FTPRC_Stopped       : info = "Stopped by admin"; break;
      case FTPRC_OutOfDiskSpace: info = "Out of disk space"; break;
      case FTPRC_WriteFailed   : info = "Write failed"; break;
   }

   reply("%03u %s", iSubRC, info);

   return 0;
}

// see also forward decl. for default parms
int FTPServer::readLine( )
{
   char *pszLineBuf = szLineBuf;
   int   nMode = 0;

   int lRC = readLineSub(hClClient, pszLineBuf, nMode);

   // sft101: optional skip records to enforce socket flushing
   if (!strncmp(szLineBuf, "SKIP ", 5))
   {
      // read intermediate skip record
      uint nLen = (uint)atol(szLineBuf+5);
      if (nLen > sizeof(abBuf)-10) nLen = sizeof(abBuf)-10;
      if (nLen) receiveBlock(hClClient, abBuf, nLen, "SKIP");

      // now read the actual record
      lRC = readLineSub(hClClient, pszLineBuf, nMode);
   }

   return lRC;
}

int FTPServer::run(uint nPort, bool bRW, bool bRun, bool bDeep, uint nPort2, uint nPasvPort)
{__
   prepareTCP();

   // user, authpw, runpw have been set by env and options
   if (!szClRunPW[0])
      strcopy(szClRunPW, szClAuthPW); // if any

   bClDeep = bDeep;

   bGlblFTPReadWrite = bRW;

   socklen_t nSoLen = sizeof(sockaddr_in);

   hClServer   = INVALID_SOCKET;
   hClClient   = INVALID_SOCKET;
   hClPasServ  = INVALID_SOCKET;
   hClData     = INVALID_SOCKET;

   bClSendFailed = 0;

   uint  nPasPort = 0;

   cchar *ppreip = "";
   cchar *pownip = "";
   cchar *pposip = ". ";
   char szRepBuf[200];

   int   namount = 0;
   pownip = ownIPList(namount, 0, " or ", 0); // ftpserv

   if (strlen(pownip))
   {
      ppreip = ", IP ";
      pposip = " - ";
      // on multiple ip's, create another line
      if (strlen(pownip) > 20)
         pposip = ".\n";
   }

   int nDefSFTVer = 105;
   // 105: linux based file attributes with sfk extensions
   // 104: support for CWD, MKD, DELE, RMD

   if (makeServerSocket(nPort, clServerAdr, hClServer, "server main port", nPort2))
      return 9;

   printf("SFK Instant FTP %d. For help, type \"sfk ftpserv -help\".\n", nDefSFTVer);
   if (bRW)
      printf("waiting on port %u%s%s%swrite allowed, %u MB limit per file. ", nPort, ppreip, pownip, pposip, nGlblTCPMaxSizeMB);
   else
      printf("waiting on port %u%s%s%sonly read allowed. ", nPort, ppreip, pownip, pposip);
   printf("%d sec timeout.\n",cs.timeOutMSec / 1000);

   int iRunRC=0,iAnim=0;
 
   // ----- single client accept loop -----
   while (!userInterrupt())
   {
      hClClient = accept(hClServer, (struct sockaddr *)&clClientAdr, &nSoLen);
      if (hClClient == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(50); continue; }
         perr("accept on server main port failed\n");
         iRunRC = 9;
         break;
      }
      setBlocking(hClClient, 1);

      strcpy(szClWorkDir, "/");

      // this is set if reply() fails to send
      bClSendFailed = 0;

      // set default mode compatible to old clients
      cs.verify = 1;

      // default for SFT version, may be downgraded:
      int nSFTVer = nDefSFTVer;

      // list IP of client machine
      struct in_addr addr;
      memcpy(&addr,&clClientAdr.sin_addr,sizeof(struct in_addr));
      char *premip = inet_ntoa(addr);
      num nnow = time(0);
      num tconstart = getCurrentTime();
      printf("> connect from %s on %s\n", premip, timeAsString(nnow,0));

      // login, pseudo-authentication
      if (reply("220 sfk instant ftp, %d sec timeout. sft %d.", cs.timeOutMSec / 1000, nSFTVer))
         { closesocket(hClClient); continue; }
      if (readLine()) { closesocket(hClClient); continue; } // > USER username
      removeCRLF(szLineBuf);

      char szClientUser[100],szClientPW[100];
      mclear(szClientUser);
      mclear(szClientPW);

      // expecting: "USER username".
      // if client uses a wrong protocol, we should detect it now.
      bool startsLikeHttpCommand(char *psz);
      if (startsLikeHttpCommand(szLineBuf)) {
         reply("500 wrong protocol (http), please use ftp://");
         shutdown(hClClient, SHUT_WR);
         closesocket(hClClient); continue;
      }
      if (stribeg(szLineBuf, "feat")) {
         reply("211-Features:");
         reply(" MDTM");
         reply(" SIZE");
         reply("211 End");
         if (readLine()) { closesocket(hClClient); continue; } // > USER username
         removeCRLF(szLineBuf);
      }
      if (strbeg(szLineBuf, "OPTS UTF8 ON")) { // just for windows junk ftp client
         reply("502 Command not implemented");
         if (readLine()) { closesocket(hClClient); continue; }
      }
      if (!stribeg(szLineBuf, "user ")) {
         reply("530 missing username");
         shutdown(hClClient, SHUT_WR);
         closesocket(hClClient); continue;
      }
      strcopy(szClientUser, szLineBuf+5);
      if (reply("331 User name ok, need password")) { closesocket(hClClient); continue; }
      if (readLine()) { closesocket(hClClient); continue; } // > PASS passwd
      removeCRLF(szLineBuf);

      if (!strncmp(szLineBuf, "PASS sft", 8)) {
         int nClientSFT = atol(szLineBuf+8);
         if (cs.quiet < 2)
            printf("> client speaks sft: %d\n", nClientSFT);
         char *pszPW = strchr(szLineBuf+8, '@');
         if (pszPW) strcopy(szClientPW, pszPW+1);
         // auto-adapt to client SFT version
         if (nClientSFT >= 101)
            nSFTVer = nClientSFT;
         if (nClientSFT >= 103) {
            // default since 103 is no verify,
            // may be changed by following SCHK.
            cs.verify = 0;
         }
      }
      else
      if (!strncmp(szLineBuf, "PASS ", 5))
         strcopy(szClientPW, szLineBuf+5);

      if (szClAuthUser[0])
      {
         if (!szClientUser[0]) {
            if (!cs.quiet)
               printf("> missing client username\n");
            reply("530 missing authentication.");
            continue;
         }
         if (strcmp(szClientUser, szClAuthUser)) {
            if (!cs.quiet)
               printf("> wrong client username (%s/%s)\n", szClientUser, szClAuthUser);
            reply("530 wrong authentication.");
            doSleep(1000);
            continue;
         }
         if (cs.verbose)
            printf("> client user ok.\n");
      }

      if (szClAuthPW[0])
      {
         if (!szClientPW[0]) {
            if (!cs.quiet)
               printf("> missing client pw\n");
            reply("530 missing authentication.");
            continue;
         }
         if (strcmp(szClientPW, szClAuthPW)) {
            if (!cs.quiet)
               printf("> wrong client pw\n");
            reply("530 wrong authentication.");
            doSleep(1000);
            continue;
         }
         if (!cs.quiet)
            printf("> client pw ok.\n");
      }
      // the RunPW, if any, is checked later.

      if (reply("230 User logged in")) { closesocket(hClClient); continue; }
      if (cs.quiet == 1)
         printf("> client connected.\n");

      // inits per client
      mclear(szClRenameFrom);

      // ----- client command loop -----
      int nbail = 0;
      while (!bClSendFailed && (nbail < 3))
      {
         int lTimeout = cs.timeOutMSec;
         num t1 = getCurrentTime();
         bool bOtherCon = 0;
         while (getCurrentTime() < t1 + lTimeout)
         {
            if (hasData(hClClient, 500))
               break;
            if (cs.autoclose && hasData(hClServer, 500)) {
               if (!cs.quiet)
                  printf("# new incoming connection, closing current\n");
               reply("226 closing connection due to new client");
               bOtherCon = 1;
               break;
            }
            if (userInterrupt())
               break;
            doSleep(10);
         }
         if (bOtherCon || userInterrupt())
            break;
         if (getCurrentTime() >= t1 + lTimeout) {
            reply("500 inactivity timeout (%d sec)", lTimeout/1000);
            if (cs.quiet == 1)
               printf("> client disconnected (timeout).\n");
            break;
         }

         // use readline without implicite skip processing
         if (readLineSub(hClClient, szLineBuf, 0)) break;
         if (cs.verbose >= 2) // sfk1934 ftpserv verbose input
            printf("- line: \"%s\"\n",dataAsTrace(szLineBuf,strlen(szLineBuf)));
         removeCRLF(szLineBuf);

         // per command inits
         mclear(szClAbsPathBuf);
         mclear(szClSysPathBuf);
         mclear(szClTmpPathBuf);
 
         if (stribeg(szLineBuf, "help")) { nbail=0;
            reply("214-Possible commands:");
            reply("   USER   PASS   QUIT   CWD    PWD    PORT   PASV");
            reply("   CDUP   RETR   STOR   SIZE   DELE   SYST   MDTM");
            reply("   LIST   NLST   MKD    RMD    RMTREE FEAT");
            reply("   TYPE  (only binary transfer supported)");
            reply("214 Command list end.");
            continue;
         }
         if (stribeg(szLineBuf, "feat")) { nbail=0;
            reply("211-Features:");
            reply(" SIZE");
            reply(" MDTM");
            reply("211 End");
            continue;
         }
         if (   stricase(szLineBuf, "NOOP")
             || stribeg(szLineBuf, "ALLO ")
            )
         {
            nbail=0;
            reply("200 OK");
            continue;
         }
         if (stribeg(szLineBuf, "SYST")) { nbail=0;
            reply("215 UNIX emulated by SFK.");
            continue;
         }
         if (stribeg(szLineBuf, "TYPE ")) { nbail=0;
            reply("200 Command OK");
            continue;
         }
         if (stribeg(szLineBuf, "SCHK ")) { nbail=0;
            int iMode = atoi(szLineBuf+5);
            if (iMode >= 0 && iMode < 2) {
               cs.verify = iMode ? 1 : 0;
               reply("200 CheckMode=%d", iMode);
            } else {
               reply("502 checkmode not supported");
            }
            continue;
         }
         if (   stribeg(szLineBuf, "PWD")
             || stribeg(szLineBuf, "XPWD")
            )
         {  nbail=0;
            reply("257 \"%s\" is current directory.", szClWorkDir);
            continue;
         }
         if (stribeg(szLineBuf, "SIZE ")) { nbail=0;
            num nFileSize=0;
            switch (mapPath(szLineBuf+5,1)) {
               case 1: continue;
               case 2: break;
               default:
                  nFileSize = getFileSize(sysPath());
            }
            if (nFileSize < 0)
               reply("550 no such file"); // sfk1872
            else
               reply("213 %s", numtoa(nFileSize));
            continue;
         }
         if (stribeg(szLineBuf, "MDTM ")) { nbail=0;
            // MDTM 20060604111037
            num nFileTime=0;
            bool bUTC=0;
            switch (mapPath(szLineBuf+5,1)) {
               case 1: continue;
               case 2:
                  reply("213 %s", timeAsString(0, 1, bUTC));
                  continue;
               default:
                  nFileTime = getFileTime(sysPath());
            }
            if (nFileTime <= 0)
               reply("550 no such file");
            else
               reply("213 %s", timeAsString(nFileTime, 1, bUTC));
            continue;
         }
         if (stricase(szLineBuf, "RETR /")) { nbail=0;
            reply("550 File not found");
            closesocket(hClData);
            hClData = INVALID_SOCKET;
            continue;
         }
         if (stribeg(szLineBuf, "CWD ")) { nbail=0; // since 104
            strcopy(szClOldWorkDir, szClWorkDir);
            char *pszRawPath = szLineBuf+4;
            if (   !strcmp(pszRawPath, ".")
                || !strncmp(pszRawPath, "./", 2)) {
               reply("550 Invalid dir");
               continue;
            }
            if (!strcmp(pszRawPath, "/")) {
               strcpy(szClWorkDir, "/");
               reply("250 CWD OK. \"%s\"", notslash(szClWorkDir));
               continue;
            }
            while (!strncmp(pszRawPath, "..", 2)) {
               char *psz = szClWorkDir+strlen(szClWorkDir);
               if (psz <= szClWorkDir)
                  break;
               if (psz[-1] == '/')
                  psz--;
               while (psz > szClWorkDir && psz[-1] != '/')
                  psz--;
               if (psz <= szClWorkDir+1) {
                  strcpy(szClWorkDir, "/");
               } else {
                  *psz = '\0';
               }
               pszRawPath += 2;
               if (*pszRawPath!='/')
                  break;
               pszRawPath++;
            }
            // cd .. or ../../.. to top level
            if (!strcmp(szClWorkDir, "/") && !pszRawPath[0]) {
               reply("250 CWD OK. \"%s\"", szClWorkDir);
               continue;
            }
            // cd ../ or ../../../ to any level
            if (!strcmp(pszRawPath, "/")) {
               reply("250 CWD OK. \"%s\"", szClWorkDir);
               continue;
            }
            // cd thedir /thedir ../thedir/subdir
            if (pszRawPath[0]) {
               switch (mapPath(pszRawPath,1)) {
                  case 1:
                     strcopy(szClWorkDir, szClOldWorkDir);
                     continue;
                  case 2:
                     strcpy(szClWorkDir, "/");
                     break;
                  default:
                     strcopy(szClWorkDir, absPath());
               }
            } else {
               if (!strcmp(szClWorkDir, "/"))
                  { }
               else
               if (szClWorkDir[0]!='/' || isPathTraversal(szClWorkDir+1, bDeep)) {
                  strcopy(szClWorkDir, szClOldWorkDir);
                  reply("550 Invalid dir");
                  continue;
               }
            }
            if (!isDir(sysPath(szClWorkDir))) {
               strcopy(szClWorkDir, szClOldWorkDir);
               reply("550 No such directory");
               continue;
            }
            addTrailSlash(szClWorkDir, sizeof(szClWorkDir));
            reply("250 CWD OK. \"%s\"", notslash(szClWorkDir));
            continue;
         }
         else
         if (   stricase(szLineBuf, "CDUP")
             || stricase(szLineBuf, "XCUP")
            )
         {  nbail=0; // since 104
            char *psz = strrchr(szClWorkDir, '/');
            if (psz!=0 && psz>szClWorkDir)
               *psz='\0';
            else
               strcpy(szClWorkDir, "/");
            reply("250 CWD OK. \"%s\"", notslash(szClWorkDir));
         }
         else
         if (   stribeg(szLineBuf, "MKD ")
             || stribeg(szLineBuf, "XMKD ")
            )
         {  nbail=0; // since 104
            if (!bRW) {
               reply("532 Write not allowed");
               continue;
            }
            char *pszRawDir = szLineBuf+4;
            if (stribeg(szLineBuf, "XMKD "))
                  pszRawDir = szLineBuf+5;
            switch (mapPath(pszRawDir,0,1)) { // w/disk space check
               case 1: continue;
               case 2:
                  reply("532 Write not allowed");
                  continue;
            }
            #ifdef _WIN32
            if (_mkdir(sysPath()))
            #else
            if (mkdir(sysPath(), S_IREAD | S_IWRITE | S_IEXEC))
            #endif
               reply("550 Cannot create. err=%d/%s",errno,strerror(errno));
            else
               reply("257 \"%s\" created.", absPath());
            continue;
         }
         else
         if (stribeg(szLineBuf, "PASV"))
         {
            nbail=0;
            // establish passive data connection server on demand
            if (hClPasServ == INVALID_SOCKET) {
               nPasPort = nPasvPort; // 0 to find new local port
               if (makeServerSocket(nPasPort, clPasServAdr, hClPasServ, "passive server port"))
                  break;
            }
            int   ihowmany = 1; // force first ip
            char *pszOwnIP = ownIPList(ihowmany, 0, "", 1); // PASV ownip
            char *psz = 0;
            while (psz = strchr(pszOwnIP, '.'))
               *psz = ',';
            if (cs.verbose)
               printf("- reply pasv with ip %s\n", pszOwnIP);
            if (reply("227 Entering Passive Mode (%s,%u,%u)",pszOwnIP,(nPasPort>>8),(nPasPort&0xFF)))
               break;
            if (hClData != INVALID_SOCKET)
               closesocket(hClData);

            if (cs.verbose)
               printf("- wait for accept on %s:%u\n", pszOwnIP, nPasPort);
            setStart();
            while (!isTimeout(3000))
            {
               nSoLen = sizeof(sockaddr_in);
               hClData  = accept(hClPasServ, (struct sockaddr *)&clClientAdr, &nSoLen);
               if (hClData == INVALID_SOCKET) {
                  int nerr = netErrno();
                  if (nerr == WSAEWOULDBLOCK) { doSleep(10); continue; }
                  perr("accept on passive port failed\n");
                  break;
               }
               else
                  break;
            }
            if (bClTimeout) { perr("accept timeout for passive port\n"); break; }
            setBlocking(hClData, 1);
            if (cs.verbose)
               printf("> accept done\n");

            if (hClData == INVALID_SOCKET)
               { perr("passive accept failed\n"); break; }
         }
         else
         if (stribeg(szLineBuf, "PORT "))
         {
            nbail=0;
            // establish active data connection
            uchar n[6];
            char *psz = szLineBuf+strlen("PORT ");
            for (int i=0; i<6; i++) {
               n[i] = (uchar)atol(psz);
               psz = strchr(psz+1, ',');
               if (psz) psz++; else break;
            }
            char szIP[50];
            sprintf(szIP, "%d.%d.%d.%d",n[0],n[1],n[2],n[3]);
            uint nPort = (((uint)n[4])<<8)|((uint)n[5]);
            if (connectSocket(szIP, nPort, clDataAdr, hClData, "active data")) break;
            reply("200 Okay");
         }
         else
         if (   stribeg(szLineBuf, "LIST")   // ftp.list: ftp full detail
            )
         {
            if (hClData == INVALID_SOCKET) {
               reply("503 Wrong command sequence");
               continue;
            }

            int lRC=0,nbail=0;
 
            char *pszAbsDir = szClWorkDir;
            char *pszParm = szLineBuf+4;
            bool  bstop = 0;
            bool  bhidden = 0;
            while (!bstop && *pszParm) {
               skipWhite(&pszParm);
               if (!strcmp(pszParm, "-a"))
                  { pszParm+=2; bhidden=1; continue; }
               if (strBegins(pszParm, "-a "))
                  { pszParm+=3; bhidden=1; continue; }
               if (!strcmp(pszParm, "-la")) { // sfk176
                  pszParm+=3;
                  if (*pszParm==' ')
                     pszParm++;
                  bhidden=1;
                  continue;
               }
               if (pszParm[0]=='-') {
                  reply("501 unsupported option: %s", pszParm);
                  bstop=1;
                  break; // fix sfk176 endless loop
               }
               // dir or file parameter from client
               switch (mapPath(pszParm,1)) {
                  case 1: bstop=1; continue;
                  default:
                     pszAbsDir = absPath();
                     break;
               }
               break;
            }
            if (bstop) continue;

            // list the dir.
            char *pszSys = str(glblPathStr);
            if (!strcmp(pszAbsDir, "/") && iClVDir) {
               // virtual dir list
               if (reply("150 Listing Directory %s", pszAbsDir)) break;
               hGlblTCPOutSocket = hClData;
               for (int i=0; i<iClVDir; i++) {
                  char *pvdir = aClVDirSrc[i];
                  char *pvdst = aClVDirDst[i];
                  if (*pvdir!='/') continue;
                  strcopy(szClTmpPathBuf, pvdir+1);
                  stripTrailSlash(szClTmpPathBuf, '/'); // vdir
                  strcopy(szClTmpPathBuf2, pvdst);
                  stripTrailSlash(szClTmpPathBuf2, glblPathChar); // sysdir
                  execVDirFTPList(szClTmpPathBuf, szClTmpPathBuf2);
               }
            } else {
               // real file list
               if (*pszAbsDir!='/')
                  { reply("550 invalid work dir"); continue; }
               if (!(pszSys = sysPath(pszAbsDir)))
                  { reply("550 invalid work dir"); continue; }
               if (setLocalWalkDir(pszSys))
                  continue;
 
               cs.subdirs = 0;
               cs.withrootdirs = 0;
               cs.hidden = bhidden;
 
               if (reply("150 Listing Directory %s", pszAbsDir)) break;
 
               bGlblFTPListFlatTS = 0;  // ux style time stamps
               bGlblFTPListTextBin = 0; // no text/binary info
 
               int lFiles=0, lDirs=0;
               num nBytes=0;
               hGlblTCPOutSocket = hClData;
               lRC = walkAllTrees(eFunc_FTPList, lFiles, lDirs, nBytes);
            }

            closesocket(hClData); hClData = INVALID_SOCKET;

            if (cs.verbose) {
               if (lRC==0 && cs.verbose>1)
                  printf("- done list \"%s\"\n", pszSys);
               if (lRC!=0)
                  printf("- done list, rc=%d: \"%s\"\n", lRC, pszSys);
            }

            reply("226 Closing data connection");
         }
         else
         if (stribeg(szLineBuf, "NLST")) // ftp.list: ftp no detail
         {
            if (hClData == INVALID_SOCKET) {
               reply("503 Wrong command sequence");
               continue;
            }

            int lRC=0,nbail=0;

            char *pszAbsDir = szClWorkDir;
            char *pszParm = szLineBuf+4;
            bool  bstop = 0;
            bool  bhidden = 0;
            while (!bstop && *pszParm) {
               skipWhite(&pszParm);
               if (!strcmp(pszParm, "-a"))
                  { pszParm+=2; bhidden=1; continue; }
               if (strBegins(pszParm, "-a "))
                  { pszParm+=3; bhidden=1; continue; }
               if (pszParm[0]=='-') {
                  reply("501 unsupported option: %s", pszParm);
                  continue;
               }
               // dir or file parameter from client
               switch (mapPath(pszParm,1)) {
                  case 1: bstop=1; continue;
                  default:
                     pszAbsDir = absPath();
                     break;
               }
               break;
            }
            if (bstop) continue;

            // list the dir.
            char *pszSys = str(glblPathStr);
            if (!strcmp(pszAbsDir, "/") && iClVDir) {
               // virtual dir list
               if (reply("150 Listing Directory %s", pszAbsDir)) break;
               // nothing to do - vdir has no files
            } else {
               // real file list
               if (*pszAbsDir!='/')
                  { reply("550 invalid work dir"); continue; }
               if (!(pszSys = sysPath(pszAbsDir)))
                  { reply("550 invalid work dir"); continue; }
               if (setLocalWalkDir(pszSys))
                  continue;
 
               cs.subdirs = 0;
               cs.withrootdirs = 0;
               cs.hidden = bhidden;
 
               if (reply("150 Listing Directory %s", pszAbsDir)) break;

               bGlblFTPListFlatTS = 0;  // ux style time stamps
               bGlblFTPListTextBin = 0; // no text/binary info

               int lFiles=0, lDirs=0;
               num nBytes=0;
               hGlblTCPOutSocket = hClData;
               lRC = walkAllTrees(eFunc_FTPNList, lFiles, lDirs, nBytes);
            }

            closesocket(hClData); hClData = INVALID_SOCKET;

            if (cs.verbose) {
               if (lRC==0 && cs.verbose>1)
                  printf("- done list \"%s\"\n", pszSys);
               if (lRC!=0)
                  printf("- done list, rc=%d: \"%s\"\n", lRC, pszSys);
            }

            reply("226 Closing data connection");
         }
         else
         if (stribeg(szLineBuf, "RETR "))
         {
            nbail=0;
            if (hClData == INVALID_SOCKET) {
               reply("500 internal error 1");
               continue;
            }
            // send file
            strcpy(szLineBuf2, szLineBuf);
            if (!mapPath(szLineBuf2+5)) {
               reply("150 Sending File");
               if (cs.quiet < 2)
                  printf("send file: \"%s\"\n", absPath());
               int lRC = sendFileRaw("ftp", hClData, sysPath());
               if (cs.quiet < 2)
                  printf("send file done, RC %d\n", lRC);
               if (cs.notifyto) // sftserv.get
                  sendNotifyStatus(cs.notifyto, 2); // down
            }
            closesocket(hClData); hClData = INVALID_SOCKET;
            reply("226 Closing data connection");
         }
         else
         if (stribeg(szLineBuf, "STOR "))
         {
            nbail=0;
            if (hClData == INVALID_SOCKET) {
               reply("500 internal error 2");
               continue;
            }
            int iSubRC = 0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW)
               reply("532 Write not allowed");
            else
            if (!mapPath(szLineBuf2+5,0,1)) { // w/disk space check
               if (reply("150 Receiving File")) break;
               if (cs.verbose)
                  printf("> recv file: \"%s\"\n", absPath());
               iSubRC = receiveFileRaw("ftp", hClData, sysPath(), -1, 0,0,0, nClDiskFree); // stor
               if (cs.verbose || iSubRC)
                  printf("> recv file done, RC %d\n", iSubRC);
               if (cs.notifyto) // sftserv.put
                  sendNotifyStatus(cs.notifyto, 1); // up
            }
            closesocket(hClData); hClData = INVALID_SOCKET;
            if (iSubRC)
               replyFromRC(iSubRC);
            else
               reply("226 Closing data connection");
         }
         else
         if (stribeg(szLineBuf, "RNFR ")) // since 104
         {
            nbail=0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW) {
               reply("532 Write not allowed");
               continue;
            }
            // remember rename source name
            if (mapPath(szLineBuf2+5))
               continue;
            if (!fileExists(sysPath(), 1)) {
               reply("550 file not found: %s", absPath());
               continue;
            }
            strcopy(szClRenameFrom, sysPath());
            reply("350 File exists, please send target name.");
         }
         else
         if (stribeg(szLineBuf, "RNTO ")) // since 104
         {
            nbail=0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW) {
               reply("532 Write not allowed");
               mclear(szClRenameFrom);
               continue;
            }
            if (mapPath(szLineBuf2+5)) {
               mclear(szClRenameFrom);
               continue;
            }
            if (fileExists(sysPath(), 1)) {
               reply("550 file exists: %s", absPath());
               mclear(szClRenameFrom);
               continue;
            }
            if (!szClRenameFrom[0]) {
               reply("503 Bad command sequence");
               mclear(szClRenameFrom);
               continue;
            }
            int iSubRC = rename(szClRenameFrom, sysPath());
            if (iSubRC)
               reply("550 rename failed (%s)", mystrerr());
            else
               reply("250 rename successful");
            mclear(szClRenameFrom);
         }
         else
         if (stribeg(szLineBuf, "DELE ")) // since 104
         {
            nbail=0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW) {
               reply("532 Write not allowed");
               continue;
            }
            // delete file
            if (mapPath(szLineBuf2+5))
               continue;
            int iSubRC = remove(sysPath());
            if (iSubRC)
               reply("550 delete failed (%s)", mystrerr());
            else
               reply("250 OK DELETED");
         }
         else
         if (   stribeg(szLineBuf, "RMD ") // since 104
             || stribeg(szLineBuf, "XRMD ")
            )
         {
            // standard behaviour of RMD is to delete the dir only
            // if it's empty. ftp clients have high effort to walk
            // through everything to delete a directory tree.

            nbail=0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW) {
               reply("532 Write not allowed");
               continue;
            }
            // delete directory tree
            char *pszRawDir = szLineBuf2+4;
            if (stribeg(szLineBuf, "XRMD "))
                  pszRawDir = szLineBuf2+5;
            if (mapPath(pszRawDir))
               continue;
            // RMD thedir/
            char *pszDir = sysPath();
            if (!isDir(pszDir)) {
               reply("550 no such directory");
               continue;
            }

            int nrc = rmdir(pszDir);
            if (nrc)
               reply("300 DELETE FAILED. err=%d,%s. (try rmtree?)", errno, strerror(errno));
            else
               reply("250 OK DELETED");
         }
         else
         if (stribeg(szLineBuf, "RMTREE ")) // sfk only, since sft 107
         {
            // especially for interactive command line clients,
            // SFK server allows to remove a dir tree instantly.

            nbail=0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW) {
               reply("532 Write not allowed");
               continue;
            }
            // delete directory tree
            if (mapPath(szLineBuf2+7))
               continue;
            // RMD thedir/
            char *pszDir = sysPath();
            if (!isDir(pszDir)) {
               reply("550 no such directory");
               continue;
            }

            if (setLocalWalkDir(pszDir))
               continue;

            cs.subdirs  = 1;
            cs.withdirs = 1;
            cs.hidden   = 1;

            int lFiles=0,lDirs=0; num nBytes=0;
            if (walkAllTrees(eFunc_Delete, lFiles, lDirs, nBytes))
               reply("300 DELETE INCOMPLETE");
            else
               reply("250 OK DELETED");
         }
         else
         if (stribeg(szLineBuf, "QUIT")) { nbail=0;
            reply("221 Goodbye."); // sfk185
            break;
         }
         else
         if (   stribeg(szLineBuf, "SGET ")
             || stribeg(szLineBuf, "SOPEN ")
            )
         {
            nbail = 0;

            bool bBlockMode = 0;

            // save linebuf as it's reused below
            char *pszRelFile = szLineBuf+5;
            if (strBegins(szLineBuf, "SOPEN ")) {
                 bBlockMode = 1;
                 pszRelFile = szLineBuf+6;
            }
            if (mapPath(pszRelFile))
               continue;

            // sft file retrieve, within control connection
            char *pszLocFile = sysPath();
            if (!fileExists(pszLocFile))
               { reply("550 no such file, or unreadable"); continue; }

            reply("200 OK, data follows");

            {
               // sending a file from server to client by SFT: here, the ack "OK\n\n"
               // is often overhauled by connection close from client, therefore server
               // doesn't verify it. should there be errors, then they're shown at client only.
               Coi *pcoi = new Coi(pszLocFile, 0);
               CoiAutoDelete odel(pcoi, 0); // no decref
               int lRC = putFileBySFT(hClClient, pcoi, nSFTVer, 0, 1, bBlockMode); // not quiet, ignore ack
               if (cs.quiet < 2 && lRC > 0)
                  info.print("send sft file done, RC %d\n", lRC);
               if (cs.notifyto) // sftserv.get
                  sendNotifyStatus(cs.notifyto, 2); // down
            }
         }
         else
         if (stribeg(szLineBuf, "SPUT ")) { nbail=0;
            if (!bRW)
               reply("532 Write not allowed");
            else {
               // sft receive file, via control connection
               strcpy(szLineBuf2, szLineBuf);
               if (mapPath(szLineBuf2+5,0,1)) // w/disk space check
                  continue;
               if (bDeep)
                  createOutDirTree(sysPath()); // sput
               if (Coi::forceWriteable(sysPath()) >= 9) {
                  reply("500 cannot write: %s", absPath());
                  // break;
               } else {
                  reply("200 OK, send data");
                  // if (cs.quiet < 2)
                  //    printf("> recv sft file: \"%s\"\n", pszFile);
                  int lRC = getFileBySFT(hClClient, sysPath(), nSFTVer, 0,0,nClDiskFree);
                  if (cs.quiet < 2 && lRC > 0)
                     info.print("recv sft file done, RC %d\n", lRC);
                  if (lRC) break; // block potential content remainder
                  if (cs.notifyto) // sftserv.put
                     sendNotifyStatus(cs.notifyto, 1); // up
               }
            }
            // getFileBySFT includes ack send
         }
         else
         if (   stribeg(szLineBuf, "SLST") // ftp.list: sft full detail
             || stribeg(szLineBuf, "SLSB") // with text/binary info
            )
         {
            int lRC=0,nbail=0;

            // since SFT 105: no text/binary infos by default.
            // if client wants those, SLSB is required.
            bool bWithTextBin = stribeg(szLineBuf, "SLSB") ? 1 : 0;

            char *pszAbsDir = szClWorkDir;
            char *pszParm = szLineBuf+4;
            bool  bstop = 0;
            bool  bhidden = 0;
            while (!bstop && *pszParm) {
               skipWhite(&pszParm);
               if (!strcmp(pszParm, "-a"))
                  { pszParm+=2; bhidden=1; continue; }
               if (strBegins(pszParm, "-a "))
                  { pszParm+=3; bhidden=1; continue; }
               if (pszParm[0]=='-') {
                  reply("501 unsupported option: %s", pszParm);
                  continue;
               }
               // dir or file parameter from client
               switch (mapPath(pszParm,1)) {
                  case 1: bstop=1; continue;
                  default:
                     pszAbsDir = absPath();
                     break;
               }
               break;
            }
            if (bstop) continue;

            // list the dir.
            char *pszSys = str(glblPathStr);
            if (!strcmp(pszAbsDir, "/") && iClVDir) {
               // virtual dir list
               if (reply("150 Listing Directory %s", pszAbsDir)) break;
               hGlblTCPOutSocket = hClClient;
               for (int i=0; i<iClVDir; i++) {
                  char *pvdir = aClVDirSrc[i];
                  char *pvdst = aClVDirDst[i];
                  if (*pvdir!='/') continue;
                  strcopy(szClTmpPathBuf, pvdir+1);
                  stripTrailSlash(szClTmpPathBuf, '/'); // vdir
                  strcopy(szClTmpPathBuf2, pvdst);
                  stripTrailSlash(szClTmpPathBuf2, glblPathChar); // sysdir
                  execVDirFTPList(szClTmpPathBuf, szClTmpPathBuf2);
               }
            } else {
               // real file list
               if (*pszAbsDir!='/')
                  { reply("550 invalid work dir"); continue; }
               if (!(pszSys = sysPath(pszAbsDir)))
                  { reply("550 invalid work dir"); continue; }
               if (setLocalWalkDir(pszSys))
                  continue;
 
               cs.subdirs = 0;
               cs.withrootdirs = 0;
               cs.hidden = bhidden;
 
               if (reply("150 Listing Directory %s", pszAbsDir)) break;
 
               bGlblFTPListFlatTS = 1;  // flat time stamps
               bGlblFTPListTextBin = bWithTextBin;
 
               int lFiles=0, lDirs=0;
               num nBytes=0;
               hGlblTCPOutSocket = hClClient;
               lRC = walkAllTrees(eFunc_FTPList, lFiles, lDirs, nBytes);
            }

            if (cs.verbose) {
               if (lRC==0 && cs.verbose>1)
                  printf("- done list \"%s\"\n", pszSys);
               if (lRC!=0)
                  printf("- done list, rc=%d: \"%s\"\n", lRC, pszSys);
            }

            reply("226 Listing done");
         }
         else
         if (stribeg(szLineBuf, "SRUN")) { nbail=0;
            // execute user command, IF -run option was set
            if (!bRun)
               reply("500 run forbidden");
            else
            if (!szClientPW[0] || !szClRunPW[0])
               reply("530 run requires authentication");
            else
            if (strcmp(szClientPW, szClRunPW)) {
               if (cs.verbose)
                  printf("/%s/%s/\n",szClientPW, szClRunPW);
               reply("530 wrong run authentication");
            }
            else
            {
               int lRC = system(szLineBuf+5);
               reply("200 Run Done, RC %d", lRC); // 226, 250
            }
         }
         else
         if (stribeg(szLineBuf, "RERUN")) // sft server
         {
            nbail=0;
            // execute user command, IF -run option was set
            if (!bRun)
               reply("500 run forbidden");
            else
            if (!szClientPW[0] || !szClRunPW[0])
               reply("530 run requires authentication");
            else
            if (strcmp(szClientPW, szClRunPW)) {
               if (cs.verbose)
                  printf("/%s/%s/\n",szClientPW, szClRunPW);
               reply("530 wrong run authentication");
            }
            else
            {
               char *psz = szLineBuf+6;

               psz = safeRunCommand(psz); // redirect stderr

               // sfk1972 rerun with new runtime sft

               #ifdef _WIN32
               FILE *pPipe = _popen(psz, "r");
               #else
               FILE *pPipe = popen(psz, "r");
               #endif
            
               if (!pPipe)
                  reply("500 Rerun Error, cannot start");
               else
               {
                  char szDataBuf[4000+100];
                  int  iDataBufSize=4000;
                  int  ierr=0;

                  myfgets_init();

                  while (1)
                  {
                     mclear(szDataBuf);
                     int iHeadSize = 17;
   
                     int iread = myfgets(szDataBuf+iHeadSize, iDataBufSize-iHeadSize, pPipe);
                     if (iread <= 0)
                        break;

                     // send two records in one go:
                     // -  control text record
                     // -  data record of defined length
                     sprintf(szDataBuf, "199 PRINT %05u", iread);
                     if (cs.verbose) {
                        szDataBuf[iHeadSize-2] = '.'; // just for verbose info
                        szDataBuf[iHeadSize-1] = '.'; // just for verbose info
                        printf("< send %d: \"%.30s\"\n",iHeadSize+iread, szDataBuf);
                     }
                     szDataBuf[iHeadSize-2] = '\r';
                     szDataBuf[iHeadSize-1] = '\n';
                     int isent = send(hClClient, szDataBuf, iHeadSize+iread, 0);
                     if (isent != iHeadSize+iread) {
                        printf("< cannot send fully (%d/%d)\n",isent,iHeadSize+iread);
                        ierr = 1;
                        break;
                     }
                  }
               
                  #ifdef _WIN32
                  int isubrc = _pclose(pPipe);
                  #else
                  int isubrc = pclose(pPipe);
                  #endif

                  if (ierr)
                     reply("500 Rerun Error, failed to send reply");
                  else
                     reply("200 Rerun Done, RC %d", isubrc); // 226, 250
               }
            }
         }
         else
         if (!strncmp(szLineBuf, "SKIP ", 5)) { nbail=0;
            // dummy record follows, to enforce line flush.
            // should be far smaller than abBuf.
            uint nLen = (uint)atol(szLineBuf+5);
            if (nLen > sizeof(abBuf)-10) nLen = sizeof(abBuf)-10;
            if (nLen) receiveBlock(hClClient, abBuf, nLen, "SKIP");
            // no ack sending
         }
         else {
            if (reply("500 not supported: \"%.32s\"%s", szLineBuf,
                      strlen(szLineBuf)>32 ? "...":""))
               break;
            // count invalid command, maybe connection is out of control:
            nbail++;
            // on 3rd invalid command, connection will be dropped.
         }
      }  // endwhile

      if (cs.quiet < 2) {
         num nnow2 = time(0);
         printf("< disconnecting client on %s after %d sec.\n",
            timeAsString(nnow2,0),
            (int)(getCurrentTime()-tconstart)/1000);
      }
      closesocket(hClClient);
   }

   closesocket(hClServer);

   #ifdef _WIN32
   // WSACleanup(); // sfk1840 only on process exit
   #endif

   return iRunRC;
}

#endif // WITH_TCP

#ifndef USE_SFK_BASE

class TestDB
{
public:
   TestDB   (char *pszFile);
  ~TestDB   ( );
   int     load     (bool bSilent);
   int     write    ( );
   void     shutdown ( );

   int     update   (char *pszInKey, char *pszInVal);
   char    *getValue (char *pszInKey);

private:
   char  *pszClFile;
   StringTable clKeys;
   StringTable clVals;
};

TestDB::TestDB(char *pszFile)
{
   pszClFile = strdup(pszFile);
}

TestDB::~TestDB() { shutdown(); }

void TestDB::shutdown() {
   if (pszClFile) { delete [] pszClFile; pszClFile = 0; }
}

// uses szLineBuf
int TestDB::load(bool bSilent) {
   FILE *fin = fopen(pszClFile, "r");
   if (!fin) {
      if (!bSilent)
         perr("unable to load %s\n", pszClFile);
      return 9;
   }
   int nLine = 0;
   while (fgets(szLineBuf, sizeof(szLineBuf)-10, fin)) {
      nLine++;
      removeCRLF(szLineBuf);
      char *psz = strchr(szLineBuf, ':');
      if (!psz) {
         perr("wrong record format in %s line %d\n", pszClFile, nLine);
         fclose(fin);
         return 9;
      }
      *psz = '\0';
      char *pszVal = psz+1;
      char *pszKey = szLineBuf;
      clKeys.addEntry(pszKey);
      clVals.addEntry(pszVal);
   }
   fclose(fin);
   return 0;
}

int TestDB::write() {
   FILE *fout = fopen(pszClFile, "w");
   if (!fout) return 9+perr("unable to write %s\n", pszClFile);
   int nRec = clKeys.numberOfEntries();
   for (int i=0; i<nRec; i++) {
      char *pszKey = clKeys.getEntry(i, __LINE__);
      char *pszVal = clVals.getEntry(i, __LINE__);
      if (!pszKey || !pszVal) { fclose(fout); return 9; }
      fprintf(fout, "%s:%s\n", pszKey, pszVal);
   }
   fclose(fout);
   return 0;
}

int TestDB::update(char *pszInKey, char *pszInVal) {
   int nRec = clKeys.numberOfEntries();
   for (int i=0; i<nRec; i++) {
      char *pszKey = clKeys.getEntry(i, __LINE__);
      char *pszVal = clVals.getEntry(i, __LINE__);
      if (!pszKey || !pszVal) return 9;
      if (!strcmp(pszKey, pszInKey)) {
         clVals.setEntry(i, pszInVal);
         return 0;
      }
   }
   // not yet contained:
   clKeys.addEntry(pszInKey);
   clVals.addEntry(pszInVal);
   return 0;
}

char *TestDB::getValue(char *pszInKey) {
   int nRec = clKeys.numberOfEntries();
   for (int i=0; i<nRec; i++) {
      char *pszKey = clKeys.getEntry(i, __LINE__);
      char *pszVal = clVals.getEntry(i, __LINE__);
      if (!pszKey || !pszVal) return 0;
      if (!strcmp(pszKey, pszInKey))
         return pszVal;
   }
   return 0;
}

#endif // USE_SFK_BASE

#ifndef USE_SFK_BASE
extern int patchMain(int argc, char *argv[], int noffs);
#endif // USE_SFK_BASE

// flags: bit 0: convert also \, to ,
// flags: bit 1: ignore cs.spat, assume -spat and -strict
int copyFormStr(char *pszDst, int nMaxDst, char *pszSrc, int nSrcLen, uint nflags)
{
   // printf("copyFormStr \"%.*s\" %d spat=%d\n",(int)nSrcLen,pszSrc,nflags,cs.spat);

   int ispat = cs.spat;

   if (nflags & 2)
       ispat = 1;

   char *pszin = pszSrc;
   int iout = 0;
   while (*pszin && (nSrcLen > 0))
   {
      if (iout >= nMaxDst-10)
         return 9+perr("format string too long: \"%s\"\n", pszSrc);

      if (!ispat)
         { } // skip all following interpretations
      else
      if (nSrcLen>=4 && !strncmp(pszin, "\\x", 2)) {
         // \xnn - any character with hex code nn
         pszin+=2; nSrcLen-=2; // skip \x
         int nhex = getTwoDigitHex(pszin);
         if (nhex <= 0) return 9+perr("illegal value for \\xnn in format string. use 01 to FF, e.g. \\x09\n");
         pszin+=2; nSrcLen-=2; // skip nn
         pszDst[iout++] = (char)nhex;
         continue;
      }
      else
      if (ispat==2 && nSrcLen>=5 && !strncmp(pszin, "\\d", 2)) {
         // \dnnn - any character with decimal code nnn
         pszin+=2; nSrcLen-=2; // skip \d
         int ndec = getThreeDigitDec(pszin);
         if (ndec <= 0) return 9+perr("illegal value for \\dnnn in format string. use 001 to 255, e.g. \\d065\n");
         pszin+=3; nSrcLen-=3; // skip nnn
         pszDst[iout++] = (char)ndec;
         continue;
      }
      else
      if (nSrcLen>=2) {
         if (!strncmp(pszin, "\\\\", 2))
            { pszDst[iout++] = '\\'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\t", 2))
            { pszDst[iout++] = '\t'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\q", 2))
            { pszDst[iout++] = '"'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\n", 2))
            { pszDst[iout++] = '\n'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\r", 2))
            { pszDst[iout++] = '\r'; pszin+=2; nSrcLen-=2; continue; }
         else
         if ((nflags & 1) && !strncmp(pszin, "\\,", 2))
            { pszDst[iout++] = ','; pszin+=2; nSrcLen-=2; continue; }
      }
      if ((nflags & 2) != 0 && *pszin == '\\')
         return 9+perr("invalid slash pattern: %s\n", pszin);
      pszDst[iout++] = *pszin++;
      nSrcLen--;
   }
   pszDst[iout] = '\0';
   // printf("-> \"%s\"\n",pszDst);
   return 0;
}

// .
int decodeHex(char *pszSrc, int iSrcLen, char *pszDst, int iMaxDest, char cPrefix)
{
   char  ahex[10];
   uchar abin[10];
   char  *psz=pszSrc;
   char  *pszMax=psz+iSrcLen;

   char  *pDstCur=pszDst;
   char  *pDstMax=pszDst+(iMaxDest-10);

   int  istatedef=1;
   if (cPrefix==0)
        istatedef=2;
   int  istate=istatedef;

   for (;psz<pszMax;psz++)
   {
      if (pDstCur >= pDstMax) {
         if (!cs.quiet)
            perr("buffer overflow on hex decode: %.40s\n", pszSrc);
         return -2;
      }

      // with pure hex, skip all whitespace
      if (cPrefix==0 && isspace(*psz)!=0)
         continue;

      // with prefixed hex, skip line ends,
      // as they must be encoded like _0d_0a
      if (cPrefix!=0 && (*psz=='\r' || *psz=='\n'))
         continue;

      switch (istate) 
      {
         case 1: // search prefix
            if (*psz!=cPrefix) {
               *pDstCur++ = *psz;
               continue;
            }
            istate=2;
            continue;

         case 2: // collect 1st hex digit
            ahex[0] = *psz;
            istate=3;
            continue;

         case 3: // collect 2nd hex digit
            ahex[1] = *psz;
            ahex[2] = '\0';
            if (hexToBin(ahex,abin,1)) {
               if (!cs.quiet)
                  perr("invalid hex code: \"%s\" (%02x %02x)\n", ahex, ahex[0], ahex[1]);
               return -1;
            }
            *pDstCur++ = (char)abin[0];
            istate=istatedef;
            continue;
      }
   }

   *pDstCur='\0';

   return (int)(pDstCur-pszDst);
}

int encodeHex(uchar *pszSrc, int iSrcLen, char *pszDst, int iMaxDest, char cPrefix, char *abToEncode)
{
   char  ahex[10];
   uchar abin[10];

   int   iSrcCur=0;
   char  *pDstCur=pszDst;
   char  *pDstMax=pszDst+(iMaxDest-10);

   for (;iSrcCur<iSrcLen;iSrcCur++)
   {
      if (pDstCur >= pDstMax) {
         if (!cs.quiet)
            perr("buffer overflow on %chex encode: %.40s\n", cPrefix?cPrefix:' ', pszSrc);
         return -2;
      }

      uchar uc = pszSrc[iSrcCur];

      if (abToEncode != 0 && abToEncode[uc] == 0) {
         *pDstCur++ = (char)uc;
         continue;
      }

      if (cPrefix!='\0') {
         sprintf(pDstCur,"%c%02X",cPrefix,uc);
         pDstCur += 3;
      } else {
         sprintf(pDstCur,"%02X",uc);
         pDstCur += 2;
      }
   }

   *pDstCur='\0';

   return (int)(pDstCur-pszDst);
}

// -------- base64 en/decoding ----------

// also used by makepw w/o last 2 chars
static const char aenc64[] =
   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
   "0123456789+/";

void encodeSub64(uchar in[3], uchar out[4], int nlen)
{
   out[0] = aenc64[in[0] >> 2];
   out[1] = aenc64[((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
   out[2] = (uchar)(nlen > 1 ? aenc64[((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6)] : '=');
   out[3] = (uchar)(nlen > 2 ? aenc64[in[2] & 0x3f ] : '=');
   #if 0
   printf("EIN : %u %u %u\n",in[0],in[1],in[2]);
   printf("EOUT: %u %u %u %u %c %c %c %c\n",
      out[0],out[1],out[2],out[3],
      out[0],out[1],out[2],out[3]
      );
   #endif
}

void decodeSub64(uchar in[4], uchar out[3])
{
   out[0] = (uchar)(in[0] << 2 | in[1] >> 4);
   out[1] = (uchar)(in[1] << 4 | in[2] >> 2);
   out[2] = (uchar)(((in[2] << 6) & 0xc0) | in[3]);
   #if 0
   printf("DIN : %u %u %u %u\n",in[0],in[1],in[2],in[3]);
   printf("DOUT: %u %u %u\n",out[0],out[1],out[2]);
   #endif
}

// rc  0: ok
// rc >0: error
int encode64(uchar *psrc, int nsrc, uchar *pdst, int nmaxdst, int nlinechars)
{
   uchar in[3], out[4];
   int i=0, nlen=0, nchars = 0;
   mclear(in);
   mclear(out);

   uchar *pmaxsrc = psrc + nsrc;
   uchar *pmaxdst = pdst + nmaxdst;
 
   while (psrc < pmaxsrc)
   {
      nlen = 0;
      for (i = 0; i < 3; i++ )
      {
         if (psrc < pmaxsrc) {
            in[i] = *psrc++;
            nlen++;
         } else {
            in[i] = 0;
         }
      }
      if (nlen) {
         encodeSub64(in, out, nlen);
         for (i = 0; i < 4; i++ ) {
            if (pdst >= pmaxdst-1) {
               perr("output buffer overflow (%d)\n",nmaxdst);
               return 9;   // output buffer overflow
            }
            *pdst++ = out[i];
         }
         nchars++;
      }
      if (   (nlinechars>0 && nchars >= (nlinechars/4))
          || (psrc >= pmaxsrc)
         ) 
      {
         if (nchars) {
            if (pdst < pmaxdst-3) {
               *pdst++ = '\r';
               *pdst++ = '\n';
            }
         }
         nchars = 0;
      }
   }

   // zero terminate output as it's a string
   *pdst = '\0';

   return 0;
}

// rc 0: no change
// else: szTopURLBuf
// uses: szLineBuf
bool encodeURL(char *pszRaw)
{
   char abToEncode[256]; // sfk1854 url blank encoding
   mclear(abToEncode);
   abToEncode[32] = 1;

   mclear(szLineBuf);

   // http://foo.com/the bar.txt
   char *ptmp = strstr(pszRaw, "//");
   if (!ptmp) return 0;

   ptmp += 2;
   ptmp = strchr(ptmp, '/');
   if (!ptmp) return 0;

   // on "/the bar.txt"
   if (!strchr(ptmp, ' ')) return 0;

   if (encodeHex((uchar*)ptmp, strlen(ptmp), szLineBuf, MAX_LINE_LEN, '%', abToEncode) < 0)
      return 0; // buffer overflow

   snprintf(szTopURLBuf, MAX_LINE_LEN, "%.*s%s",
      (int)(ptmp-pszRaw), pszRaw, szLineBuf);

   if (cs.debug)
      printf("encoded: %s\n", szTopURLBuf);

   // http://fo.com/the%20bar.txt
   return 1;
}

// return valid value+1, or 0 if it is noise.
uchar mapchar(char ch)
{
   if ((ch >= 'A') && (ch <= 'Z'))
      return (uchar)(ch - 'A')+1;
   else if ((ch >= 'a') && (ch <= 'z'))
      return (uchar)(ch - 'a' + 26)+1;
   else if ((ch >= '0') && (ch <= '9'))
      return (uchar)(ch - '0' + 52)+1;
   else if (ch == '+')
      return 62+1;
   else if (ch == '/')
      return 63+1;
   return 0;
}

// result: number of bytes decoded, or -1 on error
int decode64(uchar *psrc, int nsrc, uchar *pdst, int nmaxdst)
{
   uchar in[4], out[3], v;
   int i=0, nlen=0;
   mclear(in);
   mclear(out);
 
   uchar *pmaxsrc = psrc + nsrc;
   uchar *pmaxdst = pdst + nmaxdst;
   uchar *pdstraw = pdst;

   while (psrc < pmaxsrc) {
      for (nlen=0, i=0; i < 4 && (psrc < pmaxsrc); i++ ) {
         v = 0;
         while ((psrc < pmaxsrc) && v == 0) {
            v = *psrc++;
            v = mapchar(v);
         }
         if (psrc <= pmaxsrc) {
            if (v) {
               nlen++;
               in[i] = v - 1;
            } else {
               in[i] = 0;
            }
         } else {
            in[i] = 0;
         }
      }
      if (nlen) {
         decodeSub64(in, out);
         for (i=0; i<nlen-1; i++) {
            if (pdst >= pmaxdst)
               return -1;
            *pdst++ = out[i];
         }
      }
   }

   // no zero termination as it's a binary

   return pdst - pdstraw;
}

// convert "*pattern" or "pattern*" to pattern with left/right flags isolated.
int copyMatchPattern(char *pszDst, int nMaxDst, char *pszSrc, int &rSrcLen,
   bool &rFromLeft, bool &rToRight, bool &rForceRepeat
   )
{
   rFromLeft = 0;
   rToRight  = 0;
   int icopyoff  = 0;
   int nSrcLen   = rSrcLen;
   int ncopylen  = nSrcLen;
   if (cs.wpat && pszSrc[0] == '*') {
      rFromLeft = 1;
      rForceRepeat = 1;
      icopyoff++;
      ncopylen--;
   }
   if (cs.wpat && ncopylen > 0 && pszSrc[nSrcLen-1] == '*') {
      int nslash = 0;
      if (cs.spat) {
         // the '*' might be escaped, as in \\\\\*
         // if there is an EVEN (or zero) no. of slashes before '*',
         // then '*' really is an active wildcard.
         for (int k=nSrcLen-2; k>=0; k--) {
            if (pszSrc[k] == '\\')
               nslash++;
            else
               break;
         }
      }
      if (!(nslash & 1)) {
         rToRight = 1;
         rForceRepeat = 1;
         ncopylen--;
      }
   }
   if (ncopylen > nMaxDst-1) return 9+perr("buffer overflow: pattern too large: \"%s\"\n", pszSrc);
   memcpy(pszDst, pszSrc+icopyoff, ncopylen);
   pszDst[ncopylen] = '\0';
   rSrcLen = ncopylen;
   return 0;
}

int reperr(cchar *pszMsg, cchar *pszObj, char *pszRepFile, int nLine)
{
   if (pszRepFile)
      perr("%s: %s [within %s:%d]\n", pszMsg, pszObj, pszRepFile, nLine);
   else
      perr("%s: %s\n", pszMsg, pszObj);
 
   if (!strcmp(pszMsg, "unexpected command")) {
      if (pszRepFile)
         pinf("use :text or :binary followed by pattern lines\n");
      else
         pinf("use -text ... or -binary ...\n");
   }
   pinf("patterns must look like \"/from/to/\" or \"_from_to_\",\n");
   pinf("with three times a delimiter character like / or _\n");
   pinf("to search text \"%s\" try \"/%s/\" or \"_%s_\" etc.\n", pszObj, pszObj, pszObj);
   pinf("if \"%s\" is a single filename, specify it as first parameter.\n", pszObj);
   if (strchr(pszObj, '\"')) {
      pinf("surround your expression by two double quotes \"\n");
      pinf("escape inner quotes as \\\" or \\q (with -spat option)\n");
   }
   pinf("say -dir ... -file ... to specify multiple target files.\n");
   nGlblError = 1; // disable memory leak listing on parameter errors
   return 9;
}

// io: szLineBuf. also uses szLineBuf2.
// io: szAttrBuf. also uses szAttrBuf2.
int applyReplace(char *pszPat, int &rHitCnt, bool blstart, bool blend)
{__
   // _src_dest_
   char szSrc[200];
   char szDst[200];

   // isolate source and destination.
   char *psz1 = pszPat;
   char cbnd = '\0'; // boundary char
   if (*psz1) cbnd = *psz1++;
   char *pszSrc1 = psz1;
   while (*psz1 && (*psz1 != cbnd))
      psz1++;
   if (!*psz1) return 9+perr("illegal replacement string \"%s\"\n", pszPat);
   char *pszSrc2 = psz1;
   psz1++;
   char *pszDst1 = psz1;
   while (*psz1 && (*psz1 != cbnd))
      psz1++;
   if (!*psz1) return 9+perr("illegal replacement string \"%s\"\n", pszPat);
   char *pszDst2 = psz1;
   int nSrcLen = pszSrc2-pszSrc1;
   int nDstLen = pszDst2-pszDst1;
   if (nSrcLen < 1) return 9+perr("source pattern is empty\n");
   if (nSrcLen > (int)sizeof(szSrc)-10) return 9+perr("source pattern too large \"%.*s\"\n", nSrcLen, pszSrc1);
   if (nDstLen > (int)sizeof(szDst)-10) return 9+perr("destination pattern too large \"%.*s\"\n", nDstLen, pszDst1);
   psz1++; // step past final cbnd
   if (*psz1) {
      perr("wrong replacement string syntax \"%s\"\n", pszPat);
      pinf("if \"%c\" is the delimiter then \"%s\" is unexpected.\n",cbnd,psz1);
      return 9;
   }

   if (cs.debug)
      printf("aprep: input src %.*s\n", (int)nSrcLen, pszSrc1);

   // if source starts or ends with *
   bool bFromLeft    = 0;
   bool bToRight     = 0;
   bool bForceRepeat = 0;  // repeat replace although *\\ etc supplied
   if (copyMatchPattern(szSrc, sizeof(szSrc)-10, pszSrc1, nSrcLen, bFromLeft, bToRight, bForceRepeat))
      return 9;
   // -> sets szSrc, nSrcLen, bFromLeft, bToRight.

   if (nSrcLen < 1)
      return 9+perr("wrong source pattern. try \\%c or option -literal to replace %c\n",glblWildChar,glblWildChar);

   // convert \\ \t \n \r \x in destination
   if (copyFormStr(szDst, sizeof(szDst)-10, pszDst1, nDstLen))
      return 9;
   // if (cs.debug) printf("replace dst \"%.*s\" => \"%s\" len %d => %d\n",(int)nDstLen,pszDst1,szDst,nDstLen,strlen(szDst));
   nDstLen = strlen(szDst); // adapt to \t, \x conversions

   int nflags = cs.usecase ? eMatchCase : 0;
   int ifirst=0, ihitlen=0;

   if (cs.debug)
      printf("aprep: fromleft %d toright %d szsrc %s\n", bFromLeft, bToRight, szSrc);

   // apply replacements
   psz1 = szLineBuf;
   int ibase   = 0; // used ONLY for single line end replacing
   int ntmplen = strlen(szLineBuf); // ditto
   while (1)
   {
      ifirst=0; ihitlen=0;
      if (!matchstr(psz1+ibase, szSrc, nflags, ifirst, ihitlen))
         break;

      // replace start of line?
      if (blstart) {
         if (ifirst != 0)
            break; // no hit
         // else fall through. there is no further loop cycle.
      }

      // replace end of line?
      if (blend) {
         if ((ibase+ifirst+ihitlen) != ntmplen) {
            // no hit as it's not (yet) at line end:
            // step-thru by incrementing ibase
            ibase += ifirst+ihitlen;
            continue;
         }
         // found hit: fix ifirst, as rest is ignoring ibase
         ifirst += ibase;
         // fall through. there is no further loop cycle.
      }

      if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
      if (bToRight)   { ihitlen = strlen(psz1+ifirst); }

      psz1   += ifirst;    // to 1st char of hit
      nSrcLen = ihitlen;

      // left part, before hit
      int nLenLeft = psz1-szLineBuf;
      strncpy(szLineBuf2, szLineBuf, nLenLeft);
      szLineBuf2[nLenLeft] = '\0';
      strncpy(szAttrBuf2, szAttrBuf, nLenLeft);
      szAttrBuf2[nLenLeft] = '\0';
      if (cs.debug) printf("rleft \"%s\" ifirst %d\n",szLineBuf2,ifirst);

      // replace middle part, check output length
      int nLenRep  = strlen(szDst);
      char *pszSrcRite = psz1+nSrcLen;
      int nLenRite = strlen(pszSrcRite);
      if (nLenLeft + nLenRep + nLenRite >= MAX_LINE_LEN) {
         perr("buffer overflow during replace");
         pinf("input lines might be too long, or too many changes per line.\n");
         pinf("if input is stream text, you may try filter -wrap +filter ...\n");
         return 9;
      }
      strcat(szLineBuf2, szDst);
      memset(&szAttrBuf2[nLenLeft], 'a', nLenRep);
      szAttrBuf2[nLenLeft+nLenRep] = '\0';
      if (cs.debug) printf("rmid  \"%s\"\n",szDst);

      // step continue position to post-insert
      psz1 = szLineBuf+strlen(szLineBuf2);

      // right part, after hit
      strcat(szLineBuf2, pszSrcRite);
      strcat(szAttrBuf2, szAttrBuf+nLenLeft+nSrcLen);
      if (cs.debug) printf("rrite \"%s\"\n",pszSrcRite);

      // copy back result
      strcpy(szLineBuf, szLineBuf2);
      strcpy(szAttrBuf, szAttrBuf2);
      if (cs.debug) printf("rout: \"%s\"\n",szLineBuf);

      rHitCnt++;

      // if replacing linestart or lineend
      if (bFromLeft || bToRight)
         if (!bForceRepeat)
            break; // after first hit

      // replacing line start or end is a single operation
      if (blstart || blend)
         break;
   }
   return 0;
}

char aMaskSep[200];
bool isMaskSep(char c) {
   if (strchr(aMaskSep, c))
      return true;
   return false;
}

#define WITH_EVAL

#ifdef WITH_EVAL
static char szGlblFormEvalBuf[MAX_LINE_LEN+100];

// evaluate inner content of "$(column+100)"
int evalFormBlock(char *pfrom, char *pto,
   StringTable &oCol,
   int nSrcLine,
   int nDstLine
   )
{__
   char szword[100]; szword[0] = '\0';
   char szform[100]; szform[0] = '\0';

   int ncurval = 0;
   int nmixval = 0;

   char ccurop  = '\0';
   bool bquoted = 0;

   static char szFormTmpBuf[MAX_LINE_LEN+100];

   szGlblFormEvalBuf[0] = '\0';
   szFormTmpBuf[0] = '\0';

   char *pOutBuf = szFormTmpBuf;

   int ntype = 0; // 1:string 2:int

   char *psz1 = pfrom;
   char *psz2 = 0;
   for (; *psz1 && (psz1 < pto); psz1=psz2)
   {
      // format spec as first word?
      char *pszf = psz1;
      if (!ntype && !szform[0])
      {
         bool bfirst = 1;
         while (*pszf) {
            char c = *pszf;
            if (isdigit(c) || (c=='-' && bfirst) || c=='.' || c=='q')
               pszf++;
            else
               break;
            bfirst = 0;
         }
         // if directly followed by an op, it's not a format
         switch (*pszf) {
            case '+': case '-':
               pszf = psz1;
               break;
         }
         if (pszf > psz1) {
            int nlen = pszf-psz1;
            if (nlen > (int)sizeof(szform)-10)
               return 11+perr("format overflow: %s", psz1);
            memcpy(szform, psz1, nlen);
            szform[nlen] = '\0';
            // check and strip quotation
            bquoted = 0;
            if (nlen > 0 && szform[nlen-1] == 'q') {
               bquoted = 1;
               szform[nlen-1] = '\0';
            }
            psz1 = pszf;
            // if followed by a ':', force as format and skip ':'
            if (*psz1 == ':')
               psz1++;
         }
      }

      // operator or word?
      if (!isalnum(*psz1)) {
         switch (*psz1) {
            case '+':
            case '-':
               ccurop = *psz1;
               psz2 = psz1+1;
               continue;
            default:
               return 6+perr("unexpected: %s", psz1);
         }
      }

      psz2 = psz1;
      while (isalnum(*psz2)) psz2++;

      int nlen = psz2-psz1;
      if (nlen < 1 || nlen > (int)sizeof(szword)-10)
         return 8;
      memcpy(szword, psz1, nlen);
      szword[nlen] = '\0';

      // printf("WORD: %s ntype=%d ccurop=%c\n",szword,ntype,ccurop);

      if (strBegins(szword, "col"))
      {
         // parse column number
         int ncol = atol(szword+3);
         if (ncol < 1 || ncol-1 >= oCol.numberOfEntries()) {
            // non-existing column: leave empty
            // TODO: optionally issue a notice
         } else {
            // use column text
            char *pszcol = oCol.getEntry(ncol-1, __LINE__);
            int nlen = strlen(pszcol);
            int nrem = MAX_LINE_LEN - strlen(pOutBuf);
            // what to do with this column content?
            switch (ntype) {
               default:
                  // string mode: simply append
                  if (nrem < nlen)
                     return 10+perr("string buffer overflow");
                  strcat(pOutBuf, pszcol);
                  ntype = 1;
                  break;
               case 2:
                  // int mode: convert string to int
                  if (!isdigit(*pszcol))
                     return 12+perr("not a number: %s", pszcol);
                  ncurval = atol(pszcol);
                  // int processing is done below
                  break;
            }
         }
      }
      else
      if (!strcmp(szword, "line")) {
         ncurval = nSrcLine;
         ntype = 2;
      }
      else
      if (!strcmp(szword, "count")) {
         ncurval = nDstLine;
         ntype = 2;
      }
      else
      if (isdigit(szword[0])) {
         ncurval = atol(szword);
         ntype = 2;
      }

      if (ntype == 2)
         switch (ccurop) {
            case '+': nmixval += ncurval; break;
            case '-': nmixval -= ncurval; break;
            default : nmixval += ncurval; break;
         }

   }  // endfor

   // filter -strict is not supported, too many dependencies
   #ifdef SFK_STRICT_FILTER
   if (ntype==0 && cs.strict!=0) {
      if (cs.usevars)
         return 9+perr("wrong format, or undefined variable: %s\n", pfrom);
      else
         return 9+perr("wrong format: %s\n", pfrom);
   }
   #endif

   // auto-convert result?
   if (ntype == 2)
      sprintf(pOutBuf, "%d", nmixval);

   // copy and reformat result
   if (szform[0]) {
      // "-10.10col1" -> "%-10.10s"
      char szform2[50];
      const char *pquot = bquoted ? "\"" : "";
      snprintf(szform2, sizeof(szform2)-10, "%s%%%ss%s", pquot, szform, pquot);
      snprintf(szGlblFormEvalBuf, MAX_LINE_LEN, szform2, pOutBuf);
   } else {
      strcopy(szGlblFormEvalBuf, pOutBuf);
   }

   return 0;
}
#endif

static bool isWordChar(char c)
{
   if (c >= 'a' && c <= 'z') return 1;
   if (c >= 'A' && c <= 'Z') return 1;
   if (c == '_') return 1;
   return 0;
}

// io: szLineBuf. also uses szLineBuf2.
int applyForm(char *pszPat, bool bBlockSep, int nLineNum, int nOutLineNum)
{__
   StringTable oCol;

   // parse szLineBuf, split into columns
   char *psz1 = szLineBuf;
   char *psz2 = 0;

   if (bBlockSep)
      while (*psz1 && isMaskSep(*psz1))
         psz1++;

   while (*psz1)
   {
      psz2 = psz1;
      while (*psz2 && !isMaskSep(*psz2))
         psz2++;

      // have column from psz1 to psz2
      strncpy(szLineBuf2, psz1, psz2-psz1);
      szLineBuf2[psz2-psz1] = '\0';
      oCol.addEntry(szLineBuf2);

      // continue past separator, find next token
      if (bBlockSep) {
         // treat adjacent separators as one
         while (*psz2 && isMaskSep(*psz2))
            psz2++;
      } else {
         if (isMaskSep(*psz2))
            psz2++;
      }

      psz1 = psz2;
   }

   // oCol now holds all columns. apply mask.
   psz1 = pszPat;
   szLineBuf[0] = '\0';
   int iOut = 0;
   char *psz3 = 0;
   char szFormat1[100];
   char szFormat2[100];
   while (*psz1)
   {
      psz2 = 0;

      #ifdef SFK_STRICT_FILTER
      // support escape of run char with -strict
      if (cs.strict!=0 && psz1[0]==glblRunChar && psz1[1]==glblRunChar) {
         // replace by single run char
         iOut = strlen(szLineBuf);
         szLineBuf[iOut++] = *psz1++;
         szLineBuf[iOut] = '\0';
         psz1++;
         continue;
      }
      #endif

      if (*psz1==glblRunChar)
      {
         // parse format info, if any
         psz2 = psz1+1;
         while (*psz2 && !strBegins(psz2, "col") && !strBegins(psz2, "line")
                 && !strBegins(psz2, "count") && !strBegins(psz2, "(")
               )
         {
            // let only -n.q pass as format prefixes
            char c = *psz2;
            if (isdigit(c) || c=='-' || c=='.' || c=='q')
               psz2++;
            else {
               #ifdef SFK_STRICT_FILTER
               if (cs.strict)
                  return 9+perr("wrong format: %s\n", psz1);
               #endif
               psz2 = 0;
               break;
            }
         }
      }

      if (psz2 && *psz2)
      {
         int nFormLen = psz2-psz1-1;
         if (nFormLen > (int)sizeof(szFormat1)-10)
            break;
         strncpy(szFormat1, psz1+1, nFormLen);
         szFormat1[nFormLen] = '\0';
         // quoted format prefix?
         bool bquoted = 0;
         if (nFormLen > 0 && szFormat1[nFormLen-1] == 'q') {
            bquoted = 1;
            szFormat1[nFormLen-1] = '\0';
         }
         if (!strncmp(psz2, "col(start:", 10))
         {
            // parse column mask
            psz2 += 10;
            psz3 = szLineBuf2;
            while (*psz2!='\0' && *psz2!=')')
               *psz3++ = *psz2++;
            *psz3 = '\0';
            if (*psz2==')') psz2++;
            // search oCol table for column starting like this
            int imasklen = strlen(szLineBuf2);
            char *pszAddText = str("");
            for (int icol=0; icol<oCol.numberOfEntries(); icol++) {
               char *pszcol = oCol.getEntry(icol, __LINE__);
               if (!mystrncmp(pszcol, szLineBuf2, imasklen, cs.usecase)) {
                  // match: take whole colum text
                  pszAddText = pszcol;
                  break;
               }
            }
            {
               // add column
               if (bquoted) strcat(szLineBuf, "\"");
               if (strlen(szFormat1)) {
                  // use specified printf-like format.
                  // we cannot check this - user must know.
                  sprintf(szFormat2, "%%%ss", szFormat1);
                  sprintf(szLineBuf2, szFormat2, pszAddText);
                  strcat(szLineBuf, szLineBuf2);
               } else {
                  strcat(szLineBuf, pszAddText);
               }
               if (bquoted) strcat(szLineBuf, "\"");
            }
         }
         else
         if (!strncmp(psz2, "col", 3))
         {
            // parse column number
            psz2 += 3;
            psz3 = szLineBuf2;
            while (*psz2 && isdigit(*psz2))
               *psz3++ = *psz2++;
            *psz3 = '\0';
            int ncol = atol(szLineBuf2);
            if (ncol < 1 || ncol-1 >= oCol.numberOfEntries()) {
               static bool btold = 0;
               if (!btold) {
                  btold = 1;
               }
            } else {
               // add column
               if (bquoted) strcat(szLineBuf, "\"");
               if (strlen(szFormat1)) {
                  // use specified printf-like format.
                  // we cannot check this - user must know.
                  sprintf(szFormat2, "%%%ss", szFormat1);
                  char *pszcol = oCol.getEntry(ncol-1, __LINE__);
                  sprintf(szLineBuf2, szFormat2, pszcol);
                  strcat(szLineBuf, szLineBuf2);
               } else {
                  char *pszcol = oCol.getEntry(ncol-1, __LINE__);
                  strcat(szLineBuf, pszcol);
               }
               if (bquoted) strcat(szLineBuf, "\"");
            }
         }
         else
         if (!strncmp(psz2, "line", 4))
         {
            // insert input line number, counting from 1
            psz2 += 4;
            char szNum[30];
            sprintf(szNum, "%u", (uint)nLineNum);
            char *pszcol = szNum;
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, pszcol);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, pszcol);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         else
         if (strBegins(psz2, "count"))
         {
            // insert output line number, counting from 1
            psz2 += strlen("count");
            char szNum[30];
            sprintf(szNum, "%u", (uint)nOutLineNum);
            char *pszcol = szNum;
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, pszcol);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, pszcol);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         #ifdef WITH_EVAL
         else
         if (strBegins(psz2, "("))
         {
            psz2++;
            char *pfrom = psz2;
            psz2 = strchr(psz2, ')');
            if (!psz2)
               return 9+perr("missing ')' on expression: %s", psz1);
            char *pto = psz2; // exclusive
            psz2++;
            int nrc = evalFormBlock(pfrom, pto, oCol, nLineNum, nOutLineNum);
            if (nrc)
               return 9+perr("cannot evaluate: %s (rc=%d)", pfrom, nrc);
            // result is in szGlblFormEvalBuf
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, szGlblFormEvalBuf);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, szGlblFormEvalBuf);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         #endif
         else
         if (strBegins(psz2, "(count"))
         {
            // insert output line number, counting from 1
            psz2 += strlen("(count");
            int nCntOffset = atol(psz2);
            psz2 = strchr(psz2, ')');
            if (!psz2)
               return 9+perr("(count not closed by ')'");
            psz2++;
            char szNum[30];
            sprintf(szNum, "%d", (int)(nOutLineNum+nCntOffset));
            char *pszcol = szNum;
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, pszcol);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, pszcol);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         iOut = strlen(szLineBuf);
         // continue past token, including separator
         psz1 = psz2;
      } else {
         // apply \\t and \\xnn replacements, else copy
         if (cs.spat && !strncmp(psz1, "\\\\", 2)) {
            szLineBuf[iOut++] = '\\';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\t", 2)) {
            szLineBuf[iOut++] = '\t';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\q", 2)) {
            szLineBuf[iOut++] = '"';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\n", 2)) {
            szLineBuf[iOut++] = '\n';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\r", 2)) {
            szLineBuf[iOut++] = '\r';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\x", 2)) {
            int n = getTwoDigitHex(psz1+2);
            if (n <= 0) return 9+perr("wrong syntax or not supported: %s\n", psz1);
            szLineBuf[iOut++] = (char)n;
            psz1 += 4;
         }
         else
            szLineBuf[iOut++] = *psz1++;
         szLineBuf[iOut] = '\0';
      }
   }

   return 0;
}

struct FilterParms
{
   char  **argv;
   int  iPat;
   int  nPat;
   bool  bVerb;
   bool  bLNum;
   bool  bCnt;
   bool  bReWrite;
   bool  bDumpLF;
   bool  bSingleFile;
   bool  bSkipBinaries;
   bool  bFilenames;
   bool  bPassHitFiles;
   bool  bGlobalUnique;
   int  nTotalRC;
   char *pBlockMark;
   int  nprecon;
   int  npostcon;
   char  cprecolor;
   char  cpostcolor;
   char *pPreConMark;
   char *pPostConMark;
}
gfilter; // global filter settings

#define MAX_CONTEXT_LINES 105
class FilterContextLines
{
public:
      FilterContextLines   ( );
      void  shutdown       ( );

   void  putLine  (char *psz);
   char *getLine  (int   iPreIndex);
   void  reset    ( );

   char  szClLineTmp [MAX_LINE_LEN+100];
   char  szClAttrTmp [MAX_LINE_LEN+100];

private:
   char *aClLines [MAX_CONTEXT_LINES+4];
   char  aClValid [MAX_CONTEXT_LINES+4];
   int   iClIndex;
}
gfiltPreContext;

FilterContextLines::FilterContextLines( )
   { memset(this, 0, sizeof(*this)); }

void FilterContextLines::shutdown( )
{
   for (int i=0; i<MAX_CONTEXT_LINES; i++)
      if (aClLines[i])
         delete [] aClLines[i];
}

void FilterContextLines::reset( )
   { mclear(aClValid); }

void FilterContextLines::putLine(char *psz)
{
   if (!aClLines[iClIndex])
      if (!(aClLines[iClIndex] = new char[MAX_LINE_LEN+100]))
         return;
   mystrcopy(aClLines[iClIndex], psz, MAX_LINE_LEN);
   aClValid[iClIndex] = 1;
   iClIndex = (iClIndex + 1) % MAX_CONTEXT_LINES;
}

// In : pre index >= 1
// Out: pre context line, or NULL if n/a
char *FilterContextLines::getLine(int iPreIndex)
{
   if (iPreIndex < 1) return 0;
   int iCurIndex = iClIndex;
   for (int i=0; i<iPreIndex; i++) {
      if (--iCurIndex < 0)
         iCurIndex = MAX_CONTEXT_LINES-1;
      if (!aClValid[iCurIndex])
         return 0;
   }
   if (aClValid[iCurIndex])
      return aClLines[iCurIndex];
   return 0;
}

int getContextParms(char *psz, int &rlines, char &rcolor, char **ppConMark, int nlimit=0)
{
   rlines = atol(psz);
   if (nlimit > 0 && rlines > nlimit) {
      perr("-(pre)context supports only up to %d lines\n",nlimit);
      return 9;
   }
   while (*psz && isdigit(*psz))
      psz++;
   if (*psz==':' || *psz==',')
   {
      // parse color
      char szcol[50];
      char *pszs = ++psz;
      while (isalpha(*psz)) psz++;
      int nlen = psz - pszs;
      if (nlen > (int)sizeof(szcol)-10) return 0;
      memcpy(szcol, pszs, nlen);
      szcol[nlen] = '\0';
      if (szcol[0])
         rcolor = attribFromHumanColor(szcol, ' ');

      // parse marker
      if (*psz!=':' && *psz!=',')
         return 0;

      psz++;
      *ppConMark = psz;
   }
   return 0;
}

int setFilterParms(
   char *argv[], int argc, int iPat, int &nPat,
   struct FilterParms &rparms,
   char  **pszInFile,
   int   *iDir = 0,     // if dir parms are found
   int   *iChain = 0    // if further chaining is found
   )
{
   // valid options w/o parameters
   cchar *pszValFilt1[] = {
      "-+","-ls+","-le+",
      "++", "+ls+",         // deprecated with sfk197
      "-and+", "-lsand+",   // sfk197: replacement for ++
      "-!", "-ls!", "-le!", // accept win specific form
      "-:", "-ls:", "-le:", // and ux specific as well
      "-no-empty-lines", "-no-blank-lines",
      "-unique", "-keep-empty", "-keep-blank"
   };

   // valid options with one or more parameters
   cchar *pszValFilt2[] = {
      "1-pat", "1-notpat",
      "3-inc", "3-ex", "3-cut", "1-addmark",
      "1-keep"
   };

   // valid processing options w/o parms
   cchar *pszValOpt1[] = {
      "-ansitodos", "-todos", "-dostoansi",
      "-toupper", "-tolower",
      "-toiso", "-iso", "-toutf",
      "-ltrim", "-rtrim", "-trim",
      // "-from", // -fromurl -fromhex -from_hex
      // "-to"    // -tourl -tohex -to_hex
   };

   // valid processing options with one parameter
   cchar *pszValOpt2[] = {
      "-rep","-lsrep","-lerep",
      "-sep","-blocksep","-form","-tabform","-noop",
      "-where","-lswhere","-lewhere",
      "-within","-lswithin","-lewithin"
   };

   // set processing options, check syntax
   bool bHadProc = 0;
   bool bHadFilt = 0;
   for (int iPat2=iPat; iPat2<argc; iPat2++)
   {
      char *pszOpt = argv[iPat2];
      if (!strcmp(pszOpt, "-lnum"))
         { rparms.bLNum = 1; continue; }
      if (!strcmp(pszOpt, "-count") || !strcmp(pszOpt, "-cnt"))
         { rparms.bCnt = 1; continue; }
      if (!strcmp(pszOpt, "-c")) // -case done in setGeneralOption
         { cs.usecase = 1; continue; }
      if (!strcmp(pszOpt, "-join"))
         { rparms.bDumpLF = 0; continue; }
      if (!strncmp(pszOpt, "-bin", 4))
         { rparms.bSkipBinaries = 0; continue; }
      if (!strncmp(pszOpt, "-nofile", 7))
         { rparms.bFilenames = 0; continue; }
      if (!strcmp(pszOpt, "-hitfiles"))
         { rparms.bPassHitFiles = 1; continue; }
      if (!strcmp(pszOpt, "-global-unique"))
         { rparms.bGlobalUnique = 1; continue; }
      if (strBegins(pszOpt,"-timeout=")) // wto.wfilt
         { cs.maxwebwait = atol(pszOpt+9); continue; }

      if (strBegins(pszOpt, "-precontext="))
         { if (getContextParms(pszOpt+12, rparms.nprecon, rparms.cprecolor, &rparms.pPreConMark, MAX_CONTEXT_LINES-5)) return 9; continue; }
      if (strBegins(pszOpt, "-precon="))
         { if (getContextParms(pszOpt+8, rparms.nprecon, rparms.cprecolor, &rparms.pPreConMark, MAX_CONTEXT_LINES-5)) return 9; continue; }

      if (strBegins(pszOpt, "-postcontext="))
         { getContextParms(pszOpt+13, rparms.npostcon, rparms.cpostcolor, &rparms.pPostConMark); continue; }
      if (strBegins(pszOpt, "-postcon="))
         { getContextParms(pszOpt+9, rparms.npostcon, rparms.cpostcolor, &rparms.pPostConMark); continue; }

      if (strBegins(pszOpt, "-context=")) {
         if (getContextParms(pszOpt+9, rparms.nprecon, rparms.cprecolor, &rparms.pPostConMark, MAX_CONTEXT_LINES-5)) return 9;
         rparms.npostcon = rparms.nprecon;
         rparms.cpostcolor = rparms.cprecolor;
         continue;
      }

      if (strBegins(pszOpt, "-head=")) // filter
         { cs.maxlines = atoi(pszOpt+6); continue; }
      if (strBegins(pszOpt, "-tail="))
         { cs.taillines = atoi(pszOpt+6); continue; }
      if (strBegins(pszOpt, "-line=")) {
         cs.linesfrom = atoi(pszOpt+6);
         cs.linesto   = cs.linesfrom+1;
         cs.sellines  = 1;
         continue;
      }
      // internal due to unsolved silent hard wrap of input.
      if (strBegins(pszOpt, "-skipfirst=")) {
         cs.linesfrom = atoi(pszOpt+11)+1;
         cs.linesto   = -1;
         cs.sellines  = 1;
         continue;
      }

      int i=0;

      // check for filter options w/o parms
      for (i=0; i<(int)(sizeof(pszValFilt1)/sizeof(char*)); i++)
         if (!strncmp(pszOpt, pszValFilt1[i], strlen(pszValFilt1[i])))
            break;
      if (i < (int)(sizeof(pszValFilt1)/sizeof(char*))) {
         if (bHadProc) {
            perr("selection options (%s) are not allowed after processing options.\n", pszOpt);
            perr("say +filter %s instead.\n", pszOpt);
            return 9;
         }
         bHadFilt=1;
         continue;
      }

      // check for filter options w/ parms
      int nParms = 0;
      for (i=0; i<(int)(sizeof(pszValFilt2)/sizeof(char*)); i++) {
         cchar *psz = pszValFilt2[i];
         // 1st char is no. of parms
         if (strBegins(pszOpt, psz+1)) {
            nParms = *psz - '0';
            break;
         }
      }
      if (nParms) {
         if (bHadProc) {
            perr("selection options (%s) are not allowed after processing options.\n", pszOpt);
            perr("say +filter %s instead.\n", pszOpt);
            return 9;
         }
         if (strBegins(pszOpt, "-addmark") && (iPat2+1 < argc))
            gfilter.pBlockMark = argv[iPat2+1];
         iPat2 += nParms;  // skip additional parameter
         if (iPat2 >= argc) return 9+perr("missing parameter(s) after %s\n",pszValFilt2[i]);
         bHadFilt=1;
         continue;
      }

      // check for highlight
      if (   !strncmp(pszOpt, "-high", 5)
          || !strncmp(pszOpt, "-lshigh", 7) || !strncmp(pszOpt, "-lehigh", 7)
         )
      {
         // if (bHadProc) {
         //    perr("%s is not allowed after processing options.\n", pszOpt);
         //    perr("say +filter %s instead.\n", pszOpt);
         //    return 9;
         // }
         iPat2 += 2;  // skip additional parameters
         if (iPat2 >= argc) return 9+perr("missing parameter(s) after %s\n",pszOpt);
         // bHadFilt=1;
         continue;
      }

      // check for processing opts w/o parms
      for (i=0; i<(int)(sizeof(pszValOpt1)/sizeof(char*)); i++)
         if (!strncmp(pszOpt, pszValOpt1[i], strlen(pszValOpt1[i])))
            break;
      if (i < (int)(sizeof(pszValOpt1)/sizeof(char*)))
         { bHadProc=1; continue; }
 
      // check for processing opts w/ one parm
      for (i=0; i<(int)(sizeof(pszValOpt2)/sizeof(char*)); i++)
         if (isxopt(pszOpt, pszValOpt2[i]))
            break;
      if (i < (int)(sizeof(pszValOpt2)/sizeof(char*))) {
         iPat2++;  // skip additional parameter
         if (iPat2 >= argc) {
            perr("missing parameter after %s\n",pszOpt);
            #ifndef _WIN32
            pinf("try to use quotes \"\" with %s parameters.\n",pszOpt);
            #endif
            return 9;
         }
         // typical mistake: -sep -form w/o separator patterns
         if (  (isxopt(pszOpt, "-sep") || isxopt(pszOpt, "-blocksep"))
             && isxopt(argv[iPat2], "-form")
            )
            return 9+perr("%s must be followed by separator characters, e.g. %s \"; \"\n",pszOpt,pszOpt);
         if (iGlblInScript) // then argv[iPat2] is writeable
            fixMultiLineParm(argv[iPat2], 't'); // sfk180: filter -rep and -form
         bHadProc=1;
         continue;
      }
      else
      if (!strncmp(pszOpt, "-write", 6) || !strcmp(pszOpt, "-rewrite")) {
         rparms.bReWrite = 1;
         if (!strcmp(pszOpt, "-writeall"))
            cs.writeall = 1;
         continue;
      }

      if (   strncmp(pszOpt, "-", 1)
          && strncmp(pszOpt, "+", 1)
         )
      {
         // non-option: assume single input file
         if (chain.useany()) {
            pbad(str("filter"), pszOpt);
            if (strchr(pszOpt, glblRunChar))
               pinf("you may forgot -form or -tabform\n");
            else {
               pinf("specify options after input filename.\n");
               pinf("use +then filter to drop text from previous commands.\n");
            }
            return 9;
         }
         if (*pszInFile) {
            pbad(str("filter"), pszOpt);
            if (pszOpt[0] == '<' || pszOpt[0] == '>') {
               pinf("if you try to redirect output, there might be a quote count problem.\n");
               pinf("try using -spat ... and \\q instead of \\\"\n");
            } else {
               pinf("filter does not support short dir+file selection syntax.\n");
               pinf("specify a single input file, or -dir ... -file ... format.\n");
            }
            return 9;
         }

         *pszInFile = pszOpt;
         continue;
      }

      if (!strncmp(pszOpt, "-", 1))
         if (isDirParm(pszOpt)) {
            *iDir = iPat2;
            return 0;
         }

      if (isChainStart(pszOpt, argv, argc, iPat2, iChain)) {
         nPat = iPat2 - iPat;
         if (cs.verbose)
            printf("[filter npats=%d before %s]\n", nPat, pszOpt);
         // tell caller that there is another chain cmd:
         // was done in isChainStart via iChain
         return 0; // pdp will process chaining further
      }

      if (!strcmp(pszOpt, "-utfout")) // sfk1942 ofilt
         { cs.utfout = 1; continue; }

      if (setGeneralOption(argv, argc, iPat2))
         continue;

      return 9+perr("unknown option: %s\n", pszOpt);
   }

   if (bHadFilt && rparms.bReWrite && !cs.force && !cs.noinfo && !cs.yes) {
      pinf("line selection option(s) AND -write may cause massive changes.\n");
   }
   else
   if ((rparms.bLNum || rparms.bCnt) && rparms.bReWrite && !cs.force && !cs.noinfo && !cs.yes) {
      pinf("-lnum or -count AND -write will change all selected files.\n");
   }

   if (cs.wrapcol && (rparms.bReWrite || pszGlblSaveTo))
      return 9+perr("-wrap together with -write is not supported.\n");

   return 0;
}

// filter -unique support:
KeyMap glblFilterDups;

// filter test matrix: used with -test
#define FILT_MAXTESTMASKS 50
struct FilterTestStat {
   char *apPosMasks  [FILT_MAXTESTMASKS+4];
   int  anPosHits   [FILT_MAXTESTMASKS+4];
   char *apNegMasks  [FILT_MAXTESTMASKS+4];
   int  anNegHits   [FILT_MAXTESTMASKS+4];
}  ftest;

// io: szLineBuf. also uses szLineBuf2.
// io: szAttrBuf. also uses szAttrBuf2.
// rc: 0 if line is included, 1 if excluded, >1 on error.
int selectTextLine(char *argv[], int iPat, int nPat, bool bVerb,
   int &rIncCnt, int &rExCnt, int &rExState,
   char *pCurFile, int nCurLineNum
   )
{__
   bool bHasPositive = 0;
   bool bHasNegative = 0;
   bool bHavePosFilt = 0;
   bool bHaveNegFilt = 0;
   int nOptState = 0;
   int nHitIndex = 0;
   int nHitLen   = 0;
   bool bCase = cs.usecase;
   bool bForceExclude = 0;
   bool bForceInclude = 0;
   bool bHaveIncCmd   = 0;
   bool bDoneSingleIC = 0; // done a single inc/cut in this line

   // sfk181: option -line=n
   if (cs.sellines!=0 && nCurLineNum<cs.linesfrom)
      return 1; // no match

   for (int i=0; i<nPat; i++)
   {
      char *pszPat = argv[iPat+i];
      if (!strncmp(pszPat, "-+", 2)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " %s\"%s\"", (i>0)?"OR ":"OPTIONAL ", pszPat+2);
         // if (mystrhit(szLineBuf, pszPat+2, bCase, &nHitIndex)) {
         int nflags = bCase ? eMatchCase : 0;
         int nlen = strlen(szLineBuf);
         for (int ibase=0; ibase<nlen;)
         {
            if (cs.test && i<FILT_MAXTESTMASKS)
               ftest.apPosMasks[i] = pszPat;
            if (!matchstr(szLineBuf+ibase, pszPat+2, nflags, nHitIndex, nHitLen))
               break; // no further hit
            bHasPositive = 1;
            if (ibase+nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[ibase+nHitIndex], 'i', nHitLen);
            // continue to highlight ALL occurrences
            ibase += nHitIndex+nHitLen;
            if (cs.test && i<FILT_MAXTESTMASKS)
               ftest.anPosHits[i]++;
         }
      }
      else
      if (!strncmp(pszPat, "-ls+", 4)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " %sLINE START \"%s\"", (i>0)?"OR ":"",pszPat+4);
         // if (!mystrncmp(szLineBuf, pszPat+4, strlen(pszPat)-4, bCase)) {
         int nflags = (bCase ? eMatchCase : 0) | eMatchHead;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasPositive = 1;
            if (nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
         }
      }
      else
      if (!strncmp(pszPat, "-le+", 4)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         int nPatLen = strlen(pszPat)-4;
         int nBufLen = strlen(szLineBuf);
         int nIndex  = nBufLen-nPatLen;
         if (nIndex < 0) nIndex = 0;
         if (bVerb) fprintf(stderr, " %sLINE END \"%s\"", (i>0)?"OR ":"",pszPat+4);
         int nflags = (bCase ? eMatchCase : 0) | eMatchTail;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasPositive = 1;
            if (nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
         }
      }
      else
      if (!strncmp(pszPat, "-and+", 5) 
          || !strncmp(pszPat, "++", 2)) // deprecated with sfk197
      {
         int ioff = strncmp(pszPat, "-and+", 5) ? 2 : 5;
         static bool btold=0;
         if (ioff==2 && btold==0) {
            btold=1;
            pwarn("filter ++word is deprecated. use -and+word instead.\n");
         }
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " %s\"%s\"", (i>0)?"AND ":"", pszPat+ioff);
         int nflags = bCase ? eMatchCase : 0;
         int nlen = strlen(szLineBuf);
         bool bLocalPos = 0;
         for (int ibase=0; ibase<nlen;)
         {
            if (!matchstr(szLineBuf+ibase, pszPat+ioff, nflags, nHitIndex, nHitLen))
               break;
            bLocalPos = 1;
            if (ibase+nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[ibase+nHitIndex], 'i', nHitLen);
            ibase += nHitIndex+nHitLen;
         }
         if (bLocalPos)
            bHasPositive = 1;
         else
            bHasNegative = 1;
      }
      else
      if (!strncmp(pszPat, "-lsand+", 7)  // internal
          || !strncmp(pszPat, "+ls+", 4)) // deprecated with sfk197, internal
      {
         int ioff = strncmp(pszPat, "-lsand+", 7) ? 4 : 7;
         static bool btold=0;
         if (ioff==4 && btold==0) {
            btold=1;
            pwarn("filter +ls+word is deprecated. use -lsand+word instead.\n");
         }
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " LINE MUST START \"%s\"", pszPat+ioff);
         int nflags = (bCase ? eMatchCase : 0) | eMatchHead;
         if (matchstr(szLineBuf, pszPat+ioff, nflags, nHitIndex, nHitLen)) {
            bHasPositive = 1;
            if (nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
         } else {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strncmp(pszPat, "-!", 2) || !strncmp(pszPat, "-:", 2))
      {
         if (cs.test && (i<FILT_MAXTESTMASKS))
            ftest.apNegMasks[i] = pszPat;
         if (nOptState) { nOptState=2; break; }
         bHaveNegFilt = 1;
         if (bVerb) fprintf(stderr, " NOT \"%s\"", pszPat+2);
         // if (mystrhit(szLineBuf, pszPat+2, bCase, &nHitIndex))
         int nflags = bCase ? eMatchCase : 0;
         if (matchstr(szLineBuf, pszPat+2, nflags, nHitIndex, nHitLen)) {
            bHasNegative = 1;
            if (cs.test && (i<FILT_MAXTESTMASKS))
               ftest.anNegHits[i]++;
         }
      }
      else
      if (!strncmp(pszPat, "-ls!", 4) || !strncmp(pszPat, "-ls:", 4))
      {
         if (nOptState) { nOptState=2; break; }
         bHaveNegFilt = 1;
         if (bVerb) fprintf(stderr, " NOT \"%s\"", pszPat+4);
         // if (!mystrncmp(szLineBuf, pszPat+4, strlen(pszPat)-4, bCase)) {
         int nflags = (bCase ? eMatchCase : 0) | eMatchHead;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strncmp(pszPat, "-le!", 4) || !strncmp(pszPat, "-le:", 4))
      {
         if (nOptState) { nOptState=2; break; }
         bHaveNegFilt = 1;
         int nPatLen = strlen(pszPat)-4;
         int nBufLen = strlen(szLineBuf);
         int nIndex  = nBufLen-nPatLen;
         if (nIndex < 0) nIndex = 0;
         if (bVerb) fprintf(stderr, " NOT \"%s\"", pszPat+4);
         // if (!mystrncmp(&szLineBuf[nIndex], pszPat+4, nPatLen, bCase)) {
         int nflags = (bCase ? eMatchCase : 0) | eMatchTail;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strcmp(pszPat, "-no-empty-lines")) {
         if (strlen(szLineBuf))
            bHasPositive = 1;
         else {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strcmp(pszPat, "-no-blank-lines")) {
         char *psz = szLineBuf;
         while (*psz && isspace(*psz))
            psz++;
         if (*psz) // landed on non-space
            bHasPositive = 1;
         else {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (   !strcmp(pszPat, "-unique")
          || !strcmp(pszPat, "-global-unique")
         )
      {
         // check for -unique -keep pat1 -keep pat2 ...
         bool bForceKeep = 0;
         int iPost = iPat+i+1;
         for (; (iPost<iPat+nPat) && !bForceKeep; iPost++) {
            char *pszPost1 = argv[iPost];
            if (!strcmp(pszPost1, "-keep-empty") && !szLineBuf[0])
                  { bForceKeep=1; break; }
            if (!strcmp(pszPost1, "-keep-blank") && isWhitespace(szLineBuf, strlen(szLineBuf)))
                  { bForceKeep=1; break; }
            if ((iPost+1<iPat+nPat) && !strcmp(pszPost1, "-keep")) {
               char *pszPost2 = argv[++iPost];
               if (mystrhit(szLineBuf, pszPost2, cs.usecase, 0))
                  { bForceKeep=1; break; }
            }
         }
         if (bForceKeep) {
            // pass-through -keep line
            bHasPositive = 1;
         } else {
            // apply -unique
            char *psz = szLineBuf;
            if (!glblFilterDups.isset(psz)) {
               glblFilterDups.put(psz);
               bHasPositive = 1;
            } else {
               bHasNegative = 1;
               break;
            }
         }
      }
      else
      if (!strncmp(pszPat, "-keep-", 6)) {
         // processing was done before
      }
      else
      if (!strcmp(pszPat, "-keep")) {
         // processing was done before
         i++;
      }
      else
      if (!strncmp(pszPat, "-inc", 4)) {
         // -inc[lude] "foo*begin" to  "foo*end"
         // -inc-      "foo*begin" to  "foo*end"
         //  i+0        i+1        i+2  i+3
         if (nPat < 4) return 9; // should've been checked before
         char *pfrom = argv[iPat+i+1];
         char *plito = argv[iPat+i+2];
         char *pto   = argv[iPat+i+3];
         if (strcmp(plito, "to"))
            return 9+perr("filter -inc: missing \"to\" keyword");
         bool bStripBnd = (strlen(pszPat) >= 5 && pszPat[4] == '-');
         int nflags = bCase ? eMatchCase : 0;
         if (!strcmp(pfrom, "*") || !strcmp(pto, "*"))
         {
            // -inc single block mode with one open end
            if (bDoneSingleIC) {
               perr("filter %s: only one -inc or -cut with * allowed", pszPat);
               pinf("... you may try \"+filter %s\" instead of \"%s\".\n", pszPat, pszPat);
               return 9;
            }
            if (!strcmp(pfrom, "*")) {
               // inc from first line until "to" marker
               switch (rIncCnt) {
                  case  0:
                     // keep default to include line
                     if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen)) {
                        rIncCnt = -1; // boundary hit
                        if (bStripBnd) bForceExclude = 1; // exclude boundary
                     }
                     break;
                  case -1:
                     bForceExclude = 1;
                     break;
               }
            } else {
               // inc from "from" marker until last line
               switch (rIncCnt) {
                  case  0:
                     if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen)) {
                        rIncCnt = -1; // boundary hit
                        if (bStripBnd) bForceExclude = 1; // exclude boundary
                     }
                     else
                        bForceExclude = 1;
                     break;
                  case -1:
                     // keep default to include line
                     break;
               }
            }
            bDoneSingleIC = 1;
         }
         else
         {
            // -inc multi block mode with precise boundaries
            bHaveIncCmd = 1;
            if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen))
            {
               // ex start boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               rIncCnt++; // include active
               if (bStripBnd) bForceExclude = 1; // but exclude boundary
            }
            else
            if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen))
            {
               // ex end boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               if (rIncCnt > 0) {
                  rIncCnt--; // include inactive
                  if (!bStripBnd) // if boundary exclude is not active
                     bForceInclude = 1; // then include this line
               }
               else
               if (!cs.nocheck) {
                  perr("filter -inc: found end of block without start: %s", szLineBuf);
                  pinf("file %s line %d\n",pCurFile,nCurLineNum);
                  pinf("add option -nocheck to ignore unexpected block endings.\n");
                  return 9;
               }
            }
         }
      }
      else
      if (   strBegins(pszPat, "-cut")
          || strBegins(pszPat, "-ex")
         )
      {
         // -ex[clude] "foo*begin" to  "foo*end"
         //  i+0        i+1        i+2  i+3
         if (nPat < 4) return 9; // should've been checked before
         char *pfrom = argv[iPat+i+1];
         char *plito = argv[iPat+i+2];
         char *pto   = argv[iPat+i+3];
         if (strcmp(plito, "to"))
            return 9+perr("filter %s: missing \"to\" keyword", pszPat);
         bool bStripBnd = !strcmp(pszPat, "-cut-");
         int nflags = bCase ? eMatchCase : 0;
         if (!strcmp(pfrom, "*") || !strcmp(pto, "*"))
         {
            // -cut single block mode with one open end
            if (bDoneSingleIC) {
               perr("filter %s: only one -inc or -cut with * allowed", pszPat);
               pinf("... you may try \"+filter %s\" instead of \"%s\".\n", pszPat, pszPat);
               return 9;
            }
            if (!strcmp(pfrom, "*")) {
               // cut from first line until "to" marker
               rExState |= 1; // there is a -cut from *
               switch (rExCnt) {
                  case  0:
                     if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen)) {
                        rExState |= 2; // a -cut from * found end boundary
                        rExCnt = -1; // boundary hit
                        if (!bStripBnd) bForceExclude = 1;
                     }
                     else
                        bForceExclude = 1;
                     break;
                  case -1:
                     // keep default to include line
                     break;
               }
            } else {
               // cut from "from" marker until last line
               switch (rExCnt) {
                  case  0:
                     // keep default to include line
                     if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen)) {
                        rExCnt = -1;       // boundary hit
                        if (!bStripBnd) bForceExclude = 1;
                     }
                     break;
                  case -1:
                     bForceExclude = 1;
                     break;
               }
            }
            bDoneSingleIC = 1;
         }
         else
         {
            // -cut multi block mode with precise boundaries
            if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen))
            {
               // ex start boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               rExCnt++; // exclude active
               // exclude boundary from cutting?
               if (bStripBnd) bForceInclude = 1;
            }
            else
            if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen))
            {
               // ex end boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               if (rExCnt > 0) {
                  rExCnt--; // exclude inactive
                  if (!bStripBnd) bForceExclude = 1; // but still exclude the current line
               }
               else
               if (!cs.nocheck) {
                  perr("filter %s found end of block without start: %s", pszPat, szLineBuf);
                  pinf("file %s line %d\n",pCurFile,nCurLineNum);
                  pinf("add option -nocheck to ignore unexpected block endings.\n");
                  return 9;
               }
            }
         }
      }

   }  // endfor nPat

   if (bVerb) {
      if (bHavePosFilt || bHaveNegFilt)
         fprintf(stderr, "]\n");
      else
         fprintf(stderr, " ALL LINES: no filters given.]\n");
   }

   // block include/exclude active?
   if (rExCnt > 0 && !bForceInclude) return 1; // no match
   if (bForceExclude) return 1;
   if (bHaveIncCmd && !rIncCnt && !bForceInclude) return 1;

   bool bMatch = 0;

   // if ANY positive filter is given, matches MUST contain this.
   if (bHavePosFilt && bHasPositive && !bHasNegative)
      bMatch = 1;

   // if NO positive filter is given, ANYTHING matches,
   // except if there is a negative filter match.
   if (!bHavePosFilt && !bHasNegative)
      bMatch = 1;

   return bMatch ? 0 : 1;
}

static char szPatBuf[MAX_LINE_LEN+100];
static char szSaveBuf[MAX_LINE_LEN+100];
static char szSaveAttr[MAX_LINE_LEN+100];
static char szJoinBuf[MAX_LINE_LEN+100];

// io: szLineBuf. also uses szLineBuf2.
// io: szAttrBuf. also uses szAttrBuf2.
int processTextLine(char *argv[], int iPat, int nPat,
   int &nReplaced, bool &bUseColor, int nLineNum, int nOutLineNum
   )
{__
   bool bCase = cs.usecase;
   aMaskSep[0]     = '\0';
   bool bBlockSep  = 0;
   bool bWhereMode = 0; // a -where is active
   bool bWhereHit  = 0; // the current line matches active -where
   bool bSkipWhere = 0; // if set, -rep etc. must be skipped
   int  iSubChg    = 0;

   for (int i=0; i<nPat; i++)
   {
      char *pszPat = argv[iPat+i];

      if (   isxopt(pszPat, "-within")
          || isxopt(pszPat, "-lswithin") || isxopt(pszPat, "-lewithin")
         )
      {
         if (i+3 >= nPat) return 9+perr("missing arguments after %s\n", pszPat);

         bool blstart = strstr(pszPat, "lswithin") ? 1 : 0;
         bool blend   = strstr(pszPat, "lewithin") ? 1 : 0;

         char *psz     = argv[iPat+i+1];
         char *pRepCmd = argv[iPat+i+2];
         if (!strBegins(pRepCmd, "-rep"))
            return 9+perr("missing -replace after %s\n", pszPat);
         char *pszRep  = argv[iPat+i+3];

         // -within "{*}" -replace /foo/bar/
         // if pattern starts or ends with * is ignored
         bool bFromLeft = 0;
         bool bToRight  = 0;
         bool bForceRep = 0;
         int nPatLen   = strlen(psz);
         if (copyMatchPattern(szPatBuf, MAX_LINE_LEN, psz, nPatLen, bFromLeft, bToRight, bForceRep))
            return 9;
         // -> sets szPatBuf, nPatLen, bFromLeft, bToRight.
         int nflags = bCase ? eMatchCase : 0;
         // determine if current line matches the [ls/le]within expression
         int nlen = strlen(szLineBuf);
         for (int ibase=0; ibase<nlen;)
         {
            int ifirst=0, ihitlen=0;
            if (!matchstr(szLineBuf+ibase, szPatBuf, nflags, ifirst, ihitlen))
               break; // no further hit
            if (blstart && (ibase+ifirst) != 0)
               break; // no hit as it's not at line start
            if (blend && (ibase+ifirst+ihitlen) != nlen) {
               // no hit as it's not (yet) at line end
               ibase += ifirst+ihitlen;
               continue;
            }
            bWhereHit = 1;
            if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
            if (bToRight)   { ihitlen = strlen(szLineBuf+ibase+ifirst); }

            // isolate selected part of line:
            //  from ibase+ifirst over ihitlen chars
            strcpy(szSaveBuf , szLineBuf);
            memmove(szLineBuf, szLineBuf+ibase+ifirst, ihitlen);
            szLineBuf[ihitlen] = '\0';

            strcpy(szSaveAttr, szAttrBuf);
            memmove(szAttrBuf, szAttrBuf+ibase+ifirst, ihitlen);
            szAttrBuf[ihitlen] = '\0';

            // mark the selected area as blue:
            memset(szAttrBuf, 't', ihitlen);

            // in+out: szLineBuf. also uses szLineBuf2.
            // changes szAttrBuf contents.
            if (applyReplace(pszRep, nReplaced, 0, 0)) return 9;

            // rebuild line text
            char *pleft = szSaveBuf;
            int  nleft = ibase+ifirst;
            char *pmid  = szLineBuf;
            int  nmid  = strlen(pmid);
            char *prite = szSaveBuf+nleft+ihitlen;
            int  nrite = strlen(prite);

            if (nleft+nmid+nrite > MAX_LINE_LEN-10)
               return 9+perr("buffer overflow on %s ...", pszPat);

            memcpy(szJoinBuf, pleft, nleft);
            memcpy(szJoinBuf+nleft, pmid, nmid);
            memcpy(szJoinBuf+nleft+nmid, prite, nrite);
            szJoinBuf[nleft+nmid+nrite] = '\0';
            strcpy(szLineBuf, szJoinBuf);

            // rebuild attributes
            pleft = szSaveAttr;
            nleft = ibase+ifirst;
            pmid  = szAttrBuf;
            nmid  = strlen(pmid);
            prite = szSaveAttr+nleft+ihitlen;
            nrite = strlen(prite);

            memcpy(szJoinBuf, pleft, nleft);
            memcpy(szJoinBuf+nleft, pmid, nmid);
            memcpy(szJoinBuf+nleft+nmid, prite, nrite);
            szJoinBuf[nleft+nmid+nrite] = '\0';
            strcpy(szAttrBuf, szJoinBuf);

            // continue searching after replaced part
            ibase = nleft+nmid;
            nlen = strlen(szLineBuf);
         }

         // skip over all -within parms, then continue
         i += 3;
         continue;
      }
      else
      if (   isxopt(pszPat, "-where")
          || isxopt(pszPat, "-lswhere") || isxopt(pszPat, "-lewhere")
         )
      {
         bool blstart = !strcmp(pszPat, "-lswhere");
         bool blend   = !strcmp(pszPat, "-lewhere");
         bool bshow   = !strstr(pszPat, "-noshow");

         bWhereMode = 1;
         bWhereHit  = 0;
         bSkipWhere = 0;

         // -where "??:??:??" -replace /foo/bar/
         i++;
         if (i >= nPat) return 9+perr("missing argument after %s\n", pszPat);
         char *psz = argv[iPat+i];
         // if pattern starts or ends with * is ignored
         bool bFromLeft = 0;
         bool bToRight  = 0;
         bool bForceRep = 0;
         int nPatLen   = strlen(psz);
         if (copyMatchPattern(szLineBuf2, MAX_LINE_LEN, psz, nPatLen, bFromLeft, bToRight, bForceRep))
            return 9;
         // -> sets szLineBuf2, nPatLen, bFromLeft, bToRight.
         int nflags = bCase ? eMatchCase : 0;
         // determine if current line matches the [ls/le]where expression
         int nlen = strlen(szLineBuf);
         for (int ibase=0; ibase<nlen;)
         {
            int ifirst=0, ihitlen=0;
            if (!matchstr(szLineBuf+ibase, szLineBuf2, nflags, ifirst, ihitlen))
               break; // no further hit
            if (blstart && (ibase+ifirst) != 0)
               break; // no hit as it's not at line start
            if (blend && (ibase+ifirst+ihitlen) != nlen) {
               // no hit as it's not (yet) at line end
               ibase += ifirst+ihitlen;
               continue;
            }
            bWhereHit = 1;
            if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
            if (bToRight)   { ihitlen = strlen(szLineBuf+ibase+ifirst); }
            char cattr = 'i';
            if (bshow)
               if (ibase+ifirst+ihitlen < MAX_LINE_LEN)
                  memset(&szAttrBuf[ibase+ifirst], cattr, ihitlen);
            // continue searching after current hit
            ibase += ifirst+ihitlen;
         }
         // -rep etc. will follow, using bWhere... flags
         if (!bWhereHit)
            bSkipWhere = 1;
      }
      else
      if (isxopt(pszPat, "-rep") || isxopt(pszPat, "-lsrep") || isxopt(pszPat, "-lerep"))
      {
         bool blstart = isxopt(pszPat, "-lsrep");
         bool blend   = isxopt(pszPat, "-lerep");

         // next argument is a sed-like replacement pattern
         i++;
         if (i >= nPat) return 9+perr("-rep must be followed by a pattern\n");
         char *pszRep = argv[iPat+i];
         // execute at all?
         if (bSkipWhere)
            continue;
         // in+out: szLineBuf. also uses szLineBuf2.
         if (applyReplace(pszRep, nReplaced, blstart, blend)) return 9;
      }
      else
      if (isopt(pszPat, str("-noop"))) // skip a parameter
      {
         // next argument contains something that should be skipped
         if (i >= nPat-1) return 9+perr("-noop must be followed by a parameter (which is ignored)\n");
         i++;
         continue;
      }
      else
      if (isxopt(pszPat, "-high") || isxopt(pszPat, "-lshigh") || isxopt(pszPat, "-lehigh"))
      {
         bool blstart = isxopt(pszPat, "-lshigh");
         bool blend   = isxopt(pszPat, "-lehigh");

         // -highlight red "POST * HTTP/"
         char *pcol = str("");
         i++;
         if (i >= nPat) return 9+perr("missing argument after %s\n", pszPat);
         pcol = argv[iPat+i];
         i++;
         if (i >= nPat) return 9+perr("missing argument after %s\n", pszPat);
         char *psz = argv[iPat+i];
         // execute at all?
         if (bSkipWhere)
            continue;
         // if pattern starts or ends with *
         bool bFromLeft = 0;
         bool bToRight  = 0;
         bool bForceRep = 0;
         int nPatLen   = strlen(psz);
         if (copyMatchPattern(szLineBuf2, MAX_LINE_LEN, psz, nPatLen, bFromLeft, bToRight, bForceRep))
            return 9;
         // -> sets szLineBuf2, nPatLen, bFromLeft, bToRight.
         int nflags = bCase ? eMatchCase : 0;
         // mark ALL hits within current line
         int nlen = strlen(szLineBuf);
         for (int ibase=0; ibase<nlen;)
         {
            int ifirst=0, ihitlen=0;
            if (!matchstr(szLineBuf+ibase, szLineBuf2, nflags, ifirst, ihitlen))
               break; // no further hit
            if (blstart && (ibase+ifirst) != 0)
               break; // no hit as it's not at line start
            if (blend && (ibase+ifirst+ihitlen) != nlen) {
               // no hit as it's not (yet) at line end
               ibase += ifirst+ihitlen;
               continue;
            }
            if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
            if (bToRight)   { ihitlen = strlen(szLineBuf+ibase+ifirst); }
            // map human color to attribute code
            char cattr = attribFromHumanColor(pcol);
            if (ibase+ifirst+ihitlen < MAX_LINE_LEN)
               memset(&szAttrBuf[ibase+ifirst], cattr, ihitlen);
            // continue searching after current hit
            ibase += ifirst+ihitlen;
         }
      }
      else
      if (isxopt(pszPat, "-sep") || isxopt(pszPat, "-blocksep"))
      {
         // parse user-defined separators for format input.
         // blocksep takes several separators as a single one.
         bBlockSep = (!strcmp(pszPat, "-blocksep")) ? 1 : 0;
         i++;
         if (i >= nPat) return 9+perr("-sep must be followed by separators, e.g. -sep ;\n");
         char *pszStrForm = argv[iPat+i]; // e.g. "; \t"
         // execute at all?
         if (bSkipWhere)
            continue;
         // "-sep -form" user error is checked in setFilterParms.
         // "\t" is NOT replaced by sprintf (belongs to preprocessor),
         // so we have to replace it by native 0x09 here.
         int iout=0;
         char *pszin=pszStrForm;
         while (*pszin && (iout < (int)sizeof(aMaskSep)-10))
         {
            if (cs.spat && !strncmp(pszin, "\\\\", 2))
               { aMaskSep[iout++] = '\\'; pszin += 2; continue; }
            else
            if (cs.spat && !strncmp(pszin, "\\t", 2))
               { aMaskSep[iout++] = '\t'; pszin += 2; continue; }
            else
            if (cs.spat && !strncmp(pszin, "\\q", 2))
               { aMaskSep[iout++] = '"'; pszin += 2; continue; }
            else
            if (cs.spat && !strncmp(pszin, "\\x", 2)) {
               // \xnn - any character with hex code nn
               pszin += 2; // skip \x
               int nhex = getTwoDigitHex(pszin);
               if (nhex <= 0) return 9+perr("illegal value for \\xnn in -sep. use 01 to FF, e.g. \\x09\n");
               pszin += 2; // skip nn
               aMaskSep[iout++] = (char)nhex;
               continue;
            }
            else
               aMaskSep[iout++] = *pszin;
            pszin++;
         }
         aMaskSep[iout] = '\0';
         // printf("masksep: %02x %02x %02x %s\n",aMaskSep[0],aMaskSep[1],aMaskSep[2],pszStrForm);
         continue;
      }
      else
      if (isxopt(pszPat, "-form") || isxopt(pszPat, "-tabform"))
      {
         // alias for -ssep "\t" -form?
         if (isxopt(pszPat, "-tabform")) {
            aMaskSep[0] = '\t';
            aMaskSep[1] = '\0';
         }
         // split lines into whitespace-separated columns, selecting some.
         i++;
         if (i >= nPat) return 9+perr("-form must be followed by %ccol1 etc., e.g. -form \"%ccol2 %ccol5\"\n", glblRunChar, glblRunChar, glblRunChar);
         char *pszMask = argv[iPat+i];
         // execute at all?
         if (bSkipWhere)
            continue;
         // in+out: szLineBuf. also uses szLineBuf2.
         if (applyForm(pszMask, bBlockSep, nLineNum, nOutLineNum)) return 9;
         // form change was really applied:
         nReplaced++;
         // -form does not yet support attributes, therefore reset them.
         memset(szAttrBuf, ' ', MAX_LINE_LEN-10);
         szAttrBuf[MAX_LINE_LEN-10] = '\0';
         continue;
      }
      #ifdef _WIN32
      else
      if (   !strcmp(pszPat, "-ansitodos")
          || !strcmp(pszPat, "-todos"))
      {
         sfkchars.stransitooem(szLineBuf, &iSubChg);
      }
      else
      if (!strcmp(pszPat, "-dostoansi")) {
         sfkchars.stroemtoansi(szLineBuf, &iSubChg);
      }
      #endif
      else
      if (isopt(pszPat, str("-toupper"))) {
         changeLineCase(szLineBuf, 1, &iSubChg);
      }
      else
      if (isopt(pszPat, str("-tolower"))) {
         changeLineCase(szLineBuf, 2, &iSubChg);
      }
      else
      if (isopt(pszPat, str("-toiso="))) {
         cs.toisodef = pszPat[strlen("-toiso=")];
         utf8ToIso(szLineBuf, &iSubChg);
      }
      else
      if (   isopt(pszPat, str("-toiso"))
          || isopt(pszPat, str("-iso"))) {
         utf8ToIso(szLineBuf, &iSubChg);
      }
      else
      if (   isopt(pszPat, str("-toutf"))
          || isopt(pszPat, str("-utf"))) {
         bool bSafe = strcmp(pszPat, "-toutfsafe") ? 0 : 1;
         UTF8Codec::toutf8(szLineBuf2, MAX_LINE_LEN, szLineBuf, bSafe);
         if (strlen(szLineBuf2) != strlen(szLineBuf))
            nReplaced++;
         strcopy(szLineBuf, szLineBuf2);
      }
      else
      if (isopt(pszPat, str("-ltrim"))) {
         trimLine(szLineBuf, 1, &iSubChg);
      }
      else
      if (isopt(pszPat, str("-rtrim"))) {
         trimLine(szLineBuf, 2, &iSubChg);
      }
      else
      if (isopt(pszPat, str("-trim"))) {  // filter
         trimLine(szLineBuf, 3, &iSubChg);
      }
      #ifdef SFKINT2
      else
      if (isopt(pszPat, str("-from"))) {
         char *psub = pszPat+5;
         char szSubPat[100];
         szSubPat[0] = '\0';
         copyFormStr(szSubPat,sizeof(szSubPat),psub,strlen(psub),2);
         int idone=0;
         if (!strcmp(szSubPat,"base64")) {
            idone = decode64((uchar*)szLineBuf, strlen(szLineBuf), (uchar*)szLineBuf2, MAX_LINE_LEN);
         } else {
            char cpre  = '\0';
                 if (!strcmp(szSubPat,"hex"))   { cpre='\0';  }
            else if (!strcmp(szSubPat,"url"))   { cpre='%';   }
            else if (!strcmp(szSubPat+1,"hex")) { cpre=szSubPat[0]; } // _hex
            else return 9+perr("unknown option: %s",pszPat);
            idone = decodeHex(szLineBuf, szLineBuf2, MAX_LINE_LEN, cpre);
         }
         if (idone >= 0)
            strcpy(szLineBuf, szLineBuf2);
      }
      else
      if (isopt(pszPat, str("-to"))) {
         char *psub = pszPat+3;
         char szSubPat[100];
         szSubPat[0] = '\0';
         copyFormStr(szSubPat,sizeof(szSubPat),psub,strlen(psub),2);
         int idone=0;
         if (!strcmp(szSubPat,"base64")) {
            idone = encode64((uchar*)szLineBuf, strlen(szLineBuf), (uchar*)szLineBuf2, MAX_LINE_LEN, MAX_LINE_LEN);
         } else {
            char cpre  = '\0';
                 if (!strcmp(szSubPat,"hex"))   { cpre='\0';  }
            else if (!strcmp(szSubPat,"url"))   { cpre='%';   }
            else if (!strcmp(szSubPat+1,"hex")) { cpre=szSubPat[0]; } // _hex
            else return 9+perr("unknown option: %s",pszPat);
            idone = encodeHex((uchar*)szLineBuf, strlen(szLineBuf), szLineBuf2, MAX_LINE_LEN, cpre, 0);
         }
         if (idone >= 0)
            strcpy(szLineBuf, szLineBuf2);
      }
      #endif
   }
   if (iSubChg) nReplaced++;
   return 0;
}

FileCloser::FileCloser(Coi *pcoi) {
   pClCoi = pcoi;
}
FileCloser::~FileCloser() {
   if (pClCoi && pClCoi->isFileOpen())
      pClCoi->close();
}

void initRandom(char *penv[])
{
   // seed randomizer with time and environment
   SFKMD5 md5;
 
   num nnow = mytime(NULL);
   md5.update((uchar*)&nnow, sizeof(nnow));

   for (int i=0; penv[i] != 0; i++)
   {
      char *psz = penv[i];
      if (strlen(psz) > 0)
         md5.update((uchar*)psz, strlen(psz));
   }
 
   uchar *pdig = md5.digest();

   uint32_t nseed = 0;
   memcpy(&nseed, pdig, sizeof(nseed));
 
   srand(nseed); // initrandom, randhex
}

// dump szLineBuf/szAttrBuf to output.
// also uses szLineBuf2/3 and szAttrBuf2/3.
int dumpFilterLine
 (
   bool     bReWrite,
   SFKMD5    &md5out,
   StringTable &oOut,   // used by rewrite
   int       &nLine,
   int        &nCnt,   // output line counter
   char    *paddmark,
   char     *abLFBuf,
   bool bDumpedFileName
 )
{__
   bool  bLNum      = gfilter.bLNum;
   bool  bCnt       = gfilter.bCnt;
   bool  bDumpLF    = gfilter.bDumpLF;
   bool  bFilenames = gfilter.bFilenames;
   bool  bUseColor  = cs.usecolor;

   char  *pszLine   = szLineBuf;
   char  *pszAttr   = szAttrBuf;

   if (bReWrite)
   {
      // create cache line. have to do this always, in case.
      szLineBuf2[0] = '\0';
      char *psz1 = szLineBuf2;
      if (bLNum) { sprintf(psz1, "%03u ",nLine); psz1 += strlen(psz1); }
      if (bCnt ) { sprintf(psz1, "%03u ",nCnt ); psz1 += strlen(psz1); }
      int nRem = MAX_LINE_LEN - (psz1 - szLineBuf2);
      mystrcopy(psz1, pszLine, nRem-10);
      if (oOut.addEntry(szLineBuf2))
         return 9+perr("out of memory\n");
      int nLineLen2 = strlen(szLineBuf2);
      if (!nLineLen2)
         md5out.update((uchar*)abLFBuf, 1);
      else
         md5out.update((uchar*)szLineBuf2, nLineLen2);
      nCnt++; // output line counter

      // append extra line after block inclusion?
      if (paddmark) {
         oOut.addEntry(paddmark); // ignore rc
         md5out.update((uchar*)paddmark, strlen(paddmark));
         nCnt++;
      }
   }
   else
   if (!cs.justrc)
   {
      // now holding one large output line in pszLine / pszAttr.
      if (cs.wrapcol > 0)
      {
         int nWrapCol = cs.wrapcol;
         if (bLNum) nWrapCol -= 4;
         if (bCnt ) nWrapCol -= 4;

         // -wrap selected: create multiple output lines
         char *psz1 = pszLine;
         char *pszOld = 0;
         while (*psz1)
         {
            pszOld = psz1;
            int icnt = 0;
            char *pszGap = 0;
            // step until overflow or eod, remember last whitespace
            while (*psz1 && (icnt < nWrapCol)) {
               char c = *psz1;
               switch (c) {
                  case ' ': case '\t': case ',':
                     pszGap = psz1;
                     break;
               }
               psz1++;
               icnt++;
            }
            // if overflow, go back past whitespace. if no whitespace,
            // make a word break at that point (splitting very long words).
            if (*psz1) {
               if (pszGap)
                  psz1 = pszGap+1;
            }
            uint noff = pszOld - pszLine;
            uint nlen = psz1 - pszOld;

            // isolate section
            memcpy(szLineBuf2, pszLine+noff, nlen);
            szLineBuf2[nlen] = '\0';
            memcpy(szAttrBuf2, pszAttr+noff, nlen);
            szAttrBuf2[nlen] = '\0';

            // then dump
            if (chain.coldata)
            {
               szLineBuf3[0] = '\0';
               szAttrBuf3[0] = '\0';

               if (bFilenames && bDumpedFileName)
                  strcat(szLineBuf3, "   ");
               if (bLNum) mystrcatf(szLineBuf3, 0, "%03u ", nLine);
               if (bCnt ) mystrcatf(szLineBuf3, 0, "%03u ", nCnt );
               padBuffer(szAttrBuf3, MAX_LINE_LEN, ' ', strlen(szLineBuf3));

               mystrcatf(szLineBuf3, 0, "%s", szLineBuf2);
               mystrcatf(szAttrBuf3, 0, "%s", szAttrBuf2);

               if (bDumpLF) {
                  chain.addLine(szLineBuf3, szAttrBuf3, 1); // 1: splitByLF
               } else {
                  chain.addToCurLine(szLineBuf3, szAttrBuf3);
               }

               if (paddmark) { chain.addLine(paddmark, str("")); nCnt++; }
            } else {
               if (bFilenames && bDumpedFileName)
                  printf("   ");
               if (bLNum) printx("<prefix>%03u<def> ", nLine);
               if (bCnt ) printx("<prefix>%03u<def> ", nCnt );
               if (!bUseColor)
                  printf("%s%s", szLineBuf2, bDumpLF ? "\n":"");
               else
                  printColorText(szLineBuf2, szAttrBuf2, bDumpLF);

               if (paddmark) { printf("%s\n", paddmark); nCnt++; }

               fflush(stdout);
            }
            nCnt++; // output line counter
         }
      }
      else
      {
         // dump whole line in one step
         if (chain.coldata)
         {
            szLineBuf3[0] = '\0';
            szAttrBuf3[0] = '\0';

            if (bFilenames && bDumpedFileName)
               strcat(szLineBuf3, "   ");
            if (bLNum) mystrcatf(szLineBuf3, 0, "%03u ", nLine);
            if (bCnt ) mystrcatf(szLineBuf3, 0, "%03u ", nCnt );
            padBuffer(szAttrBuf3, MAX_LINE_LEN, ' ', strlen(szLineBuf3));

            mystrcatf(szLineBuf3, 0, "%s", pszLine);
            mystrcatf(szAttrBuf3, 0, "%s", pszAttr);

            if (bDumpLF) {
               chain.addLine(szLineBuf3, szAttrBuf3, 1); // 1: splitByLF
            } else {
               chain.addToCurLine(szLineBuf3, szAttrBuf3);
            }

            if (paddmark) { chain.addLine(paddmark, str("")); nCnt++; }
         } else {
            if (bFilenames && bDumpedFileName)
               printf("   ");
            if (bLNum) printf("%03u ", nLine);
            if (bCnt ) printf("%03u ", nCnt );
            // printf("ucl %d\nlbuf %s\nattr %s\n",bUseColor,pszLine,pszAttr);
            if (!bUseColor)
               printf("%s%s", pszLine, bDumpLF ? "\n":"");
            else
               printColorText(pszLine, pszAttr, bDumpLF);
            if (paddmark) { printf("%s\n", paddmark); nCnt++; }
            fflush(stdout);
         }
         nCnt++; // output line counter
      }
   }

   return 0;
}

void mirrorAttrBuf(char ccolin)
{
   int nNewLen = strlen(szLineBuf);
   char ccol = ccolin ? ccolin : ' ';
   memset(szAttrBuf, ccol, nNewLen);
   szAttrBuf[nNewLen] = '\0';
}

// .
int seekToLineFromEnd(Coi *pcoi, int iLineTarg)
{
   num nFileSize  = pcoi->getSize();
   num nBlockSize = mymin(MAX_ABBUF_SIZE, pcoi->getSize());
   num nBlockOffs = nFileSize - nBlockSize;
   if (pcoi->seek(nBlockOffs, SEEK_SET))
      return 9;
   if (pcoi->read(abBuf, nBlockSize) != nBlockSize)
      return 10;

   // step backwards in trailing file bytes
   int iLineDone = 0;
   char *pszMin = (char*)abBuf;
   char *pszMax = (char*)abBuf + nBlockSize;
   char *pszCur = pszMax;
   // do not count very last lf
   if (pszCur>pszMin)
      pszCur--;
   for (; pszCur>pszMin; pszCur--)
   {
      if (pszCur[-1] == '\n') {
         iLineDone++;
         if (iLineDone>=iLineTarg)
            break;
      }
   }
   num nTargOff = nFileSize - (pszMax - pszCur);
   if (cs.debug)
      printf("[seek to %s for line %d from end]\n", numtoa(nTargOff), iLineTarg);
   if (pcoi->seek(nTargOff, SEEK_SET))
      return 9;
   return 0;
}

// . for sfk load
int execLoad(Coi *pcoi)
{__
   if (pcoi->open("rb"))
      return 9+perr("cannot load: %s",pcoi->name());

   size_t nRead = 0;
   while ((nRead = pcoi->read(abBuf,sizeof(abBuf)-10)) > 0)
   {
      if (chain.coldata && chain.colbinary && !cs.collines)
      {
         if (chain.addBinary(abBuf, nRead))
            return 9;
      }
      else if (!chain.colany())
      {
         abBuf[nRead] = '\0';

         #ifdef _WIN32
         char *psz = szPrintBufMap;
         // windows only: if output is NOT directed to file, map it to DOS charset,
         // to have filenames listed with correct umlauts etc.
         if (cs.outcconv && (cs.forcecconv || bGlblHaveInteractiveConsole))
         {
            sfkchars.stransitooem((char*)abBuf);
         }
         #endif

         fwrite(abBuf, 1, nRead, stdout);
      }
      else
      {
         uchar *pSrcCur = abBuf;
         uchar *pSrcMax = abBuf + nRead;

         int iLineLen = 0, iSubLines = 0;
   
         while (pSrcCur < pSrcMax)
         {
            for (iLineLen=0; pSrcCur+iLineLen < pSrcMax; iLineLen++)
               if (pSrcCur[iLineLen]=='\r' || pSrcCur[iLineLen]=='\n')
                  break;
   
            int iRemain = iLineLen;
            iSubLines = 0;
            if (!iLineLen)
               chain.print("\n");
            else
            while (iRemain > 0)
            {
               int iCopy = MAX_LINE_LEN - 10;
   
               if (iCopy > iRemain)
                  iCopy = iRemain;
   
               memcpy(szLineBuf, pSrcCur, iCopy);
               szLineBuf[iCopy] = '\0';
               szAttrBuf[0] = '\0';
   
               chain.addLine(szLineBuf, szAttrBuf);
   
               iSubLines++;
   
               pSrcCur += iCopy;
               iRemain -= iCopy;
            }
            if (iSubLines > 1)
               cs.nlineswrapped++;
   
            // skip EOL: CRLF or LF or CR
            if (pSrcCur+1 < pSrcMax && !strncmp((char*)pSrcCur, "\r\n", 2))
               pSrcCur += 2;
            else
            if (pSrcCur < pSrcMax && (*pSrcCur == '\n' || *pSrcCur == '\r'))
               pSrcCur++;
         }
      }
   }

   pcoi->close();

   return 0;
}

// caller supplies either pszInFile or fin.
int execFilter(Coi *pcoi, FILE *fin, StringPipe *pInData, int nMaxLines, char *pszOutFile)
{__
   // only for display etc., not for fopen:
   char *pszInFile = pcoi ? pcoi->name() : 0;

   mtklog(("execFilter %s skipbin=%d", pszInFile ? pszInFile : "", gfilter.bSkipBinaries));

   char  **argv     = gfilter.argv;
   int  iPat        = gfilter.iPat;
   int  nPat        = gfilter.nPat;
   bool  bReWrite   = gfilter.bReWrite;
   bool  bFilenames = gfilter.bFilenames;

   #ifdef SFKOFFICE
   // sfk194 office safety: RE-write forbidden
   if (bReWrite && !pszOutFile && pcoi)
      if (pcoi->isOffice(__LINE__) || pcoi->isOfficeSubEntry())
         return 9+perr("filter -rewrite is not allowed with office file: %s",pcoi->name());
   #endif // SFKOFFICE

   bool bHaveOut = (pszOutFile != 0);
   if (!bHaveOut && pcoi && pcoi->isWriteable())
      pszOutFile = pcoi->name();

   // in case that -unique is used:
   if (!gfilter.bGlobalUnique)
      glblFilterDups.reset(); // reset per file
   glblFilterDups.setcase(cs.usecase);

   // INPUT FILE CLOSES AUTOMATICALLY.
   FileCloser fcin(pcoi); // does nothing if pcoi == NULL

   if (pszGlblSaveTo) bReWrite = 1;

   if (pcoi)
   {
      if (gfilter.bSkipBinaries && pcoi->isBinaryFile())
      {
         cs.binariesSkipped++;
         if (cs.verbose) {
            setTextColor(nGlblWarnColor);
            oprintf("skipping binary file: %s\n", pcoi->name());
            setTextColor(-1);
         }
         return 0;
      }
      if (gfilter.bReWrite) {
         num nFileSize = pcoi->getSize();
         if (nFileSize > nGlblMemLimit)
            return 9+perr("input file too large: %s (adjust -memlimit)\n", pcoi->name());
         if (!pcoi->isWriteable())
            return 9+perr("readonly file, cannot overwrite: %s\n", pcoi->name());
      }
      if (pcoi->open("rb"))
         return 9+perr("cannot read file: %s%s\n", pcoi->name(),pcoi->lasterr());
      if (cs.taillines > 0) {
         if (seekToLineFromEnd(pcoi, cs.taillines))
            return 9+perr("cannot jump to %dth line from end: %s\n",cs.taillines, pcoi->name());
      }
      if (cs.verbose) {
         info.setStatus("scan", pcoi->name(), 0);
      }
   } else {
      if (bReWrite)
         return 9+perr("-write requires a filename.\n");
   }
 
   StringTable oOut; // in case bReWrite is used
   SFKMD5 md5in;
   SFKMD5 md5out;

   int nMaxLineLen = sizeof(szLineBuf)-10;
   int nLine = 0, nCnt = 1;
   int nMatchingLines = 0;
   int nReplaced = 0;
   bool bUseColor = cs.usecolor;
   bool bDumpedFileName = 0;
   bool bCollectedFileName = 0;
   bool bSave = 0;
   bool bSaveChainOut = 0;
   int lRC = 0;
   bool bSnapFile = 0;
   bool bGrabSubFileName = 0;
   int nSubFiles = 0;
   num  nInputBytes = 0;
   int ncheckcnt = 0;
   int ninccnt  = 0;  // block include counter
   int nexcnt   = 0;  // block exclude counter
   int nexstate = 0;  // block exclude state flags
   int nPostConCnt = 0; // post context down counter
   int nHardWrap = 0; // no. of hard wrapped lines

   char abLFBuf[5];
   abLFBuf[0] = '\n';
   abLFBuf[1] = '\0';

   char szSnapPre[50];  // snapfile prefix
   char szSubFile[300]; // current subfile
   strcpy(szSnapPre, ":file:"); // default
   szSubFile[0] = '\0';

   myfgets_init();
   while (1)
   {
      // always provide an attrib buf in the same length
      // of input text, to allow replacements, highlight etc.
      // including the attribs.
      memset(szAttrBuf, ' ', MAX_LINE_LEN-10);
      szAttrBuf[MAX_LINE_LEN-10] = '\0';

      int nRead = 0;

      if (pInData) {
         // take line from stringpipe
         if (pInData->eod()) {
            mtklog(("filt: indata.eod"));
            break;
         }
         char *pattr = 0;
         char *psz = pInData->read(&pattr);
         // mtklog(("filt: indata.read \"%.100s\"", psz));
         mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
         strcat(szLineBuf, "\n"); // force LF
         int nlen = strlen(szLineBuf);
         if (pattr) {
            mystrcopy(szAttrBuf, pattr, MAX_LINE_LEN);
            // attrib lines are guaranteed to be as int as text
            if ((int)strlen(szAttrBuf) < nlen-1) {
               memset(szAttrBuf, ' ', nlen);
               szAttrBuf[nlen] = '\0';
            }
         }
         nRead = nlen;
         // nRead includes LF
      } else if (pcoi) { // native or virtual file
         nRead = pcoi->readLine(szLineBuf, nMaxLineLen);
         // nRead includes CRLF
      } else if (fin)  { // probably stdin
         nRead = myfgets(szLineBuf, nMaxLineLen, fin, 0, szAttrBuf);
         // nRead includes CRLF
      }
      if (!nRead) {
         mtklog(("filt: nread=0 EOD"));
         break; // EOD
      }
      if (nRead+10 >= nMaxLineLen) {
         // printf("### HARDWRAP\n");
         nHardWrap++;
      } else {
         // printf("### NOWRAP %d %d\n",nRead,nMaxLineLen);
      }

      // allow interrupt while processing very large files:
      if ((++ncheckcnt > 100000) && ((ncheckcnt & 65535)==0))
         if (userInterrupt())   // costs a bit of time
            {  lRC=9; break;  } // stop by escape

      nInputBytes += nRead;

      szLineBuf[nRead] = '\0';
      szAttrBuf[nRead] = '\0';
      nLine++;
      removeCRLF(szLineBuf);

      // 1770: option -maxlines
      if (cs.maxlines>0 && nLine>cs.maxlines)
         break;

      // sfk181: option -line=n
      if (cs.sellines!=0 && cs.linesto!=-1 && nLine>=cs.linesto)
         break;

      if (cs.usesnap && (nLine == 1)) {
         // identify snapfile by header line.
         if (strBegins(szLineBuf, ":snapfile sfk,")) {
            bSnapFile = 1;
            char *pszpre = strstr(szLineBuf, "lprefix=");
            if (pszpre) {
               pszpre += strlen("lprefix=");
               strcopy(szSnapPre, pszpre);
            }
            continue; // don't filter the header line
         }
      }
      if (cs.usesnap && bSnapFile) {
         // indentify subfile headers within a snapfile.
         if (bGrabSubFileName) {
            bGrabSubFileName = 0;
            strcopy(szSubFile, szLineBuf);
            pszInFile = szSubFile;
            bDumpedFileName = 0; // dump this name on first match
            nSubFiles++;
            if (cs.verbose) {
               int nMB = (int)(nInputBytes / 1000000);
               info.setAddInfo("%d mb, %d subfiles", nMB, nSubFiles);
               info.setStatus("scan", szSubFile, 0, eKeepAdd);
            }
            if (!cs.usesnapfiltname)
               continue;
         }
         else
         if (strBegins(szLineBuf, szSnapPre)) {
            bGrabSubFileName = 1;
            continue; // don't filter prefix itself
         }
      }

      int nLineLen = strlen(szLineBuf);
      if (!nLineLen)
         md5in.update((uchar*)abLFBuf, 1); // include empty lines
      else
         md5in.update((uchar*)szLineBuf, nLineLen);

      bool bVerb = 0;
      if (cs.verbose > 1 && nLine == 2) {
         // issue verbose infos on 2nd line, 1st is for syntax checks.
         bVerb = 1;
         if (pszInFile)
            fprintf(stderr, "[read file %s, find:", pszInFile);
         else
            fprintf(stderr, "[read stdin, find:");
      }

      int noldinc = ninccnt;
      int noldex  = nexcnt;

      int nsc = selectTextLine(argv, iPat, nPat, bVerb,
         ninccnt, nexcnt, nexstate,
         pszInFile ? pszInFile : (char*)"", nLine);
      if (nsc > 1) { lRC = nsc; break; }

      // append extra line after block inclusion?
      char *paddmark = 0;
      if (gfilter.pBlockMark) {
         // end of included block?
         if (noldinc && !ninccnt)
            paddmark = gfilter.pBlockMark;
         // end of excluded block?
         if (noldex && !nexcnt && nsc==1) {
            // create pseudo match line,
            // but do NOT set paddmark.
            nsc = 0;
            strcopy(szLineBuf, gfilter.pBlockMark);
            int nlen = strlen(szLineBuf);
            memset(szAttrBuf, 'i', nlen);
            szAttrBuf[nlen] = '\0';
         }
      }

      if (nsc == 0 || nPostConCnt > 0) // if match
      {
         // text line is selected within stream.

         // this means there is a matching file.
         if (gfilter.bPassHitFiles && chain.colfiles && !bCollectedFileName)
         {
            bCollectedFileName = 1;
            // chain mode: collect filenames with hits
            if (!pszInFile) {
                perr("wrong chaining mode: filter collects text but not filenames.\n");
                pinf("try to insert +ttf or +texttofilenames.\n");
                return 9;
            }
            // just scan for word hits: return on first hit
            if (!bReWrite) {
               if (!pcoi) return 9+perr("int. #141271849");
               chain.addFile(*pcoi);
               break;
            }
            // replace and save: do name chaining later
            bSaveChainOut = 1; // later masked by bSave
         }

         nMatchingLines++;

         // print the filename?
         if (   pszInFile && !bReWrite
             && !gfilter.bSingleFile && bFilenames
             && !cs.nonames && !bDumpedFileName
             && !cs.office // sfk194 ofilt never print filename
            )
         {
            bDumpedFileName = 1;
            if (!strncmp(pszInFile, glblDotSlash, 2))
               pszInFile += 2;
            if (chain.coldata) {
               sprintf(szLineBuf2, ":file %s", pszInFile);
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
               chain.addLine(szLineBuf2, szAttrBuf2);
            }
            else
            if (chain.colfiles) { } // done above
            else {
               setTextColor(nGlblFileColor);
               info.print("%s :\n", pszInFile);
               setTextColor(-1);
            }
         }

         // dump pre context lines, if any
         if (gfilter.nprecon)
         {
            bool bcached = 0;

            if (gfilter.pPreConMark && !nPostConCnt)
            {
               bcached = 1;
               strcpy(gfiltPreContext.szClLineTmp, szLineBuf);
               strcpy(gfiltPreContext.szClAttrTmp, szAttrBuf);
               strcopy(szLineBuf, gfilter.pPreConMark);
               mirrorAttrBuf(' ');
               if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, 0, abLFBuf, bDumpedFileName))
                  return 9;
            }

            for (int i=gfilter.nprecon; i>=1; i--)
            {
               char *pszPreLine = gfiltPreContext.getLine(i);
               if (!pszPreLine) continue;

               // dump current pre context line. this requires
               // to place it temporarily into szLine/AttrBuf.
               if (!bcached) {
                  bcached = 1;
                  strcpy(gfiltPreContext.szClLineTmp, szLineBuf);
                  strcpy(gfiltPreContext.szClAttrTmp, szAttrBuf);
               }

               // prepare a precontext line
               strcpy(szLineBuf, pszPreLine);
               mirrorAttrBuf(gfilter.cprecolor);

               // post-process the precontext line (replace, highlight etc.)
               if (processTextLine(argv, iPat, nPat, nReplaced, bUseColor, nLine, nCnt))
                  return 9;

               // dump the precontext line
               if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, 0, abLFBuf, bDumpedFileName))
                  return 9;
            }

            if (bcached) {
               strcpy(szLineBuf, gfiltPreContext.szClLineTmp);
               strcpy(szAttrBuf, gfiltPreContext.szClAttrTmp);
            }
         }

         // handle post context lines
         bool bPostConElapsed = 0;
         if (gfilter.npostcon > 0)
         {
            // why was the current line selected?
            if (!nsc) {
               // if was a true content match: reset postcnt
               // to make sure following context is dumped
               nPostConCnt = gfilter.npostcon;
            } else {
               // it was part of post context.
               mirrorAttrBuf(gfilter.cpostcolor);
               if (nPostConCnt > 0)
                  if (--nPostConCnt == 0)
                     bPostConElapsed = 1;
            }
         }

         // post-process the selected line (replace, highlight etc.)
         if (processTextLine(argv, iPat, nPat, nReplaced, bUseColor, nLine, nCnt))
            return 9;

         // dump current szLineBuf/szAttrBuf to output.
         if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, paddmark, abLFBuf, bDumpedFileName))
            return 9;

         // do we want to save the file content?
         // - if anything replaced
         // - or if found filter matches, and -force specified
         if (cs.writeall || nReplaced || (cs.force && nMatchingLines))
            bSave = 1;

         // if pre context is selected, reset cached precontext.
         gfiltPreContext.reset();

         // if post content was completed, show a marker?
         if (bPostConElapsed && gfilter.pPostConMark)
         {
            strcopy(szLineBuf, gfilter.pPostConMark);
            mirrorAttrBuf(' ');
            if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, 0, abLFBuf, bDumpedFileName))
               return 9;
         }
      }
      else
      {
         // no match, text line is removed from stream.
         nReplaced++;
         bSave = 1;

         // if pre context is selected, remember dropped line.
         if (gfilter.nprecon)
            gfiltPreContext.putLine(szLineBuf);
      }

      if (nMaxLines > -1 && nLine >= nMaxLines)
         break;

   }  // endwhile myfgets

   char *pszChainOutFile = pszInFile;

   // since 161: check for empty text caused by
   // -cut from * to a pattern, without pattern.
   if (nexstate == 1 && cs.nocheck == 0)
   {
      // -cut from * to pat: pat was not found
      bSave = 0; // do NOT rewrite empty file
      if (bReWrite) {
         // -write: simply don't change the file, tell an info.
         if (!cs.noinfo) {
            pwarn("filter -cut from * end marker not found, will not rewrite.\n");
            pinf("add -noinfo to hide this message.\n");
         }
      } else {
         // chain text processing: cannot repair, must stop.
         perr("filter -cut from * end marker not found, stopped processing.");
         pinf("add -nocheck to continue with empty text.\n");
         return 99; // stop all processing
      }
   }

   // detect hard wrap with -skipfirst=n
   if (   cs.force == 0 
       && nHardWrap != 0 && cs.sellines == 1
       && cs.linesfrom > 0 && cs.linesto == -1)
   {
      pwarn("%d long lines got hard wrapped, output is broken.\n", nHardWrap);
      if (bSave)
         pwarn("hard wrapped output will not be written.\n");
      pinf("add option -force to accept hard wrapped lines.\n");
      return 9;
   }

   if (bReWrite && bSave)
   {
      uchar *pmd5in  = md5in.digest();
      uchar *pmd5out = md5out.digest();

      // save only on changes, or if -writeall selected
      if (cs.writeall || memcmp(pmd5in, pmd5out, 16))
      {
         if (cs.sim) {
            // simulating write
            info.setStatus("write", pszOutFile);
            info.setAddInfo("%5d changes", nReplaced);
            info.printLine(1<<2);
         } else {
            // if different output is specified, create directory structure.
            if (bHaveOut)
               if (createOutDirTree(pszOutFile))
                  return 9;
            info.setStatus("write", pszOutFile);
            info.setAddInfo("%5d changes", nReplaced);
            info.printLine(1<<2);
 
            FILE *fout = fopen(pszOutFile, "w");
            if (!fout) return 9+perr("failed to write to: %s\n", pszOutFile);
 
            int nLines = oOut.numberOfEntries();
            for (int i=0; i<nLines; i++)
               fprintf(fout, "%s\n", oOut.getEntry(i, __LINE__));
            fclose(fout);
         }
         gfilter.nTotalRC = 1;
         // use save filename as chain out
         pszChainOutFile = pszOutFile;
      }
   } else {
      if (nMatchingLines > 0)
         gfilter.nTotalRC = 1;
   }

   if (!cs.nocheck) {
      if (ninccnt > 0) {
         perr("%d filter -inc block(s) open at end of: %s", ninccnt, pszInFile ? pszInFile : "");
         pinf("one or more blocks starts were not followed by a block end.\n");
         pinf("add option -nocheck to ignore missing block endings.\n");
         lRC = 5; // filter -inc failure
      }
      if (nexcnt > 0) {
         perr("%d filter -cut block(s) open at end of: %s", nexcnt, pszInFile ? pszInFile : "");
         pinf("one or more block starts were not followed by a block end\n");
         pinf("add option -nocheck to ignore missing block endings.\n");
         lRC = 5; // filter -cut failure
      }
   }

   if (bSaveChainOut && bSave) {
      Coi ocoi(pszChainOutFile, 0);
      chain.addFile(ocoi); // is copied
   }

   return lRC;
}

#ifndef USE_SFK_BASE

num nGlblCheckDiskHits = 0;
num nGlblCDWriteBytes  = 0;
num nGlblCDWriteTime   = 0;
num nGlblCDReadBytes   = 0;
num nGlblCDReadTime    = 0;

int writeDiskSlice(char *pszPath, num nSliceBytes, uchar *pBuf, int nBufSize)
{
   // 1. write slice
   num nTime1 = getCurrentTime();
   FILE *fout = fopen(pszPath, "wb");
   if (!fout) return 9+perr("unable to open test file %s\n", pszPath);
   srand(1); // writeDiskSlice
   num nRemain = nSliceBytes;
   int nBlockSize = nBufSize-10;
   while (nRemain > 0)
   {
      int nWriteSize = nBlockSize;
      if (nWriteSize > nRemain)
          nWriteSize = nRemain;
      for (int i=0; i<nWriteSize; i++)
         pBuf[i] = (uchar)rand();
      int nWriteSize2 = myfwrite(pBuf, nWriteSize, fout);
      if (nWriteSize2 != nWriteSize) {
         fclose(fout);
         return 9+esys("fwrite", "unable to fully write test file %s\n", pszPath);
      }
      nRemain -= nWriteSize;
   }
   fclose(fout);
   num nTime2 = getCurrentTime();

   nGlblCDWriteBytes += nSliceBytes;
   nGlblCDWriteTime  += (nTime2-nTime1);

   return 0;
}

int readDiskSlice(char *pszPath, num nSliceBytes, uchar *pBuf, int nBufSize)
{
   // 2. read and check slice
   num nTime1 = getCurrentTime();
   FILE *fin = fopen(pszPath, "rb");
   if (!fin) return 9+perr("unable to re-read test file %s\n", pszPath);
   srand(1); // readDiskSlice reproduce same pseudo-random sequence
   num nRemain = nSliceBytes;
   int nBlockSize = nBufSize-10;
   num nHits = 0;
   while (nRemain > 0)
   {
      int nReadSize = nBlockSize;
      if (nReadSize > nRemain)
          nReadSize = nRemain;
      int nReadSize2 = fread(pBuf, 1, nReadSize, fin);
      if (nReadSize2 != nReadSize) {
         fclose(fin);
         return 9+perr("unable to re-read test file %s\n", pszPath);
      }
      nRemain -= nReadSize;
      for (int i=0; i<nReadSize; i++)
         if (pBuf[i] != (uchar)rand())
            nHits++;
   }
   fclose(fin);
   num nTime2 = getCurrentTime();

   nGlblCDReadBytes += nSliceBytes;
   nGlblCDReadTime  += (nTime2-nTime1);

   nGlblCheckDiskHits += nHits;

   if (nHits > 0)
      return 1;

   return 0;
}

// uses szLineBuf
int checkDisk(char *pszPath, int nRangeMB)
{__
   num nTotal=0, nFree=0;
   char szFSName[200];
   char szVolID[200];
   uint nVolID=0;

   if (getFileSystemInfo(pszPath, nTotal, nFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10, nVolID))
      return 9;

   num nBrutto = 0;
   num nNetto  = 0;

   if (nRangeMB == -1) {
      nRangeMB = nFree / 1000000;
      nBrutto = (num)nRangeMB * 1000000;
      nNetto  = (num)nBrutto * 9 / 10;
   } else {
      nBrutto = (num)nRangeMB * 1000000;
      nNetto  = nBrutto;
   }

   printf("Testing Volume %s, FileSystem %s, over %u mbytes.\n", szVolID, szFSName, (uint)(nNetto/1000000));

   if (nNetto > nFree)
      return 9+perr("test range too large: volume has only %d free mbytes\n", nFree);

   num nSliceBytes = nNetto / 100;
   printf("Writing 100 temporary files of %s mbytes each. Press ESC to stop.\n", numtoa(nSliceBytes/1000000));

   char abStat[100+10];
   memset(abStat, '.', sizeof(abStat));
   abStat[100] = '\0';

   // for USB stick write performance, we MUST use the largest I/O blocks possible.
   // a large buffer makes I/O about 10 times(!) faster.
   int nWorkBufSize = 1048675 * 50; // yes, 50 megabytes
   uchar *pWorkBuf = new uchar[nWorkBufSize];
   if (!pWorkBuf)
      return 9+perr("out of memory, cannot allocate working buffer.\n");

   memset(pWorkBuf, 0xFF, nWorkBufSize);

   // NO RETURN FROM HERE!

   num nWritten = 0;
   num nTimeW1  = getCurrentTime();
   int i;
   for (i=0; i<100; i++)
   {
      if (userInterrupt())
         break;

      sprintf(szLineBuf, "%s%stmp-test-%02u.dat", pszPath, endsWithPathChar(pszPath)?"":glblPathStr, i);
      int lRC = writeDiskSlice(szLineBuf, nSliceBytes, pWorkBuf, nWorkBufSize);

      if (lRC) abStat[i] = 'E';
      else     abStat[i] = '_';

      if (i < 49) {
         printf("%03u%% > %.50s < \r", i+1, abStat);
         fflush(stdout);
      }
      if (i == 49) {
         printf("%03u%% > %.50s < - 1st half written.\n", i+1, abStat);
      }
      if (i > 49 && i < 99) {
         printf("%03u%% > %.50s < \r", i+1, &abStat[50]);
         fflush(stdout);
      }
      if (i == 99) {
         printf("%03u%% > %.50s < - 2nd half written.\n", i+1, abStat);
      }

      nWritten += nSliceBytes;
   }
   int nCheck  = i;
   num nTimeW2  = getCurrentTime();
   num nWElapse = nTimeW2-nTimeW1;

   uint nkbswrite = (uint)(nWritten / (nWElapse?nWElapse:1));
   printf("Write done at %u kbytes/sec.%.40s\n", nkbswrite, pszGlblBlank);

   memset(pWorkBuf, 0xFF, nWorkBufSize);

   printf("Reading and verifying temporary files.\n");

   memset(abStat, '.', sizeof(abStat));
   abStat[100] = '\0';

   num nFirstHits  = 0;
   num nSecondHits = 0;
   num nReadBytes  = 0;
   num nTimeR1  = getCurrentTime();
   // read and check file system
   for (i=0; i<nCheck; i++)
   {
      // if (userInterrupt())
      //   break;

      sprintf(szLineBuf, "%s%stmp-test-%02u.dat", pszPath, endsWithPathChar(pszPath)?"":glblPathStr, i);
      int lRC = readDiskSlice(szLineBuf, nSliceBytes, pWorkBuf, nWorkBufSize);

      if (lRC) abStat[i] = 'E';
      else     abStat[i] = '_';

      if (i < 49) {
         printf("%03u%% > %.50s < \r", i+1, abStat);
         fflush(stdout);
      }
      if (i == 49) {
         nFirstHits = nGlblCheckDiskHits;
         printf("%03u%% > %.50s < - %s \n", i+1, abStat, nFirstHits ? "1st half contains Errors." : "1st half OK.");
      }
      if (i > 49 && i < 99) {
         printf("%03u%% > %.50s < \r", i+1, &abStat[50]);
         fflush(stdout);
      }
      if (i == 99) {
         nSecondHits = nGlblCheckDiskHits - nFirstHits;
         printf("%03u%% > %.50s < - %s \n", i+1, abStat, nSecondHits ? "2nd half contains Errors." : "2nd half OK.");
      }

      nReadBytes += nSliceBytes;
   }
   num nTimeR2  = getCurrentTime();
   num nRElapse = nTimeR2-nTimeR1;

   uint nkbsread = (uint)(nReadBytes / (nRElapse?nRElapse:1));
   printf("Read done at %u kbytes/sec.%.40s\n", nkbsread, pszGlblBlank);

   // NO RETURN UNTIL HERE.

   delete [] pWorkBuf;
   pWorkBuf = 0;

   // cleanup: delete all files without errors.
   int nKept = 0;
   for (i=0; i<100; i++)
   {
      if (abStat[i] != 'E') {
         sprintf(szLineBuf, "%s%stmp-test-%02u.dat", pszPath, endsWithPathChar(pszPath)?"":glblPathStr, i);
         printf("%02u%% cleanup test files ... \r", i);
         fflush(stdout);
         remove(szLineBuf);
      } else {
         nKept++;
      }
   }

   if (nGlblCheckDiskHits) {
      printf("%s mb of file system checked, errors detected:\n", numtoa(nReadBytes/1000000));
      printf("%s bytes failed to re-read after write.\n", numtoa(nGlblCheckDiskHits));
      printf("%u test files with bad sectors are left over, to cover the bad areas.\n", nKept);
   } else {
      printf("%s mb of file system successfully written and re-read.\n", numtoa(nReadBytes/1000000));
   }

   return 0;
}

#endif // USE_SFK_BASE

#ifdef _WIN32
bool safeOpenClipboard(HWND hNewOwner, bool bquiet=0)
{
   int itry = 0;
   bool btold = 0;
   for (; itry<cs.cliptries; itry++) {
      if (OpenClipboard(hNewOwner))
         break; // ok
      if (itry+1>=cs.cliptries) {
         itry=cs.cliptries;
         break;
      }
      if (!btold && !bquiet) {
         btold=1;
         pinf("clipboard is locked, will retry. (rc=%d)\n",(int)GetLastError());
      }
      Sleep(100);
   }
   if (itry >= cs.cliptries) {
      if (!bquiet) {
         perr("failed to open clipboard. (rc=%d, %d/%d)\n",
            (int)GetLastError(), itry, cs.cliptries);
         pinf("close other apps which may be using it.\n");
      }
      return 0;
   }
   return 1;
}

int putClipboard(char *pszStr)
{__
   if (!safeOpenClipboard(0)) // toclip
      return 9+perr("clipboard #1\n");
   if (!EmptyClipboard())
      return 9+perr("clipboard #2\n");

   int nStrLen = strlen(pszStr);

   HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, nStrLen+10);
   if (hMem == NULL) return 9+perr("clipboard #3\n");

   LPTSTR pCopy = (char*)GlobalLock(hMem);
   if (pCopy)
   {
      memcpy(pCopy, pszStr, nStrLen);
      pCopy[nStrLen] = 0;
   }
   GlobalUnlock(hMem);

   HANDLE hData = SetClipboardData(CF_TEXT, hMem);

   if (hData == NULL) {
      CloseClipboard();
      return 9+perr("clipboard #4\n");
   }

   // System is now owner of hMem.
   CloseClipboard();

   return 0;
}

int putClipboardW(ushort *pWStr,int nchars)
{__
   if (!safeOpenClipboard(0)) // toclipw
      return 9+perr("clipboard #5\n");
   if (!EmptyClipboard())
      return 9+perr("clipboard #6\n");

   HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, nchars*2+8);
   if (hMem == NULL) return 9+perr("clipboard #7\n");

   LPTSTR pCopy = (char*)GlobalLock(hMem);
   if (pCopy) {
      memcpy(pCopy, pWStr, nchars*2);
      pCopy[nchars*2+0] = '\0';
      pCopy[nchars*2+1] = '\0';
   }
   GlobalUnlock(hMem);

   HANDLE hData = SetClipboardData(CF_UNICODETEXT, hMem);

   if (hData == NULL) {
      CloseClipboard();
      return 9+perr("clipboard #8\n");
   }

   // System is now owner of hMem.
   CloseClipboard();

   return 0;
}
#endif

int execJoin(char *pszFirstInput, char *pszDst, bool bTest, char *pszMD5Write);

void dumpFromToSeparator()
{
   sprintf(szLineBuf, " ----- changes to -----");
   mclear(szAttrBuf);
   memset(szAttrBuf, ' ', strlen(szLineBuf));

   if (chain.coldata)
      chain.addLine(szLineBuf, szAttrBuf);
   else
      printColorText(szLineBuf, szAttrBuf);
}

void dumpRepOut(uchar *pSrcCtxData, int iSrcCtxLen,
   int iHitOff, int iHitLen,
   uchar *pDstData, int iDstLen,
   num nListOffset
 )
{
   int iPart1Len = iHitOff;
   int iPart2Len = iDstLen;
   int iP3SrcOff = iHitOff + iHitLen;
   int iPart3Len = iSrcCtxLen - (iHitOff + iHitLen);
   int iTotalLen = iPart1Len+iPart2Len+iPart3Len;
   int iPart2Off = iPart1Len;
   int iPart3Off = iPart1Len+iPart2Len;

   char cframe = 'h';
   char cmatch = 'a';

   num ntotal = 0;

   uchar *pBufCur = pSrcCtxData;
   int nBufRem    = (int)iTotalLen;

   num nHexDumpOff = nGlblHexDumpOff;

   int lOutLen2=0, lIndex=0, lIndex2=0;
   int lRelPos=0;
   uchar *pTmp = 0;
   uchar ucTmp;
   uchar abBlockBuf[1000];

   int nbpl  = bGlblHexDumpWide ?  32 : 16; // bytes per line
   int itext = bGlblHexDumpWide ?  75 : 39; // text begin
   int ioffs = bGlblHexDumpWide ? 108 : 56; // offset begin
   int ieol  = ioffs + 20;
 
   if (nGlblHexDumpForm && cs.bytesperline)
       nbpl = cs.bytesperline;

   num  nTotalMax = 0;
   if (nGlblHexDumpLen > 0)
        nTotalMax = nHexDumpOff + nGlblHexDumpLen;

   if (cs.verbose) {
      printf("dump from %s ",numtoa(nHexDumpOff));
      printf("to %s ",numtoa(nTotalMax));
      printf("a total of %s bytes\n",numtoa(nGlblHexDumpLen));
   }

   bool bNoBlockTrail = (cs.dumptrail & 1) ? 1 : 0;
   bool bNoLineTrail  = (cs.dumptrail & 2) ? 1 : 0;

   uint uiCharPos = 0;

   int  iSrcOff = 0;
   uchar uc=0;

   while (1)
   {
      int nread = 0;
      if (nBufRem <= 0)
         break;
      if (nbpl < nBufRem) nread = nbpl;
      else                nread = nBufRem;

      for (int i=0; i<nread; i++)
      {
         int k = iSrcOff+i;

         if (k < iPart2Off)
            uc = pSrcCtxData[k];
         else if (k < iPart3Off)
            uc = pDstData[k-iPart2Off];
         else
            uc = pSrcCtxData[iP3SrcOff+(k-iPart3Off)];

         abBlockBuf[i] = uc;
      }
      iSrcOff += nread;
      nBufRem -= nread;

      if (nread <= 0) break;
      pTmp = abBlockBuf;

      int lOutLen = nread;
 
      // dump a full or partial output line?
      if (nTotalMax > 0) {
         num nTotalRemain = nTotalMax - ntotal;
         if (lOutLen > nTotalRemain)
            lOutLen = nTotalRemain;
         if (lOutLen <= 0)
            break;
      }

      szLineBuf[0] = '\0';
      bool bshort  = 0;
      bool bEOD    = 0;
 
      // last record?
      if (nTotalMax > 0)
         if (ntotal + nread >= nTotalMax)
            bEOD = 1;

      {
         // dump full hex format with offset and ascii
         memset(szLineBuf, ' ', ieol);
         memset(szAttrBuf, ' ', ieol);
         szLineBuf[ieol] = '\0';
         szAttrBuf[ieol] = '\0';
 
         szLineBuf[1] = '>';
         szAttrBuf[1] = cframe;
 
         char *pszHexOff = numtohex(ntotal+nListOffset, 8);
         strcpy(&szLineBuf[ioffs], pszHexOff);
         // adds zero terminator after offset info!
         int iofflen = strlen(pszHexOff);
         memset(szAttrBuf+ioffs, cframe, iofflen);
         int ieol = strlen(szLineBuf);
         szAttrBuf[ieol] = '\0';
 
         lOutLen2 = lOutLen;
 
         for(lIndex = 2, lIndex2 = itext, lRelPos = 0;
             lOutLen2;
             lOutLen2--, lIndex += 2, lIndex2++
            )
         {
            ucTmp = *pTmp++;
 
            sprintf(szLineBuf + lIndex, "%02X ", (unsigned short)ucTmp);
 
            // optional: highlight CR and LF characters
            if (cs.leattr)
               if (ucTmp == '\r' || ucTmp == '\n') {
                  szAttrBuf[lIndex+0] = cs.leattr;
                  szAttrBuf[lIndex+1] = cs.leattr;
                  szAttrBuf[lIndex2 ] = cs.leattr;
               }

            if(isprint(ucTmp))
               szAttrBuf[lIndex2] = ' ';  // mark printable text
            else
               ucTmp = '.'; // nonprintable char

            // highlight totext
            uiCharPos = ntotal + lRelPos;
            if (uiCharPos >= iPart2Off && uiCharPos < iPart3Off) {
               szAttrBuf[lIndex+0] = cmatch;
               szAttrBuf[lIndex+1] = cmatch;
               szAttrBuf[lIndex2 ] = cmatch;
            }

            szLineBuf[lIndex2] = ucTmp;

            if (!(++lRelPos & 3))     // extra blank after 4 bytes
            {  lIndex++; szLineBuf[lIndex+2] = ' '; }
         }
 
         if (!(lRelPos & 3)) lIndex--;
 
         szLineBuf[lIndex  ]   = '<';
         szLineBuf[lIndex+1]   = ' ';
         szAttrBuf[lIndex ]    = cframe;
 
         if (chain.coldata)
            chain.addLine(szLineBuf, szAttrBuf);
         else
            printColorText(szLineBuf, szAttrBuf);
      }

      ntotal += (num)nread;

      if (bEOD)
         break;
   }
}

bool isHelpOpt(char *psz) {
   if (!strcmp(psz, "-h"))     return 1;
   if (!strcmp(psz, "-help"))  return 1;
   if (!strcmp(psz, "-?"))     return 1;
   if (!strcmp(psz, "/?"))     return 1;
   if (!strcmp(psz, "/help"))  return 1;
   return 0;
}

#ifdef VFILEBASE
void resetLoadCaches(bool bfinal, const char *pszFromInfo)
{
   glblVCache.reset(bfinal, pszFromInfo);
   // fix: 1770: no glblConCache.reset here.
}
#endif // VFILEBASE

// template,tpl: command option handling loop
/*
   ifcmd (!strcmp(pszCmd, "mycommand"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk cmd ...\n"
             "\n"
             "   summary\n"
             "\n"
             "   $options\n"
             "      -opt1     text1\n"
             "\n"
             "   $pattern support\n"
             "   $command chaining\n"
             "   $see also\n"
             "\n"
             "   $examples\n"
             "      #examp1\n"
             "         explanation1\n"
             );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-opt1", &pszParm)) {
            if (!pszParm) return 9;
            nValue = atol(pszParm);
            continue;
         }
         if (!strcmp(pszArg, "-opt2")) {
            bFlag = 1;
            continue;
         }
         if (!strcmp(pszArg, "-opt3"))
            { bFlag = 1; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!strcmp(pszArg, "key1")) {
            if (iDir >= argc-1) return 9+perr("missing parameter after %s\n", pszArg);
            char *pszParm = argx[++iDir];
         }
      }
 
      // ...

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }
*/

StringTable glblSynTests;

void shutdownAllGlobalData()
{__
   mtklog(("shutdownAllGlobalData begin"));

   // final cleanup of tmp cmd data
   cleanupTmpCmdData();

   if (pGlblDumpBuf) delete [] pGlblDumpBuf;

   // cleanup for all commands
   glblFileSet.shutdown();
   glblCircleMap.reset();

   #ifdef VFILEBASE
   resetLoadCaches(1, "sd");
   glblConCache.reset(1, "sd");
   #endif // VFILEBASE

   if (pGlblFileParms)  delete pGlblFileParms;
   if (apGlblFileParms) delete [] apGlblFileParms;
   if (pszGlblJamRoot)  delete [] pszGlblJamRoot;
   if (pszGlblDstRoot)  delete [] pszGlblDstRoot;
   if (pszGlblSinceDir) delete [] pszGlblSinceDir;
   if (pszGlblDirTimes) delete [] pszGlblDirTimes;

   chain.shutdown();
   gfiltPreContext.shutdown();
   glblSynTests.resetEntries();
   #ifndef USE_SFK_BASE
   Media::current().shutdown();
   #endif // USE_SFK_BASE

   #ifndef USE_SFK_BASE // sfk180
   SFKMatch::shutdown();
   #endif // USE_SFK_BASE

   #ifndef SWINST
   sfkfreevars();
   #endif

   #ifdef SFK_CCDIRTIME
   if (glblCreatedDirs.numberOfEntries() > 0)
      if (cs.verbose >= 1) {
         pwarn("createddirs list has remaining entries:\n");
         glblCreatedDirs.dump();
      }
   glblCreatedDirs.resetEntries();
   #endif

   #ifdef _WIN32
   // used by getFileMD5NoCache, was alloc'ed on demand:
   if (pGlblMD5NoCacheBuf != 0)
      VirtualFree(pGlblMD5NoCacheBuf, nGlblMD5NoCacheBufSize, MEM_DECOMMIT);
   #endif

   #ifdef VFILEBASE
   // in case any tcp was used
   TCPCore::sysCleanup();
   #endif // VFILEBASE

   #if (defined(WITH_TCP) || defined(VFILENET) || defined(DV_TCP))
   shutdownTCP();
   #endif

   mtklog(("shutdownAllGlobalData done"));
}

void cleanupTmpCmdData()
{__
   mtklog(("cleanupTmpCmdData"));
   glblGrepPat.reset();
   glblUnzipMask.reset();
   glblIncBin.reset();
   glblSFL.resetEntries();
   glblFileListCache.resetEntries();
   #ifndef USE_SFK_BASE
   glblFTPRemList.resetEntries();
   glblFTPLocList.resetEntries();
   filedb.reset();
   glblVerifier.reset();
   #endif
   glblErrorLog.resetEntries();
   glblStaleLog.resetEntries();
}

// lowest level output for words or full lines
int sfkprintf(const char *pszFormat, ...)
{
   // output to stdout
   va_list argList;
   va_start(argList, pszFormat);
   ::vprintf(pszFormat, argList);
   return 0;
}

#ifndef USE_SFK_BASE

// register syntax test
void subregtest(cchar *pszcmd, cchar *pszTest) {
   // if not running the syntest cmd, do nothing:
   if (strcmp(pszcmd, "syntest"))
      return;
   if (!bGlblSyntaxTest) // avoid recursion
      glblSynTests.addEntry((char*)pszTest);
}

#define regtest(x) subregtest(pszCmd, x)

extern int aGlblSFKStructSizes[];

// run user interface tests, by calling main() again
int runSyntaxTests(char *penv[])
{__
   bGlblSyntaxTest = 1;
   bool bVerbose = (cs.verbose > 0);
   cs.verbose = 0;
   char **myargv = new char*[100];
   char *pszBuf  = new char[MAX_LINE_LEN+10];
   int myargc = 0;
   int lrc=0, npassed=0, nfailed=0;
   for (int i=0; i<glblSynTests.numberOfEntries(); i++)
   {
      myargc = 0;
      myargv[myargc++] = str("sfk");
      myargv[myargc++] = str("-stest");
      char *psz1 = glblSynTests.getEntry(i, __LINE__);
      if (!psz1) break;
      mystrcopy(pszBuf, psz1, MAX_LINE_LEN);
      // linux syntax fixes
      psz1 = pszBuf;
      while ((psz1 = strchr(psz1, '$')))
         *psz1++ = glblRunChar;
      // process line
      psz1 = pszBuf;
      // sfk -stest md5gento dummy.dat dummydir
      while (*psz1) {
         char *psz2 = strchr(psz1, ' ');
         if (psz2) {
            *psz2++ = '\0';
            myargv[myargc++] = psz1;
            // activate masked blanks (_)
            char *psz3 = psz1;
            while ((psz3 = strchr(psz3, '_')))
               *psz3++ = ' ';
            // continue on next parm
            psz1 = psz2;
         } else {
            if (strlen(psz1))
               myargv[myargc++] = psz1;
            break;
         }
      }
      char *pszCmd = myargv[2];
      int iDir = 3;
      bool bFatal = 0;
      lrc = submain(myargc, myargv, penv, pszCmd, iDir, bFatal); // syntest
      if (lrc || bVerbose) {
         printf("rc %d : ", lrc);
         for (int k=0; k<myargc; k++)
            printf("%s ",myargv[k]);
         printf("\n");
      }
      if (lrc) nfailed++;
      else     npassed++;

      // before the next test, reset processing state
      glblFileSet.reset();
      if (pszGlblSinceDir) { delete [] pszGlblSinceDir; pszGlblSinceDir=0; }
      chain.colfiles = 0;
      bGlblStdInAny = 0;
   }
   if (nfailed > 0)
      printf("%d syntax checks failed (%d passed).\n",nfailed,npassed);
   else
      printf(": OK : %d syntax checks passed.\n",npassed);
   delete [] pszBuf;
   delete [] myargv;
   return (nfailed > 0) ? 9 : 0;
}

int blockChain(char *pszCmd)
{
   if (chain.usefiles || chain.usedata || chain.colfiles || chain.coldata)
      return 9+perr("command \"%s\" does not support chaining.\n", pszCmd);
   return 0;
}

// .
int blockChain(char *pszCmd, int iDir, int argc, char *argv[], int nSilent=0)
{
   char *pszNext  = 0;
   bool  bforce   = 0;
   int  bbinary   = 0;
   int nNextType = findNextChainType(iDir, argv, argc, &pszNext, bforce, bbinary);
   if (nNextType == 0)
      return 0;
   if (!(nSilent & 1)) {
      perr("command \"%s\" does not support output chaining (+%s).\n", pszCmd, pszNext);
      if (!(nSilent & 2)) {
         pinf("try \"+then %s\" if \"%s\" requires no input data\n", pszNext, pszNext);
         pinf("try \"sfk -nochain ...\" if you want to process a file with name \"+%s\"\n", pszNext);
      }
   }
   return 9;
}

class SFKMainStat {
public:
    SFKMainStat (num nStartTime);
   ~SFKMainStat ( );
private:
   num clStartTime;
};

SFKMainStat::SFKMainStat(num nStartTime) {
   clStartTime = nStartTime;
}

SFKMainStat::~SFKMainStat( ) {
   if (gs.tellExecTime) {
      printf("done in %s msec. \n", numtoa(getCurrentTime()-clStartTime));
   }
}

char *tabform(char *pszSrc, const char *pszMask)
{
   int iSrcLen = (int)(mymin(MAX_LINE_LEN,strlen(pszSrc)));

   memset(szLineBuf2, 1, iSrcLen);

   char *pDstCur=szLineBuf;
   char *pDstMax=pDstCur+MAX_LINE_LEN;

   // copy selected cols
   while (*pszMask)
   {
      // get next mask col
      int icol = atoi(pszMask);
      if (icol<1) break;

      // seek to col
      int ipos=0;
      icol--;
      for (; icol>0; icol--) {
         while (pszSrc[ipos]!=0 && pszSrc[ipos]!='\t') ipos++;
         if (pszSrc[ipos]=='\t') ipos++;
      }

      // copy col, mark as done
      for (; pszSrc[ipos]!=0 && pszSrc[ipos]!='\t'; ipos++) {
         if (pDstCur >= pDstMax) break;
         *pDstCur++ = pszSrc[ipos];
         szLineBuf2[ipos]=0;
      }
      // if followed by tab mark that as done
      if (pszSrc[ipos]=='\t')
         szLineBuf2[ipos]=0;
      // but always add a tab
      if (pDstCur<pDstMax)
         *pDstCur++ = '\t';

      // to next mask col
      while (*pszMask!=0 && *pszMask!=',') pszMask++;
      if (*pszMask==',') pszMask++;
   }

   // copy rest
   for (int ipos=0; ipos<iSrcLen; ipos++) {
      if (pDstCur >= pDstMax) break;
      if (szLineBuf2[ipos])
         *pDstCur++ = pszSrc[ipos];
   }
   // correct trailing tab, if any
   if (pDstCur>szLineBuf && pDstCur[-1]=='\t')
      pDstCur--;

   *pDstCur = '\0';

   if (cs.debug) {
      printf("row.from \"%s\"\n",pszSrc);
      printf("row.to   \"%s\"\n",szLineBuf);
   }

   return szLineBuf;
}

// .
// sort and count
int groupChainText(char *pcmd, bool brev, bool bcnt, int ndig,
   int ihead=0, cchar *ptabcol=0)
{__
   // use a KeyMap of Index-Based StringMaps:
   KeyMap omap;
   omap.setcase(cs.usecase);
   omap.setreverse(brev);

   // pass-thru table headlines
   for (int i=0; i<ihead && i<chain.indata->numberOfEntries(); i++)
   {
      char *pattr = str("");
      char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
      if (chain.colany())
         chain.addLine(ptext, pattr);
      else
         printColorText(ptext, pattr, 1); // with lf
   }

   // collect text lines into groups
   for (int i=ihead; i<chain.indata->numberOfEntries(); i++)
   {
      char *pattr = str("");
      char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
      char *pkey  = ptext;
      if (ptabcol)
            pkey  = tabform(ptext, ptabcol);
      num   nidx  = 0;
      AttribStringMap *pgrp = (AttribStringMap*)omap.get(pkey);
      if (!pgrp) {
         // create new string group under search key
         pgrp = new AttribStringMap();
         if (!pgrp) return 9+perr("out of memory");
         if (omap.put(pkey, pgrp))
            return 9+perr("failed to sort, probably out of memory");
      } else {
         // add to existing group, at next index
         nidx = pgrp->size(); // next index == size
      }
      if (!pattr) pattr = str("");
      if (pgrp->put(nidx, ptext, pattr))
         return 9+perr("failed to sort, probably out of memory");
   }

   // in case of group, need this:
   StringMap oout;

   // dump group contents
   for (int i=0; i<omap.size(); i++)
   {
      char *pgrpkey = 0;
      AttribStringMap *pgrp = (AttribStringMap*)omap.iget(i, &pgrpkey);
      if (!pgrp) return 9+perr("int. #168281033");
      if (bcnt)
      {
         int nsize = pgrp->size();
         sprintf(szLineBuf, "%0*u\t", (int)ndig, nsize);
         int nlen = strlen(szLineBuf);

         memset(szAttrBuf, 'p', nlen);
         szAttrBuf[nlen] = '\0';

         int nrem = MAX_LINE_LEN - nlen;
         // get first entry of group
         char *pattr = 0, *pkey = 0;
         char *ptext = pgrp->iget(0, &pkey, &pattr);
         if (!ptext) return 9+perr("int. #168281035");

         strncpy(szLineBuf+nlen, ptext, nrem);
         szLineBuf[MAX_LINE_LEN-10] = '\0';

         strncpy(szAttrBuf+nlen, pattr, nrem);
         szAttrBuf[MAX_LINE_LEN-10] = '\0';

         oout.put(szLineBuf, szAttrBuf);
      }
      else
      for (int k=0; k<pgrp->size(); k++) {
         char *pkey = 0, *pattr = 0;
         char *pval = pgrp->iget(k, &pkey, &pattr);
         if (!pval) return 9+perr("int. #168281034");
         if (!pattr) pattr = str("");
         if (chain.colany())
            chain.addLine(pval, pattr);
         else
            printColorText(pval, pattr, 1); // with lf
      }
   }

   if (bcnt) {
      // dump sorted output
      for (int k=0; k<oout.size(); k++) {
         char *pkey=0;
         char *pattr = oout.iget(k, &pkey);
         if (!pkey) return 9+perr("int. #168281039");
         if (!pattr) pattr = str("");
         if (chain.colany())
            chain.addLine(pkey, pattr);
         else
            printColorText(pkey, pattr, 1); // with lf
      }
   }

   // cleanup
   for (int i=0; i<omap.size(); i++)
   {
      AttribStringMap *pgrp = (AttribStringMap*)omap.iget(i);
      mtklog(("pgrp-del %p", pgrp));
      if (pgrp) delete pgrp;
   }

   return 0;
}

#ifdef VFILENET
int execWGet(Coi *psrc, char *pDstDir, uint nmode)
{__
   int lRC = 0;

   num nstart = getCurrentTime();

   char *pSrcName = psrc->name();

   bool bpath2path = (nmode &  2) ? 1 : 0;
   bool b1outfile  = (nmode &  8) ? 1 : 0;
   bool bdump      = (nmode & 32) ? 1 : 0;
   bool bnodump    = (nmode & 64) ? 1 : 0;
 
   // default on single output file
   char *pDstName = pDstDir;

   int nMaxDst= 500;
   char szDstBuf[500+10]; mclear(szDstBuf);

   if (!b1outfile && pDstDir)
   {
      mystrcopy(szDstBuf, pDstDir, nMaxDst);
      strcat(szDstBuf, glblPathStr);
   }

   int isubrc = psrc->open("rb");

   if (isubrc)
      return 9+pferr(psrc->name(), "cannot read: %s%s\n", psrc->name(),psrc->lasterr());

   num nSize = psrc->nClSize; // if any

   char *pctype = psrc->header("content-type");

   // if content is not in memory yet, try to collect,
   // up to a limit of 200 MB
   num    nalloc = 0;
   uchar *pdata  = 0;
   num    nused  = 0;
   bool   btomem = psrc->data().src.data ? 0 : 1;

   // make sure to use the redirected source name
   pSrcName = psrc->name();

   bool bSetDefault = 0;

   if (b1outfile)
   {
      if (cs.verbose)
         printf("write to single output file: %s\n", pDstName);
   }
   else
   {
      // create target filename without output dir

      char *pcat = szDstBuf + strlen(szDstBuf);
      int  nrem = nMaxDst  - strlen(szDstBuf);
 
      if (!flatURLName(pSrcName, pctype, pcat, nrem, nmode, bSetDefault))
         return 9+perr("wrong URL format: %s\n", pSrcName);

      pDstName = szDstBuf;

      if (cs.verbose)
         printf("write to joined output path: %s\n", pDstName);
   }

   if (bSetDefault && !nmode)
      return 9+perr("need -path2name or -fullpath on URLs like : %s\n", pSrcName);

   if (bpath2path)
      if (createOutDirTree(pDstName))
         return 9;

   Coi *pdst = 0;

   if (!bdump) {
      pdst = new Coi(pDstName, 0);
      if (!pdst) return 9+perr("out of memory");
   }
   CoiAutoDelete odel2(pdst, 0); // no decref

   num nread    = 0;
   num nWritten = 0;

   if (chain.coldata && !chain.colbinary)
      chain.addStreamAsLines(1,0,0);

   if (pdst && pdst->open("wb"))
      perr("cannot write: %s%s\n", pdst->name(),pdst->lasterr());
   else
   {
      if (pdst) info.setAction("write", pdst->name(), "");

      while ((nread = psrc->read(abBuf, sizeof(abBuf)-1000)) > 0)
      {
         if (bdump) {
            if (!bnodump) {
               if (chain.coldata) {
                  if (chain.colbinary) {
                     if (chain.addBinary(abBuf, nread))
                        { lRC=9; break; }
                  } else {
                     chain.addStreamAsLines(2, (char*)abBuf, nread);
                  }
               } else {
                  if (myfwrite(abBuf, nread, stdout))
                     { lRC=9; break; }
               }
            }
         }
         else
         if (pdst && pdst->write(abBuf, nread) != nread) {
            perr("cannot fully write %s, probably disk full.\n", pdst->name());
            break;
         }

         if (btomem)
         {
            num nrem = nalloc - nused;
            if (nrem < nread + 1000)
            {
               // expand buffer
               if (!nalloc) nalloc = 10000; // initial

               num nalloc2 = nalloc * 2 + nread;

               if (nalloc2 >= 100 * 1000000) {
                  pinf("download will not be cached (too large).\n");
                  btomem = 0;
                  delete [] pdata;
                  pdata  = 0;
                  nalloc = 0;
               } else {
                  uchar *ptmp = new uchar[nalloc2+100];
                  memcpy(ptmp, pdata, nused);
                  // swap old and new
                  delete [] pdata;
                  pdata  = ptmp;
                  nalloc = nalloc2;
                  nrem   = nalloc - nused;
               }
            }
         }

         if (btomem)
         {
            // add block to memory
            if (nused+nread > nalloc)
               { perr("int. #228290640"); btomem=0; break; }
            memcpy(pdata+nused, abBuf, nread);
            nused += nread;
         }

         nWritten += nread;
         info.setProgress(nSize, nWritten, "bytes");
      }
   }

   if (chain.coldata) chain.addStreamAsLines(3,0,0);

   if (pdst) pdst->close();
   psrc->close();

   if (btomem && pdata && nused)
      psrc->setContent(pdata, nused, psrc->nClMTime);

   // NO cleanup of pdata, as it is cached!

   int ielapsed = (int)(getCurrentTime() - nstart);

   if (pdst != 0 && cs.quiet < 2)
      info.print("done : %s (%s bytes, %d msec).\n", pdst->name(), numtoa(nWritten), ielapsed);
   else
      info.clear(); // fix sfk1814

   if (pdst && chain.colfiles)
   {
      // use tmp coi to make sure it is copied
      Coi ocoi(pdst->name(), 0);
      chain.addFile(ocoi); // is copied
   }

   return lRC;
}
#endif // VFILENET

void reduceToPath(char *psz)
{
   int iLen = strlen(psz);

   if (iLen > 1 && psz[iLen-1] == glblPathChar)
      return; // is a path already

   // FROM F:\\mydir\\zz-index.txt
   // TO   F:\\mydir\\
   // FROM
   while (iLen > 1 && psz[iLen-1] != glblPathChar) {
      psz[iLen-1] = '\0';
      iLen--;
   }
}

// rc  0: invalid
// rc >0: length of headline
int validIndexFormat(char *pszText, char *pszFilename)
{
   // headline must contain: {TAB}name{TAB}sfk-index-
   char *pszHeadStart = pszText;
   char *pszHeadEnd   = strchr(pszHeadStart, '\n');
   char *pszHeadForm  = strstr(pszHeadStart, "\tname\tsfk-index-");
   if (pszHeadForm==0 || pszHeadEnd==0 || pszHeadForm>pszHeadEnd) {
      pwarn("invalid index format, skipping: %s\n", pszFilename);
      pinf("index files must contain a headline with {tab}name{tab}sfk-index-\n");
      return 0;
   }
   return pszHeadEnd - pszHeadStart;
}

int makeINameResultLine(char *pszText, char *pszAttr, int iMask, bool bTabs, int iDigits)
{
   // from: date{tab}time{tab}size{tab}name
   // to  : date time name
   szLineBuf[0] = '\0';
   szAttrBuf[0] = '\0';

   char *pdstt = szLineBuf;
   char *pdsta = szAttrBuf;
   char *pmaxt = szLineBuf + MAX_LINE_LEN;
   char *pmaxa = szAttrBuf + MAX_LINE_LEN;

   char *pcol  = pszText;
   char *pnex  = 0;
   char  csep  = bTabs ? '\t':' ';
   bool  bname = 0;

   for (int icol=0; *pcol; icol++)
   {
      if (!(pnex = strchr(pcol, '\t'))) {
         pnex = pcol + strlen(pcol);
         bname = 1;
      }

      int ilen = pnex - pcol;

      if (*pnex)
         pnex++;

      if (!bname && !(iMask & (1U << icol))) {
         pcol = pnex;
         continue;
      }

      if (icol==2 && bTabs==0)
      {
         // reformat size field
         num nSize = atonum(pcol);
         char *psz = numtoa_blank(nSize, iDigits);
         ilen = strlen(psz);
         if (pdstt+ilen > pmaxt) return 12;
         memcpy(pdstt, psz, ilen);
         pdstt += ilen;
         *pdstt++ = csep;
         if (pszAttr) {
            if (pdsta+ilen > pmaxa) return 12;
            memset(pdsta, ' ', ilen+1);
            pdsta += ilen+1;
         }
      }
      else
      {
         // copy all other fields as is
         if (pdstt+ilen > pmaxt)
            return 11; // overflow
 
         memcpy(pdstt, pcol, ilen);
         pdstt += ilen;
         *pdstt++ = csep;
 
         if (pszAttr) {
            if (pdsta+ilen > pmaxa)
               return 11; // overflow
            memcpy(pdsta, pszAttr+(pcol-pszText), ilen);
            pdsta += ilen;
            *pdsta++ = ' ';
         }
      }

      pcol = pnex;
   }

   *pdstt = '\0';
   *pdsta = '\0';
 
   return 0;
}

void printSearchReplaceCommands(bool bNoBlankLine=0);
void printSFKMatchHelp(bool bRepHelp, bool bFullHelp=1);
void printAboutBracketExamples();
void printXRepExamples(char *pszCmd, bool bFind, bool bRep);
void printBewareWide( );
void printBewareLean( );

void arcinf(int iind)
{
}

static const char *aWebRef[] =
{
   "sfk", "detab", "stat", "dupfind", "filefind", "env", "bintosrc",
   "sleep", "sample", "script", "partcopy", "patch", "rep",
   "pathfind", "ftpserv", "httpserv", "filetrans", "ftp", "remcrlf",
   "joinlines", "find", "filter", "snapto", "winshell", "vmftp", "md5list",
   "clip", "hexdump", "charset", "split", "list", "sincedir", "alias", "tcpdump",
   "echo", "runloop", "hsel", "hopt", "hchain", "hpat", "deblank", "tail",
   "hextobin", "fview", "del", "findclass", "inst", "reflist", "deplist",
   "netlog", "copy", "space", "filetime", "touch", "media", "version", "license",
   "index", "iname", "xex", "hexfind", "xfind", "xhexfind",
   "extract", "xrep", "xed", "csvtotab", "tabtocsv", "rename", "xmlform",
   "entab", "addcrlf", "run", "udpsend", "chars", "hex", "sort",
   "perline", "setvar", "getvar", "helpvar", "ping", "number",
   "fromnet", "wget", "web",
   "setbytes", "scantab", "join", "encode", "decode", "dec", "printloop",
   "head", "strings", "count", "linelen", "ip", "time", "calc", "spell",
   "data", "ruler", 
   0
};

void webref(cchar *pszIn)
{
   if (!strcmp(pszIn, "replace")) pszIn = "rep";

   char *psz = 0;

   for (int i=0; aWebRef[i]; i++) {
      if (!strcmp(pszIn, aWebRef[i])) {
         psz = str(aWebRef[i]);
         break;
      }
   }

   if (!psz) {
      // fprintf(stderr, "NoWebRef: %s\n", pszIn);
      return;
   }

   printx("   $web reference\n"
          "      #http://stahlworks.com/sfk-%s\n"
          "\n", psz);
}

bool isrs(char c, bool &rTabFlag)
{
   if (c == ' ')
      return 1;
   if (c == '\t')
      rTabFlag=1;
   return 0;
}

void printCharInfoRow(uchar uc, int boem, int bmin)
{
   if (bmin) {
      chain.print("%03u\t0x%02X\t%c\n", uc, uc, (char)uc);
      return;
   }

   ushort nuni  = sfkchars.ansitouni(uc);
   uchar  noem  = sfkchars.unitooem(nuni);
   char *pszuni = getuniname(nuni);

   if (boem)
      chain.print("%03u\t0x%02X\t%c\t%03u\t0x%02X\tU+%04X\t%s\n",
         (uint)uc, (uint)uc, (char)uc, (uint)noem, (uint)noem, (uint)nuni, pszuni);
   else
      chain.print("%03u\t0x%02X\t%c\tU+%04X\t%s\n",
         (uint)uc, (uint)uc, (char)uc, (uint)nuni, pszuni);
}

char *loadRepList(char *pszRepFile)
{
   char *pszRepList = 0;

   num nRawSize = 0;

   if (!(pszRepList = (char*)loadBinaryFile(pszRepFile, nRawSize)))
      return 0;

   bool bIsFreeFormat=0;

   int  iRecCur = 0;
   int  iRecMax = 0;

   if (cs.fixedbylist==0 && nRawSize>0)
   {
      char *ptmp=0;

      for (int ipass=0; ipass<2; ipass++)
      {
         if (ipass)
         {
            // this is reached only with multi line format
            iRecMax = iRecCur;
            iRecCur = 0;
            // each record is prefixed by 8 bytes
            // ":123456 "
            //  12345678
            int iHeadBytes = iRecMax * 10;
            nRawSize += iHeadBytes;
            if (!(ptmp = new char[nRawSize+100]))
               { perr("out of memory"); return 0; }
            memset(ptmp, 0, nRawSize+100);
         }

         char *pSrcCur = pszRepList;
         char *pSrcMax = pszRepList+nRawSize;
         char *pDstCur = ptmp;
         char *pDstMax = ptmp+nRawSize;
         char *pLineEnd = 0, *pNetEnd = 0;
         int istate=0,netlen=0,brutlen=0;
         int isep=0,iline=0,ipastsep=0;
         char csep=0,bcr=0,blf=0;

         while (pSrcCur<pSrcMax && *pSrcCur!=0)
         {
            pLineEnd = pSrcCur;
            while (*pLineEnd && !iseol(*pLineEnd))
               pLineEnd++;
            pNetEnd = pLineEnd;
            netlen = pNetEnd-pSrcCur;
            // skip single EOL
            bcr=0; blf=0;
            if (*pLineEnd=='\r') { bcr=1; pLineEnd++; }
            if (*pLineEnd=='\n') { blf=1; pLineEnd++; }
            brutlen = pLineEnd-pSrcCur;
            iline++;

            // printf("LINE.1=%02d l=%02d st=%d sep=%c: %s\n",iline,brutlen,istate,csep,dataAsTrace(pSrcCur,brutlen+5));
            // printf("p=%d sep=%c state=%d: %s\n",ipass,csep,istate,dataAsTrace(pSrcCur,brutlen));

            // compact format always stays in state 0
            if (istate == 0)
            {
               // strip empty lines
               if (netlen < 1) {
                  pSrcCur = pLineEnd;
                  continue;
               }
               // strip whitespace lines incl. tab
               int icheck=0;
               for (; icheck<brutlen; icheck++)
                  if (iseol(*pSrcCur)==0 && isws(*pSrcCur!=' ')==0)
                     break;
               if (icheck>=brutlen) {
                  pSrcCur = pLineEnd;
                  continue;
               }
               // no matter what format, insert prefix now
               if (ipass) {
                  if (pDstCur+9 >= pDstMax)
                     { perr("buffer overflow lrep.9"); return 0; }
                  sprintf(pDstCur, ":@%06u ", iline % 1000000);
                  pDstCur += 9;
               }
               // keep :commands and :# as is
               if (*pSrcCur==':')
               {
                  if (ipass) {
                     if (pDstCur+brutlen >= pDstMax)
                        { perr("buffer overflow lrep.1"); return 0; }
                     memcpy(pDstCur, pSrcCur, brutlen);
                     pDstCur += brutlen;
                  } else {
                     iRecCur++;
                  }
                  pSrcCur  = pLineEnd;
                  continue;
               }
               // a block start was found
               csep = *pSrcCur;
               // scan current line
               isep = 0;
               for (int i=0; i<brutlen; i++)
                  if (pSrcCur[i]==csep)
                     isep++;
               // if it's compact format, keep as is
               if (isep>=3) {
                  if (ipass) {
                     if (pDstCur+brutlen >= pDstMax)
                        { perr("buffer overflow lrep.2"); return 0; }
                     memcpy(pDstCur, pSrcCur, brutlen);
                     pDstCur += brutlen;
                  } else {
                     iRecCur++;
                  }
                  pSrcCur = pLineEnd;
                  continue;
               }
               // start free format block
               if (ipass==0) {
                  bIsFreeFormat=1;
               }
               // printf("p=%d sep=%c state=%d: %s\n",ipass,csep,istate,dataAsTrace(pSrcCur,brutlen));
               // state will be switched below
            }

            bool bTabFlag=0;

            // within free format: check plausi
            if (iseol(*pSrcCur)) {
               perr("line %d empty line not allowed within a command:", iline);
               printf("%.60s\n", pSrcCur);
               if (csep)
                  pinf("check if the previous command was completed correctly.\n");
               return 0;
            }
            if (*pSrcCur!=csep && isrs(*pSrcCur,bTabFlag)==0) {
               perr("line %d missing \"%c\" or blank at start:", iline, csep);
               printf("%.60s\n", pSrcCur);
               if (bTabFlag)
                  pinf("tab character is not allowed, use space instead.\n");
               if (csep)
                  pinf("check if the previous command was completed correctly.\n");
               return 0;
            }

            bool bWhiteStart = isrs(*pSrcCur,bTabFlag);
            char *pLineStart = pSrcCur;

            // trim left and right whitespaces
            while (isrs(*pSrcCur,bTabFlag))
               pSrcCur++;
            while (pNetEnd>pSrcCur && isrs(pNetEnd[-1],bTabFlag)!=0)
               pNetEnd--;
            netlen = pNetEnd-pSrcCur;

            // strict format check
            if (bTabFlag) {
               perr("line %d: TAB character(s) are not allowed, use space instead:", iline);
               printf("%.60s\n", pLineStart);
               return 0;
            }
            if (bWhiteStart!=0 && *pSrcCur==csep) {
               perr("line %d: separator \"%c\" must be placed at line start or end:", iline, csep);
               printf("%.60s\n", pLineStart);
               pinf("use a different separator character if '%c' should be searched.\n", csep);
               return 0;
            }

            bool bEOC = 0;
            for (int i=0; i<brutlen; i++) {
               if (pLineStart[i]==csep) {
                  istate++;
                  if (pLineStart[i+1]=='.')
                     bEOC=1;
               }
            }

            // invalid no. of separators
            if (istate>3) {
               perr("line %d: wrong total number of \"%c\" separators:", iline, csep);
               printf("%.60s\n", pLineStart);
               pinf("a %cfromtext%ctotext%c pattern requires \"%c\" 3 times,\n", csep, csep, csep, csep);
               pinf("and search-only terms must end with %c[all]\\n%c as totext.\n", csep, csep);
               pinf("if you have only search terms you may use -bylinelist\n");
               pinf("which allows one %cfromtext%c per line without any totext.\n", csep, csep);
               pinf("use a different separator character if '%c' should be searched.\n", csep);
               return 0;
            }

            // check context
            if (istate==3) {
               if (bEOC==0) {
                  perr("line %d: missing dot '.' at end of multi line command \"%c.\":", iline, csep);
                  printf("%.60s\n", pLineStart);
                  return 0;
               }
               netlen--;
            }

            if (ipass) {
               if (pDstCur+netlen >= pDstMax)
                  { perr("buffer overflow lrep.3"); return 0; }
               memcpy(pDstCur, pSrcCur, netlen);
               pDstCur += netlen;
            }
            pSrcCur  = pLineEnd;

            // end of block
            if (istate==3) {
               if (ipass) {
                  if (pDstCur+2 >= pDstMax)
                     { perr("buffer overflow lrep.4"); return 0; }
                  if (bcr) *pDstCur++ = '\r';
                  if (blf) *pDstCur++ = '\n';
               } else {
                  iRecCur++;
               }
               istate=0;
            }

         }  // endwhile data

         if (istate)
            perr("missing separator(s), use -showlist to see joined text: %s", pszRepFile);

         if (ipass) {
            *pDstCur = '\0';
            delete [] pszRepList;
            pszRepList = ptmp;
         }

         if (!bIsFreeFormat)
            break;

      }  // endfor pass
   }

   if (cs.showlist)
   {
      if (bIsFreeFormat)
         printx("$----- -bylist commands were joined to: -----\n");
      else
         printx("$----- -bylist was kept unchanged: -----\n");
      int ilen = strlen(pszRepList);
      if (cs.debug) {
         printf("%s\n", dataAsTrace(pszRepList, ilen));
      } else {
         myfwrite((uchar*)pszRepList, ilen, stdout);
         if (ilen<1 || pszRepList[ilen-1]!='\n')
            printf("\n");
      }
      printx("$-------------------------------------------\n");
   }

   return pszRepList;
}

class CharAutoRestore {
public:
      CharAutoRestore (char **pp) {
         pClPPtr   = pp;
         pClOldVal = *pClPPtr;
      }
     ~CharAutoRestore ( ) {
         *pClPPtr  = pClOldVal;
      }
private:
      char **pClPPtr;
      char *pClOldVal;
};

int dumpConsoleHelp(bool bMin)
{
   if (!bMin)
   printx("\n$Swiss File Knife is a program for the command line.<def>\n"
       // "It cannot be used by double clicking on the 'sfk' icon.\n"
          "\n"
          );

   #ifdef _WIN32

   TCHAR szOwnPath[SFK_MAX_PATH + 10];
   mclear(szOwnPath);
   ::GetModuleFileName(NULL, szOwnPath, SFK_MAX_PATH + 2);

   #if 1
   printx("It can be used like this:\n"
          "\n"
          "- create a folder like C:\\tools\n"
          "\n"
          "- copy %s\n"
          "  to C:\\tools\n"
          "\n"
          "- run the \"cmd\" application to open a command line window.\n"
          "\n"
          "- then type c:\\tools\\sfk and read the help text shown.\n"
          "\n"
          "- to use sfk just by typing 'sfk', extend the PATH like:\n"
          "  SET PATH=%cPATH%c;c:\\tools\n"
          "\n"
          , szOwnPath
          , '%', '%'
          );
   #else
   printx("- create a folder like C:\\tools\n"
          "\n"
          "- copy sfk.exe from it's current location\n"
          "  %s\n"
          "  to C:\\tools\n"
          "\n"
          "- search for the \"cmd\" application to open a shell (command line) window.\n"
          "  With Windows 7 just select \"run\" at the left bottom and type \"cmd\".\n"
          "\n"
          "- then type: c:\\tools\\sfk\n"
          "  and read the help text shown.\n"
          "\n"
          "- to use sfk just by typing 'sfk', extend the PATH like:\n"
          "  SET PATH=%cPATH%c;c:\\tools\n"
          "\n"
          "- for your first steps, use CMD but not the PowerShell.\n"
          "  within PowerShell you may have to type .\\sfk instead of sfk\n"
          "\n"
          , szOwnPath
          , '%', '%'
          );
   #endif

   #else

   // not used so far
   printx("- create a simple folder with a short path\n"
          "  that is easy to locate, for example\n"
          "     /home/youruser/tools\n"
          "- store sfk.exe into that folder\n"
          "- open a shell (command prompt window)\n"
          "- then type:\n"
          "  cd /home/youruser/tools\n"
          "  ./sfk\n"
          "- then continue reading the help text shown.\n"
          "  for example, typing\n"
          "     ./sfk stat /\n"
          "  will list folder tree sizes.\n"
          "\n"
          );

   #endif

   return 0;
}

static const char *szGlblBookSamp =
{
"[101]"
   "sfk csvtotab in.csv +xed \"/[start]*[eol]//\" \"/</&lt;/\" \"/>/&gt;/\""
   " +xex \"_[lstart]*\\t*\\t*_<record>\\n <id>[part2]</id>\\n"
   " <name>[part4]</name>\\n <city>[part6]</city>\\n</record>\\n_\"\n"
"[102]"
   "sfk xed in.xml \"/\\q/\\x27/\" +xex \"_<record>**"
   "<id>*</id>**<name>*</name>**<city>*</city>**"
   "</record>_\" -showparts\n"
"[103]"
   "sfk xed in.xml \"/\\q/\\x27/\" +xex \"_<record>**"
   "<id>*</id>**<name>*</name>**<city>*</city>**"
   "</record>_\\q[part4]\\q,\\q[part8]\\q,\\q[part12]\\q\\n_\"\n"
"[104]"
   "sfk xed messages.txt"
   " \"/+message*[eol]-de*[eol]=en*[eol]=it*[eol]"
   "/[parts 1-3]-en[parts 8,9]=de[parts 5,6,10-12]/\""
   " \"/+message*[eol]-de*[eol]=it*[eol]=en*[eol]"
   "/[parts 1-3]-en[parts 11,12]=de[parts 5,6,7-9]/\"\n"
"[105]"
   "sfk xex in.txt \"/[1.100 white][2 chars of a-z][1.100 chars of ( \\t\\r\\n)]/[part2],/\"\n"
"[106]"
   "sfk csvtotab in.csv +xed \"/*\\t*\\t*\\t*\\t*\\t*/\"\n"
"[107]"
   "sfk csvtotab in.csv +xed \"/*\\t*\\t*\\t*\\t*\\t*/"
   "[part9]\\t[part11]\\t[parts 1-3]/\" +sort\n"
};

FILE *openOutFile(int &rrc)
{
   rrc = 0;
   if (!cs.tomask) return 0;
   if (!cs.tomaskfile) return 0;
   FILE *fout = fopen(cs.tomask, "wb");
   if (!fout) {
      perr("cannot write: %s\n", cs.tomask);
      rrc = 9;
   }
   return fout;
}

int loadInput(uchar **ppInText, char **ppInAttr, num *pInSize,
   bool bstdin, char *pszInFile, bool bColor)
{
   num  nStart1 = getCurrentTime();

   uchar *pInText = 0;
   char  *pInAttr = 0;
   num    nInSize = 0;

   char szEOL[20];
   strcopy(szEOL, cs.szeol);
   int  iEOL = strlen(szEOL);

   if (cs.office && pszInFile && endsWithOfficeExt(pszInFile, __LINE__))
   {
      // load single office file content
      if (setProcessSingleDir(pszInFile)) return 9;
      int lFiles=0,lDirs=0; num nBytes=0;
      if (walkAllTrees(eFunc_Load, lFiles, lDirs, nBytes)) return 9;
      if (cs.nlineswrapped && !cs.nowarn)
         pwarn("%s lines(s) were hard wrapped.\n", numtoa(cs.nlineswrapped));
   }
   else if (bstdin || pszInFile)
   {
      if (bstdin) {
         if (!(pInText = (uchar*)loadStdIn(nInSize)))
            perr("missing input from stdin");
      } else {
         if (!(pInText = loadBinaryFlex(pszInFile, nInSize)))
            pferr(pszInFile, "cannot load: %s", pszInFile);
      }
      if (!pInText)
         return 9;
      if (bColor)
      {
         int iTol=100;
         if (!(pInAttr = new char[nInSize+iTol]))
            return 9+perr("out of memory");
         memset(pInAttr, ' ', nInSize+iTol);
         memset(pInAttr+nInSize, 0, iTol);
      }
   }
   else if (chain.nClInBinarySize)
   {
      int iTol=100; // see also loadBinary
      if (!(pInText = chain.loadBinary(nInSize)))
         return 9;
      if (bColor)
      {
         if (!(pInAttr = new char[nInSize+iTol]))
            return 9+perr("out of memory");
         memset(pInAttr, ' ', nInSize+iTol);
         memset(pInAttr+nInSize, 0, iTol);
      }
   }
   else
   {
      uchar *pDstCur=0;
      char  *pAttCur=0;
      for (int ipass=0; ipass<2; ipass++) {
         if (ipass) {
            int iTol=100;
            if (!(pInText = new uchar[nInSize+iTol]))
               return 9+perr("out of memory");
            if (bColor) {
               if (!(pInAttr = new  char[nInSize+iTol]))
                  return 9+perr("out of memory");
            }
            memset(pInText, 0, nInSize+iTol);
            if (bColor) {
               memset(pInAttr, ' ', nInSize+iTol);
               memset(pInAttr+nInSize, 0, iTol);
               pAttCur = pInAttr;
            }
            pDstCur = pInText;
         }
         for (int i=0; i<chain.indata->numberOfEntries(); i++) {
            char *pattr = 0;
            char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
            int   itext = strlen(ptext);
            if (!ipass)
               nInSize += itext+iEOL;
            else {
               memcpy(pDstCur,ptext,itext);
               memcpy(pDstCur+itext,szEOL,iEOL);
               if (bColor && pattr) {
                  int iatt = itext;
                  if (iatt > strlen(pattr))
                      iatt = strlen(pattr);
                  memcpy(pAttCur,pattr,iatt);
               }
               pDstCur += itext+iEOL;
               if (bColor) {
                  pAttCur += itext+iEOL;
               }
            }
         }
      }
      *pDstCur = '\0'; // safety
      if (bColor) {
         *pAttCur = '\0'; // safety
      }
   }

   if (cs.perf)
      printf("%d msec to collect %d input bytes\n", (int)(getCurrentTime()-nStart1), (int)nInSize);

   *ppInText = pInText;
   if (bColor)
      *ppInAttr = pInAttr;
   *pInSize  = nInSize;

   return 0;
}

// RC 0: ok
// RC 1: did terminal output without LF
// RC 9: error
int dumpOutput(uchar *pOutText, char *pOutAttr, num nOutSize, bool bHexDump)
{
   uchar *pSrcCur = pOutText;
   uchar *pSrcMax = pOutText + nOutSize;

   bool bFileDone = 0;
   bool bTermDone = 0;
   bool bGotLF    = 0;

   if (cs.tomask && cs.tomaskfile)
   {
      saveFile(cs.tomask, pOutText, nOutSize);
      bFileDone = 1;
   }

   if (bHexDump)
   {
      // on chaining dump data will be passed
      execHexdump(0, pOutText, nOutSize);
   }
   else if (cs.justrc)
   {
      // sfk181: print nothing, drop output
   }
   else if (chain.coldata && chain.colbinary && !cs.collines)
   {
      if (chain.addBinary(pOutText, nOutSize))
         return 9;
   }
   else if (chain.colany())
   {
      int iLineLen = 0, iSubLines = 0;
      bool bOverFlow = 0;

      while (pSrcCur < pSrcMax)
      {
         for (iLineLen=0; pSrcCur+iLineLen < pSrcMax; iLineLen++)
            if (pSrcCur[iLineLen]=='\r' || pSrcCur[iLineLen]=='\n')
               break;

         int iRemain = iLineLen;
         iSubLines = 0;
         if (!iLineLen)
            chain.addLine(str(""), str(""));
         else
         while (iRemain > 0)
         {
            int iCopy = MAX_LINE_LEN - 10;

            if (iCopy > iRemain)
               iCopy = iRemain;

            memcpy(szLineBuf, pSrcCur, iCopy);
            szLineBuf[iCopy] = '\0';
            if (pOutAttr) {
               memcpy(szAttrBuf, pOutAttr+(pSrcCur-pOutText), iCopy);
               szAttrBuf[iCopy] = '\0';
            } else {
               szAttrBuf[0] = '\0';
            }

            chain.addLine(szLineBuf, szAttrBuf);

            iSubLines++;

            pSrcCur += iCopy;
            iRemain -= iCopy;
         }
         if (iSubLines > 1)
            bOverFlow = 1;

         // skip EOL: CRLF or LF or CR
         if (pSrcCur+1 < pSrcMax && !strncmp((char*)pSrcCur, "\r\n", 2))
            pSrcCur += 2;
         else
         if (pSrcCur < pSrcMax && (*pSrcCur == '\n' || *pSrcCur == '\r'))
            pSrcCur++;
      }

      if (bOverFlow)
         pwarn("some output line(s) were too long and therefore wrapped.\n");
   }
   else if (!bFileDone)
   {
      // to terminal
      bTermDone=1;
      while (pSrcCur < pSrcMax)
      {
         int iCopy = pSrcMax - pSrcCur;
         if (iCopy > MAX_LINE_LEN)
             iCopy = MAX_LINE_LEN;

         // with windows, we have to strip all CR
         // as LF will be auto expanded to CRLF.

         int iDst=0;
         int iAttr=(int)(pSrcCur-pOutText);
         for (int iSrc=0; iSrc<iCopy; iSrc++)
         {
            uchar cSrc = (uchar)pSrcCur[iSrc];
            #ifdef _WIN32
            if (cSrc == '\r')
               continue;
            #endif
            if (cSrc == 0) {
               if (cs.placeholder)
                  cSrc = cs.placeholder;
               else
                  continue;
            }
            if (cs.rawterm==0 && cSrc<32) {
               // strip BEL, BS, EOF
               switch (cSrc) {
                  case '\n':
                     bGotLF=1;
                  case '\t':
                  case 0x1B:
                     break;
                  default:
                     if (cs.placeholder) {
                        cSrc = cs.placeholder;
                        break;
                     }
                     continue;
               }
            }
            szLineBuf[iDst] = (char)cSrc;
            if (pOutAttr)
               szAttrBuf[iDst] = pOutAttr[iAttr+iSrc];
            iDst++;
         }

         szLineBuf[iDst] = '\0';
         if (pOutAttr)
            szAttrBuf[iDst] = '\0';
         else
            szAttrBuf[0] = '\0';

         if (iDst > 0)
            printColorText(szLineBuf, szAttrBuf, 0);

         pSrcCur += iCopy;
      }
   }

   if (bTermDone && !bGotLF)
      return 1;

   return 0;
}

#ifdef SFKWINST
int getWinSystemPath(int nid, char *pOutPath, long nPathMax, cchar *pappend)
{
   *pOutPath = '\0';

   if (nPathMax < _MAX_PATH)
      return 10;

   LPITEMIDLIST pidl;
   HRESULT hr = SHGetSpecialFolderLocation(NULL, nid, &pidl);
   if (hr != S_OK)
      return 11;

   if (!SHGetPathFromIDList(pidl, pOutPath))
      return 12;

   LPMALLOC pMalloc = 0;

   hr = SHGetMalloc(&pMalloc);
   if (hr != S_OK)
      return 13;

   if (pMalloc)
   {
      pMalloc->Free(pidl);
      pMalloc->Release();
   }

   if (pappend) {
      if (strlen(pOutPath)+2+strlen(pappend) >= nPathMax)
         return 14;
      if (!endsWithPathChar(pOutPath))
         strcat(pOutPath,glblPathStr);
      strcat(pOutPath,pappend);
   }

   return 0;
}
#endif // SFKWINST

// block all trivial signals like SIGPIPE.

#ifndef SIGPIPE
 #define SIGPIPE  13  // Broken pipe (POSIX).
#endif

#ifndef SIGCONT
 #define SIGCONT  18  // Continue (POSIX).
#endif

#ifndef SIGWINCH
 #define SIGWINCH 28  // Window size change (4.3 BSD, Sun).
#endif

#ifndef SIGTRAP
 #define SIGTRAP   5  // Trace trap (POSIX).
#endif

void sfkSignalHandler(int nsig)
{
   const char *psig = "";
   switch (nsig) {
      case SIGPIPE : psig = "SIGPIPE"; break;
      case SIGCONT : psig = "SIGCONT"; break;
      case SIGWINCH: psig = "SIGWINCH"; break;
      case SIGTRAP : psig = "SIGTRAP"; break;
   }
   if (nsig != SIGWINCH)
      pinf("signal %u (%s) caught and ignored.\n", nsig, psig);
}

void initSignalHandlers()
{
   #ifndef _WIN32
   signal(SIGPIPE , sfkSignalHandler);
   signal(SIGCONT , sfkSignalHandler);
   signal(SIGWINCH, sfkSignalHandler);
   signal(SIGTRAP , sfkSignalHandler);
   #endif
}

int main(int argc, char *argv[], char *penv[])
{
   char cstackinfo = '\0';
   pGlblStartStack = &cstackinfo;

   // remember original argument list
   gs.argc = argc;
   gs.argv = argv;

   #ifdef VFILEBASE
   // consistent compile test
   int n1=0,n2=0,n3=0,n4=0,n5=0,n6=0;
   getAlignSizes1(n1,n2,n3);
   getAlignSizes2(n4,n5,n6);
   if (n1!=n4 || n2!=n5 || n3!=n6)
   {
      perr("compile error: different structure alignments: %d/%d %d/%d %d/%d",
         n1,n4, n2,n5, n3,n6);
      pinf("sfkext.cpp uses different alignments then sfk.cpp\n");
      return 9;
   }
   #endif // VFILEBASE

   // catch all help requests
   if (argc == 2)
   {
      char *pfirst = argv[1];
      if (   !strcmp(pfirst, "-h") || !strcmp(pfirst, "-help")
          || !strcmp(pfirst, "-?") || !strcmp(pfirst, "/?")
          || !strcmp(pfirst, "/h") || !strcmp(pfirst, "/help")
         )
      {
         printf("To get help, type the command without any parameter.\n");
         printf("For example: \"sfk\", \"sfk list\", \"sfk run\".\n");
         return 9;
      }
   }

   // block trivial signals
   initSignalHandlers();

   #ifdef WITH_TRACING
 
   // debug compile with mtktrace:
   // dump mtk ring buffer on crash
   initCrashHandler(0);
 
   #else
 
   // production: if this is set,
   // a crashlog will be written to that filename.
   char *pszCrashLog = getenv("SFK_CRASH_LOG");
   if (pszCrashLog)
      initCrashHandler(pszCrashLog);
 
   #endif

   #ifdef SFINT
   bool bSkipCNA = 0;
   #endif

   // fundamental inits
   static bool bFirstCall = 1;
   if (bFirstCall)
   {
      bFirstCall = 0;

      szGlblOpenWriteName[0] = 0;
      mclear(szOutNameRecent);
 
      initWildCards();
      initConsole();
      chain.init();

      char *pszCfg = getenv("SFK_CONFIG"); // main
      if (pszCfg)
      {
         char *aSubOpt[2];
         int   iSubOpt = 0;

         char *pszParm = strstr(pszCfg, "active-file-age:");
         if (pszParm)
            nGlblActiveFileAgeLimit = atol(pszParm+16);
         if (strstr(pszCfg, "skip-hour-jump"))
            bGlblIgnore3600 = 1;
         #ifdef SFINT
         if (strstr(pszCfg, "ignore-exec-name"))
            bSkipCNA = 1;
         #endif
         #ifdef VFILEBASE
         if (strstr(pszCfg, "xdemo"))
            gs.xelike = cs.xelike = 1;
         #endif // VFILEBASE
         #ifdef VFILENET
         // if (strstr(pszCfg, "nocache"))
         //    setDiskCacheActive(0);
         #endif // VFILENET
         if (pszParm = strstr(pszCfg, "memlimit:")) {
            int nMBytes = atol(pszParm+strlen("memlimit:"));
            setMemoryLimit(nMBytes);
         }
         if (pszParm = strstr(pszCfg, "weblimit:")) {
            int nMBytes = atol(pszParm+strlen("weblimit:"));
            gs.maxwebsize = nMBytes * 1000000;
         }
         if (pszParm = strstr(pszCfg, "webtimeout:")) { // wto.general
            int ivalue = atol(pszParm+strlen("webtimeout:"));
            gs.maxwebwait = ivalue;
         }
         if (pszParm = strstr(pszCfg, "ftptimeout:")) {
            int ivalue = atol(pszParm+strlen("ftptimeout:"));
            gs.maxftpwait = ivalue;
         }
         if (pszParm = strstr(pszCfg, "tmpdir:")) {
            pszParm += strlen("tmpdir:");
            char *pszEnd = pszParm;
            while (*pszEnd != 0 && *pszEnd != ',')
               pszEnd++;
            int iLen = pszEnd-pszParm;
            memcpy(szLineBuf, pszParm, iLen);
            szLineBuf[iLen] = '\0';
            SFTmpFile::setTmpDir(szLineBuf);
         }
         if (strstr(pszCfg, "echoonstart")) {
            fprintf(stderr, "[cmd]: ");
            for (int i=0; i<argc; i++)
               fprintf(stderr, "%s ", argv[i]);
            fprintf(stderr, "\n");
         }
         if (strstr(pszCfg, "echoonerr")) {
            gs.echoonerr = cs.echoonerr = 1;
         }
         if (strstr(pszCfg, "noesckey")) {
            bGlblDisableEscape = 1;
         }
         if (strBegins(pszCfg, "isochars") || strstr(pszCfg, ",isochars")) { // sfk190
            aSubOpt[0] = str("-isochars"); setGeneralOption(aSubOpt, 0, iSubOpt, 1);
         }
         if (pszParm = strstr(pszCfg, "codepage:")) { // sfk190
            int ivalue = atoi(pszParm+strlen("codepage:"));
            char szOpt[100];
            sprintf(szOpt, "-codepage=%d", ivalue);
            aSubOpt[0] = szOpt; setGeneralOption(aSubOpt, 0, iSubOpt, 1);
         }
         if (strBegins(pszCfg, "deacc") || strstr(pszCfg, ",deacc")) {
            aSubOpt[0] = str("-deacc"); setGeneralOption(aSubOpt, 0, iSubOpt, 1);
         }
         if (strBegins(pszCfg, "xchars") || strstr(pszCfg, ",xchars")) {
            aSubOpt[0] = str("-xchars"); setGeneralOption(aSubOpt, 0, iSubOpt, 1);
         }
         if (strBegins(pszCfg, "noacc") || strstr(pszCfg, ",noacc")) {
            aSubOpt[0] = str("-noacc"); setGeneralOption(aSubOpt, 0, iSubOpt, 1);
         }
         extern int SFKMatchDefaultMaxLen;
         int iXMaxLen = 0;
         if (strBegins(pszCfg, "xmaxlen:")) {
            if ((iXMaxLen = (int)numFromSizeStr(pszCfg+8, "xmaxlen", 1)) >= 1)
               SFKMatchDefaultMaxLen = iXMaxLen;
         }
         if (strBegins(pszCfg, ",xmaxlen:")) {
            if ((iXMaxLen = (int)numFromSizeStr(pszCfg+9, "xmaxlen", 1)) >= 1)
               SFKMatchDefaultMaxLen = iXMaxLen;
         }
         // if (strBegins(pszCfg, "xbytewild") || strstr(pszCfg, ",xbytewild")) {
         //    aSubOpt[0] = str("-xbytewild"); setGeneralOption(aSubOpt, 0, iSubOpt, 1);
         // }
         if (strBegins(pszCfg, "fixedbylist") || strstr(pszCfg, ",fixedbylist")) {
            gs.fixedbylist = cs.fixedbylist = 1;
         }
         if (strBegins(pszCfg, "upat2") || strstr(pszCfg, ",upat2")) {
            setLinuxSyntax(2);
         }
         else
         if (strBegins(pszCfg, "upat") || strstr(pszCfg, ",upat")) {
            setLinuxSyntax(1);
         }
         if (strBegins(pszCfg, "qraw") || strstr(pszCfg, ",qraw")) {
            gs.mlquotes = cs.mlquotes = 'r';
         }
         if (strBegins(pszCfg, "nostrict") || strstr(pszCfg, ",nostrict")) {
            gs.strict = cs.strict = 0;
         }
         else
         if (strBegins(pszCfg, "strict") || strstr(pszCfg, ",strict")) {
            gs.strict = cs.strict = 1;
         }
         if (strBegins(pszCfg, "usesft") || strstr(pszCfg, ",usesft")) {
            gs.allowsft = cs.allowsft = 1;
         }
         // documented
         if (strBegins(pszCfg, "chainweb") || strstr(pszCfg, ",chainweb"))
            gs.cweb = 1;
         if (strBegins(pszCfg, "nochainweb") || strstr(pszCfg, ",nochainweb"))
            gs.cweb = 0;
         // sfk1972 nodirtime by env
         if (strBegins(pszCfg, "nodirtime") || strstr(pszCfg, ",nodirtime"))
            gs.nodirtime = 1;
         // undocumented, kept for compat
         if (strBegins(pszCfg, "cweb") || strstr(pszCfg, ",cweb"))
            gs.cweb = 1;
         if (strBegins(pszCfg, "nocweb") || strstr(pszCfg, ",nocweb"))
            gs.cweb = 0;
         if (strBegins(pszCfg, "nozipmeta") || strstr(pszCfg, ",nozipmeta"))
            gs.nozipmeta = 1;
         if (strBegins(pszCfg, "keepdata") || strstr(pszCfg, ",keepdata"))
            gs.keepdata = cs.keepdata = 1;
         // yet internal with SFK_CONFIG
         if (strBegins(pszCfg, "keepchain") || strstr(pszCfg, ",keepchain"))
            gs.keepchain = cs.keepchain = 1;
      }
   }

   #ifdef SFINT
   // command name aliasing: if our executable is not sfk.exe
   char **paliasv = 0;
   int    naliasc = 0;
   if (!bSkipCNA && !mystrstri(argv[0], "sfk")) {
      // then rebuild parameter set, autoselecting the command
      paliasv = new char*[argc+10];
      naliasc = argc+1;
      for (int i=0; i<argc; i++)
        paliasv[i+1] = argv[i];
      paliasv[0] = "sfk";
      // remap parameter set
      argc = naliasc;
      argv = paliasv;
      // special option for cn-aliases: if first parm is "-version"
      // sfk list -version
      if (argc >= 3 && !strcmp(argv[2], "-version")) {
         // then run version command instead
         argv[1] = "version";
         argc = 2;
      }
   }
   #endif

   // parse and remove general prefix options, e.g. -nocol
   int iDirPre = 1;
   while ((iDirPre < argc) && setGeneralOption(argv, argc, iDirPre, 1)) // 1: global
      iDirPre++;
   memcpy(&cs, &gs, sizeof(cs)); // copy global, permanent options
   argc -= (iDirPre-1);
   argv += (iDirPre-1);

   char *pszCmd = str("?");
   int   iDir   = 0;

   if (argc < 2) {
      // no parms: show help
      if (bGlblStartedInEmptyConsole) {
         dumpConsoleHelp(0);
         bool bwait = 0;
         int isubrc = 0;
         #ifdef SFKWINST
         char *psztarg1=str("C:\\tools");
         char *psztarg2=str("D:\\tools");
         char *psztarg3=0;
         // CSIDL_PROFILE or CSIDL_PERSONAL
         if (!getWinSystemPath(CSIDL_PERSONAL,szLineBuf3,MAX_LINE_LEN,"tools"))
               psztarg3=szLineBuf3;
         printx("$Press '1' now to install SFK<def>, doing the above steps.\n");
         printx("Press $'2'<def> to install to $D:\\tools<def> instead of C:\\tools.\n");
         if (psztarg3)
            printx("Press $'3'<def> to install to $%s<def>.\n",szLineBuf3);
         printx("Press Enter to close this window.\n");
         int ikey=0;
         while (1) {
            ikey = getKeyPress(); // 49 50 13
            if (ikey != -1) break;
            doSleep(100);
         }
         switch (ikey) {
            case '1': isubrc = installSFK(psztarg1, 1); bwait=1; break;
            case '2': isubrc = installSFK(psztarg2, 1); bwait=1; break;
            case '3': if (!psztarg3) break;
                      isubrc = installSFK(psztarg3, 1); bwait=1; break;
         }
         #else
         printx("$Press Enter to close this window.<def>\n");
         getchar();
         #endif // SFKWINST
         if (bwait) {
            printx("[green]Installation %s.[def]\n",isubrc?"failed":"done");
            if (isubrc)
               printf("\nPress Enter to close this window.\n");
            else
               printx("\n==> look for $sfk shell<def> on your desktop.\n"
                      "\nPress Enter to close this window.\n"
                     );
            getchar();
         }
         return 9;
      } else {
         pszCmd = str("dump-main-help");
      }
      // and fall through
   } else {
      pszCmd = argv[1];
      iDir   = 2;
   }

   nGlblStartTime = getCurrentTime();

   SFKMainStat mainStat(nGlblStartTime);

   // see also end of main, loop processing
   bool  bFatal = 0;
   int  lRC    = 0;

   // special case like "sfk +toterm":
   if (argc == 2 && pszCmd[0] == '+')
      pszCmd++; // user wants help for chain-only command

   // sfk cmd parm
   // => nparm == 1 (one parm remaining for this command)
   // => iDir  == 2 (on the parameter, not on the command)

   // command chaining support: from list to +run etc.
   // sfk1933: notice after moveOutToIn is futile
   //    as this alreay prints a notice inside.
   #define STEP_CHAIN(iDirNext,bMod)          \
      bDone = 1;                              \
      if (iDirNext)                           \
      {                                       \
         cspre.uname = cs.uname;              \
         cspre.keepchain = cs.keepchain;      \
         if (cs.memcheck) sfkmem_checklist("command"); \
         pszCmd = argv[iDirNext];             \
         if (pszCmd[0] == '+')                \
            pszCmd++;                         \
         if (gs.nopass == 1 && pszCmd[0] == '+') \
            pszCmd++;                         \
         iDir   = iDirNext+1;                 \
         nparm  = argc-iDir;                  \
         bChainCycle = 1;                     \
         if (!bMod) {                         \
            chain.colfiles = 0;               \
            chain.coldata  = 0;               \
         } else {                             \
          if (chain.moveOutToIn(pszCmd)) {    \
            bDone = 1;                        \
            break;                            \
          }                                   \
         }                                    \
         resetStats();                        \
         if (lRC >= 9) {                      \
            pinf("chaining stops before %s: rc=%d\n", pszCmd, lRC); \
            bDone = 1;                        \
            break;                            \
         } else {                             \
            continue;                         \
         }                                    \
      }

   lRC = submain(argc, argv, penv, pszCmd, iDir, bFatal); // main

   // print overall informal messages
   if (!gs.nonotes) {
      if (gs.utf16read)
         printx("<time>%d utf-16 file(s) decoded%s.<def>\n", gs.utf16read, gs.verbose ? "":" (-verbose for more)");
      else
      if (gs.utf16found && gs.verbose)
         printx("<time>%d utf-16 file(s) found. (see \"sfk help utf\")<def>\n", gs.utf16found);
   }

   #ifdef VFILEBASE
   if (gs.cachestat) {
      num nmax  = glblVCache.bytesMax();
      num ndrop = glblVCache.filesDropped();
      printx(
         "<time>peak cache usage = %d mb. "
         "the memlimit was %sreached (%d drops).<def>\n",
         (int)(nmax / 1000000),
         (ndrop > 0) ? "":"not ",
         (int)ndrop
         );
   }
   #endif // VFILEBASE

   // print error and warning stats
   if (nGlblErrors) {
      setTextColor(nGlblErrColor);
      printf("%d errors", nGlblErrors);
      if (nGlblWarnings) {
         setTextColor(nGlblWarnColor);
         printf(", %d warnings", nGlblWarnings);
         setTextColor(nGlblErrColor);
      }
      if (bGlblSysErrOccured && !bGlblSysErrDetail) {
         printf(" occurred. ");
         setTextColor(nGlblTimeColor, 1);
         printf("add -exterr after sfk for more.\n");
      } else {
         printf(" occurred.\n");
      }
      setTextColor(-1);
   }
   else
   if (nGlblWarnings) {
      setTextColor(nGlblWarnColor);
      printf("%d warnings occurred.\n", nGlblWarnings);
      setTextColor(-1);
   }

   num nStart = getCurrentTime();

   shutdownAllGlobalData();

   #ifdef SFINT
   if (paliasv)
      delete [] paliasv;
   #endif

   #ifdef _MSC_VER
    #ifdef SFK_MEMTRACE
    if (!bFatal && !nGlblError && !nGlblErrors && !bGlblEscape && !bGlblNoMemCheck)
       listMemoryLeaks(); // if any
    #endif
   #endif

   checkFileWrite();

   if (cs.perf)
      printf("%d msec for cleanup\n", (int)(getCurrentTime()-nStart));

   // if any error occurred during file tree processing,
   // build highest error code as application return code.
   if (nGlblShellRC > lRC)
      lRC = nGlblShellRC;

   if (gs.showrc)
      printf("[sfk rc %d]\n", lRC);

   if (bGlblPauseOnEnd) {
      printf("Press ENTER to continue.\n");
      while (getchar() != '\n');
   }

   return lRC;
}

cchar *askBlackList[] = {
   "how","do","i","in","for","the","a","to",
   "use","using","of","by","many","every",
   "only","part","bytes","within","all",
   "from","into","cmd","command",
   "calculate","calc","using","with",
   "on","2g","one","two","three",
   "and","can","out","you","some","is",
   "an","computer","example","cr",
   "specific","given",
   0 // EOD
};

cchar *askReduxList[] = {
   "1bigger", "1directory", "3converting", "4splitting",
   "4comparison", "2converter", "4conversion",
   "2colored", "7tabulation", "2sorted",
   0 // EOD
};

cchar *askSynList[][2] = {
   { "search", "find" },
   { "determine", "find" },
   { "check", "find" },
   { "show", "find" },
   { "string", "word" }, { "phrase", "word" },
   { "txt", "text" },
   { ".txt", "text" },
   { ".bin"," binary" },
   { "filename", "file" },
   { "change", "replace" },
   { "generate", "create" },
   { "shortname", "alias" },
   { "hexadecimal", "hex" },
   { "coloured", "colored" },
   { "linefeed", "lf" },
   { "cr-lf", "crlf" },
   { "execute", "run" },
   { "duplicated", "duplicate" },
   { "executable", "exe" },
   { "colour", "color" },
   { "ls", "list" },
   { "rejoin", "join" },
   { "subfolder", "dir" },
   { "multiple", "many" },
   { "communication", "connection" },
   { "unix", "linux" },
   { ".exe", "exe" },
   { 0, 0 } // EOD
};

// returns a ptr into szLineBuf or NULL
char *filterAskPattern(char *prawpat, char *ppre1, char *ppre2)
{__
   // strip all 1-char words
   if (strlen(prawpat) < 2) return 0;

   int i=0;

   strcopy(szLineBuf, prawpat);
   for (i=0; askBlackList[i]; i++)
      if (!mystricmp(szLineBuf, askBlackList[i]))
         return 0;

   // word reduction:
   char *p  = szLineBuf;
   int nlen = strlen(p);

   // relevant length of -abs is 3
   int rlen = nlen;
   if (*p == '-') rlen--;

   // force all lowercase
   for (i=0; i<nlen; i++)
      p[i] = sfktolower(p[i]);

   // director ies -> director
   if (nlen > 7 && strEnds(p, "ies")) p[nlen-3] = '\0';
   else // file s -> file
   if (rlen > 3 && p[nlen-1] == 's')  p[nlen-1] = '\0';
   else // list ing -> list
   if (nlen > 6 && strEnds(p, "ing")) {
      p[nlen-3] = '\0';
      // split ting -> split by dub consonants
      if (p[nlen-4] == p[nlen-5])
         p[nlen-4] = '\0';
   }

   // reduce by list
   for (i=0; askReduxList[i]; i++) {
      cchar *ppat = askReduxList[i];
      int   nred = (*ppat++) - '0';
      if (!mystricmp(szLineBuf, ppat)) {
         int ncpy = strlen(ppat)-nred;
         memcpy(szLineBuf, ppat, ncpy);
         szLineBuf[ncpy] = '\0';
         break;
      }
   }

   // reduce synonyms
   for (i=0; askSynList[i][0]; i++) {
      cchar *pfrom = askSynList[i][0];
      cchar *pto   = askSynList[i][1];
      if (!mystricmp(p, pfrom))
      {  strcpy(p, pto); break; }
   }
   if (strBegins(p, "folder") || strBegins(p, "director")) strcpy(p, "dir");

   // reduce three word phrases
   #define ifpair(s1,s2) if (!strcmp(ppre2,s1) && !strcmp(ppre1,s2))
   if (ppre2 && ppre1) {
      ifpair ("in","a")
         if (!strcmp(p, "dir")) return 0; // "in a dir"
      ifpair ("of","a")
         if (!strcmp(p, "dir")) return 0; // "of a dir"
   }

   // reduce two word phrases
   if (ppre1) {
      if (strBegins(ppre1, "dir") && !strcmp(p, "tree"))
         return 0; // any command uses a "dir tree"
      if (!strcmp(ppre1, "in") || !strcmp(ppre1, "of") || !strcmp(ppre1, "all")) {
         if (!strcmp(p, "dir"))  return 0; // "in dir", "of dir"
         if (!strcmp(p, "tree")) return 0; // "in tree", "of tree"
      }
      if (!strcmp(ppre1, "file") && strBegins(p, "name"))
         strcpy(p, "file"); // "file name" -> "file"
      if (!mystricmp(ppre1, "cr") && !mystricmp(p, "lf"))
         strcpy(p, "crlf"); // "cr lf" -> "crlf"
   }

   // reduce number strings
   for (i=0; i<nlen; i++)
      if (!isdigit(p[i])) break;
   if (i >= nlen) return 0;

   return szLineBuf;
}

// for sfk "if"
char *pastifop(char *pleft, int *poper)
{
   char *psz=pleft;
   while (*psz) {
      if (!strncmp(psz, " = " , 3)) { *psz='\0'; *poper=0; return psz+3; }
      if (!strncmp(psz, " <> ", 4)) { *psz='\0'; *poper=1; return psz+4; }
      if (!strncmp(psz, " < " , 3)) { *psz='\0'; *poper=2; return psz+3; }
      if (!strncmp(psz, " > " , 3)) { *psz='\0'; *poper=3; return psz+3; }
      if (!strncmp(psz, " <= ", 4)) { *psz='\0'; *poper=4; return psz+4; }
      if (!strncmp(psz, " >= ", 4)) { *psz='\0'; *poper=5; return psz+4; }
      psz++;
   }
   return 0;
}

bool isEndToken(char *psz, int ilen)
{
   if (ilen==4 && strncmp(psz, "+end" , ilen)==0)  return 1;
   if (ilen==5 && strncmp(psz, "+tend", ilen)==0)  return 1;
   if (ilen==5 && strncmp(psz, "+fend", ilen)==0)  return 1;
   return 0;
}

char *findLabel(char *pszSrc, char *pszLabel)
{
   int   ilen=strlen(pszLabel);
   char *psz=pszSrc;
   char *phit=0;

   for (; *psz; psz++)
   {
      if (strncmp(psz, "label ", 6))
         continue;
      phit = psz;
      psz += 6;
      if (strncmp(psz, pszLabel, ilen))
         continue;
      psz += ilen;
      if (*psz==' ' || *psz=='\r' || *psz=='\n')
         return phit;
   }

   return 0;
}

#define SFK_ADD_SIZE { if (!bSize) { bSize=1; cs.listForm = ((cs.listForm << 8) | 0x01); } }

int parseListOpt(bool bFull, int argc, char *argv[], int &iDir, bool &bTime, bool &bSize, bool &bCRC, bool &bPure, bool &bOptErr)
{
   char *pszParm = 0;
   if (!strcmp(argv[iDir], "-size")) {
      // do not just remember the flag, but also option sequence.
      if (!bSize) {
         cs.listForm = ((cs.listForm << 8) | 0x01);
         bSize = 1;
      }
      return 1;
   }
   if (strBegins(argv[iDir], "-kbpure"))   { cs.listunit = 'K'; nGlblListDigits =  9; SFK_ADD_SIZE; return 1; }
   if (strBegins(argv[iDir], "-mbpure"))   { cs.listunit = 'M'; nGlblListDigits =  6; SFK_ADD_SIZE; return 1; }
   if (strBegins(argv[iDir], "-gbpure"))   { cs.listunit = 'G'; nGlblListDigits =  3; SFK_ADD_SIZE; return 1; }
   if (strBegins(argv[iDir], "-kb"))       { cs.listunit = 'k'; nGlblListDigits = 12; SFK_ADD_SIZE; return 1; }
   if (strBegins(argv[iDir], "-mb"))       { cs.listunit = 'm'; nGlblListDigits =  9; SFK_ADD_SIZE; return 1; }
   if (strBegins(argv[iDir], "-gb"))       { cs.listunit = 'g'; nGlblListDigits =  6; SFK_ADD_SIZE; return 1; }
   if (!strncmp(argv[iDir], "-size=", strlen("-size="))) {
      // size format with digits specified
      if (!bSize) {
         cs.listForm = ((cs.listForm << 8) | 0x01);
         bSize = 1;
      }
      char *psz1 = argv[iDir] + strlen("-size=");
      nGlblListDigits = atol(psz1);
      return 1;
   }
   if (bFull && !strncmp(argv[iDir], "-small", 6)) {
      // list sorted by size, show smallest 50 by default
      cs.listBySize = -50;
      if (!bSize && !bPure) {
         cs.listForm = ((cs.listForm << 8) | 0x01);
         bSize = 1;
      }
      if (!strncmp(argv[iDir], "-small=", strlen("-small="))) {
         char *psz1 = argv[iDir] + strlen("-small=");
         if (!strcmp(psz1, "all")) {
            cs.listBySize    = 0 - 1; // sort direction
            cs.listBySizeAll = 1;
         } else {
            cs.listBySize = 0 - atol(psz1);
         }
      }
      return 1;
   }
   if (bFull && !strncmp(argv[iDir], "-big", 4)) {
      // list sorted by size, show biggest 50 by default
      cs.listBySize = 50;
      if (!bSize && !bPure) {
         cs.listForm = ((cs.listForm << 8) | 0x01);
         bSize = 1;
      }
      if (!strncmp(argv[iDir], "-big=", strlen("-big="))) {
         char *psz1 = argv[iDir] + strlen("-big=");
         if (!strcmp(psz1, "all")) {
            cs.listBySize    = 0 + 1; // sort direction
            cs.listBySizeAll = 1;
         } else {
            cs.listBySize = atol(psz1);
         }
      }
      return 1;
   }
   if (bFull && !strncmp(argv[iDir], "-sort", 5))
   {
      // list sorted by name, ALL by default
      cs.listByName    = 0 + 1;
      cs.listByNameAll = 1;
      if (!strncmp(argv[iDir], "-sort=", 6))
      {
         char *psz1 = argv[iDir] + 6;
         if (!strcmp(psz1, "all")) {
            // all is default
         } else {
            cs.listByName    = atol(psz1);
            cs.listByNameAll = 0;
         }
      }
      if (!strncmp(argv[iDir], "-sortr", 6))
      {
         cs.listByName = 0 - 1;
         if (!strncmp(argv[iDir], "-sortrev=", 9))
         {
            char *psz1 = argv[iDir] + 9;
            if (!strcmp(psz1, "all")) {
               // all is default
            } else {
               cs.listByName    = 0 - atol(psz1);
               cs.listByNameAll = 0;
            }
         }
      }
      return 1;
   }
   if (!strcmp(argv[iDir], "-nosize")) {
      // reverse implicite size listing by "-big"
      if ((cs.listForm & 0xFF) == 0x01) {
         cs.listForm >>= 8;
         bSize = 0;
      }
      return 1;
   }
   if (   !strcmp(argv[iDir], "-time")
       || !strcmp(argv[iDir], "-times")) // sfk1920
   {
      // do not just remember the flag, but also option sequence.
      if (!bTime) {
         cs.listForm = ((cs.listForm << 8) | 0x02);
         bTime = 1;
      }
      return 1;
   }
   if (!strcmp(argv[iDir], "-flattime")) {
      if (!bTime) {
         cs.listForm = ((cs.listForm << 8) | 0x02);
         bTime = 1;
      }
      cs.flatTime = 1;
      return 1;
   }
   if (bFull && !strncmp(argv[iDir], "-old", 4)) {
      // list sorted by time, show oldest 50 by default
      cs.listByTime = -50;
      if (!bTime && !bPure) {
         cs.listForm = ((cs.listForm << 8) | 0x02);
         bTime = 1;
      }
      if (!strncmp(argv[iDir], "-old=", strlen("-old="))) {
         char *psz1 = argv[iDir] + strlen("-old=");
         if (!strcmp(psz1, "all")) {
            cs.listByTime    = 0 - 1; // sort direction
            cs.listByTimeAll = 1;
         } else {
            cs.listByTime = 0 - atol(psz1);
         }
      }
      return 1;
   }
   if (bFull && !strncmp(argv[iDir], "-late", 5)) {
      // list sorted by time, show latest 50 by default
      cs.listByTime = 50;
      if (!bTime && !bPure) {
         cs.listForm = ((cs.listForm << 8) | 0x02);
         bTime = 1;
      }
      if (!strncmp(argv[iDir], "-late=", strlen("-late="))) {
         char *psz1 = argv[iDir] + strlen("-late=");
         if (!strcmp(psz1, "all")) {
            cs.listByTime    = 0 + 1; // sort direction
            cs.listByTimeAll = 1;
         } else {
            cs.listByTime = atol(psz1);
         }
      }
      return 1;
   }
   if (bFull && haveParmOption(argv, argc, iDir, "-sort", &pszParm)) {
      if (!pszParm) {
         bOptErr = 1;
         return 9;
      }
      if (!strncmp(pszParm, "late", 4)) {
         cs.listByTime    = 0 + 1; // sort direction
         cs.listByTimeAll = 1;
      }
      if (!strncmp(pszParm, "old", 3)) {
         cs.listByTime    = 0 - 1; // sort direction
         cs.listByTimeAll = 1;
      }
      if (!strncmp(pszParm, "big", 3)) {
         cs.listBySize    = 0 + 1; // sort direction
         cs.listBySizeAll = 1;
      }
      if (!strncmp(pszParm, "small", 5)) {
         cs.listBySize    = 0 - 1; // sort direction
         cs.listBySizeAll = 1;
      }
      return 1;
   }
   if (!strcmp(argv[iDir], "-notime")) {
      // reverse implicite time listing by "-late"
      if ((cs.listForm & 0xFF) == 0x02) {
         cs.listForm >>= 8;
         bTime = 0;
      }
      return 1;
   }
   if (!strcmp(argv[iDir], "-crc")) {
      if (!bCRC) {
         bCRC = 1;
         cs.listForm = ((cs.listForm << 8) | 0x03);
      }
      return 1;
   }

   return 0;
}

void printMainHelp(bool bhelp, char *penv[])
{
   printx("<help>$SFK" SFK_BRANCH " - The Swiss File Knife Multi Function Tool.\n");
   cchar *pfix = SFK_FIXPACK;
   sprintf(szLineBuf, "Release " SFK_VERSION " %s%s%s%s of " VER_DAT_RAW ".",
      pszGlblVerType, SFK_VERTEXT, pfix[0] ? " Revision ":"", pfix);
   printx("%s\n", szLineBuf);
      printf("this binary was compiled and provided by " SFK_PROVIDER ".\n");
      printf("original source and binary package available on sourceforge,\n");
      printf("http://swissfileknife.sourceforge.net\n");

   #ifndef NO_BSD_INFO
   printx("Distributed for free under the BSD License, without any warranty.\n");
   #endif

   #ifdef _WIN32
   if (sizeof(mytime_t) < 8) {
      // if you see this warning, sfk list -time may fail on file dates > 2038.
      // 64-bit times with unix are an sfk issue left open, so there is no warning.
      printx("\ninfo: compile with latest msvc for 64-bit time and size support.\n");
   }
   #endif

   if (bhelp)
   printx("\n<help>$sfk main help (just type \"sfk\"):\n");
   else
   printx("\n<file>type \"sfk commandname\" for help on any of the following.<def>\n"
          "some commands require to add \"-help\" for the help text.\n"
          "\n");

   printHelp(
      "file system\n"
      "   sfk list       - list directory tree contents.\n"
      "                    list latest, oldest or biggest files.\n"
      "                    list directory differences.\n"
      #ifdef VFILEBASE
      "                    list zip jar tar gz bz2 contents.\n"
      #else
      "                    list zip and jar contents.\n"
      #endif // VFILEBASE
      #ifdef SFKOFFICE
      "   sfk olist      - list office files in a folder,\n"
      "                    like .docx .xlsx .ods .odt\n"
      #endif // SFKOFFICE
      "   sfk filefind   - find files by filename\n"
      "   sfk treesize   - show directory size statistics\n"
      "   sfk copy       - copy directory trees additively\n"
      "   sfk sync       - mirror tree content with deletion\n"
      "   sfk rename     - flexible multi file rename\n"
      "   sfk partcopy   - copy part from a file into another one\n"
      "   sfk mkdir      - create directory tree\n"
      "   sfk delete     - delete files and folders\n"
      "   sfk deltree    - delete whole directory tree\n"
      "   sfk deblank    - remove blanks in filenames\n"
      "   sfk space [-h] - tell total and free size of volume\n"
      "   sfk filetime   - tell times of a file\n"
      "   sfk touch      - change times of a file\n"
      "   sfk index      - create index file(s) for fast lookup\n"
      "   sfk name       - lookup file names using index files\n"
      #ifdef SFK_W64
      "   sfk fixfile    - change bad filenames and file times\n"
      #endif
      "   sfk setbytes   - set bytes at offset within a file\n"
      "\n"
      );

   printHelp(
      "compression\n"
      "   sfk zip        - create zip file from folder\n"
      "   sfk zipto      - zip selected file list\n"
      "   sfk unzip      - list or extract zip file\n"
      "   sfk checkzip   - verify zip file content\n"
      "\n"
      );

   printHelp(
      "conversion\n"
      "   sfk oload      - load office file content as text\n"
      "   sfk lf-to-crlf - convert from LF to CRLF line endings\n"
      "   sfk crlf-to-lf - convert from CRLF to LF line endings\n"
      "   sfk detab      - convert TAB characters to spaces\n"
      "   sfk entab      - convert groups of spaces to TAB chars\n"
      "   sfk scantab    - list files containing TAB characters\n"
      "   sfk split      - split large files into smaller ones\n"
      "   sfk join       - join small files into a large one\n"
      "   sfk csvtotab   - convert .csv data to tab separated\n"
      "   sfk tabtocsv   - convert tab separated to .csv format\n"
      "   sfk encode     - convert data to base64 or hex format\n"
      "   sfk decode     - decode base64, hex or url format\n"
      #ifdef _WIN32
      "   sfk wtoa       - convert wide chars to Ansi\n"
      #endif
      "   sfk wtou       - convert wide chars to UTF-8\n"
      #ifdef _WIN32
      "   sfk utoa       - convert UTF-8 text to Ansi\n"
      #endif
      "   sfk hexdump    - create hexdump from a binary file\n"
      "   sfk hextobin   - convert hex data to binary\n"
      "   sfk hex        - convert decimal number(s) to hex\n"
      "   sfk dec        - convert hex number(s) to decimal\n"
      "   sfk chars      - print chars for a list of codes\n"
      "   sfk bin-to-src - convert binary to source code\n"
      "   sfk uuencode   - encode binary files as plain text\n"
      "\n"
      );

   printHelp(
      "text processing\n"
      "   sfk filter     - search, filter and replace text data\n"
      "   sfk ofilter    - filter  text from an office file\n"
      "   sfk replace    - replace words in binary and text files\n"
      "   sfk xed        - edit stream text using sfk expressions\n"
      "   sfk xex        - extract from stream text using expressions\n"
      #ifdef _WIN32
       #if defined(SFKPRO)
       "   sfk xreplace   - replace in files using sfk expressions\n"
       #else
       "   sfk xreplace   - Plus/XE: replace in files using expressions\n"
       #endif
      #endif
      "   sfk run        - run external command on all files of a folder\n"
      "   sfk runloop    - run a command n times in a loop\n"
      "   sfk printloop  - print some text many times\n"
      "   sfk load       - load file content for further processing\n"
      "   sfk perline    - run sfk command(s) per input text line\n"
      "   sfk head       - print first lines of a file\n"
      "   sfk tail       - print last lines of a file\n"
      "   sfk snapto     - join many text files into one file\n"
      "   sfk addhead    - insert string at start of text lines\n"
      "   sfk addtail    - append string at end of text lines\n"
      "   sfk joinlines  - join text lines split by email reformatting\n"
      "   sfk strings    - extract strings from a binary file\n"
      "   sfk sort       - sort text lines produced by another command\n"
      "   sfk count      - count text lines, filter identical lines\n"
      "   sfk difflines  - show text lines differing between files\n"
      "   sfk linelen    - tell length of string(s)\n"
      "\n"
      );

   printHelp(
      "search and compare\n"
      "   sfk xfind      - search in text files using\n"
      "                    wildcards and simple expressions\n"
      #ifdef SFKOFFICE
      "   sfk ofind      - search in office files .docx .xlsx .ods\n"
      #endif // SFKOFFICE
      "   sfk xfindbin   - search in text and binary files\n"
      "   sfk xhexfind   - search with hexdump output\n"
      "   sfk extract    - extract data from text and binary\n"
      "   sfk find       - search static text, without wildcards\n"
      "   sfk hexfind    - search static binary data\n"
      "   sfk md5gento   - create list of md5 checksums over files\n"
      "   sfk md5check   - verify list of md5 checksums over files\n"
      "   sfk md5        - calc md5 over a file, compare two files\n"
      "   sfk pathfind   - search PATH for location of a command\n"
      "   sfk reflist    - list fuzzy references between files\n"
      "   sfk deplist    - list fuzzy dependencies between files\n"
      "   sfk dupfind    - find duplicate files by content\n"
      "\n"
      );

   #ifdef WITH_TCP
   printHelp(
      "networking\n"
      "   sfk httpserv   - run an instant HTTP server.\n"
      "                    type \"sfk httpserv -help\" for help.\n"
      "   sfk ftpserv    - run an instant FTP server\n"
      "                    type \"sfk ftpserv -help\" for help.\n"
      "   sfk ftp        - instant FTP client\n"
      #ifdef VFILENET
      "   sfk web        - send HTTP request to a server\n"
      "   sfk wget       - download HTTP file from the web\n"
      #endif
      "   sfk tcpdump    - print TCP conversation between programs\n"
      "   sfk udpdump    - print incoming UDP requests\n"
      "   sfk udpsend    - send UDP requests\n"
      "   sfk ip         - tell own machine's IP address(es).\n"
      "                    type \"sfk ip -help\" for help.\n"
      "   sfk netlog     - send text outputs to network,\n"
      "                    and/or file, and/or terminal\n"
      "   sfk fromnet -h - receive and print network text\n"
      "   sfk ping       - ping multiple machines in one go\n"
      "   sfk pingdiff   - find ip of new devices\n"
      "\n"
      );
   #endif

   printHelp(
      "scripting\n"
      "   sfk help chain - how to combine multiple commands\n"
      "   sfk batch      - run many sfk commands in a script file\n"
      "   sfk label      - define starting points within a script\n"
      "   sfk call       - call a sub function at a label\n"
      "   sfk echo       - print (coloured) text to terminal\n"
      "   sfk color      - change text color of terminal\n"
      "   sfk setvar     - put text into an sfk variable\n"
      "   sfk storetext  - store text in memory for later use\n"
      "   sfk alias      - create command from other commands\n"
      "   sfk mkcd       - create command to reenter directory\n"
      "   sfk sleep      - delay execution for milliseconds\n"
      "   sfk pause      - wait for user input\n"
      "   sfk stop       - stop sfk script execution\n"
      "   sfk tee        - split command output in two streams\n"
      "   sfk tofile     - save command output to a file\n"
      "   sfk toterm     - flush command output to terminal\n"
      "   sfk for        - repeat commands many times\n"
      "   sfk loop       - repeat execution of all commands\n"
      "   sfk cd         - change directory within a script\n"
      "   sfk getcwd     - print the current working directory\n"
      "   sfk require    - compare version text\n"
      "   sfk time [-h]  - print current date and time\n"
      "\n"
      );

   printHelp(
      "development\n"
      "   sfk bin-to-src - convert binary data to source code\n"
      "   sfk make-random-file - create file with random data\n"
      "   sfk fuzz       - change file at random, for testing\n"
      "   sfk sample     - print example code for programming\n"
      "   sfk patch      - change text files through a script\n"
      "   sfk inst       - instrument c++ with tracing calls\n"
      "\n"
      );

   printHelp(
      "diverse\n"
      "   sfk view       - show text output in a GUI tool,\n"
      "                    for interactive browse and filter\n"
      "   sfk status     - send colored status to the SFKTray\n"
      "                    Windows GUI utility for display\n"
      "   sfk calc       - do a simple instant calculation\n"
      "   sfk random     - create a random number\n"
      "   sfk prompt     - ask for user input\n"
      "   sfk number     - print number in diverse formats\n"
      "   sfk xmlform    - reformat xml  for easy viewing\n"
      "   sfk jsonform   - reformat json for easy viewing\n"
   // "   sfk media      - cut video and binary files\n"
      "   sfk video      - how to edit video files\n"
      #ifdef _WIN32
      "   sfk toclip     - copy command output to clipboard\n"
      "   sfk fromclip   - read text from clipboard\n"
      #endif
      "   sfk env        - search environment variables\n"
      "   sfk version    - show version of a binary file\n"
      #ifdef _WIN32
      "   sfk ascii      - list Ansi codepage characters\n"
      "   sfk ascii -dos - list OEM  codepage characters\n"
      #else
      "   sfk ascii      - list ASCII characters\n"
      #endif
      "   sfk spell      - phonetic spelling for telephone\n"
      "   sfk cmd        - print an example command\n"
      "   sfk data       - create random test data\n"
      "   sfk ruler      - measure console text width\n"
      "   sfk license    - print the SFK license text\n"
      "   sfk update     - check for SFK updates\n"
      "\n"
      );

   printHelp(
      "help by subject\n"
      #ifdef SFKOFFICE
      "   sfk help office   - how to search in office files\n"
      #endif // SFKOFFICE
      "   sfk help select   - how dirs and files are selected in sfk\n"
      "   sfk help options  - general options reference\n"
      "   sfk help patterns - wildcards and text patterns within sfk\n"
      "   sfk help chain    - how to combine (chain) multiple commands\n"
      "   sfk help var      - how to use sfk variables and parameters\n"
      "   sfk samp          - example scripts on sfk use and for\n"
      "                       http web access automation\n"
      "   sfk help shell    - how to optimize the windows command prompt\n"
      #ifdef _WIN32
      "   sfk help chars    - about locale specific characters\n"
      "   sfk help nocase   - about case insensitive search\n"
      #endif
      "   sfk help unicode  - about unicode file reading support\n"
      "   sfk help colors   - how to change result colors\n"
      "   sfk help compile  - how to compile sfk on any linux system\n"
   // "   sfk help fileset  - how to list dir names in a text file.\n"
      "\n"
      );

   bool bFirstEnv=1;
   for (int i=0; penv[i]; i++) {
      char *psz = penv[i];
      // do not print FTP_PW but only:
      if (   !strBegins(psz, "SFK_CONFIG=")
          && !strBegins(psz, "SFK_HOME=")
          && !strBegins(psz, "SFK_LOGTO=")
          && !strBegins(psz, "SFK_ZIP_EXT=")
          && !strBegins(psz, "SFK_COLORS=")
          && !strBegins(psz, "SFK_CMD_LOG=")
          && !strBegins(psz, "SFK_PROXY=")
          && !strBegins(psz, "SFK_CRASH_LOG=")
          && !strBegins(psz, "SFK_PATH=")
          && !strBegins(psz, "SFK_OWN_NET=")
          && !strBegins(psz, "SFK_OWN_IP=")
         )
         continue;
      if (bFirstEnv) {
         bFirstEnv=0;
         printx("   $sfk currently uses these environment variables:\n\n");
      }
      char *psz2=strchr(psz,'=');
      int inamelen=(int)strlen(psz);
      if (psz2!=0)
          inamelen=(int)(psz2-psz)+1;
      printx("      %.*s#%s\n", inamelen,psz,psz+inamelen);
   }
   if (!bFirstEnv) printx("\n");

   printx("   $first time user?\n"
          " \n"
          "      type #\"sfk basic\"<def> for very basic informations about\n"
          "      how to select files, general options, shell preparation,\n"
          "      complex $<>|!&?*<def> character issues and color setup.\n"
          "\n"
          "   $to search ALL help text for a topic:\n"
          "\n"
          "      type #\"sfk ask word1\"<def>    to search all for word1.\n"
          "      type #\"sfk ask w1 w2\"<def>    to search all for w1 or w2.\n"
          "      type #\"sfk dumphelp\"<def>     to print ALL help text.\n"
          "\n"
          );

   #ifndef SFKPRO
   printx("   +----------------------------------------------------------+\n"
          "   |     $Consider these addons to boost your daily work:<def>      |\n"
          "   |----------------------------------------------------------|\n"
          "   |  #SFK E-Book :<def> A PDF optimized for your smart phone.      |\n"
          #ifdef _WIN32
          "   |  #SFK Plus   :<def> Fast (x)replace, HTTPS web access and      |\n"
          "   |               27 status lights in the system tray.       |\n"
          "   |  #DView Pro  :<def> Search 10,000 text files per second.       |\n"
          "   |               Fly over 100,000 files in one window.      |\n"
          #endif
          "   |----------------------------------------------------------|\n"
          "   |          Read more under: #www.stahlworks.com<def>             |\n"
          "   +----------------------------------------------------------+\n"
          );
   #endif
}

// this crashes by intention.
void probeStack(int iloadpercall, char *pprestack)
{
   if (iloadpercall < 0) // dummy check
      return; // avoid compiler warning
   char cstackinfo = '\0';
   void *pSubStack = &cstackinfo;
   char cload[100000];
   num  nstackload = (num)abs((char*)pGlblStartStack-(char*)pSubStack);
   printf("stack size %d reached, allowing up to %d call levels.\n",
      (int)nstackload,
      (int)(nstackload/iloadpercall) - 1
      ); fflush(stdout);
   // safety: avoid swapping on strange architectures
   if (nstackload > 100 * 1000000) {
      printf("\n... stopping test.\n");
      exit(0);
   }
   // passing cload ref avoids optim by complier.
   probeStack(iloadpercall, cload);
}

SFKMapArgs::SFKMapArgs(char *pszCmd, int argc, char *argv[], int iDir)
{
   char szform[100];
   char szform2[100];
   szform[0] = '\0';
   szform2[0] = '\0';

   bdead = 0;
   bDoneAlloc = 0;
   pszClEvalOut = 0;
   szClEvalOut[0] = '\0';

   bool bUseVars   = gs.usevars;
   bool bDebug     = 0;
   bool bQuoteVars = cs.quotevars;

   // must interpret -(no)var immediately
   if (iDir<argc && strcmp(argv[iDir],"-var")==0)   bUseVars=1;
   if (iDir<argc && strcmp(argv[iDir],"-novar")==0) bUseVars=0;

   if (cs.debug)
      printf("[cmd %s uses %s]\n",pszCmd,cs.usevars?"-var":"-novar");

   // without any vars defined, use original argv
   if (!bUseVars)
   {
      clargx = argv;
      return;
   }

   // else create a separate pointer array
   clargx = new char*[argc];
   if (!clargx) { perr("outofmem (argx,%d)",argc); bdead=1; return; }
   bDoneAlloc = 1;

   // default: copy all args as they are
   memcpy(clargx, argv, argc * sizeof(char*));

   // replace those containing "foo #(var) bar"
   for (int i=iDir; i<argc && isChainStart(pszCmd,argv,argc,i,0)==0; i++)
   {
      char *ptok = clargx[i];

      // sfk189: debug of variable expansion
      if (!strcmp(ptok, "-debug"))
         bDebug = 1;

      if (!strcmp(ptok, "-novar"))
         break;

      if (!strstr(ptok, "#("))
         continue;
 
      char szVarExp[200];
      mclear(szVarExp);
 
      int nvar = glblSFKVar.size();
 
      bool bDoneAny = 0;

      char *psrccur = ptok;
      char *pdstcur = szLineBuf;
      char *pdstmax = pdstcur + MAX_LINE_LEN;

      while (*psrccur != 0 && pdstcur+10 < pdstmax)
      {
         // change ##(foo) to #(foo).
         if (!strncmp(psrccur, "##(", 3)) {
            psrccur += 3;
            *pdstcur++ = '#';
            *pdstcur++ = '(';
            bDoneAny = 1;
            continue;
         }
         // search for valid #(foo)
         if (strncmp(psrccur, "#(", 2)) {
            *pdstcur++ = *psrccur++;
            continue;
         }
         char *pskip = psrccur;
         psrccur += 2;

         // sfk186: support format spec as first chars:
         // #(03i) #( 3a) #(- 10a) #(3.3a)

         szform[0] = '\0'; // FIX sfk1862 missing init

         char *pszf = psrccur;
         int  iform = 0;
         while (*pszf) {
            char c = *pszf;
            if (isdigit(c) || (c=='-' && iform==0) || (c==' ' && iform<2) || c=='.')
               pszf++;
            else
               break;
            iform++;
         }
         if (pszf > psrccur) {
            int ilen=pszf-psrccur;
            if (ilen>sizeof(szform)-10)
                ilen=sizeof(szform)-10;
            memcpy(szform,psrccur,ilen);
            szform[ilen]='\0';
            psrccur = pszf;
         }

         char *pexpstart = psrccur;
         // search end of #(strpos(foo,'bar'))
         int inest = 1;
         bool blit = 0, bisfn = 0;
         char *pend = psrccur;
         for (; *pend; pend++) 
         {
            if (*pend == '\'' && blit == 0) {
               blit = 1;
               continue;
            }
            if (blit == 1) {
               if (*pend != '\'')
                  continue;
               blit = 0;
               continue;
            }
            if (*pend == '(') {
               inest++;
               bisfn = 1;
               continue;
            }
            if (*pend == ')') {
               inest--;
               if (inest == 0)
                  break;
            }
         }
         if (*pend != ')')
            { perr("wrong syntax: %s",ptok); bdead=1; return; }
         psrccur = pend;
         int iexplen = psrccur-pexpstart;
         if (iexplen+10 > sizeof(szVarExp))
            { perr("variable expression too long: %s",pexpstart); bdead=1; return; }
         memcpy(szVarExp, pexpstart, iexplen);
         szVarExp[iexplen]='\0';
         psrccur++; // skip ")"

         char *pval = 0;
         bool bquoted = 0;

         if (bisfn)
         {
            // evaluate #(strpos(foo,'bar'))
            int isubrc=0;
            if ((pval = eval(szVarExp)) == 0) {
               perr("invalid variable expression: %s",ptok);
               bdead=1; return; 
            }
         }
         else
         {
            // replace #(foo) by value
            // pval = (char*)sfkgetvarexp(szVarExp, 0);

            pval = (char*)sfkgetvar(szVarExp, 0);

            // sfk1972 quoted variable expansion of qname
            if (bQuoteVars==1
                && pval==0 && szVarExp[0]=='q' && szVarExp[1]!=0
                && szform[0]==0) // not with 03name etc.
            {
               bquoted = 1;
               pval = (char*)sfkgetvar(szVarExp+1, 0);
            }

            // result is TEMPORARY.
            if (!pval) {
               // sfk181 sfk filter: skip #(10.10col1)
               if (cs.relaxedvar) {
                  // we found #( at pskip, copy that
                  psrccur = pskip;
                  *pdstcur++ = *psrccur++;
                  *pdstcur++ = *psrccur++;
                  continue;
               }
               printx("<err>error: undefined variable:<def> #%s<def>\n",szVarExp);
               pinf("[nopre] within parameters: %s\n",ptok);
               bdead=1;
               return;
            }
         }

         // sfk186: apply optional format
         if (szform[0]) {
            // "-10.10" -> "%-10.10s"
            snprintf(szform2, sizeof(szform2)-10, "%%%ss", szform);
            snprintf(szGlblFormEvalBuf, MAX_LINE_LEN, szform2, pval);
            pval = szGlblFormEvalBuf;
         }

         // length of value excludes quotes
         int nval = strlen(pval);
         if (pdstcur+nval+10 >= pdstmax) {
            perr("output string too long while changing: %s",ptok);
            pinf("value too large: %s\n", pval);
            bdead=1;
            return;
         }
         if (bquoted) *pdstcur++ = '\"';
         memcpy(pdstcur, pval, nval);
         pdstcur += nval;
         if (bquoted) *pdstcur++ = '\"';

         // remember change
         bDoneAny = 1;
      }
      *pdstcur = '\0';

      // replace memory of current parm?
      if (!bDoneAny)
         continue;

      // yes: must copy memory
      char *ptoknew = ptok;
      if (clDynaStrings.addEntry(szLineBuf, -1, &ptoknew)) // is copied
         { perr("outofmem"); bdead=1; return; }

      // clargx points to copied and modified memory
      if (cs.debug || bDebug)
         printf("[%s changes arg %02d from \"%s\" to \"%s\"]\n",pszCmd,i,ptok,ptoknew);

      clargx[i] = ptoknew;
   }
}

SFKMapArgs::~SFKMapArgs( )
{
   if (pszClEvalOut)
      delete [] pszClEvalOut;

   if (!bDoneAlloc)
      return;

   if (clargx) delete [] clargx;
}

#define sfkarg \
   SFKMapArgs oxargs(pszCmd,argc,argv,iDir);  \
   if (oxargs.bdead) return 9;   \
   char **argx = oxargs.clargx;

void printHelpText(cchar *pszSub, bool bhelp, int bext=0);

int extmain(int argc, char *argv[], char *penv[],
   char *pszCmd, int &iDir,
   bool bhelp, bool bexec, bool &bDone,
   int &nparm, bool &bChainCycle, int &lRC,
   int &iStepNext, bool &bMod
 );

struct ForBlock {
   char *pszCmd;
   int   iDir;
   char  szVar[16+2]; // loop vars must be short
   num   nVarSrc;
   num   nVarDst;
   num   nVarStep;
};

int callLabel(char *pScript, int argc, char *argx[], char *penv[],
   char *pszLabel, int iLocalParm, int nLocalParm,
   int &lRC, bool &bFatal);

// submain.begin
int submain(int argc, char *argv[], char *penv[], char *pszCmd, int iDir, bool &bFatal) // sfk
{__
   // sfk183: stack size control. default with MSVC is 1 MB.
   char cstackinfo = '\0';
   void *pSubStack = &cstackinfo;
   num  nstackload = (num)((char*)pGlblStartStack-(char*)pSubStack);
   if (!strcmp(pszCmd, "sfkstackloadint"))
      return (int)nstackload;
   if (cs.tracechain)
      printf("[call  level %d stack %d]\n",iGlblInScript,(int)nstackload);

   int   nparm  = argc - iDir; // number of parameters (after command name)
   bool  bDone  = 0;
   int   lRC    = 0;
   bool  btest  = bGlblSyntaxTest;

   // help text collection support:
   bool  bhelp  = 0;
   bool  bexec  = 0;

   #define ifcmd(xcond) \
      if (bhelp || (xcond))

   #define ifhelp(xcond) \
      if (bhelp || (xcond)) {

   #define ehelp \
      if (!bhelp) return 9; printx("\n"); } bexec=1; } \
      if (!bhelp && bexec) { bexec=0

   // if the very first command starts with +
   if (*pszCmd == '+')
      pszCmd++; // then skip this char

   // for +loop: restart point
   char *pszCmdStart = pszCmd;
   int   iDirStart   = iDir;

   // for +for: restart points
   #define SFK_MAX_FOR 5
   struct ForBlock aForBlock[SFK_MAX_FOR+1];
   mclear(aForBlock);
   int iForBlock=-1;

   char szVarCmd[100];  // sfk197
   szVarCmd[0] = '\0';

   szIOTraceBuf[0] = '\0';

 bool bChainCycle = 0;
 do
 {
   bDone = 0; // sfk1892: missing init

   // sfk197 allow variable #(cmd) in script, without options
   if (cs.usevars && strbeg(pszCmd, "#(")) do {
      strcopy(szVarCmd, pszCmd+2);
      char *psz = strchr(szVarCmd, ')');
      if (!psz) break;
      *psz = '\0';
      psz = (char*)sfkgetvar(szVarCmd, 0);
      if (!psz) break;
      if (strlen(psz) < 2) break;
      if (strchr(psz, ' '))
         return 9+perr("options are not supported in variable command: \"%s\"", psz);
      strcopy(szVarCmd, psz);
      pszCmd = szVarCmd;
      if (*pszCmd == '+') pszCmd++;
      if (gs.nopass == 1 && *pszCmd == '+') pszCmd++;
   } while (0);

   strcopy(cs.curcmd, pszCmd);
   cs.argc   = argc;
   cs.argv   = argv;

   if (bChainCycle && cs.tracechain) {
      printf("[chain process index %d, \"%s\", cmd=%s, nparm=%d, \"%s\" uf=%d %d ud=%d %d cf %d cd %d]\n",
         iDir,argv[iDir-1],pszCmd,nparm,(iDir<argc)?argv[iDir]:"[eod]",
         chain.usefiles, chain.usefiles ? chain.numberOfInFiles() : 0,
         chain.usedata , chain.usedata  ? chain.indata->numberOfEntries() : 0,
         chain.colfiles, chain.coldata
         );
      if (cs.tracechain > 1)
         if (chain.usedata)
            chain.indata->dump("chain.indata");
   }
   if (cs.iotrace) { // submain
      if (szIOTraceBuf[0]) {
         // flush output of previous command
         fprintf(stderr, "%s ##             \n", szIOTraceBuf); // ## print toterm
         szIOTraceBuf[0] = '\0';
      }
      char  szInInfo[200];
      uchar abInData[200];
      char  szCmdInfo[200];
      if (chain.usedata) {
         char *pfirst = str("");
         if (chain.indata->numberOfEntries() > 0)
               pfirst = chain.indata->getEntry(0, __LINE__, 0);
         if (chain.nClInBinarySize) {
            int iShowBytes = mymin(20,chain.nClInBinarySize);
            for (int i=0; i<iShowBytes; i++) {
               abInData[i] = getTwoDigitHex(pfirst+(i*2)); 
            }
            sprintf(szInInfo, "%05u bytes (%-20.20s) =>",
               (uint)chain.nClInBinarySize,
               dataAsTrace(abInData, iShowBytes));
         } else {
            sprintf(szInInfo, "%05u lines (%-20.20s) =>",
               chain.indata->numberOfEntries(), dataAsTrace(pfirst,mymin(strlen(pfirst),20)));
         }
      } else if (chain.usefiles) {
         char *pfirst = str("");
         if (chain.numberOfInFiles() > 0) {
            Coi *pcoi = chain.getFile(0);
            if (pcoi)
               pfirst = pcoi->name();
         }
         sprintf(szInInfo, "%05u files (%-20.20s) =>",
            chain.numberOfInFiles(), pfirst);
      } else {
         strcpy(szInInfo, "--no-data-- (                    ) ##");
      }
      char *pszParm1 = (iDir+0<argc) ? argv[iDir+0]:str("");
      char *pszParm2 = (iDir+1<argc) ? argv[iDir+1]:str("");
      char *pszParm3 = (iDir+2<argc) ? argv[iDir+2]:str("");
      snprintf(szCmdInfo, sizeof(szCmdInfo)-10, "%s %s %s %s", pszCmd, pszParm1, pszParm2, pszParm3);
      snprintf(szIOTraceBuf, sizeof(szIOTraceBuf)-10,
         "CHAIN: %s %-30.30s ", szInInfo, dataAsTrace(szCmdInfo,strlen(szCmdInfo)));
      // line is completed in isChainStart
   }

   bChainCycle = 0;
   bexec       = 0;

   int lFiles=0, lDirs=0;  // deprecated stats
   num  nBytes=0;          // deprecated stats

   if (!strcmp(pszCmd, "dumphelp") || !strcmp(pszCmd, "ask"))
   {
      if (!strcmp(pszCmd, "ask") && (nparm < 1)) {
      printx("<help>$sfk ask word1 [word2 word3 ...]\n"
             "\n"
             "   search the help text of all sfk commands for lines containing\n"
             "   all given words. keep your query short and up to the point,\n"
             "   listing only the most important words.\n"
             "\n"
             "   if your query produces no results, rephrase it:\n"
             "   - use singular instead of plural: directory vs. directories,\n"
             "     file vs. files\n"
             "   - use synonyms: directory vs. folder, list file vs. find file,\n"
             "     old file vs. most recent files\n"
             "\n"
             "   $no option processing by default\n"
             "      by default, \"sfk ask\" does NOT process any options itself,\n"
             "      but treats them as text to search for. if you want to set any\n"
             "      options although, say \"sfk ask word1 word2 ... -opt -youropt\"\n"
             "\n"
             "   $no output chaining support\n"
             "      output of sfk ask can NOT be post-processed in a command chain.\n"
             "      instead, words starting with \"+\" are searched for as well:\n"
             "         #sfk ask +filter\n"
             "            searches for help text lines containing \"+filter\".\n"
             "      if you really need to post-process output from sfk ask, pipe it\n"
             "      to another sfk process like \"sfk ask foo | sfk filter -+bar\".\n"
             "\n"
             "   $examples\n"
             "      #sfk ask walk subfolders\n"
             "      #sfk ask find oldest files\n"
             "      #sfk ask replace binary\n"
             "         search for the given words.\n"
             "      #sfk ask -nocol\n"
             "         search where the word \"-nocol\" appears.\n"
             "      #sfk ask -nocol -opt -nocol\n"
             "         the same, but also use -nocol to switch off color output.\n"
             );
         return 9;
      }

      if (nparm==1 && !strcmp(argv[iDir], "-rawhelp"))
         bGlblDumpHelpRaw=1;

      // activate help text collection mode
      bGlblCheckPrintX = 1;
      bhelp = bGlblCollectHelp = 1;
      bDone = 1;
      // sfk183: main help first
      printMainHelp(bhelp, penv);
      printx("\n");
      // fall through
   }

   ifcmd (!strcmp(pszCmd, "cmd"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk cmd commandnumber\n"
             "\n"
             #ifdef _WIN32
             "   extract an example command from the help text, print it\n"
             "   as one long text line and put it into the clipboard.\n"
             #else
             "   extract an example command from the help text\n"
             "   and print it as one long text line.\n"
             #endif
             "\n"
             "   $options\n"
             "     -run        execute the command\n"
             "     -tofile x   write to an output file x\n"
             "     -force      overwrite existing output file\n"
             );
      ehelp;

      mclear(szGlblHelpCmdPat);
      mclear(szGlblHelpCmdText);

      // do NOT step iDir here! just peek the parameter

      int iDir2 = iDir;

      for (; iDir2<argc; iDir2++)
      {
         char *pszArg = argv[iDir2];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-tofile", &pszParm)) {
            if (!pszParm) return 9;
            continue;
         }
         else
         if (!strcmp(pszArg, "-run")) {
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir2))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         // process non-option keywords

         if (szGlblHelpCmdPat[0])
           return 9+perr("supply only a single command number");

         if (atoi(pszArg) < 1)
           return 9+perr("not a command number: %s", pszArg);

         snprintf(szGlblHelpCmdPat, sizeof(szGlblHelpCmdPat)-4, "[%s]", pszArg);
      }

      // check if it's an sfkbook example
      char *pszbook = (char*)strstr(szGlblBookSamp, szGlblHelpCmdPat);
      if (pszbook)
      {
         // if so fall through without collecting
      }
      else
      {
         // activate help text collection mode
         bhelp = bGlblCollectHelp = iGlblCollectCmd = 1;
         bDone = 1;
         // fall through
      }
   }

   // sfk183: moved functions with high stack load to extmain.
   {
      int iStepNext=-1;
      bool bMod=0;

      int iextrc = extmain(argc,argv,penv,pszCmd,iDir,
         bhelp,bexec,bDone,
         nparm,bChainCycle,lRC,
         iStepNext,bMod);
      // rc 0: use lRC (in STEP_CHAIN etc.)
      // rc >0: execute "return rc".
      if (iextrc > 0)
         return iextrc; // fix sfk1832
      if (btest!=0)
         return 0;
      if (iStepNext != -1) {
         STEP_CHAIN(iStepNext,bMod);
      }
      // bDone was set by ref
   }

   regtest("list -arc -time -since 5d -size xdir .dat");
   regtest("list -late -since 2006-01-01_12:01:01 -dir xdir -file .dat");
   regtest("list -old -stat -since today .");
   regtest("list -big -withdirs -since 20060101 .");
   regtest("list -small -hidden -quot .");
   regtest("list -late=20 -pure .");
   regtest("list -late=all -notime -nosize");
   regtest("list -late -sincedir rdir xdir");
   regtest("list -sincedif rdir -relnames .");

   ifcmd (   !strcmp(pszCmd, "list") || !strncmp(pszCmd, "sel", 3) // +wref
          || !strcmp(pszCmd, "dir")  || !strcmp(pszCmd, "larc")
          || !strcmp(pszCmd, "late") || !strcmp(pszCmd, "big")
          || !strcmp(pszCmd, "old")  || !strcmp(pszCmd, "small") // sfk1840
          || !strcmp(pszCmd, "today")
          || !strcmp(pszCmd, "seluni")
          || !strcmp(pszCmd, "times")
          || (bGlblOffice && !strcmp(pszCmd, "olist"))
          || (bGlblOffice && !strcmp(pszCmd, "odir"))
         )
   {
      // fix sfk1833: unwanted list on: sfk tell foo +list
      ifhelp (!chain.usefiles && (nparm < 1)) // not if (iDir < 3)
      if (iDir > 2) {
         perr("+list requires a list of files from a previous command.");
         pinf("use \"+list .\" to list the current folder.\n");
         return 9;
      }
      if (!strcmp(pszCmd,"olist"))
         printHelpText("olist", bhelp, 0);
      else
         printHelpText("list", bhelp, 0);
      ehelp;

      sfkarg;

      CommandScope ocmd("list");

      // the "dir" command is more verbose
      bool bStat = !strcmp(pszCmd, "dir") ? 1 : 0;
      if (!strcmp(pszCmd, "odir")) bStat = 1;

      // larc is the same as list -arc
      if (!strcmp(pszCmd, "larc")) {
         cs.travelzips = 1;
         #ifdef VFILEBASE
         cs.xelike     = 1;  // process zips as deep as possible
         #endif // VFILEBASE
      }

      if (!strcmp(pszCmd, "seluni"))
         cs.uname = 1;

      #ifdef SFKOFFICE
      if (!strcmp(pszCmd, "olist") || !strcmp(pszCmd, "odir"))
         cs.justoffice = 1; // but without cs.office mode
      #endif // SFKOFFICE

      cs.totalbytes = 0; // fix sfk1934

      nGlblListMode = 2;
      cs.listByTime = 0;
      cs.listBySize = 0;
      cs.listByName = 0;

      #ifdef VFILEBASE
      // list is the only command where traveling
      // of text content links is allowed.
      cs.travelHttp = 1;
      #endif // VFILEBASE

      // in case of multiple select in a chain, reset fileset:
      glblFileSet.reset();

      // the "select" command always ignores chain input:
      bool bselect = strBegins(pszCmd, "sel");
      if (bselect) chain.reset();

      bool bTime=0, bSize=0, bCRC=0, bPure=0, bOptErr=0;
      int  iSkipNew=0,iSkippedNew=0; // 1753
      bool bForceWithHead=0;

      // late is the same as list -late
      if (!strcmp(pszCmd, "late") || !strcmp(pszCmd, "old")) {
         cs.listByTime = (*pszCmd=='o')?-50:50;
         cs.listForm = ((cs.listForm << 8) | 0x02);
         bTime = 1;
         pszCmd = str("list");
      }
      // big is the same as list -big
      if (!strcmp(pszCmd, "big") || !strcmp(pszCmd, "small")) {
         cs.listBySize = (*pszCmd=='s')?-50:50;
         cs.listForm = ((cs.listForm << 8) | 0x01);
         bSize = 1;
         pszCmd = str("list");
      }
      // late is the same as list -today
      if (!strcmp(pszCmd, "today")) {
         pszCmd = str("list");
         tryGetRelTime("today", cs.sincetime);
      }
      // times is the same as list -times
      if (!strcmp(pszCmd, "times")) {
         cs.listForm = ((cs.listForm << 8) | 0x02);
         bTime = 1;
         pszCmd = str("list");
      }

      for (; iDir < argc; iDir++)
      {
         char *pszParm = 0;
         char *pszArg  = argx[iDir];
         if (parseListOpt(1, argc, argx, iDir, bTime, bSize, bCRC, bPure, bOptErr)) {
            if (bOptErr)
               return 9;
            continue;
         }
         if (!strncmp(pszArg, "-skiplate=", 10)) {
            char *psz1 = pszArg + 10;
            if (!bTime && !bPure) {
               cs.listForm = ((cs.listForm << 8) | 0x02);
               bTime = 1;
            }
            cs.listByTime    = 0 + 1; // sort direction
            cs.listByTimeAll = 1;
            iSkipNew = atol(psz1);
            continue;
         }
         if (!strcmp(pszArg, "-twinscan"))
            return 9+perr("-twinscan was replaced by sfk dupfind.\n");
         if (!strcmp(pszArg, "-stat"))
            { bStat = 1; continue; }
         if (!strcmp(pszArg, "-juststat")) // sfk1934 dir -juststat
            { bStat = 1; cs.nonames = 1; continue; }
         if (!strcmp(pszArg, "-pure")) {
            cs.pure = 1;
            cs.listForm = 0;
            bTime = 0;
            bSize = 0;
            cs.quiet = 1;
            cs.nohead  = 1;
            bPure = 1;
            continue;
         }
         if (!strcmp(pszArg, "-abs") || !strcmp(pszArg, "-absolute"))
            { cs.forceabsname = 1; continue; }
         if (strBegins(pszArg, "-tab")) {
            cs.listTabs = 1;
            nGlblListDigits = 1; // FIX: 1674
            continue;
         }
         if (strBegins(pszArg, "-cont")) {
            cs.listContent = 1;
            continue;
         }
         if (strBegins(pszArg, "-nofile")) {
            perr("-nofile cannot be used here\n");
            pinf("use it on a following command, e.g. +filefilter -nofile\n");
            return 9;
         }
         if (   strBegins(pszArg,"-fileoffset")
             || strBegins(pszArg,"-fileoff")
            )
         {
            char *psz2 = strchr(pszArg, '=');
            if (!psz2) {
               perr("wrong syntax: %s", pszArg);
               pinf("use -fileoffset=n or -fileoff=n to set first file to process\n");
               return 9;
            }
            cs.selfileoff = atoi(psz2+1);
            continue;
         }
         if (strBegins(pszArg,"-maxfiles"))
         {
            char *psz2 = strchr(pszArg, '=');
            if (!psz2) {
               perr("wrong syntax: %s", pszArg);
               pinf("use -maxfiles=n to set max. number of files to process\n");
               return 9;
            }
            cs.selfilerange = atoi(psz2+1);
            continue;
         }
         if (strBegins(pszArg,"-withhead")) // sfk197 for chaining
            { bForceWithHead=1; continue; }
         #ifdef SFKOFFICE
         if (cs.justoffice && !strcmp(pszArg, "-deep")) { // sfk1944 internal
            cs.office = 1;
            continue;
         }
         #endif
         // accept -tofile anywhere via generic options
         if (sfkisopt(pszArg)) { // fix sfk197 missing
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir)) {
               if (!strcmp(pszArg, "-since")) {
                  // selecting -since activates time listing by default
                  if (!bPure && !bTime) {
                     cs.listForm = ((cs.listForm << 8) | 0x02);
                     bTime = 1;
                  }
               }
               continue;
            } else {
               return 9+perr("unknown option: %s\n", pszArg);
            }
         }
         // filename parms:
         break;
      }

      if (bCRC && bTime)
         return 9+perr("cannot combine -crc with -time\n");

      int nsort=0, msort=0;
      if (cs.listByTime) { nsort++; msort |= 1; }
      if (cs.listBySize) { nsort++; msort |= 2; }
      if (cs.listByName) { nsort++; msort |= 4; }
      if (nsort > 1) {
         szLineBuf[0] = '\0';
         if (msort & 1) strcat(szLineBuf, "time");
         if (msort & 2) { if (szLineBuf[0]) strcat(szLineBuf, " AND "); strcat(szLineBuf, "size"); }
         if (msort & 4) { if (szLineBuf[0]) strcat(szLineBuf, " AND "); strcat(szLineBuf, "name"); }
         return 9+perr("cannot sort by %s\n", szLineBuf);
      }

      int iDirNext = 0;
      bool bAnyDirParms = 0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext, &bAnyDirParms))) return lRC;
      if (btest) return 0;

      // plausi checks
      if (chain.useany() && bAnyDirParms) {
         perr("%s got filenames from command chain AND as parameters", pszCmd);
         pinf("say \"+select\" instead of \"+%s\" to ignore chain input\n", pszCmd,pszCmd);
         return 9;
      }
      if (bselect && !cs.usingflist && !bAnyDirParms) {
         if (chain.useany()) {
            perr("%s requires dir- or filename parameters, chain input is ignored.", pszCmd);
            pinf("say \"+list\" instead of \"+%s\" to use chained input filenames.\n", pszCmd);
            return 9;
         }
         // "sfk ... +sel" without any dir parms
         perr("%s requires dir- or filename parameters.", pszCmd);
         return 9;
      }

      if (!bForceWithHead && chain.colany())
         cs.nohead = 1;

      chain.openOverallOutputFile("w"); // sfk198 if any

      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);

      info.clear();

      chain.closeOverallOutputFile();

      // prepare addColorText
      szLineBuf[0]='\0'; szAttrBuf[0]='\0';

      if (cs.listBySize) {
         int nCnt  = glblFileListCache.numberOfEntries();
         int iFrom = 0;
         if (!cs.listBySizeAll && (nCnt > abs(cs.listBySize))) {
            iFrom = nCnt - abs(cs.listBySize);
            if (!cs.nohead)
                addColorText('f', "[listing %d of %d files by size:]\n", (int)(abs(cs.listBySize)), nCnt);
         }
         for (int i=iFrom; i<nCnt; i++) {
            Coi *pcoi = glblFileListCache.getEntry(i, __LINE__);
            // get text line prefixed by metatext length
            char *pszFull = pcoi->getExtStr();
            if (!pszFull) return 9+perr("internal 141271931\n");
            int nMetaLen = atol(pszFull);
            if (nMetaLen > (int)strlen(pszFull)) return 9+perr("internal 61212\n");
            if (strlen(pszFull) < 6) return 9+perr("internal 61213\n");
            char *pszText = pszFull+6;
            if (chain.colfiles)
               chain.addFile(*pcoi);
            else {
               // sfk197 sfk big generic colored output
               szLineBuf[0]='\0'; szAttrBuf[0]='\0';
               addColorText('f', "%.*s", nMetaLen, pszText);
               addColorText(' ', "%s\n", pszText+nMetaLen);
            }
         }
      }

      // .
      if (cs.listByTime) {
         int nCnt  = glblFileListCache.numberOfEntries();
         int iFrom = 0;
         if (iSkipNew > 0) {
            int nCnt2 = nCnt;
            if (iSkipNew < nCnt)
               nCnt -= iSkipNew;
            else
               nCnt = 0;
            iSkippedNew = nCnt2 - nCnt;
            if (!cs.nohead)
                addColorText('f', "[listing %d oldest of %d files, skipping %d newest:]\n", nCnt, nCnt2, iSkippedNew);
         }
         else
         if (!cs.listByTimeAll && (nCnt > abs(cs.listByTime))) {
            iFrom = nCnt - abs(cs.listByTime);
            if (!cs.nohead)
                addColorText('f', "[listing %d of %d files by date:]\n", (int)(abs(cs.listByTime)), nCnt);
         }
         int noldday = -1;
         int i=iFrom;
         if (i > 0) i--; // one precycle to find previous entry's day
         for (; i<nCnt; i++) {
            Coi *pcoi = glblFileListCache.getEntry(i, __LINE__);
            num nTime = pcoi->getTime();
            struct tm *pLocTime = 0;
            mytime_t nTime2 = (mytime_t)nTime;
            pLocTime = mylocaltime(&nTime2);      // may be NULL
            int nday = pLocTime->tm_yday;      // 0..365
            if (i < iFrom) {
               noldday = nday;
               continue; // empty precycle
            }
            // get text line prefixed by metatext length
            char *pszFull = pcoi->getExtStr();
            if (!pszFull) return 9+perr("internal 141271933\n");
            int nMetaLen = atol(pszFull);
            if (nMetaLen > (int)strlen(pszFull)) return 9+perr("internal 61211\n");
            if (strlen(pszFull) < 6) return 9+perr("internal 61214\n");
            char *pszText = pszFull+6;
            if (chain.colfiles)
               chain.addFile(*pcoi);
            else {
               // sfk197 sfk old generic colored output
               szLineBuf[0]='\0'; szAttrBuf[0]='\0';
               char ccol = ' ';
               if (nMetaLen) {
                  if (nday != noldday) {
                     noldday = nday;
                     ccol = 'f';
                  }
                  addColorText(ccol, "%.*s", nMetaLen, pszText);
               }
               addColorText(' ', "%s\n", pszText+nMetaLen);
            }
         }
      }

      if (cs.listByName) {
         int nCnt  = glblFileListCache.numberOfEntries();
         int iFrom = 0;
         if (!cs.listByNameAll && (nCnt > abs(cs.listByName))) {
            iFrom = nCnt - abs(cs.listByName);
            if (!cs.nohead)
                addColorText('f', "[listing %d of %d files by name:]\n", (int)(abs(cs.listByName)), nCnt);
         }
         for (int i=iFrom; i<nCnt; i++) {
            Coi *pcoi = glblFileListCache.getEntry(i, __LINE__);
            // get text line prefixed by metatext length
            char *pszFull = pcoi->getExtStr();
            if (!pszFull) return 9+perr("internal 141271934\n");
            int nMetaLen = atol(pszFull);
            if (nMetaLen > (int)strlen(pszFull)) return 9+perr("internal 61220\n");
            if (strlen(pszFull) < 6) return 9+perr("internal 61221\n");
            char *pszText = pszFull+6;
            if (chain.colfiles)
               chain.addFile(*pcoi);
            else {
               // sfk197 list -sort generic colored output
               szLineBuf[0]='\0'; szAttrBuf[0]='\0';
               if (nMetaLen)
                  addColorText('f', "%.*s", nMetaLen, pszText);
               addColorText(' ', "%s\n", pszText+nMetaLen);
            }
         }
      }

      if (bStat) // FIX 153R3: do not also check quiet, nohead
      {
         num   nbytes = cs.totalbytes;
         cchar *punit  = "bytes";
         num   ndiv   = 1;

         if (nbytes > 1000000)
            {  ndiv   = 1000000; punit = "mb"; }
         else
         if (nbytes > 1000)
            {  ndiv   = 1000; punit = "kb"; }

         char nbuf1[50], nbuf2[50];

         szLineBuf[0] = '\0';
         szAttrBuf[0] = '\0';

         if (ndiv > 1)
            addColorText(' ', "%d files, %d dirs, %s %s, %s bytes",
               cs.files,cs.dirs,numtoa(nbytes/ndiv,1,nbuf1),punit,numtoa(nbytes,1,nbuf2));
         else
            addColorText(' ', "%d files, %d dirs, %s bytes",
               cs.files,cs.dirs,numtoa(nbytes,1,nbuf1));

         if (cs.numHiddenFiles || cs.numHiddenDirs) {
            // extend line and print '\n'
            addColorText(' ', ", ");
            addColorText('w', "%d hidden files, %d dirs.\n", cs.numHiddenFiles, cs.numHiddenDirs);
         }
         else
         if (cs.numHiddenFilesSkipped || cs.numHiddenDirsSkipped) {
            // flush line. print another line.
            addColorText(' ', ".\n");
            addColorText('w', "skipped %d hidden files, %d hidden dirs.\n", cs.numHiddenFilesSkipped, cs.numHiddenDirsSkipped);
         }
         else {
            // flush line.
            addColorText(' ', ".\n");
         }
      }

      // diverse convience stuff, reminders etc.
      if (!cs.nohead && !cs.quiet) {
         bool btold = 0;
         if (cs.addedFilesSkipped > 0) {
            addColorText('t', "skipped %d added files. ", cs.addedFilesSkipped);
            btold = 1;
         }
         if (cs.sincetime)
            if (cs.maxFileTime < cs.sincetime) {
               // user specified -since, but no files matched:
               num nnow = 0;
               tryGetRelTime("now", nnow);
               num nsec  = nnow - cs.maxFileTime;
               num nhrs  = nsec / 3600;
               num ndays = nhrs / 24;
               setTextColor(nGlblHeadColor, 1);
               if (ndays <= 0)
                  addColorText('h', "most recent file is %s hours old.", numtoa(nhrs));
               else
                  addColorText('h', "most recent file is %s days old.", numtoa(ndays));
               btold = 1;
            }
         if (btold) {
            addColorText(' ', "\n");
         }
      }

      // detect -sincedir user errors
      char ccol = ' ';
      if (!cs.quiet && pszGlblSinceDir && (nGlblMissingRefDirs > 0)) {
         if (nGlblMissingRefDirs > nGlblMatchingRefDirs)
            ccol = 'w';
         else
            ccol = 't';
         addColorText(ccol, "found %d matching and %d missing reference dirs (try -incref or -verbose)\n",nGlblMatchingRefDirs,nGlblMissingRefDirs);
      }

      if (!cs.quiet) {
         if (cs.noFiles)
            addColorText(' ', "%u non-regular files skipped.\n", cs.noFiles);
      }

      // sfk193: set chain rc on found files.
      if (lRC == 0 && (cs.files || cs.dirs))
          lRC = 1;

      // step to next chain command (if any),
      // and copy filenames from chainfiles2 to chainfiles.
      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "gindex")  || !strcmp(pszCmd, "gindex2") // +wref
          || !strcmp(pszCmd, "lindex")  
          || !strcmp(pszCmd, "index")  // sfk183
         )
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk gindex[2] [opts] -dir rootDir [rootDir2] ...\n"
             "<help>$sfk index [opts] -dir localDir ...\n"
             "\n"
             "   create index file(s) containing file names with time\n"
             "   and size info, for later realtime filename lookup,\n"
             "   or just to archive folder meta data.\n"
             "\n"
             "   $creating index files for use with sfk name<def>\n"
             "\n"
             "    to create a $local index of the current directory tree<def>, use\n"
             "      #sfk index .\n"
             "         which writes a local file $zz-index.txt<def>.\n"
             #ifdef _WIN32
             "         Under windows, no files are written to C:\\\n"
             "         directly, but only to a folder C:\\zz-index\\\n"
             "         to avoid storage in a special system folder\n"
             "         C:\\Users\\name\\AppData\\Local\\VirtualStore\n"
             #endif
             "\n"
             "    to create a $global index of the current machine<def>, use\n"
             "      #sfk gindex -dir C:\\ D:\\\n"
             "         which stores a base index file in your user folder:\n"
             "         %s<sla>data<sla>zz-index.txt\n"
             "\n"
             "    to create an $extended global index<def> of network drives, use\n"
             "      #sfk gindex2 -dir T:\\ P:\\ V:\\\n"
             "         if drives T, P, V are network drives. this will write\n"
             "         an extended index file in a user local folder:\n"
             "         %s<sla>data<sla>zz-index-ext.txt\n"
             , sfkhome.szClDir
             , sfkhome.szClDir
             );
      printx("\n"
             "    in other words:\n"
             "\n"
             "      $sfk index<def> writes an index locally onto the disk\n"
             "         where you are standing, $visible for all users<def>.\n"
             "         this is useful 1. under linux in the root dir \"/\"\n"
             "         to make an index of all files available for all users\n"
             "         2. on external media like USB hard drives, where an\n"
             "         index in the drive root can be used on any machine.\n"
             "\n"
             "      $sfk gindex<def> is your $personal global index<def> of whatever\n"
             "         disk contents are important for you, $not for use<def>\n"
             "         $by other users<def>, and maintained only by yourself.\n"
             );
      printx("\n"
             "   $creating special purpose meta data archives<def>\n"
             "\n"
             "    to create a $local index of a sub folder \"mydir\"<def>, use\n"
             "      #sfk index mydir\n"
             "         which writes a file $zz-index-mydir.txt<def>. this file\n"
             "         can $NOT<def> be used with $sfk name<def>. it's just an archive\n"
             "         of file meta informations for that sub folder.\n"
             );
      printx("\n"
             "   $using indexes for fast name lookup\n"
             "\n"
             "       #sfk name word [word2] [word3] [...]\n"
             "         will use local index files:\n"
             "            - in the current folder\n"
             "            - in the parent folder\n"
             "            - and so on, until the root folder \"<sla>\"\n"
             "            - and also the global Base Index file\n"
             "         and then lists all file names from those indexes\n"
             "         having the given words in their name or path.\n"
             "\n"
             "       #sfk name2 word [word2] [word3] [...]\n"
             "         does the same as name, but also includes\n"
             "         the global Extended Index file.\n"
             "\n"
             "   $sfk index options\n"
             "      -tofile f  write output into a file f instead of the\n"
             "                 default index file. can be used then with\n"
             "                 \"sfk name -from f ...\"\n"
             #if (!defined(_WIN32) && !defined(SFK_LIB5))
             "      -follow    follows symbolic directory links. this is\n"
             "                 no default as it may cause endless recursion.\n"
             #endif
             #ifdef _WIN32
             "      -hidden    list also hidden or system files\n"
             #endif
             #ifndef _WIN32
             "      -verbose   show names of skipped non-regular files\n"
             "      -showskip  tell whenever dir contents are skipped to avoid\n"
             "                 double processing caused by symbolic links.\n"
             "      -allowdups disable detection of duplicate dir contents.\n"
             #endif
             "      -arc       include contents of .zip .jar .ear etc. archives\n"
             "\n");
      printx("   $aliases\n"
             "      #sfk lindex<def>       same as #sfk index<def>\n"
             "      #sfk iname<def>        same as #sfk name<def>\n"
             "\n"
             "   $see also\n"
             "      #sfk name<def>         lookup files in local and Base Indexes\n"
             "      #sfk name2<def>        lookup in local, Base and Extended Index\n"
             "      #sfk help select<def>  the sfk file selection syntax.\n"
             "      #sfk help opt<def>     for further general options.\n"
             "      #sfk dir<def>          list contents of a directory.\n"
             "      #sfk home<def>         tell sfk home folder location\n"
             "\n");
      webref("index");
      printx("   $examples\n"
             #ifdef _WIN32
             "      #sfk gindex C:\\\n"
             "          create a global Base Index containing all file names\n"
             "          from drive C: using a short syntax.\n"
             "      #sfk gindex C:\\ <not>.tmp <not>.bak\n"
             "          the same, but excluding all .tmp and .bak files.\n"
             "          to include another drive letter in the index,\n"
             "          the long syntax must be used:\n"
             "      #sfk gindex -dir C:\\ D:\\ -subdir !tmp -file !.bak\n"
             "          create Base Index of C: and D: without any sub\n"
             "          dirs having tmp in their name, and w/o .bak files.\n"
             "      #sfk gindex2 -dir P:\\ W:\\\n"
             "          if P: and W: are network drives, this creates\n"
             "          an Extended Index file with their contents.\n"
             "      #sfk index .\n"
             "          if standing in the root dir of a drive like D:\\\n"
             "          this will write a local index file for that drive\n"
             "          which can later be used by typing $sfk name<def>\n"
             "          from within in any folder on that drive.\n"
             #else
             "      #sfk gindex /\n"
             "          create a base index containing all file names\n"
             "          from the machine.\n"
             "      #sfk gindex -dir / -subdir :tmp -file :.bak\n"
             "          create an index of / without any sub dirs\n"
             "          having tmp in their name, and without .bak files.\n"
             "      #sfk index .\n"
             "          if standing in the root dir of an embedded linux\n"
             "          device, create an index over all files.\n"
             "          this is not suitable for linux servers\n"
             "          as the index may become far too large.\n"
             "      #sfk index -dir . -subdir :/backup :/.\n"
             "          if standing in the root dir of a desktop linux\n"
             "          create an index over all files, excluding\n"
             "          folders starting with 'backup', and excluding\n"
             "          all hidden subfolders like .svn\n"
             #endif
             );
      ehelp;

      sfkarg;

      cs.travelzips = 0;
      nGlblListMode = 2;
      cs.listByTime = 0;
      cs.listBySize = 0;
      cs.listByName = 0;
      cs.listForm   = 0;
      cs.listTabs   = 1;
      nGlblListDigits = 1;
      bool bGlobal  = (pszCmd[0] == 'g') ? 1 : 0;

      // fix: 174: force absolute paths with gindex
      cs.forceabsname = bGlobal;

      glblFileSet.reset();

      bool bExt = !strcmp(pszCmd, "gindex2") ? 1 : 0;
      bool bTime=1, bSize=0, bPure=0;
      char *toFileName = 0;

      // at least list time and size
      cs.listForm = ((cs.listForm << 8) | 0x02);
      cs.listForm = ((cs.listForm << 8) | 0x01);

      // don't follow symlinks
      cs.skipLinks = 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-ext")) {
            bExt = 1;
            continue;
         }
         else
         if (!strcmp(argx[iDir], "-abs") || !strcmp(argx[iDir], "-absolute")) {
            cs.forceabsname = 1;
            continue;
         }
         else if (!strcmp(pszArg, "-follow")) {
            cs.skipLinks = 0;
            continue;
         }
         else
         if (!strncmp(argx[iDir], "-size=", strlen("-size="))) {
            char *psz1 = argx[iDir] + strlen("-size=");
            nGlblListDigits = atol(psz1);
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break; // assume dir name
      }

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext))) return lRC;
      if (btest) return 0;

      int bcoldata = chain.coldata;
      chain.coldata = 0;

      char szRelName[SFK_MAX_PATH+10];
      char szPathBuf1[SFK_MAX_PATH+10];
      char szPathBuf2[SFK_MAX_PATH+10];
      char *toMakeDir = 0;

      if (bGlobal) {
         sprintf(szRelName, "data%czz-index%s.txt", glblPathChar, bExt ? "-ext" : "");
         toFileName = sfkhome.makePath(szRelName);
      }
      else if (cs.tomaskfile) {
         toFileName = cs.tomask;
      }
      else {
         if (!glblFileSet.hasRoot(0))
            return 9+perr("missing -dir parameter");
         char *pszFirstRoot = glblFileSet.setCurrentRoot(0);
         if (   !strcmp(pszFirstRoot, glblPathStr)
             || !strcmp(pszFirstRoot, ".")
            )
         {
            toFileName = str("zz-index.txt");
         }
         else {
            if (strchr(pszFirstRoot, glblPathChar)) {
               perr("cannot lindex nested directory names.", glblPathChar);
               pinf("use only plain dir names of the current folder.\n");
               return 9;
            }
            snprintf(szRelName, sizeof(szRelName)-10,
               "zz-index-%s.txt", pszFirstRoot);
               toFileName = szRelName;
         }
         #ifdef _WIN32
         if (!getcwd(szPathBuf1,sizeof(szPathBuf1)-10))
            return 9+perr("cannot get work dir.");
         if (!mystricmp(szPathBuf1, "C:\\")
             && strBegins(toFileName, "zz-index"))
         {
            snprintf(szPathBuf2,SFK_MAX_PATH, "C:\\zz-index\\%s", toFileName); // sfk1932 index
            toFileName = szPathBuf2;
            toMakeDir  = str("C:\\zz-index");
         }
         #endif
      }

      if (!toFileName)
         return 9;

      if (!cs.quiet && !cs.tomaskfile)
         printx("$making<def> %s\n", toFileName);

      #ifdef _WIN32
      if (toMakeDir)
         if (createOutDirTree(toMakeDir,0,1))
            return 9+perr("cannot create target folder: %s", toMakeDir);
      #endif

      if (!(cs.outfile = fopen(toFileName, "w")))
         return 9+perr("cannot open index file for writing: %s", toFileName);

      fprintf(cs.outfile, "date\ttime\tsize\tname\tsfk-index-v100\n");

      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);

      if (cs.outfile) { fclose(cs.outfile); cs.outfile = 0; }

      info.clear();

      if (!cs.quiet)
      {
         printf("%d files indexed",cs.files);

         if (cs.numHiddenFiles) {
            printf(", ");
            setTextColor(nGlblWarnColor, 1);
            printf("including %d hidden files.\n", cs.numHiddenFiles);
            setTextColor(-1);
         }
         else
         if (cs.numHiddenFilesSkipped || cs.numHiddenDirsSkipped) {
            printf(".\n");
            setTextColor(nGlblWarnColor, 1);
            printf("skipped %d hidden files, %d hidden dirs.\n", cs.numHiddenFilesSkipped, cs.numHiddenDirsSkipped);
            setTextColor(-1);
         }
         else {
            printf(".\n");
         }

         if (cs.noFiles)
            printf("%u non-regular files skipped. (add -verbose to show)\n", cs.noFiles);
      }

      if (iDirNext) { // sfk1933 chain support
         if (bcoldata) {
            chain.coldata = bcoldata;
            chain.addLine(toFileName, str(""));
         }
         STEP_CHAIN(iDirNext, 1);
      }

      bDone = 1;
   }

   regtest("md5gento x.dat xdir");
   regtest("md5gento=x.dat -quiet xdir");
   regtest("md5gento x.dat -rel -dir xdir");
   regtest("list xdir +md5gento xfile.md5");

   ifcmd (!strncmp(pszCmd, "md5gento", 8)
          || !strncmp(pszCmd, "crcgento", 8)) // +wref
   {
      bool bcrc = strBegins(pszCmd, "crc");
      bool bmd5 = strBegins(pszCmd, "md5");

      ifhelp (!chain.usefiles
              && (!strcmp(pszCmd, "md5gento") || !strcmp(pszCmd, "crcgento"))
              && (nparm < 2))
      #ifdef SFKPACK
      if (bhelp || bcrc)
      {
      printx("<help>$sfk crcgento[=]outputfile [-rel[names]]]] dirname [-quiet]\n"
             "\n"
             "   create list of crc32 checksums over all selected files.\n"
             "\n"
             "   $options\n"
             "      -rel     create a list with relative filenames, i.e. strip\n"
             "               the supplied dirname from the beginning of each name.\n"
             "      -quiet   do not print progress output while reading files.\n"
             "      -tab     create tab separated columns instead of \" *\" format.\n"
             "\n"
             "   $see also\n"
             "      #sfk crccheck<def>  to verify crc lists.\n"
             "      #sfk crc<def>       create crc of a single file.\n"
             "\n"
             "   $examples\n"
             "      #sfk crcgento mydir.crc mydir\n"
             "         create checksum of all files in folder mydir and all\n"
             "         sub folders and store them in mydir.crc.\n"
             "\n"
             "      #sfk select -dir prod -file !.tmp +crcgento=checksums.crc\n"
             "         first select all files from prod, excluding .tmp files,\n"
             "         then create an crc list to checksums.crc\n"
            );
      }
      #endif // SFKPACK
      if (bhelp || bmd5)
      {
      printx("<help>$sfk md5gento[=]outputfile [-rel[names]]]] dirname [-quiet]\n"
             "\n"
             "   create list of md5 checksums over all selected files.\n"
             "\n"
             "   $options\n"
             "      -rel     create a list with relative filenames, i.e. strip\n"
             "               the supplied dirname from the beginning of each name.\n"
             "      -quiet   do not print progress output while reading files.\n"
             "      -tab     create tab separated columns instead of \" *\" format.\n"
             #if defined(SFKPRO)
             "      -arc     create checksums of .zip, .tar.gz and .tar.bz2\n"
             "               file contents, including nested archives.\n"
             "      -qarc    create checksums of top level archive contents.\n"
             #else
             "      -(q)arc  XE: create checksums of .zip, .tar.gz and .tar.bz2\n"
             "               file contents, including nested archives.\n"
             "               no demo is available in sfk base, but you may use\n"
             "               sfk xfind -arc ... to test general archive reading.\n"
             #endif
             "\n");
      printx("   $see also\n"
             "      #sfk md5check<def>  to verify md5 lists.\n"
             "      #sfk md5<def>       create md5 of a single file.\n"
             "      #sfk crcgento<def>  create crc lists of files.\n"
             "\n");
      webref("md5list");
      printx("   $examples\n"
             "      #sfk md5gento mydir.md5 mydir\n"
             "         create checksum of all files in folder mydir and all\n"
             "         sub folders and store them in mydir.md5.\n"
             "\n"
             "      #sfk select -dir prod -file !.tmp +md5gento=checksums.md5\n"
             "         first select all files from prod, excluding .tmp files,\n"
             "         then create an md5 list to checksums.md5\n"
            );
      }
      ehelp;

      sfkarg;

      if (strBegins(pszCmd, "crc")) {
         #ifndef SFKPACK
         return 9+perr("this binary supports no crc functions.\n");
         #else
         cs.crcmd5=1;
         #endif
      }

      pszGlblOutFile = 0;

      if (!strncmp(pszCmd, "md5gento=", 9)
          || !strncmp(pszCmd, "crcgento=", 9))
         pszGlblOutFile = pszCmd+9;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strncmp(pszArg, "-rel", 4)) {
            bGlblMD5RelNames = 1;
            continue;
         }
         if (!strcmp(pszArg, "-tab")) {
            cs.tabform = 1;
            continue;
         }
         if (!strcmp(pszArg, "-crc")) // internal
            { cs.crcmd5=1; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // non option parms
         if (!pszGlblOutFile) {
            pszGlblOutFile = pszArg;
            continue;
         }
         // fall through to short dir format
         break;
      }

      if (!pszGlblOutFile)
         return 9+perr("missing output filename\n");

      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iChainNext))) return lRC;
      if (btest) return 0;

      #ifndef SFKPRO
      // must block this to avoid checksums over truncated demo extracts
      if (cs.travelzips)
         return 9+perr("%s with -(q)arc requires SFK XE.",pszCmd);
      #endif

      fGlblOut = fopen(pszGlblOutFile, "w");
      if (!fGlblOut) return 9+perr("cannot write %s\n", pszGlblOutFile);

      lRC = walkAllTrees(eFunc_MD5Write, lFiles, lDirs, nBytes);

      fclose(fGlblOut);

      if (cs.quiet < 2)
         info.print("%u files hashed into %s. %u kb/sec\n", glblFileCount.value(), pszGlblOutFile, currentKBPerSec());

      pszGlblOutFile = 0; // fix sfk198 missing

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   regtest("md5check x.dat");
   regtest("md5check=x.dat -quiet -skip=2");
   regtest("md5check x.dat -rel xdir -skip 10");

   ifcmd (!strncmp(pszCmd, "md5check", 8)
          || !strncmp(pszCmd, "crccheck", 8)) // +wref
   {
      bool bcrc = strBegins(pszCmd, "crc");
      bool bmd5 = strBegins(pszCmd, "md5");

      ifhelp (!chain.usefiles
              && (!strcmp(pszCmd, "md5check") || !strcmp(pszCmd, "crccheck"))
              && (nparm < 1))
      if (bhelp || bcrc)
      printx("<help>$sfk crccheck[=]inputfile [-rel[ativeto]] dirname] [-quiet]\n"
             "\n"
             "   verify a list of crc checksums.\n"
             "\n");
      if (bhelp || bmd5)
      printx("<help>$sfk md5check[=]inputfile [-rel[ativeto]] dirname] [-quiet]\n"
             "\n"
             "   verify a list of md5 checksums.\n"
             "\n");
      printx("   $options\n"
             "      -sane    look at the modification date and time of the crc\n"
             "               list file and of every target file. ignore files\n"
             "               which are newer than the list. can be used to\n"
             "               check hard disk files for unexpected changes.\n"
             "               -sane -quiet does not list the newer files.\n"
             "      -rel     if dirname is supplied, treat filenames from list\n"
             "               as being relative to dirname. in this case, run the\n"
             "               command from dirname's parent directory.\n"
             "      -quiet   do not print progress output while checking files,\n"
             "               and do not list kb/sec speed stats.\n"
             "      -skip=n  do not check all files, perform just spot checking\n"
             "               by skipping n files after every checked file.\n"
             "\n"
             "   $return codes for batch files\n"
             "      0   normal execution, all checksums matched.\n"
             "      1   normal execution, checksum(s) mismatched.\n"
             "      2   some files were missing, all other checksums matched.\n"
             "      3   some files were missing, and some checksums mismatched.\n"
             "    >=9   severe error occurred, e.g. wrong checksum file format.\n"
             "\n");
      if (bhelp || bcrc)
      printx("   $examples\n"
             "      #sfk crccheck mydir.crc\n"
             "         check if files listed in mydir.crc still have\n"
             "         the same checksums.\n"
             );
      if (bhelp || bmd5)
      {
      printx("   $no archive file support.\n"
             "      even with sfk xe, md5check does NOT support reading\n"
             "      and verification of .zip, .tar.gz etc. archive contents.\n"
             "      instead (with xe) create another md5 list by md5gento\n"
             "      and then compare two list files by a text diff tool.\n"
             "\n");
      printx("   $see also\n"
             "      #sfk md5gento<def>  to create md5 lists.\n"
             "      #sfk md5<def>       create md5 of a single file.\n"
             "      #sfk crccheck<def>  verify crc lists.\n"
             "\n");
      webref("md5list");
      printx("   $examples\n"
             "      #sfk md5check mydir.md5\n"
             "         check if files listed in mydir.md5 still have\n"
             "         the same checksums.\n"
             #ifdef _WIN32
             "\n"
             "      #@rem windows batchfile example\n"
             "         @echo off\n"
             "         sfk md5check mysums.txt -quiet >nul 2>nul\n"
             "         IF ERRORLEVEL 1 GOTO mdfailed\n"
             "         sfk echo \"[[green]]all ok[[def]]\"\n"
             "         GOTO mddone\n"
             "         :mdfailed\n"
             "         sfk echo \"[[red]]verification failed[[def]]\"\n"
             "         :mddone\n"
             #endif
            );
      }
      ehelp;

      sfkarg;

      if (strBegins(pszCmd, "crc")) {
         #ifndef SFKPACK
         return 9+perr("this binary supports no crc functions.\n");
         #else
         cs.crcmd5=1;
         #endif
      }

      char *pszInFile = 0;
      char *pszRefDir = 0;

      // handle md5check=infile or crccheck=infile
      char *pszEqFile = strchr(pszCmd, '=');
      if (pszEqFile)
            pszInFile = pszEqFile+1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-rel", &pszParm)) {
            if (!pszParm) return 9;
            pszRefDir = pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-skip", &pszParm)) {
            if (!pszParm) return 9;
            nGlblMD5Skip = atol(pszParm);
            continue;
         }
         if (!strcmp(pszArg, "-crc"))  // internal
            { cs.crcmd5=1; continue; }
         if (!strcmp(pszArg, "-sane")) // sfk1953 internal
            { cs.sanecheck=1; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // non-option parameter:
         if (!pszInFile) {
            pszInFile = pszArg;
            continue;
         }
         return 9+pbad(pszCmd, argx[iDir]);
      }

      if (!pszInFile)
         return 9+perr("missing input filename\n");

      if (btest) return 0;

      #ifdef SFKINT
      // bad performance, not official
      if (cs.travelzips)
         cs.precachezip = 1;
      #else
      // base: must block this to avoid checksums over truncated demo extracts.
      // xe: unusable performance.
      if (cs.travelzips)
      {
         perr("%s with -(q)arc is not supported.",pszCmd);
         if (strBegins(pszCmd, "md5"))
            pinf("create another md5 file by md5gento, then compare the list text.\n");
         return 9;
      }
      #endif

      cs.sanetime = getFileTime(pszInFile);

      char *pInFile = loadFile(pszInFile);
      if (!pInFile) return 9;

      lRC = execMD5check(pInFile, pszRefDir);

      delete [] pInFile;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   regtest("md5 xfile1");
   regtest("md5 -quiet -verify bfb9acc99d1811730687f49a09318e8f xfile1");

   ifcmd (!strcmp(pszCmd, "md5") || !strcmp(pszCmd, "crc")) // +wref
   {
      bool bcrc = strBegins(pszCmd, "crc");
      bool bmd5 = strBegins(pszCmd, "md5");

      ifhelp (chain.usefiles == 0 && nparm < 1)
      #ifdef SFKPACK
      if (bhelp || bcrc)
      {
      printx("<help>$sfk crc [opts] file1 [file2 file3 ...]\n"
             "\n"
             "   calculate crc32 hash of one or more files, and optionally compare the results.\n"
             "   if crc sums are compared, a message is shown, and the shell return code\n"
             "   is set to 0 (all equal), or 1 (not equal), or >1 (any other error).\n"
             "   sfk creates the same crc32 as used in zip files.\n"
             "\n"
             "   $the same checksum may occur twice for different files.\n"
             "      an indentical checksum is an indicator, but not a proof, that two files\n"
             "      have exactly the same content. depending how important this is the\n"
             "      crc matches may be used only as a first quick step, and then be followed\n"
             "      by sfk md5 for a deeper comparison.\n"
             "\n"
             "   $options\n"
             "      -nonames   do not echo filename(s), show only the crc sum.\n"
             "                 default if a single filename is given.\n"
             "      -name      print filename even with just a single name.\n"
             "      -verify    or -ver, or -v verifies the given filename(s) against\n"
             "                 the given checksum.\n"
             "      -nocomp    if multiple filenames are given, do not compare.\n"
             "\n");
      printx("   $examples\n"
             "      #sfk crc test01.dat\n"
             "         tell crc sum of test01.dat\n"
             "\n"
             "      #sfk crc test01.dat test02.dat\n"
             "         compare both files if the content checksum is identical.\n"
             "\n"
             "      #sfk -var crc in.txt +setvar sum +tell \"the crc is: ##(sum)\"\n"
             "         place checksum in a variable, then print a text\n"
             "\n");
      }
      #endif // SFKPACK
      if (bhelp || bmd5)
      {
      printx("<help>$sfk md5 [opts] file1 [file2 file3 ...]\n"
             "\n"
             "   calculate md5 hash of one or more files, and optionally compare the results.\n"
             "   if md5 sums are compared, a message is shown, and the shell return code\n"
             "   is set to 0 (all equal), or 1 (not equal), or >1 (any other error).\n"
             "\n"
             "   $options\n"
             "      -nonames   do not echo filename(s), show only the md5 sum.\n"
             "                 default if a single filename is given.\n"
             "      -name      print filename even with just a single name.\n"
             "      -verify    or -ver, or -v verifies the given filename(s) against\n"
             "                 the given checksum.\n"
             "      -nocomp    if multiple filenames are given, do not compare.\n"
             "\n");
      printx("   $see also\n"
             "      #sfk md5var<def>    create md5 from variable content.\n"
             "      #sfk md5gento<def>  to create md5 lists.\n"
             "      #sfk md5<def>       create md5 of a single file.\n"
             "      #sfk crc<def>       create crc32 checksum of a file.\n"
             "\n");
      webref("md5list");
      printx("   $examples\n"
             "      #sfk md5 test01.dat\n"
             "         tell md5 sum of test01.dat\n"
             "\n"
             "      #sfk md5 test01.dat test02.dat\n"
             "         compare both files, if content is the same.\n"
             "\n"
             "      #sfk select mydir .exe +md5\n"
             "         create md5 of all .exe in mydir to terminal,\n"
             "         with md5sum and filename separated by tab.\n"
             "         use +md5gento instead to create a list file.\n"
             "\n"
             #ifdef _WIN32
             "      #sfk md5 -quiet -verify 14da96b20e45fd84c46c5b7aef641cb3 test01.dat\n"
             "         check if test01.dat has an md5 matching the one specified.\n"
             "         issues no output, returns just a shell return code.\n"
             "         within a windows .bat file, check the RC this way:\n"
             "\n"
             "         @echo off\n"
             "         sfk md5 -quiet -verify 14da96b20e45fd84c46c5b7aef641cb3 test01.dat\n"
             "         if errorlevel 1 goto mismatch\n"
             "         echo \"file checked, all ok\"\n"
             "         goto done\n"
             "         :mismatch\n"
             "         echo \"file content mismatch\"\n"
             "         :done\n"
             #else
             "      #sfk md5 -verify 14da96b20e45fd84c46c5b7aef641cb3 test01.dat\n"
             "         check if test01.dat has an md5 matching the one specified.\n"
             #endif
             "\n"
             "      #sfk -var md5 in.txt +setvar sum +tell \"the md5 is: ##(sum)\"\n"
             "         place checksum in a variable, then print a text\n"
             );
      }
      ehelp;

      sfkarg;

      if (!strcmp(pszCmd, "crc")) {
         #ifndef SFKPACK
         return 9+perr("this binary supports no crc functions.\n");
         #else
         cs.crcmd5=1;
         #endif
      }

      bool bMismatch  = 0;
      int  bNames     = 1;
      bool bComp      = 1;
      bool bFromChain = chain.usefiles;
      char *pszVerify = 0;
      int  iFile      = -1;
      int  iFileMax   = argc; // exclusive
      int  nFileNames = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (   haveParmOption(argx, argc, iDir, "-verify", &pszParm)
             || haveParmOption(argx, argc, iDir, "-ver", &pszParm)
             || haveParmOption(argx, argc, iDir, "-v", &pszParm)
            )
         {
            if (!pszParm) return 9;
            pszVerify = pszParm;
            continue;
         }
         if (!strcmp(pszArg, "-name")) // sfk193
            { bNames = 2; continue; }
         if (strBegins(argx[iDir], "-noname")
             || !strcmp(pszArg, "-pure")) // sfk193 internal
         {
            bNames = 0;
            continue;
         }
         if (strBegins(argx[iDir], "-nocomp")) {
            bComp = 0;
            continue;
         }
         if (!strcmp(pszArg, "-crc")) // internal
            { cs.crcmd5=1; continue; }
         if (sfkisopt(argx[iDir])) {
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext)) {
            iFileMax = iChainNext;
            break;
         }
         // process non-option keywords:
         if (iFile < 0) iFile = iDir;
         // else step through supplied filenames
         nFileNames++;
      }

      if (nFileNames==1 && bNames<2) // sfk193
         bNames=0;

      if (bFromChain == 0 && iFile < 0)
         return 9+perr("supply filename(s) for reading\n");
      if (btest) return 0;

      #ifndef SFKPRO
      // must block this to avoid checksums over truncated demo extracts
      if (cs.travelzips)
         return 9+perr("%s with -(q)arc requires SFK XE.",pszCmd);
      #endif

      num nstart = getCurrentTime();

      if (bFromChain)
      {
         fGlblOut = 0;
         lRC = walkAllTrees(eFunc_MD5Write, lFiles, lDirs, nBytes);
      }
      else
      {
         // read file(s), dump md5s underneath
         szLineBuf2[0] = '\0';
         int nFiles = 0;
         for (; iFile < iFileMax; iFile++)
         {
            nFiles++;
 
            {
               SFKMD5 md5;
               char *pszFile = argx[iFile];
               // special case: -verify checksum *filename
               // -> skip * before filename
               if (pszVerify && pszFile[0] == '*')
                  pszFile++;
               if (getFileMD5(pszFile, md5))
                  return 9;
               unsigned char *pmd5 = md5.digest();
               for (int i=0; i<(cs.crcmd5 ? 4 : 16); i++)
                  sprintf(&szLineBuf[i*2], "%02x", pmd5[i]);
               if (!cs.quiet) {
                  if (chain.colany()) {
                     if (bNames)
                        chain.print("%s\t%s", szLineBuf, pszFile);
                     else
                        chain.print("%s", szLineBuf);
                  } else {
                     if (bNames)
                        oprintf("%s\t%s\n", szLineBuf, pszFile);
                     else
                        printf("%s\n", szLineBuf);
                  }
               }
               if (szLineBuf2[0] && strcmp(szLineBuf, szLineBuf2))
                  bMismatch = 1;
               if (pszVerify && strcmp(pszVerify, szLineBuf))
                  bMismatch = 1;
               strcpy(szLineBuf2, szLineBuf);
            }
         }

         lRC = bMismatch ? 1 : 0;
 
         if (((nFiles > 1 && bComp) || pszVerify != 0) && !cs.quiet) {
            if (chain.colany()) {
               if (bMismatch)
                  chain.print("rc1 mismatch");
               else
                  chain.print("rc0 equal");
            } else {
               if (bMismatch)
                  printf("content mismatch (RC==1)\n");
               else
                  printf("content is equal (RC==0)\n");
            }
         }
      }

      if (cs.verbose)
         printf("done in %d msec\n", (int)(getCurrentTime() - nstart));

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   // .
   ifcmd (!strcmp(pszCmd, "md5var")) // sfk193
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk md5var varname\n"
             "\n"
             "   create md5 hash from sfk variable content.\n"
             "\n"
             "   $command chaining\n"
             "      supports output chaining.\n"
             "\n"
             "   $examples\n"
             "      #sfk setvar a=foo +md5var a\n"
             "         prints md5 over text 'foo'\n"
             "      #sfk setvar a=foo +md5var a +setvar sum\n"
             "         puts hash text into another variable\n"
             );
      ehelp;

      sfkarg;

      char *pszvarname = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!pszvarname)
            { pszvarname=pszArg; continue; }
         return 9+perr("unexpected: %s",pszArg);
      }

      if (!pszvarname)
         return 9+perr("missing variable name");

      int    ndata = 0;
      uchar *pdata = sfkgetvar(pszvarname, &ndata);
      if (!pdata)
         return 9+perr("no such variable: %s",pszvarname);

      SFKMD5 md5;
      md5.update(pdata, ndata);

      uchar *pmd5 = md5.digest();

      char szBuf[100]; szBuf[0]='\0';
      int  ioff=0;
      for (int i=0; i<16; i++)
         sprintf(szBuf+i*2, "%02x", pmd5[i]);

      chain.print("%s\n", szBuf);

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "license"))
   {
      ifhelp (nparm < 1)
      #ifndef SFKPRO
      printx(
         "Copyright (c) 2021 by Stahlworks Technologies, www.stahlworks.com.\n"
         "All rights reserved.\n"
         "\n"
         "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n"
         "\n"
         "    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n"
         "    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer "
         "in the documentation and/or other materials provided with the distribution.\n"
         "\n"
         "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, "
         "INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. "
         "IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, "
         "OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; "
         "OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, "
         "OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
         );
      #endif
      ehelp;
 
      bDone = 1;
   }

   #ifdef _WIN32
   if (!strcmp(pszCmd, "wtest"))
   {
      // so far wprintf does not print unicode at all.
      wchar_t szwsize[100];
      // with VC14 and setmode the german umlaut shows correctly 
      // on a german windows, but not the han character.
      // with VC7 nothing works.
      // #define _O_U16TEXT     0x20000
      // #define _O_U8TEXT      0x40000
      printf("test of 16-bit unicode character output.\n");
      _setmode(_fileno(stdout), 0x20000);
      szwsize[0] = 0x00E4;
      szwsize[1] = 0;
      wprintf(L">>> a with diaresis : %s <<<\n", szwsize);
      szwsize[0] = 0x7a7a;
      wprintf(L">>> han char 'empty': %s <<<\n", szwsize);
      bDone = 1;
   }
   #endif

   #ifdef _WIN32
   bool blistcodessys=0;

   ifcmd (!strcmp(pszCmd, "listcodes") || (!strcmp(pszCmd, "listcodes.")))
   {
      blistcodessys = strcmp(pszCmd, "listcodes.") ? 0 : 1;

      ifhelp (nparm < 1 && blistcodessys == 0)
      sfkchars.init();
      printx("<help>$sfk listcodes[.] mode\n"
             "\n"
             "   list lower/uppercase mapping codes supported\n"
             "   by sfk, depending on the active codepage.\n"
             "\n"
             "   $sfk currently uses:\n"
             "     Ansi codepage %u for data processing\n"
             "     OEM  codepage  %u for input / output\n"
             "\n"
             , sfkchars.iclacp
             , sfkchars.iclocp
             );
      printx("   $advanced options\n"
             "     -isochars      use codepage 1252, no matter what\n"
             "                    the actual system codepage is.\n"
             "     -codepage=a    use Ansi codepage a.\n"
             "     -codepage=a-o  use Ansi codepage a, OEM page o.\n"
             "\n"
             "     these options are useful only with some commands,\n"
             "     like wtoa or utoa. printed characters in the\n"
             "     terminal may look wrong, so you have to redirect\n"
             "     output to a file. code pages 1250 1251 1252 and\n"
             "     852 866 850 are hardcoded in sfk, all others are\n"
             "     taken from the windows subsystem.\n"
             "\n"
             );
      printx("   $examples<def> (advanced use)\n"
             "\n"
             "     #sfk -codepage=1251-866 listcodes.<def>\n"
             "        list cyrillic codepage, no matter what the\n"
             "        actual system codepage is. printed chars\n"
             "        may look wrong, just read the char names.\n"
             "\n"
             "     #sfk -codepage=1251 listcodes. >out.txt<def>\n"
             "        same as above, but write output to a file.\n"
             "        (the OEM codepage is not used when writing\n"
             "         to file, therefore no -866 is given.)\n"
             "        if you load out.txt with Notepad++, then select:\n"
             "        $Encoding / Character Sets / Cyrillic / Windows-1251<def>\n"
             "        it will display the cyrillic characters.\n"
             "\n"
             "     #sfk -codepage=1250-852 listcodes. >out.txt<def>\n"
             "        list central european characters. in Notepad++ use:\n"
             "        $Encoding / Character Sets / Central Europe\n"
             "        $/ Windows-1250<def>\n"
             "\n"
             );
      printx("   $examples<def> (normal use)\n"
             "\n"
             "     #sfk listcodes sys<def>\n"
             "        list the character mappings supported with\n"
             "        the current Ansi codepage of your system.\n"
             "\n"
             "     #sfk listcodes.<def>\n"
             "        same as above, but shorter to type.\n"
             "\n"
             "     #sfk listcodes full<def>\n"
             "        also show the codes which cannot be used\n"
             "        with your system's Ansi codepage.\n"
             "\n"
             "     #sfk -isochars listcodes.<def>\n"
             "        show codes with fixed 1252/850 codepage.\n"
             "        displayed characters may be wrong,\n"
             "        just look at the character names.\n"
             "\n"
             "     #sfk -deacc listcodes.<def>\n"
             "        show mappings with accent insensitive search\n"
             "        which are quite different, e.g. many a_accent\n"
             "        characters map to the same base letter a.\n"
             "\n");
      ehelp;

      sfkarg;

      bool bfull=0,ball=0,btrace=0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (!strcmp(pszArg, "-any")) { // internal
            bfull = 1;
            continue;
         }
         if (!strcmp(pszArg, "-trace")) {
            btrace = 1;
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!strcmp(pszArg, "sys")) {
            ball = 0;
            continue;
         }
         if (!strcmp(pszArg, "full")) {
            ball = 1;
            continue;
         }
         return 9+perr("unexpected: %s\n",pszArg);
      }
 
      listcodes(ball, bfull, btrace);

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }
   #endif

   if (!strcmp(pszCmd, "testftime")) // internal
   {
      Coi ocoi(str("mysrc/mytest.dat"), 0);
      num n1 = ocoi.getTime();

      FileStat ofs;
      ofs.readFrom(str("mysrc/mytest.dat"));
      #ifdef _WIN32
      ofs.src.nHaveWFT = 0;
      #endif
      ofs.writeTo(str("mysrc/towrite.dat"), __LINE__);
      num n2 = ofs.src.nMTime;

      printf("n1: %s %s\n", numtoa(n1), timeAsString(n1));
      printf("n2: %s\n", numtoa(n2));
      printf("df: %d\n", (int)(n2-n1));

      bDone = 1;
   }

   #ifdef SFK_W64
   if (!strcmp(pszCmd, "testtime2")) // internal
   {
      num n = getFileTime("timeref.dat");
      printf("%s\n", numtoa(n));

      struct __stat64 buf;
      _stat64("timeref.dat", &buf);
      n = buf.st_mtime;
      printf("%s\n", numtoa(n));

      HANDLE hFile = CreateFile("timeref.dat",
         FILE_READ_DATA, 0, 0,
         OPEN_EXISTING, FILE_FLAG_NO_BUFFERING, 0);

      FILETIME ftmod;
      SYSTEMTIME omod;
      GetFileTime(hFile, 0, 0, &ftmod);
      FileTimeToSystemTime(&ftmod, &omod);

      n = fileTimeToTimeT(&ftmod);
      printf("%s\n", numtoa(n));
      printf("%u %u %u\n",omod.wDay,omod.wHour,omod.wMinute);

      CloseHandle(hFile);

      WIN32_FILE_ATTRIBUTE_DATA odat;
      GetFileAttributesEx("timeref.dat", GetFileExInfoStandard, &odat);
      n = fileTimeToTimeT(&odat.ftLastWriteTime);
      printf("%s\n", numtoa(n));
      printf("%u %u %u\n",omod.wDay,omod.wHour,omod.wMinute);

      bDone = 1;
   }
   #endif

   if (!strcmp(pszCmd, "testtime")) // internal
   {
      char *pszTime40 = 0;

      for (int i=0; i<1; i++)
      {
         switch (i) 
         {
            case 0: pszTime40 = str("20200101120101"); break;
            case 1: pszTime40 = str("20400101123059"); break;
            case 2: pszTime40 = str("22000101123059"); break;
         }

         num nTime40 = 0;
   
         printf("time1: %19s str\n", pszTime40);
   
         if (timeFromString(pszTime40, nTime40))
            return 9+perr("cannot convert: %s",pszTime40);
         
         printf("time2: %19s uxsec\n", numtoa(nTime40));
   
         #ifdef _WIN32
   
         num nNanoSec= 0;
         FILETIME nWinTime; mclear(nWinTime);
   
         if (makeWinFileTime(nTime40, nWinTime, nNanoSec, 1)) // testtime
            return 9+perr("makeWinFileTime failed");
   
         num nmix =     (((num)nWinTime.dwHighDateTime) << 32)
                     |  (((num)nWinTime.dwLowDateTime)  <<  0);
   
         printf("time3: %19s winft1\n", numtoa(nmix));
   
         FILETIME nWinTime2; mclear(nWinTime2);
         timetToFileTime(nTime40, &nWinTime2);
   
         num nmix2 =    (((num)nWinTime2.dwHighDateTime) << 32)
                     |  (((num)nWinTime2.dwLowDateTime)  <<  0);
   
         printf("time4: %19s winft2\n", numtoa(nmix2));

         num ntime5 = fileTimeToTimeT(&nWinTime2);

         printf("time5: %19s reconv\n\n", timeAsString(ntime5));

         #endif
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "testcrc"))
   {
      int n = 100;
      uchar *buf = new uchar[n];
      memset(buf, 0, n);
      uint ncrc  = sfkPackSum(buf, n, 0);
      printf("CRC: %x\n", ncrc);
      delete [] buf;
      bDone = 1;
   }

   if (!strcmp(pszCmd, "testabs"))
   {
      printf("%s\n",getAbsPathStart(str("https://foo.com/bar.xml")));
      printf("%s\n",getAbsPathStart(str("C:foo.txt")));
      printf("%s\n",getAbsPathStart(str("C:\\bar.txt")));
      printf("'%s'\n",getAbsPathStart(str("foo1.txt")));
      printf("'%s'\n",getAbsPathStart(str("\\foo2.txt")));
      printf("'%s'\n",getAbsPathStart(str("\\\\foo3.txt")));
      bDone = 1;
   }

   if (!strcmp(pszCmd, "test"))
   {
      if (argc < 3) {
      printx("<help>$sfk test mode dbfile tctitle infile\n"
             "\n"
             "   record/compare automated test results on a database.\n"
             "\n"
             "      mode:\n"
             "         rec   record checksum of infile\n"
             "         upd   record only if not yet contained in db\n"
             "         cmp   compare checksum against db entry\n"
             "      dbfile : a database file, created by sfk in mode -rec\n"
             "      tctitle: name of the testcase, e.g. T01.1.mytest\n"
             "      infile : an output file resulting from a testcase\n"
             "\n"
             "   the sequence of text lines within the infile is ignored.\n"
             "   this may lead to a checksum of \"0000\" if the input file\n"
             "   contains the same content twice.\n"
             "\n"
             "   $examples\n"
             "      #sfk test rec mycrc.db T01.1.encoding out1.dat\n"
             "      -> creates checksum of out1.dat, writes to mycrc.db\n"
             "         under the title T01.1.encoding\n"
             "      #sfk test cmp mycrc.db T01.1.encoding out1.dat\n"
             "      -> creates checksum of out1.dat, reads 2nd checksum\n"
             "         from mycrc.db, and compares both.\n"
             );
         return 9;
      }

      if (argc >= 3 && !strcmp(argv[2], "workdir"))
      {
         szLineBuf[0] = '\0';
         if (getcwd(szLineBuf,sizeof(szLineBuf)-10)) { }
         char *psz = strrchr(szLineBuf, glblPathChar);
         if (!psz) return 9;
         psz++;
         char *pszRelWorkDir = psz;
         if (argc == 4) {
            if (!strcmp(argv[3], pszRelWorkDir))
               return 0;
            else {
               if (cs.verbose)
                  printf("\"%s\" != \"%s\"\n",pszRelWorkDir,argv[3]);
               return 9;
            }
         } else {
            printf("%s\n", pszRelWorkDir);
         }
         return 0;
      }

      if (argc < 6) return 9+perr("missing arguments. type \"sfk test\" for help.\n");

      char *pszMode   = argv[2];
      char *pszDBFile = argv[3];
      char *pszTitle  = argv[4];
      char *pszInFile = argv[5];

      // create checksum of infile in szLineBuf.
      if (getFuzzyTextSum(pszInFile, abBuf))
         return 9;
      for (int i=0; i<16; i++)
         sprintf(&szLineBuf2[i*2], "%02x", abBuf[i]);

    {
      TestDB tdb(pszDBFile);

      // select command
      if (!strcmp(pszMode, "rec")) {
         tdb.load(1); // silent: ignore rc, create on 1st use
         // write unconditional, overwrite existing vals
         if (tdb.update(pszTitle, szLineBuf2)) return 9;
         if (tdb.write()) return 9;
         int tlen = strlen(pszTitle);
         if (tlen > 15) tlen = 15;
         printf(":REC : %s%.*s %s\n", pszTitle, (int)(15-tlen), pszGlblBlank, szLineBuf2);
      }
      else
      if (!strcmp(pszMode, "upd")) {
         tdb.load(1); // silent: ignore rc, create on 1st use
         // write only if not yet contained
         if (!tdb.getValue(pszTitle)) {
            if (tdb.update(pszTitle, szLineBuf2)) return 9;
            if (tdb.write()) return 9;
            int tlen = strlen(pszTitle);
            if (tlen > 15) tlen = 15;
            printf(":ADD : %s%.*s %s\n", pszTitle, (int)(15-tlen), pszGlblBlank, szLineBuf2);
         }
      }
      else
      if (!strcmp(pszMode, "cmp")) {
         if (tdb.load(0)) return 9;
         char *pszVal = tdb.getValue(pszTitle);
         if (!pszVal) return 9+perr("no such entry: %s\n", pszTitle);
         if (!strcmp(pszVal, szLineBuf2)) {
            // match
            printf(": OK : %s\n", pszTitle);
         } else {
            // mismatch
            printf(":FAIL: %s   - mismatch of %s\n", pszTitle, pszInFile);
            lRC = 9;
         }
      }
      else
         return 9+perr("unknown test mode: %s\n", pszMode);
    }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "proctest")) // internal
   {
      if (nparm < 1)
      {
      printx("<help>$sfk proctest script.txt [testid] [ff]\n"
             "\n"
             "   test text processing by running testcases\n"
             "   from a script. per testcase,\n"
             "\n"
             "   - an input file tmpin.txt is written\n"
             "   - another file tmpout.txt is written\n"
             "     with same content as tmpin.txt,\n"
             "     to allow direct replace in tmpout.txt\n"
             "   - a command from the script is executed\n"
             "   - output file tmpout.txt is compared\n"
             "     against the output template data in the script.\n"
             "\n"
             "   $script syntax\n"
             "      :test name of test case 1\n"
             "      :from\n"
             "      ... [any text data] ...\n"
             "      :command\n"
             "      ... [single line command] ...\n"
             "      :to\n"
             "      ... [any text data] ...\n"
             "      :done\n"
             "\n"
             "      :test name of test case 2\n"
             "      ...\n"
             "\n"
             "   $script example\n"
             "      :test 01 replace foo\n"
             "      :from\n"
             "      the foo and the bar\n"
             "      :command\n"
             "      sfk rep tmpout.txt -text \"/foo/bar/\" -yes\n"
             "      :to\n"
             "      the bar and the bar\n"
             "      :done\n"
             "\n"
             "   $parameters\n"
             "      testid    run only single test case\n"
             "      ff        run all cases starting from testid\n"
             "\n"
             "   $options\n"
             "      -quiet    redirect terminal output to >nul\n"
             "      -cmd=x    replace $$cmd at line starts by x\n"
             "\n"
             "   $examples\n"
             "      #sfk proctest myscript.txt\n"
             "         runs script myscript.txt\n"
             );
      return 9;
      }

      char *pszScript = 0;
      char *pszStart  = 0;
      char *pszTheCmd = 0;
      bool  bContinuous = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-cmd", &pszParm)) {
            if (!pszParm) return 9;
            pszTheCmd = pszParm;
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszScript) {
            pszScript = pszArg;
            continue;
         }
         if (!pszStart) {
            pszStart = pszArg;
            continue;
         }
         if (!strcmp(pszArg, "ff")) {
            bContinuous = 1;
            continue;
         }
         return 9+pbad(pszCmd, pszArg);
      }

      if (!pszScript)
         return 9+perr("missing script filename\n");

      char *pScript = loadFile(pszScript);
      if (!pScript)
         return 9+pferr(pszScript, "cannot load: %s", pszScript);

      char *pTestName,*pFromStart,*pFromEnd;
      char *pCommand,*pToStart,*pToEnd;

      bool  btelltmp = 0;
      char *pCur = pScript;
      while (pCur && *pCur)
      {
         if (strBegins(pCur, ":done")) {
            if (nextLine(&pCur)) break;
            continue;
         }
         skipOver(&pCur, " \r\n");
         if (!*pCur) break;
         if (!strBegins(pCur, ":test "))
            { perr("missing :test"); break; }
         pTestName = pCur+6;
         if (nextLine(&pCur)) break;
         if (strBegins(pCur, ":command")) {
            pFromStart=str("");
            pFromEnd=pFromStart;
            pCommand = pCur;
         } else {
            if (!strBegins(pCur, ":from"))
               { perr("missing :from after :test"); break; }
            if (nextLine(&pCur)) break;
            pFromStart = pCur;
            pFromEnd = strstr(pCur, "\n:command");
            if (!pFromEnd)
               { perr("missing :command after :from"); break; }
            pFromEnd++;
            pCommand = pFromEnd;
         }
         if (nextLine(&pCommand)) break;
         while (*pCommand == '#')
            nextLine(&pCommand);
         // auto convert ./sfk to target system
         if (pCommand[0]=='.' && pCommand[1]==glblWrongPChar)
            pCommand[1]=glblPathChar;
         // join multi line command
         char *pToStart=0;
         {
            char *psrc=pCommand;
            char *pdst=psrc;
            bool bstop=0;
            bool bquotes=0;
            while (*psrc)
            {
               // copy until line end
               while (*psrc!=0 && *psrc!='\r' && *psrc!='\n') {
                  if (*psrc=='\"') bquotes ^= 0x1;
                  *pdst++ = *psrc++;
               }
               // skip line end
               while (*psrc=='\r' || *psrc=='\n')
                  psrc++;
               // check for command end
               if (*psrc==0 || *psrc==':')
                  break;
               // skip next line white start
               if (!isspace(*psrc)) {
                  perr(":command must be a single command: %s\n",pCommand);
                  bstop=1; break; }
               // insert blank if not quoted
               if (!bquotes)
                  *pdst++=' ';
               while (isspace(*psrc)) psrc++;
            }
            *pdst='\0';
            pToStart=psrc;
            if (bstop) break;
         }
         if (!strBegins(pToStart, ":to"))
            { perr("missing :to after :command"); break; }
         if (nextLine(&pToStart)) break;
         pToEnd = strstr(pToStart, "\n:done");
         if (!pToEnd)
            { perr("missing :test or :done after :to"); break; }
         pToEnd++;
         pCur = pToEnd;
         // execute single test case
         if (pszStart!=0 && !strstr(pTestName,pszStart))
            { }
         else
         {
            if (pszStart && bContinuous)
               pszStart = 0;
            printx("#TEST: ===== %s =====\n", pTestName);
            if (!cs.quiet)
               printf("FROM: %s\n", dataAsTrace(pFromStart, pFromEnd-pFromStart));
            if (saveFile(str("tmpin.txt"), (uchar*)pFromStart, pFromEnd-pFromStart))
               break;
            if (saveFile(str("tmpout.txt"), (uchar*)pFromStart, pFromEnd-pFromStart))
               break;
            // replace $cmd by -cmd parameter
            {
               char *psrccur=pCommand;
               char *psrcmax=psrccur+strlen(psrccur);
               char *pdstcur=szLineBuf2;
               char *pdstmax=pdstcur+MAX_LINE_LEN;
               while (psrccur<psrcmax && pdstcur+100<pdstmax) {
                  if (!strncmp(psrccur, "$cmd ", 5)) {
                     if (!pszTheCmd)
                        return 9+perr("missing -cmd for $cmd entries in test script");
                     memcpy(pdstcur, pszTheCmd, strlen(pszTheCmd));
                     pdstcur+=strlen(pszTheCmd);
                     psrccur+=5;
                     *pdstcur++=' ';
                     continue;
                  }
                  *pdstcur++ = *psrccur++;
               }
               *pdstcur='\0';
               pCommand = szLineBuf2;
            }
            if (!cs.quiet)
               printf("CMD : %s\n", pCommand);
            if (cs.quiet && !strstr(pCommand, " >")) {
               snprintf(szLineBuf, MAX_LINE_LEN, "%s >nul 2>&1", pCommand);
               if (system(szLineBuf)) { }
            } else {
               if (system(pCommand)) { }
            }
            if (!cs.quiet) {
               printf("NEED: %s\n", dataAsTrace(pToStart, pToEnd-pToStart));
               saveFile(str("tmpneed.txt"), (uchar*)pToStart, pToEnd-pToStart);
            }
            num nOutSize=0;
            uchar *pOut = loadBinaryFile(str("tmpout.txt"), nOutSize);
            if (!pOut)
               { perr("missing output file tmpout.txt"); break; }
            if (!cs.quiet)
               printf("GOT : %s\n", dataAsTrace(pOut, nOutSize));
            #ifdef _WIN32
            if (nOutSize != pToEnd-pToStart) {
               delete [] pOut;
               perr("... output size differs (%d/%d)",(int)nOutSize,(int)(pToEnd-pToStart));
               btelltmp=1;
               break;
            }
            if (memcmp(pOut,pToStart,nOutSize)) {
               delete [] pOut;
               perr("... output differs.");
               btelltmp=1;
               break;
            }
            #else
            uchar abSum1[20];
            uchar abSum2[20];
            getFuzzyTextSum((char*)pToStart, (int)(pToEnd-pToStart), abSum1);
            getFuzzyTextSum((char*)pOut, (int)nOutSize, abSum2);
            if (memcmp(abSum1,abSum2,16)) {
               delete [] pOut;
               perr("... output differs (fuzzy).");
               btelltmp=1;
               break;
            }
            #endif
            delete [] pOut;
         }
      }
      if (!cs.quiet && btelltmp)
         printf("  ... see tmpneed.txt and tmpout.txt\n");

      delete [] pScript;

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "snapto")) // +wref
   {
      ifhelp (1)
      printx("<help>$sfk snapto=outfile [-pure] [-nosub] -dir mydir1 -file .ext1 .ext2\n"
             "\n"
             "   Collect many text files into one large text file, specifying\n"
             "   what sub folders and file (extensions) to include or exclude.\n"
             "   The resulting file can be loaded directly by Depeche View,\n"
             "   allowing interactive search and filtering of the content.\n"
             "\n"
             "   $options\n"
             "      -office     include text from office files like .docx .xlsx\n"
             "                  .ods .odt. for details see: sfk help office\n"
             "      -justoffice reads only office files, but no plain text files.\n"
             "      -keeputf    keep UTF-8 encoding from office file contents.\n"
             "                  default is to convert to Ansi characters of your\n"
             "                  system's codepage.\n"
             "      -fileset x  instead of specifying long lists of -dir / -file\n"
             "                  statements on the command line, you may write them\n"
             "                  all into a text file, then use that. for more infos,\n"
             "                  type \"sfk help fileset\".\n"
             );
      arcinf(8); // snapto
             #ifdef _WIN32
      printx("      -hidden     include hidden and system files (not default).\n");
             #endif
      printx("      -allbin     include binary files as text extract (not default).\n"
             "      -wlbin      include binaries selected by file mask white list.\n" // sfk1944
             #ifdef _WIN32
             "      -binallchars  when extracting text from binaries include all\n"
             "                  printable characters, like accents or non latin.\n"
             #endif
             "      -pure       don't insert filenames.\n"
             "      -pure=2     no filenames and no header.\n"
             "      -prefix=x   insert x before every file.\n"
             "      -nometa     by default, sfk adds the file system's time and size\n"
             "                  info to each :file: header. can be disabled here.\n"
             "                  note that size= may not reflect the actual bytes used\n"
             "                  within the snapfile, due to line ending conversions.\n"
             "      -raw        collect faster by adding text file content as is,\n"
             "                  without CRLF conversions, but still replacing any\n"
             "                  null or EOF bytes. skips binary files completely.\n"
          // "                  assures that the\n"
          // "                  size= header field reflects the true content size.\n"
          // "      -rawest     like -raw but does not even convert unexpected null\n"
          // "                  or EOF (0x1A) characters within text data.\n"
             "      -nosub      or -norec does not include subdirectories (subfolders).\n"
             "      -wrap[=n]   auto-wrap long lines [near column n], e.g. -wrap=80.\n"
             "      -stat       show time stats at end.\n"
             #ifdef _WIN32
             "      -slow       run with a lower process priority.\n"
             #endif
             ,glblPathChar);
      printx("\n"
             "   $see also\n"
             "      #sfk view<def>    a GUI tool that can load and view sfk snap files\n"
             "                  directly and search them at high speed.\n"
             "      #sfk getdv<def>   instant download of Depeche View Lite (portable,\n"
             "                  no installation) to browse snap file contents.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk snapto=all-src.cpp . .cpp .hpp .dll <not>tmp\n"
             "         includes .cpp, .hpp and even .dll text extracts, excludes all\n"
             "         files with \"tmp\" in their name, e.g. tmp10.cpp\n"
             "\n"
             "      #sfk snapto=all-src.cpp -dir src2 <not>src2<sla>old -file -all .doc\n"
             "         includes all text files, and .doc binary extracts.\n"
             "\n"
             "      #sfk snapto=all-src.cpp -fileset zz-myset.txt\n"
             "         includes whatever dirs and files are specified in the\n"
             "         fileset definition \"zz-myset.txt\" (sfk help fileset).\n"
             "\n"
             "      #sfk select src5 .txt .exe +snapto=all.txt\n"
             "         filenames provided by command chaining are always included,\n"
             "         no matter if binary or not. in this case, extracts from .exe\n"
             "         binary files are also placed into the output.\n"
             "\n"
             "      #sfk select -text mydir <not>.bak +snapto=all.txt\n"
             "         select all text files from mydir, excluding .bak files.\n"
             /*
             "\n"
             "      #sfk snapto=alldoc.txt -office mydir .docx .xlsx\n"
             "         collect text from all .docx and .xlsx files in folder\n"
             "         mydir into one large file alldoc.txt, which can be\n"
             "         browsed and searched by: #dview alldoc.txt\n"
             */
             );
      ehelp;
      // no real action here
      return 9;
   }

   regtest("snapto=xfile.txt xdir .cpp .hpp -wrap");
   regtest("snapto=xfile.txt -pure -prefix=foo -dir xdir1 xdir2 -file .cpp");
   regtest("list xdir +snapto=xfile.txt");

   if (!strncmp(pszCmd, "snapto=", strlen("snapto=")))   // +chaining
   {
      sfkarg;

      pszGlblOutFile = pszCmd+strlen("snapto=");

      bool bstat     = 0;
      cs.addsnapmeta = 0xFFFFUL; // add as much infos as possible
      cs.addsnaplf   = "\n";     // by default converted by fprintf etc.

      #ifdef VFILEBASE
      cs.precachezip = 1;
      #endif // VFILEBASE

      cs.hidezipcomment = 1; // snapto

      const char *poutmode = "w";

      int iChainNext = 0;
      for (; iDir < argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strncmp(pszArg,"-prefix=",strlen("-prefix="))) {
            char *psz = pszArg+strlen("-prefix=");
            if (strlen(psz) > 40)
               return 9+perr("prefix too long, only up to 40 characters are allowed.");
            pszGlblJamPrefix = psz;
            continue;
         }
         if (!strcmp(pszArg,"-pure=2"))
            { bGlblJamPure = 2; continue; }
         if (!strcmp(pszArg,"-pure"))
            { bGlblJamPure = 1; continue; }
         if (!strcmp(pszArg,"-stat"))
            { bstat = 1; continue; }
         if (!strcmp(pszArg,"-nometa"))
            { cs.addsnapmeta = 0; continue; }
         if (!strcmp(pszArg,"-office"))     // snapto
            { cs.office = 1; continue; }
         if (!strcmp(pszArg,"-justoffice")) // snapto
            { cs.office = 1; cs.justoffice = 1; continue; }
         if (cs.office && !strcmp(pszArg, "-keeputf")) // snapto i/o -utfout
            { cs.utfout = 1; continue; }
         if (!strcmp(pszArg,"-raw")) {
            cs.addsnapraw = 1;
            // write snapfile in binary mode,
            // to avoid any conversions by fwrite
            poutmode = "wb";
            // therefore we need to specify exact
            // line endings used for header lines
            #ifdef _WIN32
            cs.addsnaplf  = "\r\n";
            #else
            cs.addsnaplf  = "\n";
            #endif
            continue;
         }
         if (!strcmp(pszArg,"-rawest")) {
            cs.addsnapraw = 2;
            poutmode = "wb";
            continue;
         }
         if (sfkisopt(pszArg)) { // fix sfk197 missing
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         // fix sfk197 missing:
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         break;
      }

      // collect dir and mask parms
      bGlblAllowAllPlusPosFile = 1;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iChainNext))) return lRC;
      if (btest) return 0;

      fGlblOut = fopen(pszGlblOutFile, poutmode);
      if (!fGlblOut) return 9+perr("cannot write %s\n", pszGlblOutFile);

      if (bGlblJamPure < 2) {
         // write global file header
         fprintf(fGlblOut, ":snapfile sfk,1.1,%slprefix=%s",
            cs.addsnapraw ? "raw,":"", pszGlblJamPrefix);
         if (cs.wrapcol > 0)
            fprintf(fGlblOut, ",wrap=%u", cs.wrapcol);
         fprintf(fGlblOut,"%s%s",cs.addsnaplf,cs.addsnaplf);
         // we will scan the input if we see this content, and exclude it
      }

      // reset stats in case of input chaining
      glblFileCount.reset();
      cs.lines   = 0;
      cs.totalbytes = 0;

      lRC = walkAllTrees(eFunc_JamFile, lFiles, lDirs, nBytes);

      fclose(fGlblOut);

      uint nmbytes = (uint)(cs.totalbytes/1000000UL);
      uint nkbytes = (uint)(cs.totalbytes/1000UL);
      uint nkbsec  = currentKBPerSec();
      uint nmbsec  = nkbsec / 1000UL;
      uint nmsec   = (uint)(getCurrentTime() - nGlblStartTime);
      uint nsec    = nmsec / 1000UL;

      info.clear();

      if (bstat)
      printf("%u files collected into %s, %d lines, %u %s, %u %s, %u %s/sec\n",
         glblFileCount.value(), pszGlblOutFile, cs.lines,
         (nmbytes>0)?nmbytes:nkbytes, (nmbytes>0)?"mb":"kb",
         (nsec>=10)?nsec:nmsec, (nsec>=10)?"sec":"msec",
         (nmbsec>=10)?nmbsec:nkbsec, (nmbsec>=10)?"mb":"kb");
      else
      printf("%u files collected into %s, %d lines, %u %s\n",
         glblFileCount.value(), pszGlblOutFile, cs.lines,
         (nmbytes>0)?nmbytes:nkbytes, (nmbytes>0)?"mb":"kb");

      pszGlblOutFile = 0; // fix sfk198 missing

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   regtest("text-join-lines xinfile xoutfile");

   ifcmd (!strcmp(pszCmd, "joinlines") || !strcmp(pszCmd, "text-join-lines"))
   {
      ifhelp (nparm < 2)
      printx("<help>$sfk joinlines infile outfile\n"
             "\n"
             "   join text lines from text split by email reformatting.\n"
             "\n");
      webref("joinlines");
      ehelp;

      sfkarg;

      char *pszInFile=0,*pszOutFile=0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!pszInFile)
            { pszInFile=pszArg; continue; }
         if (!pszOutFile)
            { pszOutFile=pszArg; continue; }
         return 9+perr("unexpected: %s",pszArg);
      }
      if (!pszInFile || !pszOutFile)
         return 9+perr("missing parameters");
      if (btest) return 0;

      char *pInFile = loadFile(pszInFile);
      if (!pInFile) return 9;

      fGlblOut = fopen(pszOutFile, "w");
      if (!fGlblOut) {
         perr("cannot write %s\n", pszOutFile);
         delete [] pInFile;
         return 9;
      }

      lRC = execTextJoinLines(pInFile);

      fclose(fGlblOut);
      delete [] pInFile;

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "scantab2"))
   {
      cs.scanTabs = 1;
      if ((lRC = processDirParms(pszCmd, argc, argv, 2, 3))) return lRC;
      lRC = walkAllTrees(eFunc_Detab, lFiles, lDirs, nBytes);
      printf("%d files of %d contain tabs.\n", cs.tabFiles, cs.files);
      bDone = 1;
   }

   regtest("scantab -dir xsrc1 xsrc2 -file .cpp .hpp .txt");
   regtest("scantab -quiet -pure . .cpp .hpp");
   regtest("list xdir .txt +scantab");

   ifcmd (!strcmp(pszCmd, "scantab"))  // +chaining
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk scantab [-quiet] dir [mask] [-pure]\n"
             "\n"
             "   list files containing tabs.\n"
             "\n"
             "   $options\n"
             "      -quiet   do not list filenames, show only statistics.\n"
             "      -pure    list only filenames, but no statistics.\n"
          // "      -ind[ent]  collect also indentation statistics\n"
          // "      -indsel=4  list only files with indentation 4\n"
          // "      -verbose   list estimated indendation per file\n"
             "\n"
             "   $return codes for batch files\n"
             "      0 = no tabs, 1 = tabs found, >1 = error occurred.\n"
             "\n");
      webref("scantab");
      printx("   $examples\n"
             "      #sfk scantab mydir\n"
             "         list all text files with tabs in mydir.\n");
      ehelp;

      sfkarg;

      // allow option -pure to be used anywhere:
      bGlblAllowGeneralPure = 1;

      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-indsel", &pszParm)) {
            if (!pszParm) return 9;
            cs.indentFilt = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argx[iDir], "-ind", 4)) {
            cs.scanIndent = 1;
            continue;
         }
         else
         if (!strcmp(argx[iDir], "-pure")) {
            cs.pure = 1;
            continue;
         }
         else
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         break;
      }

      memset(aGlblIndentStats, 0, sizeof(aGlblIndentStats));
      cs.scanTabs = 1;
      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext))) return lRC;
      if (btest) return 0;

      lRC = walkAllTrees(eFunc_Scantab, lFiles, lDirs, nBytes);
      if (!lRC && (cs.tabFiles > 0)) lRC = 1; // found files with tabs

      if (!cs.indentFilt && !cs.pure)
         printf("%d files of %d contain tabs.", cs.tabFiles, cs.files);

      bool bTold=0;
      if (cs.scanIndent)
      {
         // create sorted indent stats
         int i,k;
         int asize[20], acnt[20];
         memset(asize, 0, sizeof(asize));
         memset(acnt , 0, sizeof(acnt));
         // transform
         for (i=0; i<=8; i++) {
            int nsize = i;
            int ncnt  = aGlblIndentStats[i];
            asize[i] = nsize;
            acnt[i]  = ncnt;
         }
         // sort
         for (i=0; i<10; i++)
            for (k=i+1; k<10; k++)
               if (acnt[k] > acnt[i] || (asize[i] == 0)) {
                  int n   = acnt[i];
                  acnt[i]  = acnt[k];
                  acnt[k]  = n;
                       n   = asize[i];
                  asize[i] = asize[k];
                  asize[k] = n;
               }
         // dump sorted stats
         for (i=0; i<=10; i++) {
            if (acnt[i] > 0) {
               if (!bTold) {
                  printf(" %d files have indent %d", acnt[i], asize[i]);
                  bTold = 1;
               }
               else
               if (asize[i] > 0) {
                  printf(", %d/%d", acnt[i], asize[i]);
                  bTold = 1;
               }
               else
               if (bTold) // list unknowns only if others listed before
                  printf(", %d/unknown", acnt[i]);
            }
         }
      }

      if (bTold)
         printf(".\n");
      else
      if (!cs.indentFilt && !cs.pure)
         printf("\n");

      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   regtest("detab=3 xfile");
   regtest("detab=3 xsrc .cpp .hpp");
   regtest("list xdir .txt +detab=3");

   ifcmd (!strncmp(pszCmd, "detab", 5)) // +wref
   {
      ifhelp(   strncmp(pszCmd, "detab=", 6)
             || (!chain.useany() && (nparm < 1))
            )
      printx("<help>$sfk detab=tabsize dir ext1 [ext2 ...] [-to outmask]\n"
             "\n"
             "   replace tabs by spaces within file(s) or text stream.\n"
             "\n"
             "   $options\n"
             "      -to outmask   do not overwrite original files, but write\n"
             "                    to output files according to outmask, e.g.\n"
             "                    #-to tmp<sla><run>path<sla><run>base.<run>ext<def> or #-to tmp<sla><run>file\n"
             "      -yes          if files are selected, really (re)write them.\n"
             "                    without -yes, detab is only simulated.\n"
             "      -memlimit=n   process files with up to n mbytes (default=300).\n"
             "      -nowarn       do not tell about skipped or unreadable files.\n"
             "\n"
             "   $see also\n"
             "      #sfk scantab<def>   list files containing TAB characters.\n"
             "      #sfk help opt<def>  how to change the memlimit permanently.\n"
             #ifdef _WIN32
             "      #sfk view<def>      a text file viewer that can show all TAB\n"
             "                    characters in blue by pressing CTRL+T.\n"
             #endif
             "\n");
      webref("detab");
      printx("   $examples\n"
             "      #sfk detab=3 sources .cpp .hpp\n"
             "         replace tabs by up to 3 blanks, within all .cpp and .hpp\n"
             "         files of directory tree \"sources\".\n"
             "\n"
             "      #sfk select -dir src -file .java +detab=4 -to tmp<sla><run>file\n"
             "         list all .java files of src, then detab with tabsize 4,\n"
             "         writing all outputs to directory tree \"tmp\".\n"
             "\n"
             "      #sfk detab=4 src .java -relnames -to tmp<sla><run>file\n"
             "         nearly the same, however stripping the \"src\" input directory\n"
             "         name from output file paths (not possible with \"+detab\" form).\n"
             "\n"
             "      #sfk filter mytext.txt +detab=8\n"
             "         detab content of a single file to the console.\n"
            );
      ehelp;

      sfkarg;

      char *pszTabSize = pszCmd+strlen("detab=");
      if (!(cs.tabSize = atol(pszTabSize))) return 9+perr("invalid tab size\n");
 
      cs.scanTabs = 0;
 
      // since 161: process only text files. before that,
      // user had to select text files by file extension.
      cs.textfiles = 1;
 
      // since 161: accept generic options
      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break; // short file parms
      }

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1, &iDirNext))) return lRC;
      if (btest) return 0;

      cs.sim = !cs.yes;

      if (chain.usedata) {
         // detab stream line
         for (int i=0; i<chain.indata->numberOfEntries(); i++) {
            szLineBuf[0]  = '\0';
            szLineBuf2[0] = '\0';
            char *psrc = chain.indata->getEntry(i, __LINE__);
            if (psrc) {
               strcopy(szLineBuf, psrc);
               removeCRLF(szLineBuf);
            }
            detabLine(szLineBuf, szLineBuf2, MAX_LINE_LEN, cs.tabSize);
            if (chain.coldata) {
               chain.addLine(szLineBuf2, str(""));
            } else {
               printf("%s\n", szLineBuf2);
            }
         }
      } else {
         // detab file contents
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         lRC = walkAllTrees(eFunc_Detab, lFiles, lDirs, nBytes);

         const char *sxinfo = cs.sim ? "would be ":"";
         printf("%d files checked, %d %sdetabbed, %d tabs in total.\n",
            cs.files, cs.tabFiles, sxinfo, cs.tabsDone);
 
         if (cs.anyFileTooLarge)
            pinf("use -memlimit=1000 to process larger files.\n");

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");
      }

      if (chain.usedata) {
         STEP_CHAIN(iDirNext, 1); // 1: use new data
      } else {
         STEP_CHAIN(iDirNext, 0); // detab
      }

      bDone = 1;
   }

   ifcmd (strBegins(pszCmd, "del") || strBegins(pszCmd, "rmtree")) // +wref
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk delete dir ext1 [ext2 ...] [-yes]\n"
             "$sfk deltree targetdir [-yes]\n"
             "$sfk del -dir dir1 dir2 -file .ext1\n"
             "\n"
             "   delete files or dirs, even if they're write protected.\n"
             "   deltree or rmtree deletes a directory tree with all contents.\n"
             "\n"
             "   $options\n"
             "      -yes          really delete the files. without option -yes,\n"
             "                    del only lists the files that would be deleted.\n"
             "      -withdirs     if you supply a file mask other than \"<wild>\",\n"
             "      or -wdir      and file deletion leads to an empty directory,\n"
             "                    then the directory is removed as well. if you\n"
             "                    supply no file mask (or \"<wild>\"), then every\n"
             "                    empty directory is always deleted. this option\n"
             "                    cannot be used with chaining, as chaining passes\n"
             "                    only filenames, but no processed directory names.\n"
             #ifdef _WIN32
             "      -hidden       include hidden and system files.\n"
             "                    this option is default when using deltree.\n"
             #endif
             "      -quiet        print nothing\n"
             "      -stat         show statistics even with -quiet\n"
             "      -stoponerr    stop chain execution if delete is incomplete.\n"
             "      -retry=n[:d]  if delete fails, retry up to n times waiting\n"
             "                    d ms inbetween. default with deltree (not del)\n"
             "                    is -retry=2:100\n"
             "\n"
             "   $command return codes\n"
             "      rc 0 : ok all deleted\n"
             "      rc 5 : delete incomplete\n"
             "      rc 9 : sfk rc with -stoponerr\n"
             "\n"
             "   $lazy confirmation on command chaining\n"
             "      if you selected files in a command chain, then want to add +del\n"
             "      you may type \"+del.\" (with a dot) or \"+del!\" (windows only)\n"
             "      instead of \"+del -yes\" to actually delete the files.\n"
             "\n");
      webref("del");
      printx("   $examples\n"
             "      #sfk del -withdirs src .bak\n"
             "         deletes .bak files within src and all subdirs.\n"
             "         if a directory contained only .bak files,\n"
             "         it is deleted as well.\n"
             "\n"
             "      #sfk del -yes -withdirs -hidden tmp\n"
             "         delete tmp with all files, including hidden files.\n"
             "\n"
             "      #sfk deltree. tmp\n"
             "         the same as above, with \".\" as a short for -yes.\n"
             "\n"
             "      #sfk list -dir src -file foo*.hpp +del\n"
             "         first list target files, then add +del\n"
             #ifdef _WIN32
             "\n"
             "      #sfk fromclip +del\n"
             "         take a list of filenames from clipboard and delete them.\n"
             "         see \"sfk help shell\" on how to configure your windows\n"
             "         command prompt, to allow easy copying of filename lists.\n"
             #endif
            );
      ehelp;

      sfkarg;

      bool bdeltree   = 0;
      bool bstoponerr = 0;

      if (strBegins(pszCmd, "deltree")) {
         bdeltree = cs.hidden = cs.withdirs = 1;
         if (   !strcmp(pszCmd, "deltree.")
             || !strcmp(pszCmd, "deltree!")
            )
            cs.yes = 1;
      }

      if (strBegins(pszCmd, "rmtree")) {
         bdeltree = cs.hidden = cs.withdirs = 1;
         if (   !strcmp(pszCmd, "rmtree.")
             || !strcmp(pszCmd, "rmtree!")
            )
            cs.yes = 1;
      }

      int  iretries   = bdeltree ? 2 : 0;
      int  idelay     = 100;

      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-retry", &pszParm)) {
            if (!pszParm) return 9;
            // -retry=10:500
            char *psz=pszParm;
            iretries = atoi(psz);
            while (*psz!=0 && *psz!=':') psz++;
            if (!*psz) continue;
            psz++;
            idelay = atoi(psz);
            continue;
         }
         if (strBegins(pszArg, "-stoponerr"))
            { bstoponerr = 1; continue; }
         if (strBegins(pszArg, "-showrc")) // internal
            { cs.showrc = 1; continue; }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         // process non-option keywords:
         break; // fall through
      }

      // lazy confirmation: accept -del. as -del -yes
      if (!strcmp(pszCmd, "del.") || !strcmp(pszCmd, "del!"))
         cs.yes = 1;

      int iDirNext = 0;
      bool bAnyDirParms = 0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1, &iDirNext, &bAnyDirParms))) return lRC;
      if (btest) return 0;

      // sfk197 plausi checks
      if (chain.useany() && bAnyDirParms) {
         perr("%s got filenames from command chain AND as parameters", pszCmd);
         pinf("say \"+then %s\" instead of \"+%s\" to ignore chain input\n", pszCmd,pszCmd);
         return 9;
      }

      cs.sim = !cs.yes;

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      for (int itry=0; itry<1+iretries; itry++)
      {
         if (itry>0) 
         {
            doSleep(idelay);
            if (cs.quiet<2)
               printf("[retrying delete %d/%d]\n", itry, iretries);
         }

         cs.filesDelFailed = 0;
         cs.dirsDelFailed = 0;

         lRC = walkAllTrees(eFunc_Delete, lFiles, lDirs, nBytes);
         // always returns 0, therefore check dirsDelFailed.

         // sfk193: deltree auto retry
         if (cs.filesDelFailed==0 && cs.dirsDelFailed==0)
            { lRC = 0; break; }

         // sfk193: deltree rc 5 on failure
         lRC = bstoponerr ? 9 : 5; // deltree failure
      }

      info.clear();

      if (cs.showstat()) {
         const char *sxinfo = cs.sim ? "would be ":"";
         if (cs.withdirs)
            printf("%d files, %d dirs %sdeleted. ", cs.filesDeleted, cs.dirsDeleted, sxinfo);
         else
            printf("%d files %sdeleted. ", cs.filesDeleted, sxinfo);
         cchar *pcont = "including ";
         if (cs.filesDeletedWP) {
            printx("<time>including %d readonly files<def>", cs.filesDeletedWP);
            pcont = ", ";
         }
         if (cs.dirsDeletedWP)
            printx("<time>%s%d readonly dirs<def>", pcont,cs.dirsDeletedWP);
         printf("\n");
      }

      if (cs.sim && !cs.nohead) {
         #ifdef _WIN32
         printx("$[say -yes, %s. or %s! to execute.]\n",bdeltree ? "deltree":"del",bdeltree ? "deltree":"del");
         #else
         printx("$[say -yes or %s. to execute.]\n",bdeltree ? "deltree":"del");
         #endif
      }

      if (cs.filesDelFailed || cs.dirsDelFailed)
         pwarn("%s did not complete.\n", pszCmd);

      if (cs.showrc)
         printf("[%s rc %d]\n", pszCmd, lRC);

      STEP_CHAIN(iDirNext, 0); // del

      bDone = 1;
   }

   regtest("entab=3 xfile");
   regtest("list xdir .java +entab=4");

   ifcmd (!strcmp(pszCmd, "entab") || !strncmp(pszCmd, "entab=", 6)) // +wref
   {
      ifhelp (!strcmp(pszCmd, "entab") || (!chain.usefiles && (nparm < 1)))
      printx("<help>$sfk entab=tabsize dir ext1 [ext2 ...]\n"
             "\n"
             "   replace groups of spaces by tabs within file(s).\n"
             "\n"
             "   $options\n"
             "      -to outmask   do not overwrite original files, but write\n"
             "                    to output files according to outmask, e.g.\n"
             "                    #-to tmp<sla><run>path<sla><run>base.<run>ext<def> or #-to tmp<sla><run>file\n"
             "      -yes          if files are selected, really (re)write them.\n"
             "                    without -yes, entab is only simulated.\n"
             "      -memlimit=n   process files with up to n mbytes (default=300).\n"
             "      -nowarn       do not tell about skipped or unreadable files.\n"
             "\n"
             "   $see also\n"
             "      #sfk scantab<def>   list files containing TAB characters.\n"
             "      #sfk help opt<def>  how to change the memlimit permanently.\n"
             #ifdef _WIN32
             "      #sfk view<def>      a text file viewer that can show all TAB\n"
             "                    characters in blue by pressing CTRL+T.\n"
             #endif
             "\n");
      webref("entab");
      printx("   $examples\n"
             "      #sfk entab=3 sources .cpp .hpp\n"
             "         replace 3 spaces each by a TAB character in all .cpp\n"
             "         and .hpp files within folder sources.\n"
             "\n"
             "      #sfk entab=3 singleFileName.txt\n"
             "         the same, but only in a single file.\n"
            );
      ehelp;

      sfkarg;

      if (chain.usedata)
         return 9+perr("entab does not support chain text input.");

      char *pszTabSize = pszCmd+strlen("entab=");
      if (!(cs.tabSize = atol(pszTabSize))) return 9+perr("invalid tab size\n");
      cs.scanTabs = 0;

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1, &iDirNext))) return lRC;
      if (btest) return 0;

      cs.sim = !cs.yes;

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      lRC = walkAllTrees(eFunc_Entab, lFiles, lDirs, nBytes);

      const char *sxinfo = cs.sim ? "would be ":"";
      printf("%d files checked, %d %sentabbed, %d tabs in total.\n",
         cs.files, cs.tabFiles, sxinfo, cs.tabsDone);

      if (cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      STEP_CHAIN(iDirNext, 0); // entab
      bDone = 1;
   }

   regtest("addcr xfile");
   regtest("lf-to-crlf xsrc .cpp .hpp");
   regtest("list xdir .txt +addcr");
   regtest("list -dir xdir1 xdir2 -file .cpp .hpp +lf-to-crlf");

   bool baddcr  = 0;
   bool blistle = 0;

   ifcmd (   !strcmp(pszCmd, "lf-to-crlf") // +wref
          || !strcmp(pszCmd, "addcr")
          || !strcmp(pszCmd, "addcrlf")
          || !strcmp(pszCmd, "listle")     // sfk185
         )
   {
      blistle = strBegins(pszCmd, "listle");
      baddcr  = blistle ? 0 : 1;

      ifhelp (!chain.usefiles && (nparm < 1))
      if (bhelp || baddcr) {
      printx("<help>$sfk lf-to-crlf [options] dir .ext1 .ext2 [-to outmask]\n"
             "\n"
             "   convert just-lf (unix) text format to cr+lf (dos/windows).\n"
             "\n"
             "   if only a single filename, or list of filenames, is given\n"
             "   then these are converted immediately.\n"
             "\n"
             "   if a directory parameter is given then the command runs\n"
             "   in simulation mode, requiring option -yes to convert.\n"
             "\n"
             "   $options\n"
             "      -forceend    if a file is changed and rewritten then\n"
             "                   also add a line ending at the last line\n"
             "                   even if there was none in the input file.\n"
             "      -writeall    rewrite all files no matter if changed\n"
             "\n"
             "   $aliases\n"
             "      #sfk addcr<def>    same as sfk lf-to-crlf\n"
             "\n"
             "   $see also\n"
             "      #sfk remcr<def>    convert crlf to just lf\n"
             "      #sfk listle<def>   list line end infos for files\n"
             "\n");
      webref("addcrlf");
      printx("   $examples\n"
             "      #sfk addcr . .csv\n"
             "         add crlf on all .csv files in current folder.\n"
             "\n"
             "      #sfk addcr src .cpp .hpp\n"
             "         add crlf on all .cpp and .hpp files within src.\n"
             "\n"
             "      #sfk select -dir doc -file .txt +addcr -to tmp<sla><run>file\n"
             "         add crlf on all .txt files within doc, saving to tmp.\n"
             "\n"
            );
      }
      if (bhelp || blistle) {
      printx("<help>$sfk listle dir [.ext1 .ext2]\n"
             "\n"
             "   list line end infos for all text files of a folder\n"
             "   and also show unterminated text files.\n"
             "\n"
             "   for each ASCII text file found this shows:\n"
             "\n"
             "      crlf : contains at least one CR/LF line end\n"
             "             (windows line end format)\n"
             "\n"
             "      lf   : contains at least one pure LF line end\n"
             "             (linux line end format)\n"
             "\n"
             "      ut   : is unterminated, i.e. last line of file\n"
             "             is not followed by CR or LF. to fix\n"
             "             such files you may use addcr or remcr\n"
             "             with option -forceend.\n"
             "\n"
             "      cr   : contains at least one pure CR line end\n"
             "             (old macintosh line end format)\n"
             "\n");
      printx("   $see also\n"
             "      #sfk addcr<def>  convert lf to crlf line endings\n"
             "      #sfk remcr<def>  convert crlf to lf line endings\n"
             "\n"
             );
      webref("listle");
      printx("   $examples\n"
             "      #sfk listle mydir\n"
             "         shows infos for all text files in mydir.\n"
             "\n"
            );
      }
      ehelp;

      sfkarg;

      int iDirNext = 0;
      bool bshowle = 0;
 
      nGlblConvTarget = eConvFormat_CRLF;

      if (!strcmp(pszCmd, "listle")) {
         nGlblConvTarget = eConvFormat_ShowLE;
         mclear(aGlblConvStat);
         bshowle = 1;
      }

      // SFK 1.7.2: only text files
      cs.textfiles = 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (strBegins(pszArg, "-forceend")) {
            cs.forcele = 1;
            continue;
         }
         else
         if (strBegins(pszArg, "-writeall")) {
            cs.writeall = 1;
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break;
      }

      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1, &iDirNext))) return lRC;
      if (btest) return 0;

      if (!bshowle && (!cs.sim || cs.yes))
      {
         // list of filenames: execute immediately
         if (glblSFLNumberOfEntries() > 0)
            cs.yes = 1;
 
         cs.sim = !cs.yes;
      }

      if (!bshowle && cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      lRC = walkAllTrees(eFunc_FormConv, lFiles, lDirs, nBytes);

      if (!bshowle && cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      if (bshowle) {
         printx("$%d files with CR/LF, %d with LF, %d unterminated, %d with CR.<def>\n",
            aGlblConvStat[0],aGlblConvStat[1],aGlblConvStat[2],aGlblConvStat[3]);
      } else {
         printf("%d files %sconverted.\n", cs.files, cs.sim ? "would be ":"");
      }

      STEP_CHAIN(iDirNext, 0); // addcr
      bDone = 1;
   }

   regtest("remcr xfile");
   regtest("crlf-to-lf xsrc .cpp .hpp");
   regtest("list xdir .txt +remcr");
   regtest("list -dir xdir1 xdir2 -file .cpp .hpp +crlf-to-lf");

   ifcmd (   !strcmp(pszCmd, "crlf-to-lf") // +wref
          || !strcmp(pszCmd, "remcr")
          || !strcmp(pszCmd, "remcrlf")
         )
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk crlf-to-lf [options] dir .ext1 .ext2 [-to outmask]\n"
             "\n"
             "   convert cr+lf (dos/windows) text format to just-lf (unix).\n"
             "\n"
             "   if only a single filename, or list of filenames, is given\n"
             "   then these are converted immediately.\n"
             "\n"
             "   if a directory parameter is given then the command runs\n"
             "   in simulation mode, requiring option -yes to convert.\n"
             "\n"
             "   $options\n"
             "      -forceend    if a file is changed and rewritten then\n"
             "                   also add a line ending at the last line\n"
             "                   even if there was none in the input file.\n"
             "      -writeall    rewrite all files no matter if changed\n"
             "\n"
             "   $aliases\n"
             "      #sfk remcr<def>    same as sfk crlf-to-lf\n"
             "\n"
             "   $see also\n"
             "      #sfk addcr<def>    convert lf to crlf\n"
             "      #sfk listle<def>   list line end infos for files\n"
             "\n");
      webref("remcrlf");
      printx("   $examples\n"
             "      #sfk remcr src .cpp .hpp\n"
             "         reduce crlf to lf on all .cpp and .hpp files within src.\n"
             "\n"
             "      #sfk select -dir doc -file .txt +remcr -to tmp<sla><run>file\n"
             "         change crlf on all .txt files within doc, saving to tmp.\n"
            );
      ehelp;

      sfkarg;

      int iDirNext = 0;

      nGlblConvTarget = eConvFormat_LF;

      // SFK 1.7.2: only text files
      cs.textfiles = 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (strBegins(pszArg, "-forceend")) {
            cs.forcele = 1;
            continue;
         }
         else
         if (strBegins(pszArg, "-writeall")) {
            cs.writeall = 1;
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break;
      }

      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1, &iDirNext))) return lRC;
      if (btest) return 0;

      if (!cs.sim || cs.yes)
      {
         // list of filenames: execute immediately
         if (glblSFLNumberOfEntries() > 0)
            cs.yes = 1;
 
         cs.sim = !cs.yes;
      }

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      lRC = walkAllTrees(eFunc_FormConv, lFiles, lDirs, nBytes);

      if (cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      printf("%d files %sconverted.\n", cs.files, cs.sim ? "would be ":"");

      STEP_CHAIN(iDirNext, 0); // remcr
      bDone = 1;
   }

   regtest("stat -minsize=10 .");
   regtest("stat -quiet -i");

   ifcmd (   strcmp(pszCmd, "stat")==0       // stat, not status
          || (strBegins(pszCmd, "stat") != 0 // stat10 etc.
              && isdigit(pszCmd[4]) != 0)
          || strBegins(pszCmd, "treesize"))  // +wref
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk treesize [-minsize=n] dir [-i]\n"
             "$sfk stat [mb] dir\n"
             "\n"
             "   show directory tree size statistics in mbytes.\n"
             #ifdef _WIN32
             "   hidden and system files are included by default,\n"
             "   to make sure the real size usage is always shown.\n"
             #endif
             "\n"
             "   $options\n"
             "      -minsize=n   list only dirs and files with a size larger\n"
             "                   or equal to this, e.g. 100 = 100 bytes,\n"
             "                   10k = 10 kbytes, 10m = 10 megabytes.\n"
             "      -i           read list of directories from stdin.\n"
             #ifdef _WIN32
             "      -nohidden    exclude hidden and system files.\n"
             #endif
             "      -nosum       print no summary at end of listing.\n"
             "      -sum         print only the summary.\n"
             "      -gb[ytes]    list all sizes in gigabytes.\n"
             "      -kb[ytes]    list all sizes in kilobytes.\n"
             "      -bytes       list all sizes in bytes.\n"
             "      -flat        show the no. of files and bytes per folder\n"
             "                   without its subfolders (do not accumulate).\n"
             "      -flist x     read a list of filenames from file x\n"
             "\n"
             "   $aliases\n"
             "      #sfk stat10<def>       does the same as #sfk stat -minsize=10m<def>\n"
             "      #sfk treesize100<def>  does the same as #sfk stat -minsize=100m<def>\n"
             #ifdef VFILEBASE
             "\n"
             "   $limitations\n"
             "      this command cannot summarize zip file contents.\n"
             #endif // VFILEBASE
             "\n");
      webref("stat");
      printx("   $examples\n"
             "      #sfk stat . -minsize=10m\n"
             "          list sizes of all directories below the current one\n"
             "          having a size of at least 10 mbytes.\n"
             "\n"
             "      #sfk stat50 docs\n"
             "          list all directories and single files under the docs\n"
             "          directory tree having a size of >= 50 mbytes.\n"
             "\n"
             "      #type dirlist.txt | sfk stat -quiet -i\n"
             "          list sizes of dirs listed in dirlist.txt\n"
             );
      ehelp;

      sfkarg;

      nGlblListMode = 1;
      cs.withdirs   = 1; // always, esp. on receive of dirs by chain
      bool bSummary = 1;
      cs.hidden     = 1; // INCLUDE HIDDEN FILES BY DEFAULT (windows)

      // command aliases: "stat10" == "stat -minsize=10"
      char *pqsize = pszCmd + 4;
      if (strBegins(pszCmd, "treesize"))
            pqsize = pszCmd + 8;
      if (*pqsize) {
         if (!isdigit(*pqsize)) return 9+perr("supply a number after stat, like stat10.\n");
         nGlblListMinSize = atol(pqsize) * 1000000;
      }

      int iChainNext = 0;
      for (; iDir < argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-minsize", &pszParm)) {
            if (!pszParm) return 9;
            nGlblListMinSize = numFromSizeStr(pszParm, "-minsize");
            if (nGlblListMinSize < 0) return 9;
            continue;
         }
         if (strBegins(argx[iDir], "-kb")) {
            cs.listunit = 'k';
            continue;
         }
         if (strBegins(argx[iDir], "-byte")) {
            cs.listunit = 'b';
            continue;
         }
         if (strBegins(argv[iDir], "-gb")) {
            cs.listunit = 'g'; 
            continue;
         }
         if (!strcmp(argx[iDir], "-flat")) {
            cs.flatdirstat = 1;
            continue;
         }
         if (!strncmp(argx[iDir], "-nosum", 6)) {
            bSummary = 0;
            continue;
         }
         if (strBegins(argx[iDir], "-sum")) {
            cs.statonlysum = 1;
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break; // short file set expected
      }

      int nAutoComp = (bGlblStdInAny || chain.usefiles) ? 3 : 1;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, nAutoComp, &iChainNext)))
         return lRC;
      if (btest) return 0;

      // on which level should directory size summaries be highlighted?
      if (glblFileSet.numberOfRootDirs() < 2)
         cs.stathilitelevel = 1; // on 0 (rootdir) and 1 (first below)
      // else >= 2 roots exist, highlight only on that level

      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);

      if (cs.flatdirstat) {
         lFiles = cs.flatfilecnt;
         lDirs  = cs.flatdircnt;
         nBytes = cs.flatbytecnt;
      }

      int lMBytes = (int)(nBytes / 1000000);

      szLineBuf[0] = '\0';
      szAttrBuf[0] = '\0';

      if (!cs.quiet && bSummary) {
         // chained mode: no dir stats, just add filesizes.
         switch (cs.listunit) {
            case 'b':
               addColorText('h', "%s, %5d files, %d dirs, %s bytes.\n", numtoa_blank(nBytes, 12), lFiles, lDirs, numtoa(nBytes));
               break;
            case 'k':
               addColorText('h', "%s kb, %5d files, %d dirs, %s bytes.\n", numtoa_blank(nBytes/1000, 10), lFiles, lDirs, numtoa(nBytes));
               break;
            case 'g':
               addColorText('h', "%s gb, %5d files, %d dirs, %s bytes.\n", numtoa_blank(nBytes/1000000000, 10), lFiles, lDirs, numtoa(nBytes));
               break;
            default :
               addColorText('h', "%5d mb, %5d files, %d dirs, %s bytes.\n", lMBytes, lFiles, lDirs, numtoa(nBytes));
               break;
         }
         if (cs.noFiles)
            addColorText(' ', "%u non-regular files skipped.\n", cs.noFiles);
      }

      // chaining: collected text lines
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   regtest("find -norec -text -lnum -nocol xdir xpat1 xpat2");
   regtest("grep -c -names -quiet -pat xpat1 -dir xdir1 xdir2 -file .dat");
   regtest("list xdir +find mypat");
   regtest("list xdir +find -pat mypat");

   bool bIsFTex = 0;
   bool bIsFBin = 0;

   ifcmd (   !strcmp(pszCmd, "find") || !strcmp(pszCmd, "grep") // +wref
          || !strcmp(pszCmd, "findbin")
          || !strcmp(pszCmd, "ftext") // deprecated
         )
   {
      bIsFBin = strcmp(pszCmd, "findbin") ? 0 : 1;
      bIsFTex = bIsFBin ? 0 : 1;

      ifhelp (nparm < 1)
      if (bIsFBin)
      printx("<help>$sfk find [opts] singledir word [word2] [word3] ... [-names]\n"
             "\n"
             "   case-insensitive text search for text and binary files.\n"
             "   sfk find tries to autodetect if a file is text or binary,\n"
             "   adapting the output text formatting.\n"
             );
      else
      printx("<help>$sfk find [opts] singledir word [word2] [word3] ... [-names]\n"
             "\n"
             "   search text in text files. if multiple words are given\n"
             "   then only areas containing all words are listed.\n"
             "\n"
             "   this is a basic command to search only static words.\n"
             "   type sfk xfind to use wildcards and expressions.\n"
             "\n"
             );
      printx("   $options\n");
      arcinf(7); // find
      printx("      -case      search case sensitive. default is case insensitive.\n"
             "                 for details type: sfk help nocase\n"
             "      -bin       do not autodetect file content, process all as binary.\n"
             "                 can also be used for floating text files (one linefeed per\n"
             "                 paragraph, not per line). may produce unwanted line breaks\n"
             "                 with short-lined text.\n"
             "      -len=n     increase the line length for text extracted from binary\n"
             "                 to find longer strings. maximum is 600 approx.\n"
             "      -wide      same as -len=300\n"
         //  "      -nojoin    do not auto join records extracted from binary\n"
         //  "                 if result hits are spread across them\n"
             "      -delim=.,; set delimiters to enable soft word wrapping.\n"
             "                 default is to soft wrap only on white space.\n"
         //  "      -noind     with binary data: no not indentate output text.\n"
         //  "      -rtrim[=n] trim results after right side hit, and optionally\n"
         //  "                 keep n characters after that.\n"
             #ifdef _WIN32
             "      -hidden    include hidden and system files.\n"
             #endif
             "      -c         case-sensitive search (not default).\n"
             "      -lnum      list line numbers of hits.\n"
             "      -nocol     disable color highlighting of output (sfk help colors).\n"
             "      -names     list only names of files containing at least one hit.\n"
             "      -notnames  list only names of files not containing any hit.\n"
             "      -count     list no. of matching lines per file. implies -names.\n"
             "                 requires -text option, cannot be used with binary files.\n"
             "      -quiet     do not show \"scan\" progress info.\n"
             "      -pure      do not list filenames, list only text hits without indent.\n"
             "                 default when specifying a single file as first parameter.\n"
             "      -verbose   tells in detail what find is actually searching for.\n"
             #ifdef _WIN32
             "      -nocconv   disable umlaut and accent character conversions during\n"
             "                 output to console. \"sfk help opt\" for details.\n"
             #endif
             "      -firsthit  show only first matching result per file.\n"
             "      -justrc    print nothing to terminal, just set return code.\n"
             "      -head=n    read only first n text lines from files.\n"
             );
      printx("\n"
             "   $search limitations within binary data\n"
             "      by default, only lines up to 80 characters are extracted\n"
             "      from binary data, so strings longer than this may not be found.\n"
             "      this can be changed by option -len=n or -wide.\n"
             );
      printx("\n"
             "   $pattern support\n"
             "      no wildcards or slash patterns are supported, with one exception:\n"
             "      if you need to find patterns starting with \"-\" or \"+\", prefix\n"
             "      them with backslash \\ to avoid misinterpretation as options.\n"
             "\n"
             "   $return codes for batch files\n"
             "      0 = no matches, 1 = matches found, >1 = major error occurred.\n"
             "      see also \"sfk help opt\" on how to influence error processing.\n"
             "\n");
      if (!bIsFBin)
      printx("   $aliases\n"
             "      #sfk findbin<def>  same as sfk find but reads also binary files.\n"
             "\n");
      printSearchReplaceCommands();
      webref("find");
      printx("   $examples\n"
             "      #sfk find . foo bar include\n"
             "         search text files in current dir for the words foo+bar+include.\n"
             "         note that the short form syntax supports one directory name,\n"
             "         and any number of text patterns, but no file name patterns.\n"
             "\n"
             "      #sfk find -pat text1 text2 -dir src1 src2 -file .cpp .hpp\n"
             "         searches within the specified directories and file masks.\n"
             "\n");
      if (bIsFBin)
      printx("      #sfk findbin -wide -pat http:// .html -dir mydir -file .dat\n"
             "       #+filter -rep \"_*http://_http://_\" -rep \"_.html*_.html_\"\n"
             "         find all http://*.hml references in binary .dat files,\n"
             "         using -wide to find links beyond 80 characters,\n"
             "         then reduce the output to just the link text.\n"
             "\n");
      printx("      #sfk list src +find -verbose \\-pat \\\\-foo \\+list\n"
             "         find lines containing words \"-pat\", \"\\-foo\" and \"+list\"\n"
             "         in all files of directory src, with verbose search infos.\n"
             #ifdef _WIN32
             "\n"
             "      #sfk find testfiles class +view\n"
             "         search \"class\" within \"testfiles\", and show results\n"
             "         interactively in Depeche View (\"sfk view\" for details).\n"
             #endif
             );
      ehelp;

      sfkarg;

      CommandScope oscope("find");

      bGlblAllowGeneralPure  = 1;
      bGlblBinGrep           = 0; // sfk194 find
      bGlblBinGrepAutoDetect = 0; // sfk194 find

      cs.shortsyntax    = 0;
      cs.binallchars    = 1;  // sfk190

      bool bGotFileDir  = 0;
      bool bcolpat      = 0;  // collecting patterns
      bool bcolpat2     = 0;  // dummy

      // alias presets
      if (!strcmp(pszCmd, "findbin")) {
         bGlblBinGrep = 1;
         bGlblBinGrepAutoDetect = 1;
      }

      #ifdef VFILEBASE
      cs.precachezip = 1;
      #endif // VFILEBASE

      // only enable colorful scan status if console is available
      if (!bGlblConsColumnsSet)
         cs.quiet = true;

      // since 1703: always join extracted records from binary
      cs.joinlines = 1;
      // and set binary wrap as twice of console width, by default 160.
      cs.wrapbincol = autoCalcWrapColumns() * 2;

      int iDirNext=0;

      for (; iDir < argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (!bcolpat2 && haveParmOption(argx, argc, iDir, "-delim", &pszParm)) {
            if (!pszParm) return 9;
            cs.delim = pszParm;
            continue;
         }
         if (    !bcolpat2
             && (   haveParmOption(argx, argc, iDir, "-len", &pszParm)
                 || haveParmOption(argx, argc, iDir, "-length", &pszParm)
                )
            )
         {
            if (!pszParm) return 9;
            int iWrap = atoi(pszParm);
            if (iWrap < 40) return 9+perr("specify 80 or higher for -len");
            cs.wrapbincol = iWrap * 2;
            continue;
         }
         if (!bcolpat2 && strBegins(pszArg, "-rtrim=")) {
            cs.rtrim = atoi(pszArg+7)+1;
            continue;
         }
         if (!bcolpat2 && !strcmp(pszArg, "-rtrim")) {
            cs.rtrim = 1;
            continue;
         }
         if (!bcolpat2 && !strcmp(pszArg, "-wide")) {
            cs.wrapbincol = 300 * 2;
            continue;
         }
         if (!bcolpat2 && !strcmp(pszArg, "-text")) {
            bGlblBinGrep = 0;
            bGlblBinGrepAutoDetect = 0;
            continue;
         }
         if (!bcolpat2 && !strncmp(pszArg, "-bin", 4)) {
            bGlblBinGrep = 1;
            bGlblBinGrepAutoDetect = 0;
            continue;
         }
         if (!bcolpat2 && !strcmp(pszArg, "-lnum"))
            { bGlblGrepLineNum = 1; continue; }
         if (!bcolpat2 && !strcmp(pszArg, "-nojoin"))
            { cs.joinlines = 0; continue; }
         if (!bcolpat2 && !strcmp(pszArg, "-c"))
            { cs.usecase = 1; continue; } 
         if (!bcolpat2 && !strcmp(pszArg, "-count")) {
            if (bGlblBinGrep || bGlblBinGrepAutoDetect) {
               perr("-count cannot be used only with text file search");
               pinf("say -text -count instead of -count\n");
               return 9;
            }
            cs.useJustNames    = 1;
            cs.countMatchLines = 1;
            continue;
         }
         if (!bcolpat2 && !strcmp(pszArg, "-to")) {
            perr("-to is not supported with find.");
            return 9;
         }
         if (!bcolpat2 && !strcmp(pszArg, "-tofile")) {
            perr("-tofile is not supported with find.");
            #if defined(SFKXDXE)
            pinf("you may use +tofile or try xfind.\n");
            #else
            pinf("you may use +tofile instead.\n");
            #endif
            return 9;
         }
         if (!bcolpat2 && strBegins(pszArg, "-head=")) { // ftext
            cs.maxlines = atoi(pszArg+strlen("-head="));
            continue;
         }
         if (!bcolpat2 && setGeneralOption(argx, argc, iDir))
            continue;
         if (!bcolpat2 && sfkisopt(pszArg))
            break; // process int -dir form
         if (!bcolpat && !chain.usefiles && !bGotFileDir) {
            // single dir or file specified.
            bGotFileDir = 1;
            Coi ocoi(pszArg, 0);
            if (ocoi.isTravelDir()) {
                if ((lRC = setProcessSingleDir(pszArg)))
                   return lRC;
            } else {
                // if (!fileExists(pszArg))
                //    return 9+perr("no such file or dir: %s\n", pszArg);
                glblSFL.addEntry(ocoi); // is copied
                cs.pure = 1;
            }
            cs.shortsyntax = 1;
            bcolpat = 1;
            // is -pat following immediately?
            if ((iDir < argc-1) && !strcmp(argx[iDir+1], "-pat")) // find
               iDir++; // then skip this
            continue;
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iDirNext))
            break; // fall thru, let pdp set iDirNext
         // search pattern specified.
         bcolpat = 1;
         char *psz = pszArg;
         if (psz[0] == '+') {
            perr("unknown chain command: %s\n", psz);
            pinf("to search for this word, say \\%s\n", psz);
            return 9;
         }
         if (!strncmp(psz, "\\\\", 2) || !strncmp(psz, "\\+", 2) || !strncmp(psz, "\\-", 2))
            psz++;
         glblGrepPat.addString(psz);
         // see also: processDirParms, which may also add to glblGrepPat.
      }
 
      if (cs.justrc) {
         cs.nonames = 1;
      }

      if (iDir < argc) {
         if (!bGotFileDir && !iDirNext)
            if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext))) // find
               return lRC;
      } else {
         if (!chain.usefiles && !bGotFileDir)
            return 9+perr("please specify a directory or file name.\n");
      }

      if (cs.verbose) {
         printf("[searching lines with");
         int nGrepPat = glblGrepPat.numberOfEntries();
         for (int i=0; i<nGrepPat; i++) {
            char *pszPat = glblGrepPat.getString(i);
            if (i==0)
               printf(" \"%s\"", pszPat);
            else
               printf(" AND \"%s\"", pszPat);
         }
         printf("]\n");
      }
      if (!glblGrepPat.numberOfEntries())
         return 9+perr("no search patterns specified.\n");
      if (btest) return 0;

      if (chain.colany())
         cs.quiet = 1;

      lRC = walkAllTrees(eFunc_Find, lFiles, lDirs, nBytes);
      if (!lRC && cs.anymatches) lRC = 1; // found a match
      info.clear(); // in case nothing was found

      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "home"))
   {
      ifhelp (nparm >= 1 && isHelpOpt(argv[iDir]))
      printx("<help>$sfk home\n"
             "\n"
             "   tells the location of the SFK Home folder\n"
             "   for configuration and data storage, currently:\n"
             "\n"
             "      %s\n"
             "\n"
             "   it is used primarily with sfk gindex and sfk name2.\n"
             "\n"
             "   SFK Home can be set manually by:\n"
             "\n"
             "      #<exp> SFK_HOME=<def>absolutefoldername\n"
             "\n", sfkhome.szClDir
             );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         return 9+pbad(pszCmd,pszArg);
      }

      chain.print("%s\n", sfkhome.szClDir);

      STEP_CHAIN(iChainNext, 1); // sfk1933 home chaining

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "bin-to-src")) // +wref
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk bin-to-src [...] infile outfile namePrefix\n"
             "\n"
             "   create sourcefile containing a binary data block. the outfile\n"
             "   will contain variable definitions beginning with namePrefix.\n"
             "\n"
             "   $options\n"
             "      -java       create java source code output, default is C.\n"
             "      -class      java: create a fully compilable class with a short\n"
             "                  demo source code how to write the data to a file.\n"
             "      -pack       C source: compress data with a simple RLE scheme.\n"
             "      -hex        C source: produce hex numbers instead of decimal.\n"
             "      -append     do not overwrite output, but append to it.\n"
             "      -recsize=n  java: define number of bytes per record used\n"
             "                  within the raw data. default is 500. higher values\n"
             "                  produce less records, which may help if you get\n"
             "                  a \"code too large\" error during java compile.\n"
             "\n");
      #ifdef _WIN32
      printx("   $further commands\n"
             "      #sfk clipsrc<def>   convert clipboard text to C    style source code\n"
             "      #sfk clipphp<def>   convert clipboard text to PHP  style source code\n"
             "      #sfk clipjava<def>  convert clipboard text to Java style source code\n"
          // "      #sfk clipxml<def>   convert clipboard text to XML  style source code\n"
             "      ... add #+toclip<def> to copy converted result back to clipboard.\n"
             "\n");
      #endif
      webref("bintosrc");
      printx("   $examples\n"
             "      #sfk bin-to-src myimg.dat imgsrc.cpp img01\n"
             "         create C source code containing content from myimg.dat.\n"
             "\n"
             "      #sfk bin-to-src -java -class myimg.dat imgdata.java imgdata\n"
             "         create a Java class \"imgdata\" with myimg.dat content.\n"
            );
      ehelp;

      sfkarg;

      bool bPack  = 0;
      bool bHex   = 0;
      bool bJava  = 0;
      bool bClass = 0;
      bool bAppend= 0;
      int nrecsize = 500;
      char *pszInFile  = 0;
      char *pszOutFile = 0;
      char *pszPrefix  = 0;

      int iChainNext = 0;
      for (; iDir < argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-recsize", &pszParm)) {
            if (!pszParm) return 9;
            nrecsize = atol(pszParm);
            continue;
         }
         if (!strcmp(argx[iDir], "-pack"))
            { bPack = 1; continue; }
         if (!strcmp(argx[iDir], "-hex"))
            { bHex  = 1; continue; }
         if (!strcmp(argx[iDir], "-java"))
            { bJava = 1; continue; }
         if (!strcmp(argx[iDir], "-class"))
            { bClass = 1; continue; }
         if (!strcmp(argx[iDir], "-append"))
            { bAppend = 1; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!pszInFile)
            { pszInFile=pszArg; continue; }
         if (!pszOutFile)
            { pszOutFile=pszArg; continue; }
         if (!pszPrefix)
            { pszPrefix=pszArg; continue; }
         return 9+perr("unexpected: %s",pszArg);
      }
      if (!pszInFile || !pszOutFile || !pszPrefix)
         return 9+perr("missing parameters");

      num   nFileSize = 0;
      uchar *pInFile = loadBinaryFile(pszInFile, nFileSize);
      if (!pInFile) return 9+perr("cannot read %s\n", pszInFile);

      fGlblOut = fopen(pszOutFile, bAppend ? "a":"w");
      if (!fGlblOut) {
         perr("cannot write %s\n", pszOutFile);
         delete [] pInFile;
         return 9;
      }

      if (bJava)
         lRC = execBinToJava(pInFile, (int)nFileSize, bPack, pszPrefix, bClass, nrecsize);
      else
         lRC = execBinToCpp(pInFile, (int)nFileSize, bPack, pszPrefix, bHex);

      fclose(fGlblOut);
      delete [] pInFile;

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   regtest("filter -no-empty-lines -count -lnum -case ++mypat");
   regtest("filter -no-blank-lines");
   regtest("filter -cnt -c -+mypat2 -+mypat3 -rep _foo_bar_");
   #ifdef _WIN32
   regtest("filter -+foo -+!bar -ls+start -le+end -ls!nstart -le!nend");
   regtest("filter -sep \" \" -form $40col1_$-50col2 -join");
   regtest("filter -sep ; -form $col3_$col5 -wrap");
   regtest("filter x.txt -blocksep _ -form $col1 -wrap=80");
   #else
   regtest("filter -+foo -+:bar -ls+start -le+end -ls:nstart -le:nend");
   regtest("filter -sep \" \" -form \"#40col1_#-50col2\" -join");
   regtest("filter -sep ; -form \"#col3_#col5\" -wrap");
   regtest("filter x.txt -blocksep _ -form #col1 -wrap=80");
   #endif

   int  iIsOFilt = 0;

   ifcmd (   !strncmp(pszCmd, "filt", 4) || !strncmp(pszCmd, "ffilt", 5) // +wref
          || !strncmp(pszCmd, "filefilt", 8)
          || !strncmp(pszCmd, "wfilt", 5)
          || (bGlblOffice && strBegins(pszCmd, "ofilt"))
         )
   {
      bool wfilt = strncmp(pszCmd, "wfilt", 5) ? 0 : 1;

      #ifdef SFKOFFICE
      if (strBegins(pszCmd, "ofilt"))
         iIsOFilt = 1;
      #endif // SFKOFFICE

      ifhelp (!chain.usedata && !chain.usefiles && (nparm < 1))
      printHelpText("filter", bhelp, wfilt | (iIsOFilt<<1));
      ehelp;

      // skip #(10.10col1) in var args
      cs.relaxedvar = 1;

      sfkarg;

      CommandScope ocmd("filter");

      bool bfilefilt = 0;
      if (strbeg(pszCmd,"ffilt")) bfilefilt=1;
      if (strbeg(pszCmd,"filefilt")) bfilefilt=1;

      #ifdef SFKOFFICE
      if (iIsOFilt == 1) {
         // ffilt of .docx content
         cs.office    = 1;
         cs.textfiles = 1;
         cs.hidezipcomment = 1; // ofilter
         bfilefilt    = 1;
      }
      #endif // SFKOFFICE

      memset(&gfilter, 0, sizeof(gfilter));

      gfilter.argv    = argx;
      gfilter.iPat    = iDir;
      gfilter.nPat    = argc - iDir; // MAX estimation, must be reduced on chaining
      gfilter.bDumpLF = 1;
      gfilter.bSkipBinaries = 1; // always, this is a text-only filter.
      gfilter.bFilenames = 1;
      gfilter.cprecolor  = ' ';
      gfilter.cpostcolor = ' ';

      #ifdef VFILEBASE
      cs.precachezip = 1;
      cs.execweb = 1; // filter
      #endif // VFILEBASE

      char *pszInPath = 0;
      char  szURLBuf[SFK_MAX_PATH+10];

      // if we're a chain receiver
      bool bOldUseFiles = chain.usefiles;
      bool bWalkDirs    = chain.colfiles | chain.usefiles;
      if (chain.usedata)
         cs.quiet = 1; // no filename listings

      // set options, check syntax
      int iDirNew   = 0;
      int iChainNew = 0;
      if (setFilterParms(
         argx, argc, gfilter.iPat, gfilter.nPat,
         gfilter,
         &pszInPath, &iDirNew, &iChainNew
         ))
         return 9;

      // wfilter: auto extend .100 to http://.100
      if (strBegins(pszCmd, "wfilt")) {
         if (pszInPath && !isHttpURL(pszInPath)) {
            snprintf(szURLBuf, sizeof(szURLBuf)-10, "http://%s", pszInPath);
            pszInPath = szURLBuf;
         }
      }

      // if -test mode, init test stats
      if (cs.test)
         mclear(ftest);

      // logical autocomplete of options:
      // saying -lnum or -count AND -write always means to write ALL files.
      if ((gfilter.bLNum || gfilter.bCnt) && gfilter.bReWrite)
         cs.writeall = 1;

      // plausbility
      if (gfilter.bReWrite && cs.justrc)
         return 9+perr("-justrc and -write cannot be combined.");

      bool bsid = 0;
      if (pszInPath) {
         // single input file or directory specified?
         bWalkDirs = 1;
         Coi ocoi(pszInPath, 0);
         if (iIsOFilt && ocoi.isZipSubEntry()) { // sfk194
            perr("ofilter cannot be used with nested archive contents.");
            return 9;
         }
         if ((bsid = ocoi.isTravelDir()))
         {
            setProcessSingleDir(pszInPath);
            // gfilter.bSkipBinaries = 1;
         } else {
            if (!cs.usesnap)
               gfilter.bSingleFile = 1;
            glblSFL.addEntry(ocoi); // is COPIED.
         }
      }

      int nInputs = 0;
      if (pszInPath)    nInputs++;
      if (iDirNew > 0)  nInputs++;
      if (bOldUseFiles) nInputs++;

      if (nInputs > 1) {
         perr("filter cannot process input files from multiple sources.\n");
         int nsrc = 1;
         setTextColor(nGlblWarnColor);
         if (bOldUseFiles) {
            printf("info : source %d are filenames from previous command.\n", nsrc++);
            printf("tip  : try to select all files within the previous command.\n");
         }
         if (pszInPath)   printf("info : source %d is input %s \"%s\"\n", nsrc++, bsid?"directory":"file", pszInPath);
         if (iDirNew > 0) printf("info : source %d is directory or file parameter \"%s\"\n", nsrc++, argx[iDirNew]);
         setTextColor(-1);
         return 9;
      }

      // if any dir parms found
      if (iDirNew)
      {
         iDir = iDirNew;
         // gfilter.bSkipBinaries = 1;
         if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3+8, &iChainNew))) // filter
            return lRC;
         // sfk1933 detect wrong ffilter parm sequence
         if (bfilefilt==1 && iChainNew>iDirNew && iChainNew<argc
             && argx[iChainNew][0]=='-') 
         {
            pwarn("%s must be given before -dir ... -file ...\n",argx[iChainNew]);
            pinf("better use: sfk select ... +ffilter\n");
         }
         bWalkDirs = 1;
      }
 
      // snapfile parse does not allow rewrite
      if (cs.usesnap && gfilter.bReWrite)
         return 9+perr("options -snap and -rewrite not allowed together.");

      if (btest) return 0;

      // if collecting filenames for another chained command
      if (chain.colfiles) {
         cs.quiet = 1;
         char *pszChainCmd = iChainNew ? argx[iChainNew] : (char*)"";
         if (!gfilter.bSingleFile // sfk1934 don't send single input name
             && !strcmp(pszChainCmd, "+copy")) 
         {
            // copy follows: insist on true input filenames
            gfilter.bPassHitFiles = 1;
         }
      }

      if (bWalkDirs)
      {
         // used in most cases:
         if (gfilter.bReWrite) {
            cs.sim = !cs.yes;
            if (cs.sim && !cs.nohead)
               printx("$[simulating:]\n");
         }
         if (!gfilter.bPassHitFiles && chain.colfiles) {
            // the next chain step (e.g. run) wants us to collect filenames.
            // but we are processing a single input file,
            // therefore auto-reconfig:
            chain.colfiles    = 0;
            chain.coldata     = 1;  // collect text now
            chain.text2files  = 1;  // but let it autoconvert
         }
         lRC = walkAllTrees(eFunc_Filter, lFiles, lDirs, nBytes);
         if (cs.sim && !cs.nohead)
            printx("$[add -yes to really write changes.]\n");
         if (!lRC) lRC = gfilter.nTotalRC;   // info if any matches found
      }
      else
      {
         // processing stdin or chain data:
         if (gfilter.bReWrite) {
            perr("-write cannot be used this way, as it needs filenames.\n");
            pinf("maybe you want to use filefilter (ffilt) instead of filter?\n");
            return 9;
         }
         if (chain.colfiles) {
            // the next chain step (e.g. run) wants us to collect filenames.
            // but we are processing an input text stream.
            // therefore auto-reconfig:
            chain.colfiles    = 0;
            chain.coldata     = 1;  // collect text now
            chain.text2files  = 1;  // but let it autoconvert
         }
         if (!cs.usesnap)
            gfilter.bSingleFile = 1; // don't dump filename
         if (cs.debug) {
            if (chain.usedata)
               printf("[filter reads from chain data]\n");
            else
               printf("[filter reads from stdin (no chain data)]\n");
         }
         lRC = execFilter(0, stdin, chain.usedata ? chain.indata : 0);
         if (!lRC) lRC = gfilter.nTotalRC;   // info if any matches found
      }

      info.clear(); // for -verbose output

      if (!cs.quiet && cs.binariesSkipped)
         printx("<time>%d binary files skipped%s.<def>\n", cs.binariesSkipped, cs.verbose?"":" (-verbose for more)");

      // command cleanup:
      glblFilterDups.reset(); // after last file

      // analyze -test results
      if (cs.test) {
         lRC = 0;
         for (int i=0; i<FILT_MAXTESTMASKS; i++) {
            // if (ftest.apPosMasks[i])
            //    printf("%d: pos %s %d\n",i,ftest.apPosMasks[i],ftest.anPosHits[i]);
            if (ftest.apPosMasks[i] && !ftest.anPosHits[i]) {
               // a required phrase was not found
               printx("<err>miss :<def> %s\n", ftest.apPosMasks[i]);
               lRC = 10;
            }
            if (ftest.apNegMasks[i] &&  ftest.anNegHits[i]) {
               // an error phrase was found
               printx("<err>fail :<def> %s\n", ftest.apNegMasks[i]);
               lRC = 11;
            }
         }
      }

      int iDirNext = iChainNew;
      STEP_CHAIN(iDirNext, 1);
 
      bDone = 1;
   }

   // .
   ifcmd (!strcmp(pszCmd, "addhead") || !strcmp(pszCmd, "addtail")) // sfk187
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk addhead <in >out [-blank] string1 string2 ...\n"
             "$sfk filter in.txt +addtail string1 string2 ...\n"
             "\n"
             "   insert string(s) at the start or end of text lines.\n"
             "\n"
             "   $options\n"
             "      -blank    add blank chars between added strings.\n"
             "                not default since sfk 1.8.7.\n"
             "\n"
             "   $chaining support\n"
             "      supports input and output chaining.\n"
             "\n"
             "   $see also\n"
             "      #sfk filter infile.txt -form \"string1<run>col1\"\n"
             "         does the same and is more flexible.\n"
             "\n"
             "   $examples\n"
             "      #sfk echo bar +addhead foo\n"
             "         prints \"foobar\".\n"
            );
      ehelp;

      sfkarg;

      bool bhead = (strcmp(pszCmd, "addhead") ? 0 : 1);
      bool btail = bhead ? 0 : 1;

      bool bblank = 0;  // sfk187 new default
      int  iFirst = 0;
      int  iLast  = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-blank")) {
            bblank = 1;
            continue;
         }
         if (!strcmp(pszArg, "-noblank")) {
            bblank = 0;
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (iFirst == 0) {
            iFirst = iLast = iDir;
            continue;
         }
         iLast = iDir;
      }

      int iCurLine = 0;

      while (1)
      {
         char *pattr = 0;
         char *ptext = 0;

         // get next line
         if (chain.usedata) {
            if (iCurLine >= chain.indata->numberOfEntries())
               break;
            ptext = chain.indata->getEntry(iCurLine++, __LINE__, &pattr);
            if (!ptext)
               break;
         } else {
            if (fgets(szLineBuf, MAX_LINE_LEN, stdin) == 0)
               break;
            removeCRLF(szLineBuf);
            ptext = szLineBuf;
         }

         // add text
         szLineBuf2[0] = '\0';
         if (btail==1 && strlen(szLineBuf2)+strlen(ptext)<MAX_LINE_LEN)
            strcat(szLineBuf2, ptext);
         if (btail==1 && bblank==1)
            strcat(szLineBuf2, " ");
         for (int i1=iFirst; i1<=iLast; i1++) 
         {
            if (strlen(szLineBuf2)+strlen(argx[i1]) >= MAX_LINE_LEN)
               break;
            strcat(szLineBuf2, argx[i1]);
            if (bhead) {
               if (bblank==1) {
                  strcat(szLineBuf2, " ");
               }
            } else {
               if (bblank==1 && i1+1<=iLast) {
                  strcat(szLineBuf2, " ");
               }
            }
         }
         if (bhead==1 && strlen(szLineBuf2)+strlen(ptext)<MAX_LINE_LEN)
            strcat(szLineBuf2, ptext);

         // write output
         if (chain.colany()) {
            chain.addLine(szLineBuf2, pattr ? pattr : str(""));
         } else {
            printf("%s\n", szLineBuf2);
         }
      }

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   #ifndef NO_ZIP_LIST
   // internal, to test zip/jar listing via central dir
   if (!strcmp(pszCmd, "ziplist"))
   {
      if (checkArgCnt(argc, 3)) return 9;

      FileList oFiles;
      getZipList(argv[2], oFiles);

      int nFiles = oFiles.clNames.numberOfEntries();
      for (int i=0; i<nFiles; i++)
      {
         char *psz = oFiles.clNames.getEntry(i, __LINE__);
         num nSize = oFiles.clSizes.getEntry(i, __LINE__);
         num nTime = oFiles.clTimes.getEntry(i, __LINE__);
         printf("%s %s %s\n", timeAsString(nTime), numtoa(nSize,10), psz);
      }
      bDone = 1;
   }
   #endif

   // internal, to test zip listing as stream
   if (!strcmp(pszCmd, "ziplist2"))
   {
      if (checkArgCnt(argc, 3)) return 9;

      SFKMD5 md5;
      FileList oFiles;
      getZipMD5(argv[2], md5, oFiles, 1);

      int nFiles = oFiles.clNames.numberOfEntries();
      for (int i=0; i<nFiles; i++)
      {
         char *psz = oFiles.clNames.getEntry(i, __LINE__);
         num nSize = oFiles.clSizes.getEntry(i, __LINE__);
         num nTime = oFiles.clTimes.getEntry(i, __LINE__);
         printf("%s %s %s\n", timeAsString(nTime), numtoa(nSize,10), psz);
      }
      bDone = 1;
   }

   #ifndef USE_SFK_BASE
   ifcmd (!strcmp(pszCmd, "patch"))
   {
      ifhelp (nparm < 1)
      printx(
          "<help>$sfk patch [-revoke|-redo] yourpatchfile.cpp [-sim|-verify]\n"
          "\n"
          "   search text blocks in file(s) and replace them by other text blocks,\n"
          "   including backup creation and optional restore of original files.\n"
          "\n"
          "   -revoke: undo all patches, by replacing the modified targets\n"
          "            by the backup files which sfk stores in save_patch.\n"
          "            the target files are touched afterwards (date/time update)\n"
          "            to enforce proper recompile. use -keep-dates to avoid this.\n"
          "   -redo  : undo all patches and then re-apply patches.\n"
          "            best used whenever you change the patchfile itself,\n"
          "            to have your changes updated in the target files.\n"
          "   -exact-match: by default, leading whitespaces are ignored.\n"
          "                 use this option enforce exact 1:1 line matching.\n"
          "   -keep-dates: by default, revoked files get touched. use this option\n"
          "                to enforce original file dates (yet windows only).\n"
          "   -sim     : simulate what the patch would do, don't change anything.\n"
          "   -qs      : quick summary, just tell a one-line status.\n"
          "   -stats   : show statistics of select-replace usage.\n"
          "   -verify  : check if an applied patch is still intact.\n"
          "   -nopid   : apply irrevocable patch without [patch-id].\n"
          "   -anyroot : ignore the :root dir entry in a patch file.\n"
          "\n"
         );
      printx(
         "   $patchfile rules:\n"
         "   - patches are executed exactly in the order as given in the patchfile.\n"
         "   - each :from/:to statement is executed exactly once.\n"
         "   - if ANY of the :from/:to statements doesn't match the input,\n"
         "     the whole file is NOT patched.\n"
         "   - the first :to block for a new target file must contain the word [patch-id],\n"
         "     by using a comment in the target file's syntax, e.g. in C++: // [patch-id].\n"
         "     this marks the file as being patched -> sfk will not patch it again.\n"
         "\n"
         "   it is recommended that your patchfiles have the ending .cpp (or .java etc.)\n"
         "   to enable syntax highlighting with your favourite text editor.\n"
         "\n"
         );
      printx("   #sfk patch -example\n"
             "      shows a detailed patchfile example.\n"
             "   #sfk patch -template\n"
             "      gives a simple, empty patchfile template.\n"
             );
      ehelp;

      sfkarg;

      #ifdef SFK_MEMTRACE
      bGlblNoMemCheck = 1;
      sfkmem_nocheck();
      #endif // SFK_MEMTRACE

      lRC = patchMain(argc-1, argx, 1);

      bDone = 1;
   }
   #endif // USE_SFK_BASE

   ifcmd (!strcmp(pszCmd, "if")
          || !strcmp(pszCmd, "tif") // sfk193
         )
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk ... +if [opts] expression command1 ... +command2\n"
             "$sfk ... +[t]if expr [+]begin +cmd1a +cmd1b ... +endif +cmd2\n"
             "\n"
             "   execute command1 if expression is true, then continue to command2.\n"
             "   if expression is not true, skip directly to command2.\n"
             "   can be used only in a command chain, after another command.\n"
             "\n"
             "   use \"+if expr +begin ... +endif\" to run multiple commands\n"
             "   as one block, if expression is true.\n"
             "\n"
             "   $supported expressions\n"
             "\n"
             "      $return code comparison\n"
             "      \"rc=n\"     return code of previous command equal  to   n\n"
             "      \"rc>n\"     return code of previous command higher than n\n"
             "      \"rc<n\"     return code of previous command lower  than n\n"
             "      \"rc<>n\"    return code of previous comm.  not equal to n\n"
             "\n"
             "      $generic text or number comparison\n"
             "      \"l = r\"    left part is equal to right\n"
             "      \"l <> r\"   left part is not equal to right\n"
             "      \"l < r\"    left part is lower  then right\n"
             "      \"l > r\"    left part is higher then right\n"
             "      \"l <= r\"   left part is lower  or equal\n"
             "      \"l >= r\"   left part is higher or equal\n"
             "      if both l and r contain only digits a numeric\n"
             "      comparison is done, else a text comparison.\n"
             "\n"
             "   $options\n"
             "      options for if must be given before expression.\n"
          // "      -showrc    tell rc which is passed to if\n"
             "      -var       use sfk variables, must be first option\n"
             "      -text      force text comparison (nocase)\n"
             "      -case      case sensitive text comparison\n"
             "      -debug     tell what is done in a generic comparison\n"
             "\n"
             "   $limited nesting\n"
             "      #if ... begin ... endif<def>\n"
             "      - may $not<def> contain other #if[exist] / begin / endif<def>\n"
             "      - but may contain short #if ...<def> without begin.\n"
             "      invalid nesting causes an undefined program flow.\n"
             "\n"
             "   $chaining support since sfk 1.9.3\n"
             "      #+if<def>   does not accept any chain input data, as this\n"
             "            creates ambiguities with many following\n"
             "            commands, like +if ... +setvar a=text\n"
             "      #+tif<def>  expects text and stream chain input data.\n"
             "      $bad example:\n"
             "        #+xed /a/b/ +if ... +xed /b/c/\n"
             "          data cannot be passed from the first to the\n"
             "          second xed this way, as +if will block this.\n"
             "      $correction:\n"
             "        #+xed /a/b/ +tif ... +xed /b/c/\n"
             "          the +tif explicitely requests text data.\n"
             "          you may also use global option -keepdata.\n"
             "          for more details see: $sfk help chain\n"
             "\n"
             "   $see also\n"
             "      #sfk ifexist<def>  check if a file or folder exists.\n"
             "      #sfk call<def>     call sub functions in a script.\n"
             "      #sfk goto<def>     jump to a local label.\n"
             "\n"
             "   $examples\n"
             "      #sfk filter in.txt -+err +if \"rc>0\" run -yes \"x.bat\" +echo done\n"
             "         if file in.txt contains the word \"err\", run x.bat.\n"
             "         the \"echo done\" is always executed.\n"
             "\n"
             "      #sfk xex -justrc in.txt \"/foo*bar/\"\n"
             "       #+if \"rc=0\" stop 9 \"[[Red]]error:[[def]] miss\" +echo \"match\"\n"
             "         type this all in one line, or use \"sfk cmd 18\". [18]\n"
             "         if file in.txt does not contain the search pattern\n"
             "         then stop with return code 9, printing an error.\n"
            );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      char *pexpr    = 0;
      int iThenCmd   = 0;
      int iMode      = 0;
      int istate     = 0;

      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (istate == 0)
         {
            // sfk1814: accept "-yes = -yes" etc.
            for (char *psz=pszArg; *psz; psz++) {
               switch (*psz) {
                  case '=': case '<': case '>':
                     istate = 1;
                     break;
               }
            }
         }
         if (!istate && !strcmp(pszArg, "-text")) {
            iMode = 1;
            continue;
         }
         if (!istate && strBegins(pszArg, "-num")) {
            iMode = 2;
            continue;
         }
         if (!istate && sfkisopt(argx[iDir])) {
            // sfk1812: accept options BEFORE expression
            if (!strcmp(pszArg, "-showrc"))
               { cs.showrc = 1; continue; }
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
            continue;
         }
         // sfk1920: support if "+a = +a" ...
         // as long as no expression was found 
         // do not accept begin or +tell etc.
         if (pexpr) { // sfk1920 support if "+a = +a" ...
            if (   !strcmp(argv[iDir], "begin")
                || !strcmp(argv[iDir], "+begin"))
            {
               // begin ... +endif support since sfk189.
               // about nested if handling: this needs to
               // - parse all if [+]begin endif
               // - combined with if ... without endif
               // - combined with ifexist ... [begin]
               if (iDir+1<argc)
                  iThenCmd = iDir+1;
               while (iDir<argc && strcmp(argv[iDir],"+endif")!=0)
                  iDir++;
               if (iDir>=argc)
                  return 9+perr("missing +endif after if \"%s\" begin", pexpr?pexpr:"");
               continue;
            }
            if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
               break;
         }
         // non-option parms
         if (!pexpr) {
            pexpr = argx[iDir];
            // detect user error: "rc =" "rc <" "rc >" in unparsed data
            char *ptmp = argv[iDir];
            if (strBegins(ptmp, "rc =") || strBegins(ptmp, "rc <")
                || strBegins(ptmp, "rc >"))
            {
               pwarn("possible wrong 'if' syntax: \"%s\"\n", ptmp);
               pinf("check command rc without blanks, like: if \"rc=0\"\n");
            }
            continue;
         }
         if (!iThenCmd)
            { iThenCmd = iDir; continue; }
         // ignore all other parms as they probably belong
         // to the thenCmd.
      }

      if (!pexpr)    return 9+perr("need an expression after if.");
      if (!iThenCmd) return 9+perr("need a command after if \"%s\", without \"+\".", pexpr);

      if (cs.showrc)
         printf("[if got rc %d]\n", lRC);

      // evaluate expression
      bool btrue = 0;
      if (strBegins(pexpr, "rc=")) {
         int ncmp = atol(pexpr+3);
         btrue = (lRC == ncmp) ? 1 : 0;
      }
      else
      if (strBegins(pexpr, "rc<>")) {  // sfk1890
         int ncmp = atol(pexpr+4);
         btrue = (lRC != ncmp) ? 1 : 0;
      }
      else
      if (strBegins(pexpr, "rc<")) {
         int ncmp = atol(pexpr+3);
         btrue = (lRC < ncmp) ? 1 : 0;
      }
      else
      if (strBegins(pexpr, "rc>")) {
         int ncmp = atol(pexpr+3);
         btrue = (lRC > ncmp) ? 1 : 0;
      }
      else
      {
         // sfk1812
         strcopy(szLineBuf, pexpr);

         char *pleft = szLineBuf;
         int   ioper = 0;
         char *prite = pastifop(pleft, &ioper);
         if (!prite) {
            perr("unsupported expression: %s\n", pexpr);
            if (!cs.usevars && strstr(pexpr, "#("))
               pinf("use -var to enable #() variable replacements.\n");
            return 9;
         }
         // left side was zero terminated.

         bool blanydig=0,blnum=1;
         bool branydig=0,brnum=1;
         for (char *psz=pleft; *psz; psz++) {
            if (isdigit(*psz))
               blanydig = 1;
            else
               blnum = 0;
         }
         for (char *psz=prite; *psz; psz++) {
            if (isdigit(*psz))
               branydig = 1;
            else
               brnum = 0;
         }

         // if both sides look like numbers
         if (iMode==0 && blanydig && blnum && branydig && brnum)
            iMode = 2;

         if (iMode==0)
            iMode = 1;

         if (cs.debug)
         {
            printf("[IF compares %s \"%s\" and \"%s\"]\n",
               (iMode==1) ? "strings":"numbers",
               pleft, prite);
            if (!cs.usevars && (strstr(pleft,"#(") || strstr(prite,"#(")))
               printf("... use -var as first option to read variables.\n");
         }

         if (iMode==1)
         {
            // string comparison
            int ival = 0;
            if (cs.usecase)
               ival = strcmp(pleft, prite);
            else
               ival = mystricmp(pleft, prite);

            switch (ioper)
            {
               case 0: btrue = (ival == 0) ? 1 : 0; break; // =
               case 1: btrue = (ival == 0) ? 0 : 1; break; // <>
               case 2: btrue = (ival <  0) ? 1 : 0; break; // <
               case 3: btrue = (ival >  0) ? 1 : 0; break; // >
               case 4: btrue = (ival <= 0) ? 1 : 0; break; // <=
               case 5: btrue = (ival >= 0) ? 1 : 0; break; // >=
            }

            // printf("if /%s/%d/%s/ mode=%d delta=%d res=%d\n",
            //   pleft, ioper, prite, iMode, ival, btrue);
         }
         else
         {
            // numeric comparison
            num nleft = atonum(pleft);
            num nrite = atonum(prite);

            switch (ioper)
            {
               case 0: btrue = (nleft == nrite) ? 1 : 0; break;
               case 1: btrue = (nleft == nrite) ? 0 : 1; break;
               case 2: btrue = (nleft <  nrite) ? 1 : 0; break;
               case 3: btrue = (nleft >  nrite) ? 1 : 0; break;
               case 4: btrue = (nleft <= nrite) ? 1 : 0; break;
               case 5: btrue = (nleft >= nrite) ? 1 : 0; break;
            }
         }
      }

      if (btrue)
         iChainNext = iThenCmd;

      // IF can NOT decide (at start of execution)
      // if the next command to execute needs data.
      STEP_CHAIN(iChainNext, 0); // if
      // sfk181 changed default from 1 to 0

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "ifexist")      // sfk1912
          || !strcmp(pszCmd, "ifexists")
          || !strcmp(pszCmd, "ifnotexist")   // sfk193
          || !strcmp(pszCmd, "ifnotexists")  // sfk193
         )
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk ifexist [opts] file command1 ... +command2\n"
             "$sfk ifnotexist file command1 ... +command2\n"
             "\n"
             "   execute command1 if a file or folders exists with the\n"
             "   given name, then continue to command2. if no file or\n"
             "   folder exists skip directly to command2.\n"
             "\n"
             "   use \"+ifexist file begin ... +endif\" to run multiple\n"
             "   commands as one block, if a file or folder exists.\n"
             "\n"
             "   use \"+ifnotexist\" to run command(s) if a file\n"
             "   or folder does not exist.\n"
             "\n"
             "   $options\n"
             "      -var      use sfk variables, must be first option.\n"
             "\n"
             "   $return code\n"
             "      rc=0      nothing exists\n"
             "      rc=1      exists and is a file\n"
             "      rc=2      exists and is a dir\n"
             "      return code is the same no matter\n"
             "      if ifexist or ifnotexist is used.\n"
             "\n"
             "   $see also\n"
             "      #sfk call<def>  call sub functions in a script.\n"
             "      #sfk goto<def>  jump to a local label.\n"
             "\n"
             "   $examples\n"
             "      #sfk ifexist out.txt stop -all \"output file exists\" +endif\n"
             "         stop whole sfk script if out.txt exists already\n"
             "      #sfk ifexist in.txt begin load in.txt +appendto out.txt +endif\n"
             "         if in.txt exists append it's content to out.txt\n"
             "      #sfk ifexist foo begin +if \"rc=2\" stop -all nofile +endif\n"
             "         if foo exists, but is a folder, stop with message \"nofile\".\n"
             "      #sfk ifnotexist mydir<sla>a.txt unzip -yes mydir.zip +tell \"ok\"\n"
             "         if no file mydir<sla>a.txt exists extract mydir.zip\n"
             "         which may contain mydir<sla>a.txt and other files\n"
            );
      ehelp;

      sfkarg;

      int bNegate    = strstr(pszCmd, "not") ? 1 : 0;

      int iChainNext = 0;
      char *pexpr    = 0;
      int iThenCmd   = 0;
      int iMode      = 0;
      bool bOrDir    = 1;
      bool bJustDir  = 0;
      int istate     = 0;

      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!istate && sfkisopt(pszArg)) {
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
            continue;
         }
         if (   !strcmp(argv[iDir], "begin")
             || !strcmp(argv[iDir], "+begin"))
         {
            if (iDir+1<argc)
               iThenCmd = iDir+1;
            while (iDir<argc && strcmp(argv[iDir],"+endif")!=0)
               iDir++;
            if (iDir>=argc)
               return 9+perr("missing +endif after if \"%s\" begin", pexpr?pexpr:"");
            continue;
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // non-option parms
         if (!pexpr) {
            pexpr = argx[iDir];
            istate = 1;
            continue;
         }
         if (!iThenCmd)
            { iThenCmd = iDir; continue; }
         // ignore all other parms as they belong to thenCmd.
      }

      if (!pexpr)    return 9+perr("need an expression after if.");
      if (!iThenCmd) return 9+perr("need a command after \"if expression\", without \"+\".");

      // evaluate expression
      int  btrue  = 0;
      int  bIsDir = 0;

      Coi ocoi(pexpr, str(""));
      int bExistsAny = ocoi.existsFile(bOrDir, &bIsDir);

      if (bJustDir && bIsDir)
         btrue = 1;
      else
      if (bExistsAny)
         btrue = 1;

      lRC = 0;
      if (btrue==1 && bIsDir==0)
         lRC = 1;
      if (btrue==1 && bIsDir==1)
         lRC = 2;

      if (btrue ^ bNegate)
         iChainNext = iThenCmd;

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "goto")
          || !strcmp(pszCmd, "tgoto")  // sfk193
         )
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk goto label\n"
             "\n"
             "   jump to a $local<def> label within the command chain.\n"
             "\n"
             "   $A local label means:\n"
             "   - #no +end<def> is allowed between goto and the label.\n"
             "     use #+stop<def> instead to interrupt execution.\n"
             "   - the label must start like #+label name<def>,\n"
             "     but not like \"sfk label name\".\n"
             "\n"
             "   The very last command of the overall command chain\n"
             "   must be followed by +end.\n"
             "\n"
             "   $chaining support since sfk 1.9.3\n"
             "      #+goto<def>   does not accept any chain input data.\n"
             "      #+tgoto<def>  expects text and stream chain input data.\n"
             "\n"
             "   $see also\n"
             "      #sfk call<def>        call a global label\n"
             "      #sfk storetext<def>   store whole chain data\n"
             "      #sfk gettext<def>     recall stored chain data\n"
             "\n"
             "   $examples\n"
             "      $--- file dofilter.bat: ---\n"
             "      sfk script %%0 -from begin %%1\n"
             "      GOTO xend\n"
             "      sfk label begin\n"
             "         +if \"%%1 = \" #goto help\n"
             "         +echo \"got filename: %%1\"\n"
             "         +then filter %%1 -+foo\n"
             "         #+stop 0\n"
             "      \n"
             "         #+label help\n"
             "            +echo \"usage: dofilter.bat filename\"\n"
             "         #+end\n"
             "      \n"
             "      :xend\n"
             );
      ehelp;

      sfkarg;

      char *pszLabel = 0;
      int   iPastLabel = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (pszLabel)
            return 9+pbad(pszCmd, pszArg);
         pszLabel = pszArg;
      }

      if (!pszLabel)
         return 9+perr("missing target label");
      if (!iChainNext)
         return 9+perr("missing further chain commands");

      for (int i=0; i<argc; i++)
      {
         char *pszArg = argx[i];
         if (strcmp(pszArg, "+label"))
            continue;
         if (i+1<argc) i++;
         if (strcmp(argx[i], pszLabel))
            continue;
         if (i+1>=argc)
            continue;
         iPastLabel = i+1;
         break;
      }

      if (iPastLabel == 0)
         return 9+perr("label %s not found",pszLabel);

      STEP_CHAIN(iPastLabel, 0);

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "call")   // +var
          || !strcmp(pszCmd, "tcall")
          || !strcmp(pszCmd, "fcall")
         )
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk ... +call label [parm1 parm2 ...]\n"
             "\n"
             "   call a sub function in the current script,\n"
             "   starting at the given label.\n"
             "\n"
             "   $chaining input control\n"
             "      by default, \"call\" does not consume or pass\n"
             "      through text input from previous commands.\n"
             "      use #+tcall<def> to expect text input,\n"
             "      use #+fcall<def> to expect file list input.\n"
             "\n"
             "   $recursion limit\n"
             "      if the called function calls another function\n"
             "      by call or perline this should not be nested\n"
             "      too often, otherwise sfk may crash.\n"
             "\n");
      printx("   $see also\n"
             #ifdef _WIN32
             "      #sfk samp sfkbat<def>   script example\n"
             #else
             "      #sfk samp sfkbash<def>  script example\n"
             #endif
             "      #sfk stop<def>          stop a function with rc\n"
             "      #sfk if<def>            conditional execution\n"
             "      #sfk stacksize<def>     test available stack size\n"
             "\n"
             "   $examples\n"
             "      #--- file script.txt begin ---\n"
             "      sfk label begin\n"
             "         +echo \"script starts\"\n"
             "          +call mysub in.txt foo\n"
             "         +echo \"all done\"\n"
             "         +end\n"
             "\n"
             "      sfk label mysub\n"
             "         +filter %%1 -justrc -+%%2\n"
             "            +if \"rc=0\" stop 9 \"[[Red]]miss[[def]]\"\n"
             "         +echo \"found\"\n"
             "         +end\n"
             "      #--- file script.txt end ---\n"
             "\n"
             "      #sfk script script.txt\n"
             "        searches input file in.txt for word \"foo\".\n"
             "        if not found, prints \"miss\" and stops the script.\n"
             "        note that stop return code 9 or higher is required\n"
             "        to stop further execution after \"call\".\n"
            );
      ehelp;

      sfkarg;

      char *pszLabel  = 0;

      int  iChainNext =  0;
      int  iLocalParm = -1;
      int  nLocalParm =  0;
      int  nState     =  0;
      bool bliteral   =  0;

      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (nState < 1 && sfkisopt(argx[iDir])) {
            // general options are interpreted only before script name,
            // i.e. as int as nState == 0.
            if (strBegins(argx[iDir], "-lit")) {
               bliteral = 1;
               continue;
            }
            else
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (!bliteral && isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszLabel) {
            pszLabel = argx[iDir];
            nState = 1;
         }
         else
         if (iLocalParm < 0) {
            iLocalParm = iDir;
            nLocalParm = 1;
            nState = 2;
         }
         else
            nLocalParm++;
      }

      if (!pGlblCurrentScript)
         return 9+perr("cannot use call outside a script.");

      // pGlbl is the original script data we're running within.
      // make a copy as this will be stuffed with terminators.
      char *pScript = strdup(pGlblCurrentScript);

      // this copy must then be auto deleted.
      CharAutoDel odel(pScript);

      int iExecRC = callLabel(pScript, argc, argx, penv, // call
            pszLabel, iLocalParm, nLocalParm, lRC, bFatal);
      // pScript is modified with zero terms.

      if (iExecRC) // fatal errors that stop chaining
         return iExecRC;

      // pScript is auto deleted.

      if (lRC >= 9) return lRC;

      STEP_CHAIN(iChainNext, 0); // call, fix sfk181: call should not change chain data
      // ,1 here on previous versions cleared the chain.

      bDone = 1;
   }

   regtest("run echo_$purefile xdir .cpp .hpp");
   regtest("list xdir +run echo_$pfile");

   bool bReRun = false;

   ifcmd (   !strcmp(pszCmd, "run")    // +wref +var
          || !strcmp(pszCmd, "run.")   // sfk191
          || !strcmp(pszCmd, "rerun")  // sfk198 internal
         )
   {
      bReRun = strcmp(pszCmd, "rerun") ? 0 : 1;
      ifhelp (!chain.usefiles && !chain.usedata && (nparm < 1))
      if (bhelp || !bReRun)
      {
      printx("<help>$sfk run \"your command <run>file [<run>relfile] [...]\" [-yes] [-nohead] [-quiet] [...]\n"
             "\n"
             "   run a self-defined command on every file- or directory name.\n"
             "   within your command string, you may specify:\n"
             "\n"
             "      $<run>file<def>                     - insert full filename, including path.\n"
             "      $<run>quotfile<def>    or $<run>qfile<def>    - just as <run>file, but with quotes \"\" around.\n"
             "      $<run>relfile<def>     or $<run>qrelfile<def> - insert relative filename, without path.\n"
             "      $<run>base<def>        or $<run>qbase<def>    - the relative base filename, without extension.\n"
             "      $<run>ext<def>         or $<run>qext<def>     - filename extension. foo.bar.txt has extension .txt.\n"
             "      $<run>path<def>        or $<run>qpath<def>    - the path (directory) without filename.\n"
             "      $<run>relpath<def>     or $<run>qrelpath<def> - sub path relative to start folder.\n"
             "      $<run>ufile<def>       or $<run>upath<def>    - force unix style slashes \"/\" on output.\n"
             "      $<run>qufile<def>      or $<run>qupath<def>   - unix slashes and quotes combined.\n"
             "      $<run>since<def>       or $<run>qsince<def>   - with option -sincediff: the reference file name.\n"
             "      $<run>text<def>        or $<run>qtext<def>    - one record of input text, similar to <run>file.\n"
             "      $<run>targ<def>        or $<run>qtarg<def>    - with -tomake: target filename.\n"
             "\n"
             "      always prefer 'q' forms over non-quoted forms: as soon as there is a filename\n"
             "      containing blanks, e.g. X:\\the src files\\test one.txt, you will need quotations,\n"
             "      or you have to manually insert \\\" or \\q escaped quotes (see 3rd example below).\n"
             "      you may also use <run>quotrelfile, <run>quotsince, <run>quottext for greater clarity.\n"
             "      if you supply only <run>path expressions, only directories will be processed.\n"
             "      on single word chain commands like \"+run vi\", \" <run>qfile\" is added automatically.\n"
             "\n"
             /*
             "   $strict command string syntax<def> - #Pending Syntax Change!<def>\n"
             "      if unknown tokens like #<run>foo<def> are found in the run command, by default\n"
             "      they are kept as is. use option $-strict<def> to create an error in this case,\n"
             "      or set an environment variable: #<exp> SFK_CONFIG=strict\n"
             "      the word must then be escaped like #<run><run>foo<def>\n"
             "      #future SFK versions may use -strict by default<def>, so check your scripts now.\n"
             "\n"
             */
             "   $further pattern support:\n"
             "      -spat       activates slash patterns like \\t \\q \\xnn etc.\n"
             #ifdef _WIN32
             "      -upat       unix style syntax using ## instead of $$\n"
             #endif
             "\n"
             "   $options\n"
             "      -yes        really execute. default is just to simulate what would be done.\n"
             "                  you may also type #run.<def> (with a dot) as quick confirmation.\n"
             /*
             #ifdef SFK_BOTH_RUNCHARS_HELP
             "      -strict     #produce an error if unknown words starting with $$ or ## are found.<def>\n"
             "                  these must then be escaped using $$$$ or ####\n"
             #else
             "      -strict     #produce an error if unknown words starting with <run> are found.<def>\n"
             "                  these must then be escaped using <run><run>\n"
             #endif
             */
             "      -nohead     does not display the [simulating:] info text.\n"
             "      -noinfo     unless you use <run>text, sfk checks the input filenames\n"
             "                  1. if they contain blanks, but no quotes are given within command.\n"
             "                  2. if they seem to use the wrong path separator character.\n"
             "                  in both cases, a reminder is printed. if you know that your command\n"
             "                  needs no changes, add -noinfo or use <run>text instead of <run>file.\n"
             "      -quiet      does not echo the commands before execution.\n"
             "      -relnames   strips the root directory names from filenames.\n"
             "      -i[files]   process a text or filename list from stdin.\n"
             "      -idirs      process a directory name list from stdin.\n"
             "                  on stdin, '##' remark lines and empty lines are skipped. note:\n"
             "                  \"sfk.exe <list.txt\" supports only 4 KB for list.txt under windows.\n"
             "                  \"type list.txt | sfk.exe\" supports unlimited stream length.\n"
             "      -nofile[names]   with chaining, does not create \":file \" name records.\n"
             "      -printcmd   print the full command which is executed to console.\n"
             "      -stoprc=n   stop processing if a command returns return code >= n.\n"
             "\n");
      printx("   $command string format\n"
             "      with option -spat, slashpatterns like \\t \\q \\xnn are supported.\n"
             "      due to syntax limitations of the command shell, it may help\n"
             "      - to use \\q instead of \\\"   (avoids quote miscounting at shell)\n"
             "      - to use \\x26 instead of &  (if ampersand is behaving unexpected)\n"
             "\n");
      printx("   $quoted variable expansion\n"
             "      when using sfk variables which contain filenames, like in\n"
             "         #run \"copy ##(src) ##(dst)\"\n"
             "      then spaces in filenames require enquoting. when using -spat\n"
             "      and \\q it may cause conflicts if the filename itself contains\n"
             "      known slash patterns, like \\t in file 'mydir\\thebar.txt'.\n"
             "      to avoid this you can use (with sfk run only):\n"
             "         #run \"copy ##(qsrc) ##(qdst)\"\n"
             "      which will surround variable contents by double quotes.\n"
             "\n");
      printx("   $quoted multi line parameters are supported in scripts\n" // run
             "      using parm trim. type \"sfk script\" for details.\n"
             "\n");
      printx("   $temporary or permanent output files\n"
             "      if run output is post-processed by $command chaining<def>, e.g. run ... +filter,\n"
             "      sfk creates temporary files to collect the output. by default, these files\n"
             "      are deleted when run finishes. say \"sfk help options\" for more on this.\n"
             "      specify $-to targetdir<sla><run>file<def> to write command output into a permanent\n"
             "      target fileset. required directories are created automatically.\n"
             "      -to accepts the same mask as run itself, e.g. -to \"mydir<sla><run>path<sla><run>base.tmp\"\n"
             "      by default, standard output AND standard error stream are written to file.\n"
             "      add $2>nul<def> to your command to strip the error stream.\n"
             "\n");
      printx("   $return code by variable\n"
             "      sfk variable #run.lastrc<def> contains the return code of the external\n"
             "      program called. if multiple files were processed then it contains\n"
             "      only the rc of the last file.\n"
             "\n");
      printx("   $command chaining notes\n"
             "      sfk run \"...<run>path...\" +nextcmd: will pass directories, not filenames.\n"
             "      sfk run ... -to tmp<sla><run>file +nextcmd: will pass output filenames, not input.\n"
             "      sfk run ... +run: will pass unchanged input filename list.\n"
             "\n");
      printx("   $see also\n"
             "      #sfk perline<def>  run sfk command(s) per text input line.\n"
             "      #sfk runloop<def>  run commands using a loop counter.\n"
             "\n");
      webref("run");
      printx("   $examples\n"
             "      #sfk run \"attrib -R <run>qfile\" -quiet testfiles\\FooBank\\BarDriver\n"
             "         removes readonly attribute on all files within BarDriver\n"
             "      #sfk run \"<img src=<run>quottext>\" -dir . -file .jpg -nohead >index.html\n"
             "         create html-style image list of all jpegs (using just simulation).\n"
             "         note that option -nohead removes the [simulating:] info text lines.\n"
             "      #type dirlist.txt | sfk run -idirs \"xcopy \\\"x:<sla><run>path\\\" \\\"z:<sla><run>path\\\" /I /D\"\n"
             "         update-copy all directories from dirlist.txt from x: to z:\n"
             "      #sfk run \"diff oldsrc<sla><run>file newsrc<sla><run>file\" -relnames -sincediff oldsrc newsrc\n"
             "         compare directories, run \"diff\" on all files with different content.\n"
             "      #sfk run \"diff <run>qsince <run>qfile\" -sincediff oldsrc newsrc\n"
             "         same as above, only shorter and safer (including quotes around filenames).\n"
             "      #sfk run \"zip update.zip <run>qfile\" -since 20070131 . .java .jsp\n"
             "         collect .java and .jsp files added/changed since 31-Jan-2007 into a zip file.\n"
             "      #sfk list testfiles .txt +run vi\n"
             "         open all .txt files in vi. <run>qfile is added automatically.\n"
             "      #sfk sel . .avi +run \"ffmpeg -i <run>file -f image -t .02 thumbs<sla><run>base-%%d.jpg\"\n"
             "         extract first image from all .avi movies, videos using ffmpeg.\n"
             "      #sfk sel -since 30m . .cpp .hpp +run -printcmd \"rm <run>path/<run>base.o\"\n"
             "         delete all object files of source codes changed in the last 30 minutes\n"
             "      #sfk echo -lines 100 101 102 +run \"showstatus.bat <run>text\"\n"
             "         run showstatus.bat three times with the given numbers, e.g. local ip's.\n");
      printx("      #sfk sel soundlib .wav -tomake \"outdir<sla><run>base.mp3\"\n"
             "       #+run \"ffmpeg -i <run>qfile <run>qtarg\"\n"
             "         for all .wav files within soundlib that have no, or an older, .mp3 file\n"
             "         within outdir, run command ffmpeg to convert from .wav to .mp3.\n"
             "      #sfk -exectime run. \"copy in.dat out.dat\"\n"
             "         measure the time it takes to run a copy command.\n"
             "      #sfk -var run \"myprog.exe\" -yes +tell \"myprog rc: ##(run.lastrc)\"\n"
             "         run external program myprog.exe and tell it's return code.\n"
             "\n");
      printx("   Don't try to execute a full run statement in ONE GO. Almost certainly, something\n"
             "   will go wrong (wrong files selected, syntax error in the command itself), and you\n"
             "   end up with many wrong output files. Instead, use THREE STEPS:\n"
             "   \n"
             "   $1. find the correct file set, by some trial and error:\n"
             "         #sfk run \"echo <run>quotfile\" mydir\n"
             "      This will simply show all filenames from \"mydir\". no command is executed\n"
             "      on those files, so nothing bad is happening. almost certainly, you notice\n"
             "      that too many files are included. Maybe you have to add \"-nosub\" to exclude\n"
             "      subfolders, or add more details about your file selection, like:\n"
             "         #sfk run \"echo <run>quotfile\" mydir .jpg .jpeg\n"
             "      which reduces the file set to just .jpg and .jpeg files within \"mydir\".\n"
             "   \n"
             "   $2. Replace \"echo\" by the actual command, still running in simulation mode.\n"
             "         #sfk run \"copy <run>quotfile \\\"d:\\pic\\small_<run>base.jpg\\\"\" mydir .jpg .jpeg\n"
             "      This simulates a copy of all images from mydir to d:\\pic, prefixing their name\n"
             "      by \"small_\", and ensuring that all target file extensions are only \".jpg\".\n"
             "   \n"
             "   $3. When you're satisfied with the simulation output, add \"-yes\".\n"
             "\n"
             );
      }
      if (bReRun)
      {
      printx("<help>$sfk rerun [options] \"command\"\n"
             "\n"
             "   run a self-defined command with redirection of output,\n"
             "   to allow output processing by further chain commands.\n"
             "\n"
             "   for help on command string formats and options, type\n"
             "      #sfk run\n"
             "\n"
             "   $experimental command.<def> only use command strings which call\n"
             "   clean, simple external command line programs that do not\n"
             "   expect user input, and which will stop after a while.\n"
             "\n"
             "   $options important for rerun\n"
             "   -verbose   print every line received by external command.\n"
             "              the very last line of output may not be shown.\n"
             "   -printcmd  if a command blocks endless, use -printcmd,\n"
             "              read and copy the exact command sfk is running,\n"
             "              and run that without sfk. then you should see\n"
             "              the reason for blocking by it's full output.\n"
             "   -quiet     or -noinfo does now show progress info.\n"
             "\n"
             "   $if the external command blocks endless\n"
             "   1. press Enter. it may wait for input, e.g. asking\n"
             "      if an output file should be overwritten.\n"
             "   2. study the external program's help text. see if it\n"    
             "      has options like -y to never ask questions\n"
             "      but assume everything is answered as 'yes'.\n"
             #ifdef _WIN32
             "   3. add ' <nul' to tell there is no user input, like\n"
             "      #sfk rerun \"other.exe <nul\"\n"
             #else
             "   3. add ' </dev/null' to tell there is no user input, like\n"
             "      #sfk rerun \"externalcmd </dev/null\"\n"
             #endif
             "\n"
             "   $examples\n"
             "   #sfk rerun \"ffmpeg -i in.mov out.avi -y\" -yes +ttail\n"
             "      run ffmpeg to convert a video. if out.avi exists\n"
             "      already it will by overwritten without asking, due\n"
             "      to option -y. show last lines of terminal output.\n"
             "   #sfk rerun ffmpeg -yes +xex \"_ version * (c) *-* the _[part6]\\n_\"\n"
             "      get the ffmpeg binary release year.\n"
             "\n"
             );
      }
      ehelp;

      cs.quotevars = 1; // allow #(qvarname), just with run

      sfkarg;

      if (!strcmp(pszCmd, "run."))
         cs.yes = 1;

      bool bOpen      = false;
      int  iChainNext = 0;

      if (bReRun)
         cs.rerun = 1;

      cs.execweb = 1;
      cs.openbyapp = 0;

      for (; iDir < argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-stoprc", &pszParm)) {
            if (!pszParm) return 9;
            cs.stoprc = atol(pszParm);
            continue;
         }
         if (!strcmp(argx[iDir], "-i")) {
            bGlblStdInAny   = 1;
            bGlblStdInFiles = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-printcmd")) {
            cs.printcmd = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-ifiles")) {
            if (bGlblStdInDirs) return 9+perr("cannot use -ifiles and -idirs together.\n");
            bGlblStdInFiles = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-idirs"))  {
            if (bGlblStdInFiles) return 9+perr("cannot use -ifiles and -idirs together.\n");
            bGlblStdInDirs = 1;
            cs.justdirs  = 1;
            continue;
         }
         #ifdef _WIN32
         if (!strcmp(argx[iDir], "-open"))
            { cs.openbyapp = true; continue; }
         #endif
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!cs.runCmd[0])
         {
            if (iGlblInScript) // then argx[iDir] is writeable
               fixMultiLineParm(argx[iDir], 'p'); // run

            cs.runCmd = argx[iDir];

            // special command: echo WITHOUT any valid token
            if (!strcmp(cs.runCmd, "echo")) {
               cs.runCmd = cs.justdirs ? (char*)"echo $quotpath" : (char*)"echo $quotfile";
               cs.sim = 1;
            }
            continue;
         }
         // further non-option keys:
         // short dir parms IF not reading chain
         if (chain.useany()) {
            perr("conflicting parameter: %s\n", argx[iDir]);
            pinf("run is already receiving chain input, so %s is too much.\n", argx[iDir]);
            return 9;
         }
         break; // fall through
      }
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1, &iChainNext))) return lRC;

      if (cs.debug) {
         if (iChainNext)
            printf("[run chainnext is %d: %s]\n",iChainNext,argv[iChainNext]);
         else
            printf("[run has no chainnext]\n");
      }

      bool bAnyToken = 0;

      // sfk1822 fix: check for token in run command
      if (cs.runCmd)
         bAnyToken = anyFileInRunCmd(cs.runCmd, 1); // incl. path, text

      if (!bAnyToken) {
         if (chain.useany()) {
            perr("detected chain input data, but no token found in run command:\n");
            setTextColor(nGlblWarnColor);
            printf("       %s\n", cs.runCmd);
            setTextColor(-1);
            pinf("you may add %cfile or some other token to the run command.\n", glblRunChar);
            pinf("to drop the chain contents, replace +run by \"+then run\".\n");
            pinf("to print them, insert \"+toterm\" or \"+tofile filename\" before +run.\n");
         // pinf("type \"sfk run\" for help. add -verbose to list the chain input on error.\n");
            if (cs.verbose) chain.dumpContents(); // not sure if this helps
            return 9;
         }
         // no token and no chain input: execute simple command once.
         if (!cs.rerun)
            cs.quiet = 1;
         cs.force = 1;
      }

      if (bGlblStdInDirs)
         if (anyFileInRunCmd(cs.runCmd, 0))
            return 9+perr("-idirs only allowed with %cpath, not with file commands.\n", glblRunChar);

      if (chain.usedata)
         chain.convInDataToInFiles();

      // add $qfile implicitely if 1) single word command 2) chain input 3) no -force:
      char *pszDynaRunCmd = 0;
      if (!cs.force && !bAnyToken && chain.usefiles && !strchr(cs.runCmd, ' ')) {
         // in this case, accept trailing "." as a replacement for -yes.
         int nlen = strlen(cs.runCmd);
         if (cs.runCmd[nlen-1] == '.') { cs.yes=1; nlen--; }
         sprintf(szLineBuf, "%.*s \"%cfile\"", (int)nlen, cs.runCmd, glblRunChar);
         cs.runCmd = pszDynaRunCmd = strdup(szLineBuf);
         bAnyToken = 1;
      }
      else
      if (!bAnyToken && !cs.force) {
         if (!cs.runCmd[0])
            perr("empty run command. type \"sfk run\" for help.\n");
         else {
            perr("no valid token in run command: \"%s\". type \"sfk run\" for help.\n", cs.runCmd);
            pinf("you may also add -force to run the command without any tokens.\n");
         }
         return 9;
      }

      // NO RETURN W/O DELETE FROM HERE

      if (btest) { if (pszDynaRunCmd) delete [] pszDynaRunCmd; return 0; }

      cs.sim = !cs.yes;

      if (chain.coldata && cs.sim)
         pwarn("%s will receive no data as long as in simulation.\n", argx[iChainNext]);

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      if (!bAnyToken) {
         // no tokens at all: run command w/o any file input
         if (cs.debug) printf("no token, run string as is: \"%s\"\n", cs.runCmd);
         int lFiles=0, lDirs=0; num nBytes=0;
         Coi ocoi((char*)"?", 0); // dummy
         cs.nonames = 1; // do NOT create a ":file ?" line
         lRC = execRunFile(&ocoi, 0, 0, lFiles, lDirs, nBytes); // todo: -to support
      }
      else
      if (bGlblStdInFiles || bGlblStdInDirs) {
         if (cs.debug) printf("run stdin list using: \"%s\"\n", cs.runCmd);
         lRC = walkStdInListFlat(eFunc_Run, lFiles, nBytes);
      } else {
         if (!anyFileInRunCmd(cs.runCmd, 0))
            cs.justdirs = true;
         if (cs.debug) printf("run on %s using: \"%s\"\n", cs.justdirs?"dirs":"files", cs.runCmd);
         lRC = walkAllTrees(eFunc_Run, lFiles, lDirs, nBytes);
         // tell if sfk didn't check a single file or dir.
         if (!cs.noinfo && !lFiles && !lDirs) { // sfk193 run info
            pinf("no filenames to run.%s\n", cs.verbose ? "":" (-verbose for more)\n");
            if (cs.verbose) {
               pinf("you may try +texttofilenames like: echo name +ttf +run ...\n");
               pinf("you may remove unwanted '%c' file masks from command.\n", glblRunChar);
            }
         }
      }

      // comment on user errors
      if (!cs.quiet && !cs.noinfo && !bGlblStdInAny) {
         if (cs.badNameForm & 1)
            pinf("%d input names contain blanks, but no quotes (or %cqfile) found.\n", cs.blankRunFiles, glblRunChar);
         if (cs.badNameForm & 2)
            pinf("%d input names seem to use %c path separator instead of %c\n", cs.wrongpcRunFiles, glblWrongPChar, glblPathChar);
      }

      if (cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      // NO RETURN W/O DELETE UNTIL HERE
      if (pszDynaRunCmd) delete [] pszDynaRunCmd;

      if (chain.coldata) {
         STEP_CHAIN(iChainNext, 1);
      } else {
         // pass a newly created filename list
         // - if we did not receive a filename list
         // - or if -to outfiles were defined
         STEP_CHAIN(iChainNext, (!chain.usefiles || cs.tomask) ? 1 : 0); // run
      }

      bDone = 1;
   }

   regtest("runloop 1 100 copy_xfilesrc_xfiledst$03i.dat");

   ifcmd (   !strcmp(pszCmd, "runloop") || !strcmp(pszCmd, "printloop") // +wref +var
          || !strcmp(pszCmd, "rerunloop") // internal
         )
   {
      bReRun = strbeg(pszCmd, "rerun");
      ifhelp (nparm < 3)
      printx("<help>$sfk runloop ifrom ito \"your command <run>[digits]i\" [-yes] [-nohead] [-quiet]\n"
             "$sfk runloop ifrom -steps=n [-inc=i] \"your command <run>[digits]i\"\n"
             "$sfk printloop ifrom ito \"your text <run>[digits]i\"\n"
             "\n"
             "   run a self-defined command many times, or simply print text to\n"
             "   the console, with a counter starting at ifrom, running until ito,\n"
             "   or running n times if -steps=n is specified.\n"
             "\n"
             "   with runloop, execution of commands is just simulated by default,\n"
             "   so nothing happens. as soon as your command is looking well, add\n"
             "   option \"-yes\" to really execute.\n"
             "\n"
             "   $options\n"
             "      -inc=i    increment step counter by i instead of 1.\n"
             "      -spat     support slashpatterns like \\t \\q \\xnn.\n"
             "      -delay=n  wait n msec after every executed command.\n"
             "      -nohead   does not display the [simulating:] info text.\n"
             "                printloop is the same as runloop -nohead.\n"
             "      -quiet    does not echo the commands before execution.\n"
             "      -quietrc  do not print rc status message per command.\n"
             "\n"
             "   $command string format\n"
             "      the command string may contain <run>i which is replaced by the\n"
             "      loop counter, or slashpatterns if option -spat is given.\n"
             "      due to syntax limitations of the command shell, it may help\n"
             "      - to use \\q instead of \\\"   (avoids quote miscounting at shell)\n"
             "      - to use \\x26 instead of &  (if ampersand is behaving unexpected)\n"
             "      <run>i also supports format parameters before 'i' like:\n"
             "         <run>5i    print 5 digits, right justified, filled with blanks.\n"
             "         <run>05i   print 5 digits, right justified, filled with zeros.\n"
             "         <run>-5i   print 5 digits, left  justified, filled with blanks.\n"
             "      to print the <run> char itself in output use <run><run>\n"
             "\n");
      printx("   $quoted multi line parameters are supported in scripts\n" // runloop
             "      using parm trim. type \"sfk script\" for details.\n"
             "\n");
      printx("   $aliases\n"
             "      #sfk printloop<def>  do not execute anything but just print\n"
             "                     the resulting text to terminal.\n"
             "\n"
             "   $see also\n"
             "      sfk run - run self-defined command on filenames.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk runloop 1 100 \"copy mytest.dat testfile_<run>03i.dat\" -yes\n"
             "         creates 100 copies of mytest.dat named testfile_001.dat,\n"
             "         testfile_002.dat, testfile_003.dat etc.\n"
             "\n"
             "      #sfk printloop 1 100 -spat \"<a href=\\qhttp://...&page=<run>i\\q><run>i</a>\"\n"
             "         creates html code containing 100 web links. note that \\q was used\n"
             "         instead of \\\", as '&' may create problems when combined with \\\"\n"
             "         (a syntax mess produced by the command shell, not by sfk itself.)\n"
             "         and to enable slash patterns like \\q, -spat had to be added.\n"
             );
      ehelp;

      sfkarg;

      bool bisprint = !strcmp(pszCmd, "printloop");

      bool bHaveFrom=0, bHaveTo=0, bNoRC=0;
      int nfrom = 0;
      int nto   = 0;
      int ninc  = 1;
      int idelay= 0;
      char *pszRunMask = 0;
      int  iChainNext = 0;

      if (bReRun)
         cs.rerun = 1;

      for (; iDir < argc; iDir++)
      {
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;

         if (strBegins(argx[iDir], "-steps=")) {
            if (bHaveTo) return 9+perr("too many parameters before %s",argx[iDir]);
            if (!bHaveFrom) return 9+perr("a start value must be specified before %s",argx[iDir]);
            nto = nfrom + atol(argx[iDir]+7) - 1;
            bHaveTo = 1;
            continue;
         }

         if (strBegins(argx[iDir], "-inc=")) {
            ninc = atol(argx[iDir]+5);
            if (ninc <= 0) return 9+perr("-inc value must be > 0");
            continue;
         }

         if (strBegins(argx[iDir], "-quietrc")) {
            bNoRC = 1;
            continue;
         }

         if (strBegins(argx[iDir], "-delay=")) {
            idelay = atol(argx[iDir]+7);
            if (idelay <= 0) return 9+perr("-delay value must be > 0");
            continue;
         }

         if (sfkisopt(argx[iDir])) {
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unexpected option: %s\n",argx[iDir]);
         }

         // first non-option parm: from value
         if (!bHaveFrom) {
            nfrom = atol(argx[iDir]);
            bHaveFrom = 1;
            continue;
         }
 
         // 2nd non-option parm: to value
         if (!bHaveTo) {
            nto = atol(argx[iDir]);
            bHaveTo = 1;
            continue;
         }

         // 3rd: the run mask
         if (!pszRunMask) {
            if (iGlblInScript) // then argx[iDir] is writeable
               fixMultiLineParm(argx[iDir], 'p'); // runloop
            pszRunMask = argx[iDir];
            continue;
         }

         return 9+pbad(pszCmd, argx[iDir]);
      }

      // do not check for ito >= ifrom, allowing also noop cases.

      if (!bHaveFrom || !bHaveTo || !pszRunMask)
         return 9+perr("missing parameters. type \"sfk runloop\" for help.\n");

      if (btest) return 0;

      char szTokMask[20];

      cs.sim = !cs.yes;
      cs.nohead |= cs.quiet;

      // chaining plausi
      if (chain.colfiles) {
         perr("runloop cannot collect filenames, only text data.\n");
         if (iChainNext)
            pinf("try to insert +texttofilenames or +ttf before %s\n",argx[iChainNext]);
         return 9;
      }
      if (chain.colany())
         cs.nohead = 1;
      if (!bReRun && !cs.sim && chain.colany())
         return 9+perr("output chaining is supported only for simulation output.\n");

      if (!bisprint && cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      copyFormStr(szRunCmdBuf, MAX_LINE_LEN, pszRunMask, strlen(pszRunMask));
      pszRunMask = szRunCmdBuf;

      for (int i=nfrom; i<=nto && !userInterrupt(); i += ninc)
      {
         szLineBuf[0] = '\0';
         char *pszCur = pszRunMask;
         while (1)
         {
            char *pszTok = strchr(pszCur, glblRunChar);
            if (!pszTok)
               break;
            // copy left part before $
            int nBufLen = strlen(szLineBuf);
            sprintf(&szLineBuf[nBufLen], "%.*s", (int)(pszTok-pszCur), pszCur);
            // special case: $$ means $
            if (pszTok[1] == glblRunChar)
            {
               nBufLen = strlen(szLineBuf);
               szLineBuf[nBufLen+0] = glblRunChar;
               szLineBuf[nBufLen+1] = '\0';
               pszCur = pszTok+2;
               continue;
            }
            // isolate token until 'i'
            char *pszTok2 = pszTok;
            while (*pszTok2 && *pszTok2 != 'i')
               pszTok2++;
            if (*pszTok2 != 'i') return 9+perr("wrong syntax, expected %ci somewhere.\n",glblRunChar);
            strcpy(szTokMask, "%d");
            int nTokExtLen = pszTok2-pszTok-1;
            if (nTokExtLen > 0)
               sprintf(szTokMask, "%%%.*sd",(int)nTokExtLen,pszTok+1);
            // use (formatted) token
            nBufLen = strlen(szLineBuf);
            sprintf(&szLineBuf[nBufLen], szTokMask, i);
            // continue with next part
            pszCur = pszTok2+1;
         }
         if (pszCur)
            strcat(szLineBuf, pszCur);

         // now holding full command in szLineBuf.
         if (!cs.quiet && !cs.sim) {
            printf("%s\n", szLineBuf);
            fflush(stdout);
         }

         int iRC = 0;
 
         if (bisprint || cs.sim) {
            // special case: just dump resulting command to terminal
            if (chain.coldata)
               chain.addLine(szLineBuf, str(""));
            else
               printf("%s\n", szLineBuf);
         } else {
            if (cs.rerun) // runloop
               iRC = runExtProg(szLineBuf); // runloop
            else
               iRC = system(szLineBuf);
         }
 
         if (!cs.quiet && !bNoRC && !cs.sim) {
            if (iRC) {
               printf("... rc %d\n", iRC);
               fflush(stdout);
            }
         }
 
         if (idelay > 0)
            doSleep(idelay);
      }

      if (!bisprint && cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      if (chain.coldata) {
         STEP_CHAIN(iChainNext, 1);
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "tohtml")) // internal
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk sel ... +tohtml mode out.html\n"
             "\n"
             "   $mode\n"
             "      piclist      plain image list\n"
             );
      ehelp;

      sfkarg;

      int imode=0;
      int iaspect=0;
      char *pszOutFile=0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!imode && !strcmp(pszArg, "picreader"))
            imode = 1;
         else
         if (!imode && !strcmp(pszArg, "piclist"))
            imode = 2;
         else
         if (!iaspect && (!strcmp(pszArg, "fitw") || !strcmp(pszArg, "land")))
            iaspect = 1;
         else
         if (!iaspect && (!strcmp(pszArg, "fith") || !strcmp(pszArg, "port")))
            iaspect = 2;
         else
         if (!pszOutFile)
            pszOutFile = pszArg;
         else
            return 9+pbad(pszCmd, pszArg);
      }

      if (!imode)
         return 9+perr("missing mode");
      if (!pszOutFile)
         return 9+perr("missing output filename for .html file");
      if (!mystrstri(pszOutFile, ".htm"))
         return 9+perr("no .htm or .html file: %s", pszOutFile);

      if (!iaspect)
         iaspect=1;

      uchar *pInText = 0;
      char  *pInAttr = 0;
      num    nInSize = 0;

      if (loadInput(&pInText, &pInAttr, &nInSize, 0, 0, 1))
         return 9;

      execToHtml(imode, iaspect, (char*)pInText, pszOutFile);

      if (pInText)  delete [] pInText;
      if (pInAttr)  delete [] pInAttr;

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0); // runloop
         }
      }

      bDone = 1;
   }

   #ifdef WITH_FN_INST
   ifcmd (!strcmp(pszCmd, "inst")) // +chaining
   {
      ifhelp (   ( chain.usefiles && (nparm < 2))
              || (!chain.usefiles && (nparm < 3))
             )
      printx("<help>$sfk inst mtkinc mtkmac -dir ... -file ...\n"
             "$sfk inst -revoke[|-redo] [-keep-dates] -dir ... -file ...\n"
             "\n"
             "  instrument c++ sourcecode with calls to sfk micro tracing kernel.\n"
             "  simulates by default. add -yes to apply changes.\n"
             "\n"
             "  $parameters\n"
             "    mtkinc         path and name of mtktrace.hpp file\n"
             "    mtkmac         mtk block entry macro name, _mtkb_\n"
             "\n"
             "  $options\n"
             "    -revoke        undo all changes (copy backups back).\n"
             "                   do not specify mtkinc, mtkmac on -revoke.\n"
             "    -keep-dates    on revoke, also reactivate original file dates\n"
             "    -redo          redo all changes\n"
             "    -witheol       also instrument { at end of line, like in:\n"
             "                   void Foo::bar(int nmode) {\n"
             "\n"
             "       #sfk inst mtk/mtktrace.hpp _mtkb_ -dir testfiles !<sla>save_ -file .cpp\n"
             "          instrument the code (saving all in save_inst dirs)\n"
             "\n"
             "       #sfk inst -revoke -keep-dates -dir testfiles !<sla>save_ -file .cpp\n"
             "          restore original code (copying back from save-inst dirs),\n"
             "          also restoring the original time stamps.\n"
             "\n"
             "       #sfk sel -dir base ext lib -file .cpp +inst mtk/mtktrace.hpp _mtkb_\n"
             "          select the files of interest, and when done, run +inst on them.\n"
             "\n"
             "    NOTE: is is recommended that you do NOT say \"-dir .\" in your batch files\n"
             "          to ensure that instrumenting is always done on the correct path.\n"
             "\n"
             "    read more about the sfk micro tracing kernel in the mtk/ dir.\n"
            );
      ehelp;

      sfkarg;

      #ifdef SFK_MEMTRACE
      bGlblNoMemCheck = 1;
      sfkmem_nocheck();
      #endif // SFK_MEMTRACE

      for (; (iDir < argc) && sfkisopt(argx[iDir]); iDir++)
      {
         // inst-specific prefix options
         if (!strcmp(argx[iDir], "-revoke")) {
            bGlblInstRevoke = 1;
         }
         else
         if (!strcmp(argx[iDir], "-redo")) {
            bGlblInstRevoke = 1;
            bGlblInstRedo   = 1;
         }
         else
         if (!strcmp(argx[iDir], "-keep-dates")) {
            bGlblTouchOnRevoke = 0;
         }
         else
         if (!strcmp(argx[iDir], "-witheol")) {
            bGlblInstEol   = 1;
         }
         else
         if (isDirParm(argx[iDir]))
            break; // fall through
         else
         if (!setGeneralOption(argx, argc, iDir))
            break; // other option, fall through
      }
      if (!bGlblInstRevoke || bGlblInstRedo) {
         // no revoke: expect further parms
         if (iDir >= argc-1) { fprintf(stderr, "error  : inst: missing parms. supply include and macro.\n"); return 9; }
         pszGlblInstInc = argx[iDir++];
         pszGlblInstMac = argx[iDir++];
      }
      int iDirNext=0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext))) return lRC;

      if (!cs.yes) printx("$[simulating:]\n");

      lRC = walkAllTrees(eFunc_Inst, lFiles, lDirs, nBytes);

      if (!cs.yes) printx("$[add -yes to write changes.]\n");

      STEP_CHAIN(iDirNext, 0); // inst

      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "pathfind") || !strcmp(pszCmd, "where"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk pathfind mycmd\n"
             "$sfk where mycmd\n"
             "\n"
             #ifdef _WIN32
             "   search the current directory and the PATH for the location\n"
             "   of a command mycmd. \"where\" is the same as \"pathfind\".\n"
             "\n"
             "   if mycmd does not contain a dot '.', sfk searches for all\n"
             "   extensions listed in PATHEXT, e.g. mycmd.bat, mycmd.exe etc.\n"
             #else
             "   search the PATH for the location of a command mycmd.\n"
             #endif
             "\n"
             "   $chaining support\n"
             "      output chaining is supported.\n"
             "\n"
            );
      webref("pathfind");
      printx("   $examples\n"
             "      #sfk where sfk.exe\n"
             "         tell location of sfk.exe\n"
             "      #sfk where sfk.exe +setvar ownpath +getvar\n"
             "         store location of sfk.exe in a variable,\n"
             "         then list all variables\n"
             );
      ehelp;

      sfkarg;

      char *pszName = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!pszName)
            { pszName=pszArg; continue; }
         return 9+pbad(pszCmd, pszArg);
      }

      if (!pszName) return 9+perr("supply a command name to search within PATH.\n");

      lRC = 0;

      #ifdef _WIN32
      if (!strchr(pszName, '.'))
      {
         // user did NOT supply .bat etc: search for every possible extension
         int nhits = listPathAny(pszName, 0); // 0: not silent
         if (!nhits) {
            if (!cs.quiet)
               printf("nothing like %s found within PATH and current dir.\n", pszName);
            lRC = 1;
         }
      }
      else
      #endif
      {
         char *pszAbs = findPathLocation(pszName);
         if (!pszAbs) {
            if (!cs.quiet) {
               #ifdef _WIN32
               printf("%s not found within PATH and current dir.\n", pszName);
               printf("... try also .exe, .bat, .cmd extensions.\n");
               #else
               printf("%s not found anywhere within PATH.\n", pszName);
               #endif
            }
            lRC = 1;
         } else {
            chain.print("%s\n", pszAbs);
         }
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   regtest("deblank xdir .cpp .hpp");
   regtest("list xdir +deblank -dir xdir");

   ifcmd (!strcmp(pszCmd, "deblank")) // +wref
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk deblank dirname [.ext1] [.ext2] [...]\n"
             "\n"
             "   remove blanks from filenames and directory names.\n"
             "   simulates by default. add -yes to apply changes.\n"
             "\n");
      webref("deblank");
      printx("   $examples\n"
             "\n"
             "      #sfk deblank docs\n"
             "         lists all directories and files within docs having\n"
             "         blanks in their names, previewing changes.\n"
             "\n"
             "      #sfk select docs +deblank\n"
             "         deblanks only the names of files, not of directories.\n"
             "\n"
             "      #sfk select -withdirs docs +deblank\n"
             "         deblanks filenames and directories.\n"
            );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argx[iDir], "-packalnum")) {
            cs.packalnum = 1;
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break; // fall through
      }

      // sfk deblank -yes
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1, &iChainNext))) return lRC;
      if (btest) return 0;

      if (!cs.yes) printx("$[simulating:]\n");
      lRC = walkAllTrees(eFunc_Deblank, lFiles, lDirs, nBytes);
      if (!cs.yes) printx("$[add -yes to execute.]\n");

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   regtest("reflist -dir xdir1 xdir2");

   ifcmd (!strcmp(pszCmd, "reflist") || !strcmp(pszCmd, "deplist")) // +wref
   {
      cs.deplist = !strcmp(pszCmd, "deplist");

      ifhelp (nparm < 2)

      // if dumping all help text, run two passes
      for (int i=0; i<2; i++) {

      if (!cs.deplist)
      printx("<help>$sfk reflist [-path] [-wide] -dir sdir -file .text -dir tdir -file .sext\n"
             "$sfk reflist -dir sourcedir -dir targetdir1 [targetdir2 targetdir3] [...]\n"
             "\n"
             "   list possible dependencies between files through (fuzzy) content analysis.\n"
             "   find out which target files are referenced by any of the source files.\n");
      else
      printx("<help>$sfk deplist [-flat] -dir srcdir [-file ...] -dir targdir [-file ...]\n"
             "$sfk deplist [-flat] singleSourceFile -dir targdir [tdir2 tdir3] [-file ...]\n"
             "\n"
             "   list possible dependencies between files through (fuzzy) string analysis.\n"
             "   find out on which target files the specified source files depend.\n");

      printx("\n"
             "   a list of target files is created from directory targdir. then all source\n"
             "   files are loaded from srcdir, and scanned if the names of the targets appear\n");

      if (!cs.deplist)
      printx("   within their content. if so, the targets are listed, with the number of\n"
             "   referring source files, and a list (of the first 10) of these files.\n"
             "\n"
             "   NOTE that sfk reflist DOES NOT GUARANTEE that files are (not) referenced.\n"
             "   This way of reference detection is just a FUZZY INDICATOR, so keep thinking\n"
             "   and make backups before you massively cleanup files without references!\n"
             "\n");
      else
      printx("   within their content. if so, the sources are listed with their dependencies.\n"
             "\n"
             "   by default, deplist also checks which targdir files depend on other targdir\n"
             "   files (recursive dependencies), resulting in more complete listings.\n"
             "   specify -flat to disable recursive checks.\n"
             "\n"
             "   if you specify just a singleSourceFile name, the source name is NOT included\n"
             "   in the output (unless -incsrc specified), and the filename list can be used\n"
             "   by subsequent (chained) commands.\n"
             "\n");

      printx("   NOTE: you may specify any number of target directories. if your list of\n"
             "   target directories is incomplete, files from there will NOT be found.\n"
             "\n");

      printx("   by default, only relative target filenames are searched, without path,\n"
             "   but including the file name extension.\n"
             "\n"
             "                   e.g. the target file: #the/path/foosys.dll\n"
             "                      runs a search for: #foosys.dll\n"
             "                    in the source files.\n"
             "\n"
             "   $options\n"
             "      -path        search target filenames including path information.\n"
             "                   e.g. the target file: #the/path/foosys.dll\n"
             "                      runs a search for: #the/path/foosys.dll\n"
             "      -noext       strip .extensions from filenames, compare only basename.\n"
             "                   e.g. the target file: #the/path/foosys.dll\n"
             "                      runs a search for: #foosys\n"
             "                   which may lead to ambiguities, listing too many hits.\n"
             "                   -noext can also be combined with -path.\n");
      if (!cs.deplist)
      printx("      -wide[=n]    list references in an extended format, with a list of\n"
             "                   (up to to n) source files per target file, telling in\n"
             "                   detail which text patterns were found.\n");
      printx("      -case        force case sensitive string comparison (not default).\n"
             "      -quiet       do not print the number of source and target files.\n"
             "      -relnames    if using -path, strip targdir name from target paths\n"
             "                   for comparison.\n"
             "      -flat        do not check if target files depend on other target files.\n"
             "                   set this to improve speed, if you know that such\n"
             "                   dependencies cannot exist, e.g. if the targets are .wav files.\n"
             "      -memlimit=n  load and analyze only files with a size up to n mbytes.\n"
             "                   the default load limit is 300 mbytes.\n"
             "\n");
      if (!cs.deplist)
      printx("   $see also\n"
             "      #sfk deplist<def>  list file dependencies.\n");
      else
      printx("   $see also\n"
             "      #sfk reflist<def>  list file references.\n");
      printx("\n");
      webref(pszCmd);
      printx("   $examples\n");

      if (!cs.deplist)
      printx("      #sfk reflist -dir mysrcdir mytargdir\n"
             "         check every file in mytargdir if it is referenced\n"
             "         by any file within mysrcdir.\n"
             "\n"
             "      #sfk reflist -dir movie -file .ppt -dir pic -file .png\n"
             "         find out which .png files within pic are referenced\n"
             "         by .ppt files within movie.\n"
             "\n"
             "      #sfk reflist -wide=100 -dir bin -file .exe -dir bin -file .dll\n"
             "         find out which .dlls are directly referenced by .exe files\n"
             "         within directory bin, listing up to 100 references per target.\n"
             "\n"
             "      #sfk reflist -dir . -file .flp -dir . -file .wav\n"
             "         within a FruityLoops project directory lists which .wav files\n"
             "         are referenced by which .flp project files of that directory.\n"
             "\n"
             "      #sfk reflist -dir film -file .ppj -dir audio frames clips\n"
             "         tell which audio, image and movie clip files (e.g. .wav .bmp .avi)\n"
             "         are used by which Adobe Premiere project files (.ppj) within the\n"
             "         film directory. if image sequences are used, only the first image\n"
             "         of such sequences will be found, e.g. foobar00001.bmp\n"
            );
      else
      printx(
             "      #sfk deplist -dir bin -file .exe -dir lib1 lib2 lib3 -file .dll\n"
             "         create a list of all .exe files in bin, and the dlls they depend on,\n"
             "         searching for dlls in lib1, lib2 and lib3 directories.\n"
             "\n"
             "      #sfk deplist bin\\diff.exe -dir bin -file .dll +run \"copy <run>file tmp\"\n"
             "         find out which .dlls are used by diff.exe, and copy them to tmp.\n"
             "\n"
             "      #sfk deplist -relnames -case -path -noext -dir classes -dir classes\n"
             "         find dependencies between java .class files. -path uses path infos,\n"
             "         -noext strips \".class\", -case keeps the capital letters within names.\n"
             "         -relnames strips \"classes/\" from target names for comparison.\n"
             "\n"
             "      #sfk deplist -flat -dir . -file .flp -dir . -file .wav\n"
             "         within a FruityLoops project directory lists which .flp project\n"
             "         files are using which .wav files of that directory. note that\n"
             "         .wav files cannot \"use\" other .wav files, therefore -flat was set\n"
             "         to avoid recursive target checks, speeding up the search.\n"
            );

      if (bhelp) { cs.deplist = cs.deplist ? 0 : 1; printx("\n"); } else break; }
      // end of two passes if dumping all help text

      ehelp;

      sfkarg;

      bool bIncDstAsSrc  = 0;
      char *pszSingleSrc = 0;
      bool bIncSrc       = 0;
      bool bAutoMax      = 0;

      memset(abGlblRefChars, 0, sizeof(abGlblRefChars));

      if (cs.deplist) {
         bGlblRefWideInfo  = 1;
         bAutoMax          = 1;  // will auto-adapt RefMaxSrc
         bIncDstAsSrc      = 1;
      }

      int iChainNext = 0;
      for (; iDir < argc; iDir++)
      {
         if (!strncmp(argx[iDir], "-wide=", 6)) {
            // user-selected list truncation
            bGlblRefWideInfo = 1;
            nGlblRefMaxSrc   = atol(argx[iDir]+6);
            continue;
         }
         else
         if (!strcmp(argx[iDir], "-wide")) {
            bGlblRefWideInfo = 1;
            bAutoMax         = 1;  // will auto-adapt RefMaxSrc
            continue;
         }
         else
         if (!strcmp(argx[iDir], "-path") || !strcmp(argx[iDir], "-abs")) {
            bGlblRefRelCmp = 0;
            continue;
         }
         else
         if (!strcmp(argx[iDir], "-noext") || !strcmp(argx[iDir], "-base")) {
            bGlblRefBaseCmp = 1;
            continue;
         }
         else
         if (!strcmp(argx[iDir], "-incsrc")) {
            bIncSrc = 1;
            continue;
         }
         else
         if (!strcmp(argx[iDir], "-flat")) {
            bIncDstAsSrc = 0;
            continue;
         }
         else
         if (!strncmp(argx[iDir], "-fast", 5)) {
            // yet experimental: strip chars from sources input.
            // do not strip all printable chars, except if fast2.
            if (strcmp(argx[iDir], "-fast2"))
               for (uint uc=0; uc<256; uc++)
                  if (isprint((char)uc))
                     abGlblRefChars[uc] = 1;
            cs.refstripsrc = 1;
            continue;
         }
         else
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option parameter:
         if (!cs.deplist)
            return 9+perr("unexpected: %s\n", argx[iDir]);
         // expect single source file name
         if (pszSingleSrc)
            return 9+perr("only one source file name supported, %s is unexpected.\n",argx[iDir]);
         pszSingleSrc = argx[iDir];
         if (!fileExists(pszSingleSrc))
            return 9+perr("no such file: %s\n", pszSingleSrc);
         cs.depsingle = 1;
      }
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iChainNext))) return lRC;

      // check input: only two dir roots allowed
      if (!pszSingleSrc && glblFileSet.numberOfRootDirs() < 2)
         return 9+perr("need at least two root dirs, for sources and targets.\n");

      if (chain.colfiles) {
         if (cs.depsingle) {
            cs.quiet = 1;
         } else {
            perr("filename chaining is not supported this way.\n");
            if (cs.deplist) {
               pinf("try specifying a single source filename.\n");
            }
            return 9;
         }
      }

      if (btest) return 0;

      // tree layer 0: targets
      // tree layer 1: sources
      int rlFiles=0, rlDirs=0;
      FileList oDirFiles;
      num  rlBytes = 0, nLocalMaxTime = 0, nTreeMaxTime  = 0;

      // ===== collect list of sources to determine nGlblRefMaxSrc =====
      int isrcroot = 0;
      int idstroot = 1;
      nGlblFunc = eFunc_RefColSrc;
      if (pszSingleSrc) {
         if (execRefColSrc(pszSingleSrc))
            return 9;
         idstroot = 0;
      } else {
         char *pszTree = glblFileSet.setCurrentRoot(isrcroot);
         if (cs.debug) info.print("] src: %s\n", pszTree);
         if (!isDir(pszTree)) return 9+perr("no such directory: %s\n", pszTree);
         Coi *pcoi = new Coi(pszTree, 0); // no relroot, is absolute
         int nrc = walkFiles(pcoi, 0, rlFiles, oDirFiles, rlDirs, rlBytes, nLocalMaxTime, nTreeMaxTime);
         if (!pcoi->refcnt()) delete pcoi;
         if (nrc) return 9;
      }
      int nSrcToList = glblRefSrc.numberOfEntries();
      if (bIncDstAsSrc) {
         // deplist: auto-include destinations as sources.
         // nSrcToList tells how many sources will be listed in output.
         cs.coldstnames = 1;
         for (int iroot=idstroot; iroot<glblFileSet.numberOfRootDirs(); iroot++) {
            char *pszTree = glblFileSet.setCurrentRoot(iroot);
            if (cs.debug) info.print("] dst: %s [included as src]\n", pszTree);
            if (!isDir(pszTree)) return 9+perr("no such directory: %s\n", pszTree);
            Coi *pcoi = new Coi(pszTree, 0); // no relroot, is absolute
            int nrc = walkFiles(pcoi, 0, rlFiles, oDirFiles, rlDirs, rlBytes, nLocalMaxTime, nTreeMaxTime);
            if (!pcoi->refcnt()) delete pcoi;
            if (nrc) return 9;
         }
      }
      if (!cs.quiet) {
         if (bIncDstAsSrc)
            info.print("%05u source files (%u internal sources)\n", nSrcToList, cs.refsrccnt);
         else
            info.print("%05u source files\n", cs.refsrccnt);
      }

      // auto-adapt nGlblRefMaxSrc
      if (bAutoMax && (cs.refsrccnt + 10 > nGlblRefMaxSrc))
         nGlblRefMaxSrc = cs.refsrccnt + 10;

      // setup reference table
      glblRefDst.addRow(__LINE__); // for dst file names
      glblRefDst.addRow(__LINE__); // for dst ref counts
      int i=0;
      for (i=0; i<nGlblRefMaxSrc; i++) {
         glblRefDst.addRow(__LINE__); // for source infos
      }

      // ===== collect list of targets (execRefColDst) =====
      nGlblFunc = eFunc_RefColDst;
      if (bIncDstAsSrc) {
         // have scanned dest. files already, reuse memory list.
         for (i=0; i<glblRefDstNames.numberOfEntries(); i++) {
            char *pszFile = glblRefDstNames.getEntry(i, __LINE__);
            Coi ocoi(pszFile, 0);
            if (execRefColDst(&ocoi))
               return 9;
         }
      } else {
         // have not scanned dest. yet, scan now.
         for (int iroot=idstroot; iroot<glblFileSet.numberOfRootDirs(); iroot++) {
            char *pszTree = glblFileSet.setCurrentRoot(iroot);
            if (cs.debug) info.print("] dst: %s\n", pszTree);
            if (!isDir(pszTree)) return 9+perr("no such directory: %s\n", pszTree);
            Coi *pcoi = new Coi(pszTree, 0); // no relroot, is absolute
            int nrc = walkFiles(pcoi, 0, rlFiles, oDirFiles, rlDirs, rlBytes, nLocalMaxTime, nTreeMaxTime);
            if (!pcoi->refcnt()) delete pcoi;
            if (nrc) return 9;
         }
      }
      if (!cs.quiet)
         info.print("%05u target files\n", glblRefDst.numberOfEntries(0));

      // ===== process potential sources (execRefProcSrc) =====
      /*
      fprintf(stderr, "excluded char map dump:\n");
      for (uint i=65; i<155; i++)
         if (!abGlblRefChars[i])
            fprintf(stderr, "%c", (char)i);
      fprintf(stderr, "\n");
      */
      for (i=0; i<cs.refsrccnt; i++) {
         char *pszsrc = glblRefSrc.getEntry(i, __LINE__);
         if (execRefProcSrc(pszsrc, 0, i, cs.refsrccnt))
            return 9;
      }
      info.clear();

      if (!bGlblEscape)
      if (cs.deplist) {
         // dump dependency list
         for (int isrc=0; isrc<nSrcToList; isrc++)
         {
            char *pszSrc = glblRefSrc.getEntry(isrc, __LINE__);
            StringTable asrc;
            bool bprinted = 0;
            if (bIncSrc || !pszSingleSrc) bprinted = 2; // dump a tab
            listDependencies(asrc, pszSrc, 0, bIncSrc || (pszSingleSrc ? 0 : 1), bprinted);
            chain.print(' ', 1, ""); // 1: with post-lf
         }
      } else {
         // dump reference list
         for (int idst=0; idst<glblRefDst.numberOfEntries(0); idst++)
         {
            char *pszDst  = glblRefDst.getString(0, idst);
            int  nRefCnt = glblRefDst.getLong(1, idst, __LINE__);
            if (nRefCnt > 0) {
               chain.print('i', 0, "%05u %s       ", (unsigned int)nRefCnt, pszDst);
               if ((nRefCnt > 0) && bGlblRefWideInfo) {
                  chain.print(' ', 2, "      :ref:\t"); // 2: with pre-lf (newline)
               } else {
                  chain.print(' ', 0, "<- "); // within same line
               }
               int nDump = nRefCnt;
               if (nDump > nGlblRefMaxSrc)
                  nDump = nGlblRefMaxSrc;
               for (i=0; i<nDump; i++)
               {
                  char *pszSrc  = glblRefDst.getString(2+i, idst);
                  chain.print(' ', 0, "%s ", pszSrc); // within same line
                  if (bGlblRefWideInfo && (i<nDump-1)) {
                     chain.print(' ', 2, "      :ref:\t"); // 2: with pre-lf
                  }
               }
               chain.print(' ', 1, ""); // 1: with post-lf
            } else {
               chain.print(' ', 0, "%05u %s", (unsigned int)nRefCnt, pszDst); // with lf
               chain.print(' ', 1, ""); // 1: with post-lf
            }
         }
      }

      // if reflists are incomplete, warn about it
      if (bGlblRefLimitReached) {
         printx("<warn>lists of source files have been truncated at the %dth entry.<def>\n",nGlblRefMaxSrc);
         printx("<time>use option -wide[=n] to list more source files per target.<def>\n");
      }

      // cleanup
      info.setStatus("wait", "cleaning up memory");
      glblRefDst.reset();
      glblRefSrc.resetEntries();
      glblRefDstNames.resetEntries();
      info.clear();

      // pass created text to next chain command, if any
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "echo")  // +wref +var
          || !strcmp(pszCmd, "tell")
         )
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk echo [options] string [string2] [string3] [...]\n"
             "$sfk tell [-spat] string [string2] [string3] [...]\n"
             "\n"
             "   prints the supplied string, which may contain color patterns:\n"
             "\n"
             "       [Red][[Red]][def],[Green][[Green]][def],[Blue][[Blue]][def],"
                    "[Yellow][[Yellow]][def],[Cyan][[Cyan]][def],[Magenta][[Magenta]][def]   (bright)\n"
             "       [red][[red]][def],[green][[green]][def],[blue][[blue]][def],"
                    "[yellow][[yellow]][def],[cyan][[cyan]][def],[magenta][[magenta]][def]   (dark)\n"
             "         print the following text in the selected color.\n"
             "\n"
             "       $[[def]]<def>\n"
             "         switch back to default color.\n"
             "\n"
             "       $[[[[<def> print the '[[' character, no not interpret the following word.\n"
             "       $]]]]<def> print the ']]' character, do not interpret it.\n"
             "\n"
             "   $options:\n"
             "      -literal  or -lit disables everything, even color patterns,\n"
             "                i.e. words in brackets like [[red]] are not changed.\n"
             "      -noline   stay in the same line, print no linefeed.\n"
             "                if your string ends with \\r, -noline is assumed.\n"
             "                for command chaining -noline requires -literal\n"
             "                and a command accepting binary data, like xed:\n"
             "                   #sfk echo -lit -noline \"%%1\" +xed ...\n"
             "      -pure     same as -literal -noline. use this always to send\n"
             "                chain input data as unchanged as possible, like\n"
             "                filenames from parameters, to following commands:\n"
             "                   #sfk echo -pure \"%%1\" +xed \"_/_\\\\_\" ...\n"
             "      -stream   no extra linefeeds, no colors, binary transfer.\n"
             "                best for following +setvar or +xed commands.\n"
             "      -spat     activates slash patterns: \\t=TAB \\q=\" \\r=CR \\n=LF\n"
             "                \\xnn = any code with hex value nn. can be given\n"
             "                after -lit to use slash patterns without colors.\n"
             "      -join[line]  join all into one line. line ends are stripped\n"
             "                from quoted multi line parms (full trim). multiple\n"
             "                string parameters are joined without blanks.\n"
             "      -lines    print every given string as a single line.\n"
             "\n");
      printx("   $command chaining support\n"
             "\n"
             "      $sfk tell<def>  just prints to terminal, and never sends text\n"
             "                to a following command. always prefer this\n"
             "                if you just want to print an info to terminal.\n"
             "\n"
             "      $sfk echo<def>  will send the given text to a following command\n"
             "                if it accepts text or filename list input.\n"
          // "\n"
          // "      to send a single string as unchanged as possible to a command\n"
          // "      accepting binary data, like xed, use -literal -noline.\n"
             "\n"
             "      by default, echo produces only text data, not filenames.\n"
             "      to send this to file commands use +texttofilenames or +ttf.\n"
             "      echo -lines may produce filename lists directly.\n"
             "\n");
      printx("   $quoted multi line parameters are supported in scripts\n" // echo
             "      using auto indent. type \"sfk script\" for details.\n"
             "      use option -joinline to apply full trim.\n"
             "\n");
      printx("   $see also:<def> sfk help colors\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk tell \"[[Red]]error:[[def]] missing filename.\"\n"
             "         prints \"[Red]error:[def] missing filename.\" onto terminal.\n"
             "\n"
             "      #sfk tell [[Cyan]]NOTE:[[def]] type the word [[[[red]]]] with brackets!\n"
             "         prints \"[Cyan]NOTE:[def] type the word [[red]] with brackets!\" onto terminal.\n"
             "\n"
             "      #sfk echo \"[[Green]]mytext contains:[[def]]\" +then filter mytext.txt\n"
             "         $+then<def> forces echo $not<def> to pass its text to filter, but to\n"
             "         print it immediately. filter then prints the content of mytext.\n"
             "\n"
             "      #sfk tell \"[[Green]]mytext contains:[[def]]\" +filter mytext.txt\n"
             "         same as above, but shorter. tell never sends text to following\n"
             "         commands therefore +then is not required.\n"
             #ifdef _WIN32
             "\n"
             "      #sfk tell -nocconv -spat \"\\xc9\\xcd\\xbb\\n\\xba \\xba\\n\\xc8\\xcd\\xbc\\n\"\n"
             "         print a graphical box using extended dos characters.\n"
             "         more infos under $sfk ascii -dos<def> and $sfk help opt<def>\n"
             #endif
             "\n"
             "      #sfk echo -spat \"foo\\nand\\nbar\" +tofile mydir\\test1.txt\n"
             "         create a small text file with three text lines\n"
             "\n"
             "      #sfk tell -spat \"\\x2b++foo+++\"\n"
             "         print the word 'foo' surrounded by plus characters.\n"
             "         first plus must be masked as \\x2b otherwise sfk thinks\n"
             "         it is the next chain command.\n"
             "\n"
             "      #sfk echo -pure \"C:\\in.txt\" +xed -dump\n"
             "         send the string C:\\in.txt as unchanged as possible to xed\n"
             "         and create a hexdump, to check that no (CR)LF was added.\n"
             "\n"
             "      #sfk echo -pure -spat \"foo\\tbar\" +xed -dump\n"
             "         send the word \"foo\" followed by tab character then \"bar\"\n"
             "         to xed and create a hexdump. \"\\t\" is changed by -spat.\n"
             "\n"
             "      #sfk echo -lines 100 101 102 +perline \"web .$$text/status.xml\"\n"
             "         load page /status.xml from three local ip's .100, .101, .102\n"
             );
      ehelp;

      sfkarg;

      bool bTell = strcmp(pszCmd, "tell") ? 0 : 1;
      bool bEcho = bTell ? 0 : 1;
      bool bNoLine = 0;
      abBuf[0] = '\0';
      int  iChainNext = 0;
      bool bfirst = 1;
      bool bNoBlank = 0;
      bool bAsLines = 0;
      bool bstream  = 0;
      int  iIndent  = 0;
      int  iLinesArgMin = 0;
      int  iLinesArgMax = 0;
      char ctrimparm = 'i';

      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-ind", &pszParm)) {
            if (!iGlblInScript)
               return 9+perr("-ind[ent] can be used only within a script.");
            if (!pszParm) return 9;
            iIndent = atoi(pszParm);
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-indent", &pszParm)) {
            if (!pszParm) return 9;
            iIndent = atoi(pszParm);
            continue;
         }
         if (!strcmp(pszArg, "-noline")) {
            bNoLine = 1;
            continue;
         }
         if (!strcmp(pszArg, "-pure")) {
            cs.spat = 0;
            cs.wpat = 0;
            bNoLine = 1;
            continue;
         }
         if (strBegins(pszArg, "-join")) {  // sfk187
            ctrimparm = 't';
            bNoBlank = 1;
            continue;
         }
         if (!strcmp(pszArg, "-stream")) {  // sfk1935 internal
            // no linefeeds, no colors, binary transfer
            bstream   = 1;
            ctrimparm = 't';
            cs.wpat   = 0;
            continue;
         }
         if (!strcmp(pszArg, "-lines")) {
            bAsLines = 1;
            continue;
         }
         if (!strcmp(pszArg, "-noblank")) {  // deprecated by -join,
            bNoBlank = 1;                    // kept for compat
            continue;
         }
         if (!strcmp(pszArg, "-ftrim")) { // internal
            ctrimparm = 't';
            continue;
         }
         if (sfkisopt(pszArg))
         {
            // any indicator that this is not an option?
            char *psz = pszArg+1;
            bool baca = *psz ? 1 : 0; // all chars alphabetic
            for (; *psz; psz++)
               if (!isalpha(*psz))
                  { baca = 0; break; }
            // special cases
            if (!strcmp(pszArg, "-yes+"))
               baca = 1;

            if (!baca)  // e.g. ---===---
               { }      // fall through, take as text
            else
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;

         // sfk1973: clear possible info output with tell
         if (bTell) info.clear();

         // process non-option keywords:

         // if multiple strings are supplied, insert blanks:
         if (!bfirst && !bNoBlank)
            strcat((char*)abBuf, " ");
         bfirst = 0;

         // append another echo string, converting \t etc.

         if (iGlblInScript) // then pszArg is writeable
            fixMultiLineParm(pszArg, ctrimparm, iIndent); // 'i' echo

         char *pszsrc = pszArg;
         int  nsrclen = strlen(pszsrc);
         char *pszdst = (char*)abBuf + strlen((char*)abBuf);
         int  nmaxdst = MAX_ABBUF_SIZE - strlen((char*)abBuf);
         copyFormStr(pszdst, nmaxdst, pszsrc, nsrclen);
         // just copies if no -spat is given

         if (bAsLines) {
            bfirst = 1;
            if (iLinesArgMin == 0)
               iLinesArgMin = iDir;
            iLinesArgMax = iDir;
         }
      }

      if (bAsLines)
      {
         // echo -lines supports filename transfer.
         for (int i=iLinesArgMin; i<=iLinesArgMax; i++)
         {
            char *pszLine = argx[i];
            if (bEcho && chain.colfiles) {
               Coi ocoi(pszLine, 0);
               chain.addFile(ocoi); // is copied
            }
            else if (bEcho && chain.coldata) {
               chain.addLine(pszLine, str(""), 0);
            }
            else {
               printf("%s\n", pszLine);
            }
         }

         STEP_CHAIN(iChainNext, bEcho); // sfk181 echo -lines always
      }
      else
      {
         // if constructed string ends with \r, imply -noline
         int nlen = strlen((char*)abBuf);
         if (nlen > 0 && abBuf[nlen-1] == '\r')
            bNoLine = 1;
 
         if (!cs.wpat) {
            // do not interpret any [red] etc. commands
            if (bEcho && chain.coldata) {
               if (bNoLine) {
                  if (bstream || chain.colbinary)
                     chain.addBinary(abBuf, strlen((char*)abBuf)); // sfk1840
                  else
                     chain.addToCurLine((char*)abBuf, str(""), 0);
               } else {
                  if (bstream)
                     chain.addBinary(abBuf, strlen((char*)abBuf)); // sfk1935
                  else
                     chain.addLine((char*)abBuf, str(""), 2); // splitbylf, also on termlf
               }
            } else {
               printf("%s%s",(char*)abBuf,bNoLine?"":"\n");
            }
         } else {
            // default: support [red] etc.
            uint nflags = bNoLine ? 1 : 0;
            if (bTell)
                 nflags |= 2;
            printEcho(nflags, "%s", (char*)abBuf);
         }

         if (iChainNext) {
            if (bEcho) {
               STEP_CHAIN(iChainNext, chain.coldata); // sfk181 echo always
            } else {
               chain.usedata = 0; // nopass.tell, fix sfk189 tell ... +setvar
               STEP_CHAIN(iChainNext, 0);
            }
         }
      }

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "time")  
          || !strcmp(pszCmd, "unixtime")
          || !strcmp(pszCmd, "clock")
          || !strcmp(pszCmd, "clock2")
          || !strcmp(pszCmd, "clock3")
          || !strcmp(pszCmd, "date")   // sfk197
         )
   {
      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      printx("<help>$sfk time [options] [format]\n"
             "$sfk clock[2]\n"
             "\n"
             "   prints the current date and time, or shows\n"
             "   a clock with absolute and relative time.\n"
             "\n"
             "   $format:\n"
             "      Y = year\n"
             "      M = month\n"
             "      D = day\n"
             "      h = hour\n"
             "      m = minute\n"
             "      s = second\n"
             "      any other char is passed through.\n"
             "      default format is YMDhms.\n"
             "\n"
             "   $options\n"
             "      -nice      print format Y-M-D h:m:s\n"
             "      -spat      support slash patterns \\t etc.\n"
             "      -from n    print unix timestamp n as human readable time.\n"
             "      -strfpat   use alternative formats chars as defined by\n"
             "                 the strftime c function (but without %%).\n"
             "\n"
             "   $aliases\n"
             "      #sfk date<def>       show just the date\n"
             "      #sfk clock2<def>     show just a relative time\n"
             #ifdef _WIN32
             "      #sfk clock3<def>     also shows overall start time\n"
             "                     and (on Enter) a second column with\n"
             "                     relative time since overall start\n"
             "\n"
             "   $interactive control<def>\n"
             "      press Enter while displaying sfk clock\n"
             "      to reset the relative time.\n"
             #endif
             "\n"
             );
      printx("   $chaining support\n"
             "      cannot use chain input data.\n"   // sfk1833
             "\n"
             "   $see also\n"
             "      #sfk unixtime<def>   prints the unix timestamp\n"
             "      #sfk sleep<def>      delay execution for some time\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk time -spat \"Y-M-D\\th:m:s\" +filt -tabform \"<run>col2 <run>col1\"\n"
             "         prints 2011-06-16 06:17:31 to terminal,\n"
             "         with a tab character between date and time,\n"
             "         post processing the output by sfk filter.\n"
             "      #sfk clock\n"
             "         permanently show absolute and relative time.\n"
             "\n"
             );
      ehelp;

      sfkarg;

      bool bUnixTime = strcmp(pszCmd, "unixtime") ? 0 : 1;
      bool bJustDate = strcmp(pszCmd, "date") ? 0 : 1;

      int   iChainNext = 0;
      num   nFromTime = 0;
      bool  bClock  = strBegins(pszCmd, "clock") ? 1 : 0;
      bool  bClock2 = strcmp(pszCmd, "clock2") ? 0 : 1;
      bool  bClock3 = strcmp(pszCmd, "clock3") ? 0 : 1;
      bool  bstrftime = 0;

      char *pszFormatMask = bClock ? str("Y-M-D h:m:s") : 0;

      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-from", &pszParm)) {
            if (!pszParm) return 9;
            nFromTime = myatonum(pszParm);
            continue;
         }
         if (!strcmp(pszArg, "-nice")) {
            if (bJustDate)
               pszFormatMask = str("Y-M-D");
            else
               pszFormatMask = str("Y-M-D h:m:s");
            continue;
         }
         if (!strcmp(pszArg, "-strfpat")) // sfk197
            { bstrftime = 1; continue; }
         if (sfkisopt(argx[iDir]))
         {
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:
         if (!pszFormatMask)
            pszFormatMask = argx[iDir];
         else
            return 9+pbad(pszCmd,argx[iDir]);
      }

      num tstart  = getCurrentTime();
      num tstart2 = tstart;
      int iRelSec = 0, iLastRelSec = -1;
      int iRelSec2= 0;
      bGlblEnter  = 0;
      bool btwotimes = 0;
      szLineBuf3[0] = '\0';

      while (!userInterrupt(1,0)) // with enter detect
      {
         num nTime = nFromTime ? nFromTime : mytime(NULL);
   
         if (bUnixTime)
         {
            numtoa(nTime, 10, szLineBuf2);
         }
         else
         {
            if (!pszFormatMask) {
               if (bJustDate)
                  pszFormatMask = str("YMD");
               else
                  pszFormatMask = str("YMDhms");
            }

            // get current time
            struct tm *pLocTime = 0;
            mytime_t nTime2 = (mytime_t)nTime;
    
            pLocTime = mylocaltime(&nTime2);      // may be NULL
    
            struct tm oNullTime;
            mclear(oNullTime);
    
            if (!pLocTime)
               pLocTime = &oNullTime;
    
            // apply slash patterns
            if (cs.spat) {
               copyFormStr(szLineBuf3, MAX_LINE_LEN, pszFormatMask, strlen(pszFormatMask), 0);
               pszFormatMask = szLineBuf3;
            }

            /*
               strftime target mask chars
                  a  abbreviated weekday
                  A  full        weekday
                  b  abbreviated month
                  B  full        month
            */

            // format according to mask
            char *psz1 = pszFormatMask;
            char *psz2 = szLineBuf;
            for (;*psz1;psz1++)
            {
               if (bstrftime)
               {
                  if (isalpha(*psz1))
                     { *psz2++ = '%'; *psz2++ = *psz1; }
                  else
                     *psz2++ = *psz1;
               }
               else switch (*psz1)
               {
                  case 'Y': *psz2++ = '%'; *psz2++ = 'Y'; break;
                  case 'M': *psz2++ = '%'; *psz2++ = 'm'; break;
                  case 'D': *psz2++ = '%'; *psz2++ = 'd'; break;
                  case 'h': *psz2++ = '%'; *psz2++ = 'H'; break;
                  case 'm': *psz2++ = '%'; *psz2++ = 'M'; break;
                  case 's': *psz2++ = '%'; *psz2++ = 'S'; break;
                  default : *psz2++ = *psz1;
               }
            }
            *psz2 = '\0';
            strftime(szLineBuf2, MAX_LINE_LEN, szLineBuf, pLocTime);
            if (bClock3 && !szLineBuf3[0]) {
               char *psz = strchr(szLineBuf2, ' ');
               if (psz)
                  sprintf(szLineBuf3, " <time>* %s<def>", psz+1);
            }
         }

         if (bClock) 
         {
            if (bGlblEnter) {
               printf("\n");
               bGlblEnter = 0;
               tstart = getCurrentTime();
               if (bClock3) btwotimes = 1;
            }
            iRelSec  = (int)(getCurrentTime()-tstart)/1000;
            iRelSec2 = (int)(getCurrentTime()-tstart2)/1000;
            if (iRelSec != iLastRelSec) {
               int iSec   = iRelSec;
               int iHour  = iSec/3600; iSec -= iHour*3600;
               int iMin   = iSec/60;   iSec -= iMin*60;
               int iSec2  = iRelSec2;
               int iHour2 = iSec2/3600; iSec2 -= iHour2*3600;
               int iMin2  = iSec2/60;   iSec2 -= iMin2*60;
               if (btwotimes)
                  printx("<time>%s<def> - $%02u:%02u:%02u<def> <time>- %02u:%02u:%02u<def>\r",szLineBuf2,iHour,iMin,iSec,iHour2,iMin2,iSec2);
               else if (bClock2)
                  printx("$%02u:%02u:%02u<def>\r",iHour,iMin,iSec);
               else
                  printx("<time>%s<def> - $%02u:%02u:%02u<def>%s\r",szLineBuf2,iHour,iMin,iSec,szLineBuf3);
               fflush(stdout);
               iLastRelSec = iRelSec;
            }
         } else if (chain.coldata) {
            chain.addLine(szLineBuf2, str(""));
         } else {
            printf("%s\n",szLineBuf2);
         }

         if (!bClock)
            break;

         doSleep(200);
      }

      if (iChainNext) {
         // producing command
         STEP_CHAIN(iChainNext, chain.coldata); // sfk181 time always
      }

      bDone = 1;
   }

   bool bZeroFile = 0;

   ifcmd (   !strcmp(pszCmd, "make-random-file")
          || !strcmp(pszCmd, "make-zero-file")
         )
   {
      bZeroFile = (strcmp(pszCmd, "make-zero-file") ? 0 : 1);

      ifhelp (nparm < 2)
      if (bhelp || bZeroFile)
      printx("<help>$sfk make-zero-file outfilename size\n"
             "\n"
             "   create a file full of null bytes. primarily used\n"
             "   to clean unused space on an embedded system's\n"
             "   sd card, before creating an .iso image of that card,\n"
             "   which is then compressed for distribution.\n"
             "\n"
             "   if filename contains folder(s) the directory tree\n"
             "   is created automatically.\n"
             "\n"
             "   $example\n"
             "      #sfk make-zero-file tmp1.dat 1m\n"
             "         produce a file tmp1.dat with 1 mbyte of size.\n"
             "      #sfk make-zero-file tmp1.dat 100g\n"
             "         write a file with 100 gigabytes. if the available\n"
             "         space is less, e.g. 8 gbytes, it will stop as soon\n"
             "         as all space is used, with an error.\n"
             );
      if (bhelp || !bZeroFile)
      printx("<help>$sfk make-random-file outfilename size [-text] [-seed=n]\n"
             "\n"
             "   creates a file full of random binary data for testing.\n"
             "   size parameters like 5m, 100k, 9000b are supported.\n"
             "   type \"sfk dupfind\" for details on size parameters.\n"
             "\n"
             "   $options\n"
             "      -text     create text data instead of binary.\n"
             "      -seed=n   specify randomizer seed. default is\n"
             "                to use a time based seed.\n"
             "      -lock=n   wait n msec before closing the file,\n"
             "                to keep the file locked for testing.\n"
             "\n"
             "   $see also\n"
             "      #sfk make-zero-file<def>    create file with null bytes\n"
             "\n"
             "   $examples\n"
             "      #sfk make-random-file tmp1.dat 1m -seed=1234\n"
             "         produce a file tmp1.dat with 1 mbyte of size.\n"
             "      #sfk make-random-file mydir<sla>foo.txt 1k -text\n"
             "         create folder mydir, and foo.txt within.\n"
            );
      ehelp;

      sfkarg;

      char *pszFile = 0;
      char *pszSize = 0;
      bool bText = 0, bForceSeed = 0;
      unsigned nSeed = (unsigned)time(NULL);
      int   nLock = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-seed", &pszParm)) {
            if (!pszParm) return 9;
            nSeed = (unsigned)atol(pszParm);
            bForceSeed = 1;
            continue;
         }
         if (!strcmp(pszArg, "-text")) {
            bText = 1;
            continue;
         }
         // internal: -lock=n keeps file locked for n msec
         if (haveParmOption(argx, argc, iDir, "-lock", &pszParm)) {
            if (!pszParm) return 9;
            nLock = atoi(pszParm);
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszFile) {
            pszFile = pszArg;
            continue;
         }
         if (!pszSize) {
            pszSize = pszArg;
            continue;
         }
         return 9+pbad(pszCmd,pszArg);
      }

      if (!pszFile)
         return 9+perr("missing output filename");
      if (!pszSize)
         return 9+perr("missing output size");

      num nSize = numFromSizeStr(pszSize, "size");
      if (nSize < 0)
         return 9+perr("invalid output size");

      // sfk1914: create out dir tree
      if (strchr(pszFile, glblPathChar))
         if (createOutDirTree(pszFile))
            return 9+perr("Cannot create folder for: %s\n", pszFile);

      Coi ocoi(pszFile, 0);
      int isubrc = 0;

      isubrc = ocoi.open("wb"); // sfk1972 always wb
      if (isubrc)
         return 9+esys("fopenw", "unable to write %s\n", pszFile);

      if (!cs.quiet)
         info.setAction("write", pszFile, "");

      if (bGlblRandSeeded==0 || bForceSeed==1) {
         bGlblRandSeeded = 1;
         srand(nSeed); // make-random-file, checks seeded
      }

      num nRemain  = nSize;
      num nWritten = 0;
      int nBlockSize = sizeof(abBuf)-10;
      memset(abBuf, 0, nBlockSize);
      int i=0;
      while (nRemain > 0) 
      {
         if (bZeroFile)
            { }
         else
         if (bText) {
            int ibreak = 40 + rand() % 80;
            for (i=0; i<nBlockSize; i++)
            {
               abBuf[i] = (uchar)(rand()%26+'a');
               // add line breaks near 80 chars
               if ((i % ibreak) == ibreak-2)
                  { abBuf[i] = '\r'; }
               if ((i % ibreak) == ibreak-1) {
                  abBuf[i] = '\n';
                  ibreak = 40 + rand() % 80;
               }
            }
         } else {
            for (i=0; i<nBlockSize; i++)
               abBuf[i] = (uchar)rand();
         }
         int nWriteSize = nBlockSize;
         if (nWriteSize > nRemain)
             nWriteSize = nRemain;
         num nWrite = ocoi.write(abBuf, nWriteSize);
         if (nWrite != nWriteSize) {
            esys("fwrite", "unable to write after %s bytes.\n", numtoa(nWritten));
            lRC = 9;
            break;
         }
         nRemain  -= nWriteSize;
         nWritten += nWriteSize;
         if (!cs.quiet)
            info.setProgress(nSize, nWritten, "bytes");
      }

      if (nLock > 0) {
         printf("waiting %d msec before close.\n",nLock);
         doSleep(nLock);
      }

      ocoi.close();

      if (cs.quiet < 2)
         info.print("written %s (%s bytes).\n", pszFile, numtoa(nWritten));

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "color"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk color colorname\n"
             "\n"
             "   switches the text color of terminal (command line).\n"
             "   supported color names are:\n"
             "\n"
            );
      if (bhelp) {
      printx("   white,grey,red,green,blue,yellow,cyan,magenta,black\n");
      } else {
         setTextColor(15); printf("      white  \n");
         setTextColor(14); printf("      grey   \n");
         setTextColor( 3); printf("      red    \n");
         setTextColor( 5); printf("      green  \n");
         setTextColor( 9); printf("      blue   \n");
         setTextColor( 7); printf("      yellow \n");
         setTextColor(13); printf("      cyan   \n");
         setTextColor(11); printf("      magenta\n");
         setTextColor( 0); printf("      black  \n");
         setTextColor(-1);
      }
      ehelp;

      sfkarg;

      char *pszCol = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!pszCol)
            { pszCol=pszArg; continue; }
         return 9+perr("unexpected: %s",pszArg);
      }
      if (!pszCol)
         return 9+perr("missing parameter");

           if (!strcmp(pszCol, "white" ))  { setTextColor(15); }
      else if (!strcmp(pszCol, "grey"  ))  { setTextColor(14); }
      else if (!strcmp(pszCol, "red"   ))  { setTextColor( 3); }
      else if (!strcmp(pszCol, "green" ))  { setTextColor( 5); }
      else if (!strcmp(pszCol, "blue"  ))  { setTextColor( 9); }
      else if (!strcmp(pszCol, "yellow"))  { setTextColor( 7); }
      else if (!strcmp(pszCol, "cyan"))    { setTextColor(13); }
      else if (!strcmp(pszCol, "magenta")) { setTextColor(11); }
      else if (!strcmp(pszCol, "black" ))  { setTextColor( 0); }
      else { lRC=1; printf("unsupported color: %s\n", pszCol); }

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "colortest"))
   {
      ifhelp (0)
      printx("<help>$sfk colortest\n"
             "\n"
             "   test all current logical colors.\n"
             "\n"
            );
      ehelp;

      sfkarg;

      printf("\n"
             "=== List of current logical SFK colors. ===\n"
             "=== If text is not colored type \"sfk help color\" for more. ===\n"
             "\n"
             );
      printf("Now follows the list of logical colors:\n"
             #ifndef _WIN32
             "default, "
             #endif
             "head, example, file, link, hit, replace,\n"
             "error, warning, pre, info, traceinc, traceex\n"
             "\n"
             );
      #ifndef _WIN32
      setTextColor(nGlblDefColor);      printf("default  color, for the linux shell\n");
      #endif
      setTextColor(nGlblHeadColor);     printf("head     color, for help text headers\n");
      setTextColor(nGlblExampColor);    printf("example  color, for help text examples\n");
      setTextColor(nGlblFileColor);     printf("file     color, for file names\n");
      setTextColor(nGlblLinkColor);     printf("link     color, for symbolic link files\n");
      setTextColor(nGlblHitColor);      printf("hit      color, for search result hits\n");
      setTextColor(nGlblRepColor);      printf("replace  color, to highlight replaced text\n");
      setTextColor(nGlblErrColor);      printf("error    color, for error messages\n");
      setTextColor(nGlblWarnColor);     printf("warning  color, for warning messages\n");
      setTextColor(nGlblPreColor);      printf("pre      color, for previous line hits\n");
      setTextColor(nGlblTimeColor);     printf("info     color, for many info messages\n");
      setTextColor(nGlblTraceIncColor); printf("traceinc color, for -tracesel included files\n");
      setTextColor(nGlblTraceExcColor); printf("traceex  color, for -tracesel excluded files\n");
      #ifdef _WIN32
      setTextColor(-1,0,1);             printf("default  color\n");
      #else
      setTextColor(-1,0,1);             printf("default  color, again\n");
      #endif
      return 0;
   }

   ifcmd (   !strncmp(pszCmd, "ver", 3) && strncmp(pszCmd, "veri",4) // +wref
          || !strncmp(pszCmd, "winver", 6)
         )
   {
      if (chain.useany()) {
         perr("sfk ver does not support input chaining.");
         pinf("you may use \"+then ver filename\" instead.\n");
         return 9;
      }

      ifhelp (nparm < 1 && strcmp(pszCmd, "ver."))
      printx(
         "<help>$sfk version filename\n"
         "$sfk ver -own\n"
         "\n"
         "   print version of a binary file, or of sfk itself.\n"
         "   this function can be used:\n"
         "\n"
         "   1. with binary files containing a portable version string:\n"
         "\n"
         "      #$$%s:name=sfk,type=base,os=windows,vernum=1.5.1,fix=0,\n"
         "      #title=Swiss File Knife,date=Aug  2 2008,info=major rework$$\\0\n"
         "\n"
         "   2. with windows binaries, where only file version and bitsize\n"
         "      are extracted, and shown with the file modification time.\n"
         "      if a product version is found that differs from the file\n"
         "      version it is shown in the info field.\n"
         "\n"
         "   $%s string fields:\n"
         "    [2] *name    short name, usually similar to the executable name\n"
         "    [3]  type    the type of edition, e.g. base or extended\n"
         "    [4] *os      operating system, e.g. windows, linux-lib6, linux-lib5\n"
         "    [5] *vernum  version number, any number of values separated by dots\n"
         "    [6]  fix     fix level, e.g. a revision or service pack number\n"
         "    [7] *title   long, descriptive name, as printed in a help text\n"
         "    [8] *date    release or compile date\n"
         "    [9]  info    additional infos or remarks, free text string\n"
         "\n"
         "   fields marked with \"*\" are mandatory for a valid version string.\n"
         "   the other fields can be left out, or be empty like \",fix=,\".\n"
         "   if found, contents are printed TAB-separated, #after the filename<def>,\n"
         "   therefore the #[]<def> numbers given above are #output column numbers<def>,\n"
         "   not the location in the input string (which is random anyway).\n"
         "\n"
         "   $options\n"
         "      -num[ber]  just print the full version number, combining\n"
         "                 vernum and fix to a dotted string.\n"
         "                 cannot be used with -own.\n"
         "      -verbose   tells a warning if file(s) contain no version.\n"
         "      -win[dows] compact display of file, os, version and filetime\n"
         "                 which is all that's shown for windows binaries.\n"
         "\n"
         "   $aliases\n"
         "      #sfk winver<def>  - same as sfk ver -win to primarily list\n"
         "                    windows file version infos.\n"
         "\n"
         "   $see also\n"
         "      #sfk require<def> - check if a required version is used.\n"
         "\n"
         ,"version","version"
         );
      webref("version");
      printx("   $examples\n"
         "      #sfk ver dview.exe\n"
         "         print the version of a Depeche View executable.\n"
         "      #sfk ver -own\n"
         "         print sfk's version.\n"
         "      #sfk ver.\n"
         "         print sfk's version (quickest).\n"
         "      #sfk ver . .exe\n"
         "         show the version of all .exe files within\n"
         "         the current folder and all sub folders.\n"
         "      #sfk ver -nosub . .exe +filt -ssep \"\\t\" -sform \"$$-20.20col1\\t$$col5\"\n"
         "         search all .exe files of the current dir for versions,\n"
         "         reformatting the output, with a 20 chars filename limit.\n"
         "\n"
         );
      ehelp;
 
      sfkarg;

      bool bOwn = 0;

      if (!strcmp(pszCmd, "ver.")) bOwn = 1;
      if (strBegins(pszCmd, "winver")) cs.winver = 1;

      int iChainNext = 0; // dummy, not used

      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-own")) {
            bOwn = 1;
            continue;
         }
         if (strBegins(pszArg, "-win")) {
            cs.winver=1;
            continue;
         }
         if (strBegins(pszArg, "-num")) {
            cs.justvernum = 1;
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         break; // sic
      }

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext))) return lRC;
      if (btest) return 0;

      int nVer = 0;

      if (bOwn)
      {
         // tell own version
         // 1.1.7.2 -> 1172 decimal. 1.1.7 -> 1170 decimal.
         // $version:vernum,shortid,full name,type$\0"
         // 0123456789
         StringMap omap;
         if (parseVersion((char*)pszGlblVersion, strlen(pszGlblVersion), omap))
            return -1;

         char *pnam = omap.get(str("name"  ), str(""));
         char *ptyp = omap.get(str("type"  ), str(""));
         char *pos  = omap.get(str("os"    ), str(""));
         char *pnum = omap.get(str("vernum"), str(""));
         char *pfix = omap.get(str("fix"   ), str(""));
         char *ptit = omap.get(str("title" ), str(""));
         char *pdat = omap.get(str("date"  ), str(""));
         char *pinf = omap.get(str("info"  ), str(""));

         // create integer from version string
         char *psz1 = pnum;
         int nDot = 3;
         while (*psz1) {
            char c = *psz1++;
            if (c == '.')
               { nVer = nVer * 10; nDot--; }
            else
               nVer = nVer + (c - '0');
         }
         while (nDot-- > 0)
            nVer = nVer * 10;

         chain.print("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", argx[0],
            pnam,ptyp,pos,pnum,pfix,ptit,pdat,pinf);

      }
      else
      {
         lRC = walkAllTrees(eFunc_Version, lFiles, lDirs, nBytes);
         info.clear();
      }

      if (iDirNext) { // sic, not iChainNext
         // producing command
         STEP_CHAIN(iDirNext, 1);   // sfk181 ver always
      } else {
         if (bOwn) {
            // return version to shell, for further processing
            lRC = nVer;
         }
      }

      bDone = 1;
   }
 
   ifcmd (!strcmp(pszCmd, "require"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk require inputVersion requiredVersion\n"
             "$sfk require -own requiredVersion\n"
             "\n"
             "   check a version text against a required version,\n"
             "   or check SFK's version itself.\n"
             "\n"
             "   produces shell return code 0 if input version\n"
             "   is greater or equal to required version.\n"
             "\n"
             "   $options\n"
             "      -name=x   if input version is too old, SFK prints\n"
             "                an error message containing x.\n"
             "      -own      check SFK's own version.\n"
             "      -quiet    do not print info message\n"
             "                in case of failure.\n"
             "      -nostop   do not stop command chaining,\n"
             "                set rc 5 if requirement fails\n"
             "\n"
             "   $windows .bat file example\n"
             "      @echo off\n"
             "      sfk require -own 1.6.1.2\n"
             "      IF %%ERRORLEVEL%%==0 GOTO sfkok\n"
             "      echo \"wrong SFK version, stopping.\"\n"
             "      exit /B\n"
             "      :sfkok\n"
             "\n"
             "   $linux bash example\n"
             "      sfk require -own 1.6.1.2\n"
             "      iReturnCode=$$?\n"
             "      if [ ! $$iReturnCode -eq 0 ]; then\n"
             "         echo \"wrong SFK version, stopping.\"\n"
             "         exit\n"
             "      fi\n"
             "\n"
             "   $further examples\n"
             "      #sfk ver -number dview.exe +require -name=dview 1.4.8\n"
             "         check if dview.exe is 1.4.8.0 or higher.\n"
             );
      ehelp;
 
      sfkarg;

      char *pszReqVersion = 0;
      char *pszSubject = 0;
      bool bOwn = 0;
      int iFailRC = 10;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-name", &pszParm)) {
            if (!pszParm) return 9;
            pszSubject = pszParm;
            continue;
         }
         if (!strcmp(argx[iDir], "-own"))
            { bOwn = 1; continue; }
         if (!strcmp(argx[iDir], "-nostop"))
            { iFailRC = 5; continue; }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!pszReqVersion) {
            pszReqVersion = argx[iDir];
            continue;
         }
         return 9+pbad(pszCmd, argx[iDir]);
      }
 
      if (!pszReqVersion)
         if (bOwn)
            return 9+perr("supply required version, e.g. 1.6.1");
         else
            return 9+perr("supply a filename and required version, e.g. myfile 1.6.1");
 
      const char *pszBaseVersion = SFK_VERSION;
      const char *pszFixPack     = SFK_FIXPACK;

      char szOwnVersion[50];
 
      if (chain.usedata)
      {
         // sfk1935 fix: default 0.0.0 if no data present
         char *psz = str("0");
         if (chain.indata->numberOfEntries() > 0)
            psz = chain.indata->getEntry(0, __LINE__);

         strcopy(szOwnVersion, psz);
         // enforce quadruple format
         psz = szOwnVersion;
         int iparts = 0;
         while (psz) {
            if (*psz) iparts++;
            if (!(psz = strchr(psz, '.')))
               break;
            psz++;
         }
         for (; iparts<4; iparts++) {
            int ilen = strlen(szOwnVersion);
            if (ilen > 0 && szOwnVersion[ilen-1] == '.')
               strcat(szOwnVersion, "0");
            else
               strcat(szOwnVersion, ".0");
         }
         if (cs.verbose)
            printf("using: %s\n", szOwnVersion);
      }
      else
      {
         if (!bOwn)
            return 9+perr("missing -own parameter.\n");
 
         snprintf(szOwnVersion, sizeof(szOwnVersion)-10,
            "%s%s%s"
            , pszBaseVersion
            , pszFixPack[0] ? ".":""
            , pszFixPack
            );
      }
 
      lRC = 0;
 
      // compare version parts
      char *pszOwn = szOwnVersion;
      char *pszReq = pszReqVersion;
      while (1)
      {
         int iOwnPart = atoi(pszOwn);
         int iReqPart = atoi(pszReq);
 
         if (iOwnPart < iReqPart)
            { lRC = iFailRC; break; }
 
         if (iOwnPart > iReqPart)
            break;

         pszOwn = strchr(pszOwn, '.');
         if (!pszOwn) break; // end of own quad version
         pszOwn++;

         pszReq = strchr(pszReq, '.');
         if (!pszReq) break; // end of triple or quad req
         pszReq++;
      }
 
      if (lRC && !cs.quiet)
      {
         if (bOwn)
         {
            char *pszOwnPath = findPathLocation(argx[0]);
            if (!pszOwnPath) pszOwnPath = str("sfk");
            perr("script requires Swiss File Knife (sfk) version: %s", pszReqVersion);
            pinf("current binary %s has version %s\n", pszOwnPath, szOwnVersion);
         }
         else
         {
            if (pszSubject)
               perr("script requires %s version %s (current=%s)",
                  pszSubject, pszReqVersion, szOwnVersion);
         }
      }

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "messagebox"))
   {
      if (argc < 4) return 9+perr("missing parameters, specify title and text\n");
      char *pszTitle = argv[2];
      char *pszText  = argv[3];
      copyFromFormText(pszText, strlen(pszText), szLineBuf, MAX_LINE_LEN);
      int irc = MessageBox(0, szLineBuf, pszTitle, 6 | 0x200); // MB_CANCELTRYCONTINUE);
      // rc 2=cancel 10=try 11=continue
      printf("rc %d\n", irc);
      return 0;
   }
   #endif

   #ifdef WITH_TCP
   ifcmd (strBegins(pszCmd, "httpserv") || strBegins(pszCmd, "webserv")) // +wref
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      printx(
         "<help>$sfk httpserv [-h[elp]]]] [-port=nport] [-rw]\n"
         "\n"
         "   The SFK Instant HTTP Server for easy file transfer.\n"
         "\n"
         "   $default behaviour since sfk 1.9.8:\n"
         "   * the current folder AND SUB FOLDERS are made accessible.\n"
         "     use option -nosub to disable.\n"
         "   * just ONE CLIENT (browser etc.) can connect at a time.\n"
         "\n"
         "   $only for trusted environments!\n"
         "     sfk httpserv is intended only for personal file transfer\n"
         "     between two machines that the user has control of, within\n"
         "     a trusted LAN environment. it should not be used to offer\n"
         "     files in the internet. if security is important then do not\n"
         "     use sfk httpserv but a full scale web server like Apache.\n"
         "\n"
         "   $options\n"
         "     -nosub       do not list folder names, allow no access\n"
         "                  to files in sub folders.\n"
         "     -rw          allow write access with upload of files.\n"
         "     -nolist      do not provide a content listing, but change\n"
         "                  any access to \"/\" into \"index.html\".\n"
         "                  includes -nosub to disable sub folder access.\n"
         "     -deep        only after -nolist: allow access to files\n"
         "                  in sub folders, for html references.\n"
         "     -port=n      use other port than default, e.g. -port=81.\n"
         "     -port2=n     alternative port, used if first port fails.\n"
         "                  use -port2=0 to disable alternative port.\n"
         "     -raw         send no http reply header, just raw content.\n"
         "     -headers     show incoming request headers.\n"
         "     -startdir x  set default subdir to redirect to if a client\n"
         "                  connects for the first time, requesting '/'.\n"
         "\n"
         "   $about filename character encodings\n"
         "     only filenames with characters of the system codepage\n"
         "     are supported. for details type: #sfk listcodes sys\n"
         "     names with chars beyond that cannot be accessed.\n"
         "\n");
      printx(
         "   $see also\n"
         "     #sfk ftpserv -h<def>    the SFK Instant FTP server.\n"
         #ifdef VFILENET
         "     #sfk wget<def>          a web file download command.\n"
         #endif // VFILENET
         "\n");
      webref("httpserv");
      printx(
         "   $examples: display a simple web page\n"
         "     #sfk webserv -nolist\n"
         "        no file listings, load index.html if present.\n"
         "        access to files in sub folders is blocked.\n"
         "     #sfk webserv -nolist -deep\n"
         "        same as above, but allow access to sub folder files.\n"
         "\n"
         "   $examples: easy file down- and upload\n"
         "     #sfk webserv\n"
         "        make current folder, and all sub folders, accessible\n"
         "        for reading and downloading.\n"
         "     #sfk webserv -rw\n"
         "        same as above, but also allow upload of files.\n"
         "     #sfk webserv -nosub\n"
         "        do not show sub folders, do not allow access to files\n"
         "        in sub folders. (sfk 1.9.7 default behaviour)\n"
         "\n");
      ehelp;

      sfkarg;

      cs.timeOutMSec = 30000;

      int   iDir    =     2;
      int  iChainNext =   0;
      uint nPort    =    80;
      uint nPort2   =  8080;
      char *pszPath =     0;
      bool  bSub    =     0;
      bool  bDeep   =     0;
      bool  bNoList =     0;
      bool  bRW     =     0;
      bool  bRaw    =     0;
      bool  bUseDirParms = 0;

      // no verbose progress indicator at server side.
      cs.noprog = 1;

      // default since sfk198:
      bDeep = 1;
      cs.withdirs = 1;

      for (; iDir < argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;

         // for sfk 1.9.7 behaviour:
         if (!strcmp(pszArg, "-nosub"))
            { bDeep = 0; cs.withdirs = 0; continue; }
         if (!strcmp(pszArg, "-rw"))
            { bRW = 1; continue; }

         // old "deep" access with index file, no listing
         if (!strcmp(pszArg, "-nolist")) // includes -nosub
            { bNoList = 1; 
              bDeep = 0; cs.withdirs = 0; continue; }
         if (!strcmp(pszArg, "-deep"))
            { bDeep = 1; continue; }

         if (haveParmOption(argx, argc, iDir, "-port", &pszParm)) {
            if (!pszParm) return 9;
            nPort  = atol(pszParm);
            nPort2 = 0;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-port2", &pszParm)) {
            if (!pszParm) return 9;
            nPort2 = atol(pszParm);
            continue;
         }
         if (!strcmp(pszArg, "-raw")) 
            { bRaw = 1; continue; }
         if (!strcmp(pszArg, "-usehta")) // internal
            { cs.usehta = 1; continue; }
         if (haveParmOption(argx, argc, iDir, "-timeout", &pszParm)) { // httpserv
            if (!pszParm) return 9;
            cs.timeOutMSec = atol(pszParm) * 1000;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-startdir", &pszParm)) { // internal
            if (!pszParm) return 9;
            cs.pwebstartdir = pszParm;
            continue;
         }
         if (!strcmp(pszArg, "-wide")) // sfk198 deleted
            continue;
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg)) {
               bUseDirParms = 1;
               break; // fall through
            }
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszPath)
            pszPath = pszArg;
         else
            return 9+pbad(pszCmd, pszArg);
      }
 
      if (bUseDirParms)
      {
         // read multiple dirs
         if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1)))
            return lRC;
      }
      else
      {
         // default: single folder only
         if (!pszPath) pszPath = str(".");
         if (glblFileSet.beginLayer(false, __LINE__)) return 9;
         glblFileSet.addRootDir(pszPath, __LINE__, false, false); // sfk193 fix http list .zip
         glblFileSet.autoCompleteFileMasks(3);
         glblFileSet.setBaseLayer();
      }
 
      cs.subdirs = bSub; // in case of list command

      if (btest) return 0;

      httpServ(nPort, nPort2, bDeep, bNoList, bRW, bRaw);

      bDone = 1;
   }

   #endif // WITH_TCP

   regtest("hexdump -showle -wide -nohead xdir .dat1 .dat2");
   regtest("hexdump -lean -pure -dir xdir -file .dat");
   regtest("hexdump -hexsrc xfile1");
   regtest("hexdump -decsrc xfile1 xfile2");
   regtest("hexdump -flat xfile1");
   regtest("tcpdump 5000 -forward xhost:xport -timeout 20000");

   #ifdef VFILENET
   bool bGetDV = 0;

   if (!strcmp(pszCmd, "dview"))
   {
      printx(
         "\n"
         "$Depeche View<def> is the world's fastest #browser and editor<def>\n"
         "#for all text files of a folder<def>, especially source code.\n"
         "\n"
         "It is used in embedded software development to analyze\n"
         "projects with #ten thousands of source files<def>, but also\n"
         "helpful for a #quick overview<def> over #documentation<def>,\n"
         "#config files<def>, or to #filter log files<def>.\n"
         "\n"
         "#Further features:\n"
         "- receive and filter network text sent by UDP\n"
         "- load text from http:// URLs directly\n"
         "- run self defined scripts on hotkeys\n"
         "\n"
         "Type #\"sfk getdv\"<def> to download Depeche View Lite now.\n"
         "It runs instantly #without installation<def>.\n"
         "\n"
         "Once downloaded it can be used standalone,\n"
         "or combined with SFK as shown under: #\"sfk view\"<def>\n"
         "\n"
         "For all infos see: #http://stahlworks.com/dview/<def>\n"
         );

      bDone = 1;
   }

   #ifdef _WIN32
   if (!strcmp(pszCmd, "getdv"))
   {
      printf("\n=== Depeche View Lite download ===\n\n");
      printx("$sfk will open a web browser, with URL:\n\n");
      printf("   http://stahlworks.com/dview.exe\n");
      char *pszWritePath=0;
      int   isubrc=0;
      if ((pszWritePath=getWritePath(isubrc))) {
         printx("\nyou may then save dview.exe to folder %s\n",pszWritePath);
         printx("or into the same folder as sfk.exe.\n");
      } else {
         char *pszsfk = findPathLocation("sfk" EXE_EXT, 1); // for getdv. 1=nocwd
         if (pszsfk) {
            char *psz=strrchr(pszsfk, '\\');
            if (psz) *psz='\0';
            printx("\n$you may then save dview.exe in the same folder as sfk:\n\n");
            printf("   %s\n", pszsfk);
         }
      }
      printf("\n");

      printx("#press ENTER to continue, or CTRL+C to stop.\n");
      getchar();

      ShellExecute(NULL, "open", "http://stahlworks.com/dview.exe", NULL, NULL, SW_SHOWNORMAL);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "gettray"))
   {
      printf("\n=== SFKTray Free Edition download ===\n\n");
      printx("$sfk will open a web browser, with URL:\n\n");
      printf("   http://stahlworks.com/dev/sfk/sfktray-set-up.exe\n");
      printf("\n");
      printx("$Windows requires an installation for programs\n");
      printx("$that want to display a task icon.\n");
      printf("\n");
      printf("   However SFKTray requires no admin rights.\n");
      printf("   Just install it to the path suggested by setup.\n");
      printf("\n");

      printx("#press ENTER to continue, or CTRL+C to stop.\n");
      getchar();

      ShellExecute(NULL, "open", "http://stahlworks.com/dev/sfk/sfktray-set-up.exe", NULL, NULL, SW_SHOWNORMAL);

      bDone = 1;
   }
   #endif

   #ifdef _WIN32
   ifcmd (!strcmp(pszCmd, "wget"))
   #else
   ifcmd (!strcmp(pszCmd, "wget") || !strcmp(pszCmd, "getdv")) // +var
   #endif
   {
      bGetDV = (strcmp(pszCmd, "getdv") == 0) ? 1 : 0;

      ifhelp (chain.useany() == 0 && nparm < 1 && bGetDV == 0)
      printx("<help>$sfk wget [options] url [outfile|outdir] [options]\n"
             "\n"
             "   download content from a given http:// URL.\n"
             "   an output filename or directory can be specified.\n"
             "   existing output files are overwritten without asking back.\n"
             "\n"
             "   $options\n"
             "      -user=u     and -pw=p set http basic authentication.\n"
             "                  you may also use global options -webuser, -webpw.\n"
             "                  note that passwords are not encrypted on transfer,\n"
             "                  except when using SFK Plus with HTTPS connections.\n"
             "      -proxy      hostname:port of a proxy server. from within a company\n"
             "                  network, it is often required to connect through proxies.\n"
             "                  alternatively, set the environment variable SFK_PROXY :\n"
             "                    #<exp> SFK_PROXY=myproxyhost:8000\n"
             "                  to find out what proxy your browser is using, see\n"
             "                  - Firefox: tools/options/advanced/network/settings\n"
             "                  - IE: tools/internet options/connections/lan settings\n"
             "      -path2name  include web path in generated output name,\n"
             "                  to create unique names on multiple downloads.\n"
             "                  this option is default on chained processing.\n"
             "      -fullpath   recreate the whole web path within output dir.\n"
             "      -nodom      do not include domain name in output name.\n"
             "      -nopath     do not include any path and domain information\n"
             "                  within the output names. will not work if URL\n"
             "                  does not contain any relative filename.\n"
         //  "      -usecache   allow caching of downloads.\n"
             "      -quiet      or -noprog shows no download progress indicator.\n"
             "      -quiet=2    show no \"done\" info line.\n"
             "      -addext     always add a filename extension like .txt, .html\n"
             "                  or .dat even if the URL has no such extension.\n"
             "      -timeout=n  wait up to n msec for data\n" // wto.wget
             "      -verbose    tell current proxy settings, if any\n"
             "      -noclose    do not send \"Connection: close\" header.\n"
             "\n"
             "   $automatic name expansions\n"
             "      http:// is added automatically. short ip's like .100 are\n"
             "      extended like 192.168.1.100 depending on your subnet.\n"
             "\n");
      printx("   $quoted multi line parameters are supported in scripts\n" // wget
             "      using full trim. type \"sfk script\" for details.\n"
             "\n");
      printx("   $limitations\n"
             "      although sfk wget can download a list of URLs, it is not\n"
             "      a real webpage downloader/archiver, as this would require\n"
             "      the conversion of html pages to adapt contained links.\n"
             "\n");
      printx("   $HTTPS support\n"  // sfkplus.anno wget
             "      SSL/TLS downloads are supported with SFK Plus.\n"
             "      read more under:\n"
             "         #stahlworks.com/sfkplus\n"
             "\n");
      printx("   $chaining support\n"
             "      output filename chaining is supported.\n"
             "\n"
             "   $see also\n"
             "      #sfk web<def>      send a simple web request with instant\n"
             "                   result output to terminal\n"
             #ifndef _WIN32
             "      #wget<def>         linux command for file download\n"
             #endif
             "      #curl<def>         powerful web request and download tool\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk wget -proxy myproxy:8000 http://foobar.com/x.zip foo.zip\n"
             "         download x.zip, writing the content into a file foo.zip,\n"
             "         connecting through a proxy server myproxy on port 8000.\n"
             "\n"
             "      #sfk filt urls.txt +wget mydir\n"
             "         if urls.txt contains a list of http:// URLs, load it\n"
             "         and download all contents into mydir. the output names\n"
             "         will include path information found in the source URL.\n"
             "\n"
             "      #sfk filt urls.txt +wget -fullpath mydir +list -big\n"
             "         the same as above, but create the whole dir structure,\n"
             "         and then list biggest files from the downloaded.\n"
             "\n"
             "      #sfk wget -quiet=2 server/info.xml tmp.txt +ffilter -nofile\n"
             "         download info.xml from server, write it as file tmp.txt\n"
             "         and instantly print the tmp.txt content to terminal\n"
             "         without any status messages or filename infos.\n"
            );
      ehelp;

      sfkarg;

      CommandScope oscope("wget");

      char *pSrcName    = 0;
      char *pDstName    = 0;
      bool  bchained    = chain.useany();
      bool  bpath2name  = bchained;
      bool  bpath2path  = 0;
      bool  bwithdom    = 1;
      bool  bcache      = 0;
      bool  bsynext     = 0;
      bool  bdump       = 0;

      cs.execweb = 1; // wget

      if (bGetDV)
      {
         pSrcName = str("http://stahlworks.com/dview.exe");
         #ifdef _WIN32
         pDstName = str(".");
         #else
         pDstName = str("dview-linux.exe");
         #endif
         bpath2name = 0;
      }

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-user", &pszParm)) { // sfk198
            if (!pszParm) return 9;
            cs.pwebuser = pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-pw", &pszParm)) { // sfk198
            if (!pszParm) return 9;
            cs.pwebpass = pszParm;
            continue;
         }
         if (bGetDV && !strcmp(argx[iDir], "-web")) {
            #ifdef _WIN32
            printx("$opening :<def> %s\n", pSrcName);
            ShellExecute(NULL, "open", pSrcName, NULL, NULL, SW_SHOWNORMAL);
            #endif
            return 0;
         }
         if (!strncmp(pszArg,"-timeout=",9)) { // wto.wget.new
            cs.maxwebwait = atol(pszArg+9);
            continue;
         }
         if (!strncmp(pszArg,"-maxwait=",9)) { // wto.wget compat
            cs.maxwebwait = atol(pszArg+9);
            continue;
         }
         if (!strcmp(pszArg, "-path2name")) {
            bpath2name = 1;
            continue;
         }
         if (!strcmp(pszArg, "-fullpath") || !strcmp(pszArg, "-path2path"))
         {
            bpath2path = 1;
            continue;
         }
         if (!strcmp(pszArg, "-nopath")) {
            bpath2name = bpath2path = 0;
            continue;
         }
         if (!strcmp(pszArg, "-nodom")) {
            bwithdom = 0;
            continue;
         }
         if (!strcmp(pszArg, "-usecache")) {
            bcache = 1;
            continue;
         }
         if (!strcmp(pszArg, "-addext")) {
            bsynext = 1;
            continue;
         }
         if (!strcmp(pszArg, "-noclose")) // wget
            { cs.webnoclose = 1; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pSrcName && !bchained) {
            if (iGlblInScript) // then pszArg is writeable
               fixMultiLineParm(pszArg, 't'); // sfk180: wget
            pSrcName = pszArg;
            continue;
         }
         if (!pDstName)
            { pDstName = pszArg; continue; }
         pbad(pszCmd, pszArg);
         pinf("use \"+then wget\" to use multiple wget in one command chain.\n");
         return 9;
      }

      if (bGetDV)
      {
         printx("$download:<def> Depeche View Lite\n"
                "$from URL:<def> %s\n",
                pSrcName
               );
      }
 
      if (!pSrcName && !bchained)
         return 9+perr("missing URL.\n");

      uint nmode = bpath2name ? 1 : 0;
      if (bpath2path) nmode |= 2;
      if (bwithdom)   nmode |= 4;
      if (pDstName && !isDir(pDstName))
         nmode |= 8; // single output file
      if (bsynext)    nmode |= 16;
      if (bdump)      nmode |= 32;

      if (chain.usedata!=0)
         chain.convInDataToInFiles();

      if (pSrcName)
      {
         // auto expand url?
         char szURL[SFK_MAX_PATH+100];
         if (   !striBegins(pSrcName, "http:")
             && !striBegins(pSrcName, "https:")
             && !striBegins(pSrcName, "ftp:")
            )
         {
            snprintf(szURL,SFK_MAX_PATH,"http://%s",pSrcName);
            pSrcName=szURL;
         }

         #ifdef SFKINT
         // sfk1860 url blank encoding
         if (encodeURL(pSrcName))
            pSrcName = szTopURLBuf;
         #endif

         // TODO: mem/disk caching is yet undefined
         Coi *psrc = bcache ? glblVCache.get(pSrcName) : 0;
         if (!psrc) {
            psrc = new Coi(pSrcName, 0);
            if (!psrc) return 9+perr("out of memory");
            psrc->incref("wget");
         }
         CoiAutoDelete odel(psrc, 1); // with decref

         if (execWGet(psrc, pDstName, nmode)) {
            // download failed
            #ifdef _WIN32
            if (bGetDV)
               printx("You may try #sfk getdv -web<def> to download via web browser.\n");
            #else
            if (bGetDV)
               printx("Please download manually from %s\n", pSrcName);
            #endif
         } else {
            #ifndef _WIN32
            if (bGetDV) {
               // post process: make binary executable
               snprintf(szLineBuf, sizeof(szLineBuf)-10, "chmod +x \"%s\"", pDstName);
               if (system(szLineBuf))
                  perr("cannot set x attribute (%s)\n", szLineBuf);
               // and duplicate to "dview" without .exe
               snprintf(szLineBuf, sizeof(szLineBuf)-10, "cp \"%s\" dview", pDstName);
               if (system(szLineBuf))
                  perr("cannot copy %s to \"dview\"\n", pDstName);
               else {
                  printf("done : ./dview (copy of %s)\n", pDstName);
                  printf("note : please copy \"dview\" into a folder listed in your PATH.\n");
                  char *pszPath = getenv("PATH");
                  if (pszPath)
                     printf("       PATH = %s\n", pszPath);
               }
            }
            #endif
         }

         if (bcache && !psrc->isCached() && psrc->data().src.data) {
            glblVCache.put(psrc->orgName(), psrc, "wget");
         }
      }
      else
      if (chain.usefiles)
      {
         if ((nmode & 8)!=0 && chain.numberOfInFiles()>1)
            return 9+perr("more than 1 input URLs, but no existing output folder given.");

         for (int i=0; i<chain.numberOfInFiles(); i++)
         {
            Coi *pcoi = chain.getFile(i);
            if (!pcoi) return 9+perr("int. #9529726");
            execWGet(pcoi, pDstName, nmode);
         }
      }
      else
         return 9+perr("wrong chain input, need filenames.");

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   #endif // VFILENET

   if (!strcmp(pszCmd, "xe")) // alias for sfk help xe
   {
      printHelpText("xe", bhelp);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "book"))
   {
      ifhelp (nparm < 1)
      printx("The $Five Dollar SFK Book<def> is a $300 page PDF file<def>, optimized\n"
             "for reading on smartphones and tablets, featuring:\n"
             "\n"
             "-  a $large font<def> and no side borders, for $zoomless reading<def>\n"
             "   even on small smartphone screens.\n"
             "\n"
             "-  a $60 pages tutorial<def>, with a step by step introduction\n"
             "   into SFK with input, command and output:\n"
             "   -  basics of file and folder selection\n"
             "   -  mass file rename, copy, cleanup\n"
             "   -  index files for fast filename search\n"
             "   -  find duplicate files\n"
             "   -  search and replace in files\n"
             "   -  filter, edit and sort CSV data\n"
             "   -  file transfer by web or ftp server\n"
             "   -  script creation and more.\n"
             "\n"
             "-  the tutorial includes $25 pages of Xed examples<def>\n"
             "   with input, script, output and detailed explanations:\n"
             "   -  conversion and processing of CSV and XML data\n"
             "   -  cleanup of a translation file\n"
             "   -  convert Wiki markup text to HTML\n"
             "   -  HTTP request scripting and test automation\n"
             "   -  how to fill in an XML file with program meta data\n"
             "   -  scripting with variables and parameters\n"
             "\n"
             "-  $page links!<def> touch and jump to related content, instantly.\n"
             "   feature may depend on PDF reader used. test it with the\n"
             "   free Demo PDF available on stahlworks.com\n"
             "\n"
             "-  zero weight, $always with you on your smartphone<def>.\n"
             "\n"
             "All details and Demo PDF under: #stahlworks.com/ebook<def>\n"
             "\n"
             #ifdef _WIN32
             "To open a web browser now, type: #sfk book web\n"
             #endif
             "\n"
             "$----------- Do you prefer a printed book? -----------\n"
             "\n"
             "    Search for #100 Command Line Tools<def> on Amazon!\n"
             "\n"
             );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         #ifdef _WIN32
         if (!strcmp(pszArg, "web")) {
            ShellExecute(NULL, "open", "http://stahlworks.com/ebook", NULL, NULL, SW_SHOWNORMAL);
            return 0;
         }
         #endif
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "update"))
   {
      ifhelp (nparm >= 1 && isHelpOpt(argv[iDir]))
      printx("<help>$sfk update [-get]\n"
             "\n"
             "   check for SFK updates.\n"
             "\n"
             );
      ehelp;

      sfkarg;

      int iDownload = 0;
      bool bforce   = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-force")) {
            bforce = 1;
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
      }

      Coi oxml(str("http://stahlworks.com/sfkver.xml"), 0);

      uchar *pxml  = 0;
      num    nsize = 0;

      uchar *pbin = 0;
      num    nbin = 0;

      if (oxml.preload("upd", &pxml, nsize, 0)) // update
      {
         printx("<err>Cannot download update status from www.stahlworks.com\n");
         printx("\nIf you have to connect through a proxy you may try\n");
         printx("option -proxy as documented under: #sfk wget<def>\n");
         printx("\nTo check for updates manually, go to:\n");
         printx("$http://stahlworks.com/sfk\n");
         return 9;
      }

      /*
         <Program_Version>1.7.6</Program_Version>
         <Program_Release_Month>01</Program_Release_Month>
         <Program_Release_Day>12</Program_Release_Day>
         <Program_Release_Year>2016</Program_Release_Year>
         <Program_Release_Status>Major Update</Program_Release_Status>
         <Program_Change_Info>added function fixfile under windows to correct
            filenames with bad characters and time. added function
            num to print a number in many formats.</Program_Change_Info>
         // may differ from actual size:
         <File_Size_Bytes>1613824</File_Size_Bytes>
         // may differ from binarie's platform:
         <Primary_Download_URL>http://stahlworks.com/sfk.exe</Primary_Download_URL>
         // extended pad:
         <SFK_Extension>
            <change_list>
            -  add: xfind, xhexfind: option -names to show just
                    the names of files containing hits.
            -  fix: find: option -justrc produced blank lines.
            -  add: udpdump: option -from now supports multiple
                    ips separated by comma.
            </change_list>
            <download_1_windows-any>http://stahlworks.com/sfk.exe</>
            <download_2_windows-any>...
            <download_1_linux-arm>http://stahlworks.com/sfkarm</>
         </SFK_Extension>
         windows-any, linux-arm, linux-lib6, linux-lib5,
         mac-osx-i686, mac-osx-ppc, linux-lib6-64
      */
      do
      {
         char *pver = strstr((char*)pxml, "<Program_Version>");
         if (!pver) break; pver += strlen("<Program_Version>");

         char *pchg = strstr((char*)pxml, "<Program_Change_Info>");
         if (!pchg) break; pchg += strlen("<Program_Change_Info>");

         char *plst = strstr((char*)pxml, "<change_list>");
         if (plst) {
            plst += strlen("<change_list>");
            while (*plst=='\r' || *plst=='\n') plst++;
         }

         char *pinf = strstr((char*)pxml, "<additional_info>");
         if (pinf) {
            pinf += strlen("<additional_info>");
            while (*pinf=='\r' || *pinf=='\n') pinf++;
         }

         char *pfreq = strstr((char*)pxml, "<check_frequency>");
         if (pfreq) pfreq += strlen("<check_frequency>");

         char *pend = pver; while (*pend!=0 && *pend!='<') pend++; if (*pend) *pend='\0';

         // fix sfk1872: auto correct version "1.8.7." to "1.8.7"
         while (pend>pver && isdigit(pend[-1])==0)
            { pend[-1] = '\0'; pend--; }

         if (pchg)
            {  pend = pchg; while (*pend!=0 && *pend!='<') pend++; if (*pend) *pend='\0'; }

         if (pfreq)
            {  pend = pfreq; while (*pend!=0 && *pend!='<') pend++; if (*pend) *pend='\0'; }
 
         if (plst)
            {
               pend = plst; while (*pend!=0 && *pend!='<') pend++; if (*pend) *pend='\0';
               myrtrimany(plst, " \t\r\n");
            }
         if (pinf)
            {
               pend = pinf; while (*pend!=0 && *pend!='<') pend++; if (*pend) *pend='\0';
               myrtrimany(pinf, " \t\r\n");
            }

         // "1.7.6", "added function fixfile ..."
         if (!iDownload)
            printx("$Latest version available:<def> %s\n", pver);

         // compare version parts
         // fix sfk1812: create quad part version
         char szOwn[100];
         strcpy(szOwn, SFK_VERSION);
         if (strlen(SFK_FIXPACK) > 0) {
            strcat(szOwn, ".");
            strcat(szOwn, SFK_FIXPACK);
         }
         char *pszOwn = szOwn;
         char *pszNew = pver;
         bool  bOld   = 0;
         while (1)
         {
            int iOwnPart = atoi(pszOwn);
            int iReqPart = atoi(pszNew);
       
            if (iOwnPart < iReqPart)
               { bOld = 1; break; }
       
            if (iOwnPart > iReqPart)
               break;
       
            pszOwn = strchr(pszOwn, '.');
            pszNew = strchr(pszNew, '.');
      
            if (!pszNew) break; // end of triple or quad req
            pszNew++;
            // new continues e.g. 1.8.1.2
      
            if (!pszOwn) { // fix sfk1812
               // but own stops e.g. 1.8.1
               bOld = 1;
               break;
            }
            pszOwn++;
         }
         if (!bforce && !bOld)
         {
            if (pfreq)
               printx("$It is recommended to look for updates %s.\n", pfreq);
            printx("$Your version of SFK is up to date.\n");
            break;
         }

         if (!iDownload)
         {
            if (pchg) {
               printx("$Summary:<def>\n");
               printf("%s\n", pchg);
            }

            if (plst) {
               printx("$Changelist:<def>\n");
               printf("%s\n", plst);
            }
 
            if (pinf) {
               printx("$Additional infos:<def>\n");
               printf("%s\n", pinf);
            }

            printx("#------------------------------------<def>\n");
            printx("#A newer version of SFK is available.\n");
            printx("#------------------------------------<def>\n");

            {
               printx("To download, go to one of:\n"
                  "$http://stahlworks.com/sfk\n"
                  "$http://sourceforge.net/projects/swissfileknife/\n"
                  #ifdef SFK_LINUX_FULL
                  "or check your Linux packet manager for a possible update.\n"
                  #endif
                  );
            }
         }

      }
      while (0);

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "filesys") || !strcmp(pszCmd, "fsinfo")
          || !strcmp(pszCmd, "space") || !strcmp(pszCmd, "diskspace")
          || !strcmp(pszCmd, "freespace")
         )
   {
      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      #ifdef _WIN32
      printx("<help>$sfk space [dirname|-help]\n"
             "$sfk filesys [dirname]\n"
             "\n"
             "   show disk space and/or file system informations.\n"
             "   a folder name can be specified which relates\n"
             "   to a specific volume or hard disk.\n"
             "\n"
             "   $options\n"
             "      -byte[s]   all size infos in bytes\n"
             "      -tab[s]    pure values, tab separated\n"
             "      -bin[ary]  calculate with binary megabytes\n"
             "                 of 1048576 bytes each.\n"
             "\n"
             "   $aliases\n"
             "      $sfk diskspace<def>  same as space\n"
             "      $sfk fsinfo<def>     same as filesys\n"
             "      $sfk freespace<def>  tell only free space\n"
             "\n");
      printx("   $chaining support\n"
             "      cannot use chain input data.\n"   // sfk1833
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk filesys\n"
             "         tell details about the file system of the\n"
             "         current directory (.)\n"
             "\n"
             "      #sfk filesys D:\n"
             "         tell about the file system used for drive D:\n"
             "\n"
             "      #sfk space\n"
             "         tell total and free MB of the current volume.\n"
             );
      #else
      // no filesystem (name) infos yet available under linux
      printx("<help>$sfk [-help] space [dirname]\n"
             "\n"
             "   show disk space informations.\n"
             "   a folder name can be specified which relates\n"
             "   to a specific volume or hard disk.\n"
             "\n"
             "   $options\n"
             "      -byte[s]  all size infos in bytes\n"
             "      -tab[s]   pure values, tab separated\n"
             "      -bin[ary] calculate with binary megabytes\n"
             "                of 1048576 bytes each.\n"
             "\n"
             "   $aliases\n"
             "      $sfk diskspace<def>  same as space\n"
             "      $sfk freespace<def>  tell only free space\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk space /thedir\n"
             "         tell total and free MB of the file system\n"
             "         used in /thedir. This can be a different\n"
             "         volume or medium than the current directory.\n"
             );
      #endif
      ehelp;

      sfkarg;

      bool bspace = (!strcmp(pszCmd, "diskspace") || !strcmp(pszCmd, "space")) ? 1 : 0;
      bool bfree  = 0;
      char *proot = 0;
      bool btabs  = 0;
      num  nDivisor = 1000000;
 
      if (!strcmp(pszCmd, "freespace"))
         { bspace=1; bfree=1; }

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (strBegins(argx[iDir], "-tab")) {
            btabs = 1;
            continue;
         }
         else
         if (strBegins(argx[iDir], "-byte")) {
            nDivisor = 1;
            continue;
         }
         else
         if (strBegins(argx[iDir], "-bin")) {
            nDivisor = 1048576;
            continue;
         }
         else
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!proot)
            { proot = argx[iDir]; continue; }
         return 9+pbad(pszCmd, argx[iDir]);
      }

      if (!proot)
         proot = str(".");

      num nTotal=0, nFree=0;
      char szFSName[200];
      char szVolID[200];
      uint nVolID=0;
 
      if (getFileSystemInfo(proot, nTotal, nFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10, nVolID))
         return 9+perr("unable to read file system infos.");
 
      char szTotal[100]; mclear(szTotal);
      char szFree[100];  mclear(szFree);

      numtoa(nTotal/nDivisor, 0, szTotal);
      numtoa(nFree/nDivisor, 0, szFree);
 
      const char *pszUnit = (nDivisor > 1) ? "mb":"";

      if (bfree)
         chain.print("%s\n", szFree);
      else
      if (bspace)
      {
         if (btabs)
            chain.print("%s\t%s\n", szTotal, szFree);
         else
            chain.print("total%s=%s\tfree%s=%s\n", pszUnit, szTotal, pszUnit, szFree);
      }
      else
      {
         if (btabs)
            chain.print("\"%s\"\t\"%s\"\t%s\t%s\n",
               szFSName, szVolID, szTotal, szFree);
         else
            chain.print("filesys=\"%s\" volume=\"%s\" total%s=%s free%s=%s\n",
               szFSName, szVolID, pszUnit, szTotal, pszUnit, szFree);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "testattr"))
   {
      if (argc < 3) return 9;
      char *pszFile = argv[2];
      Coi ocoi(pszFile, 0);
      uint nattr = ocoi.getAttr();

      printf("sfkattr %08X:\n", nattr);

      printf("   %c%c%c %c%c%c %c%c%c\n",
         (nattr & (1U << 8)) ? 'r':'-',
         (nattr & (1U << 7)) ? 'w':'-',
         (nattr & (1U << 6)) ? 'x':'-',

         (nattr & (1U << 5)) ? 'r':'-',
         (nattr & (1U << 4)) ? 'w':'-',
         (nattr & (1U << 3)) ? 'x':'-',

         (nattr & (1U << 2)) ? 'r':'-',
         (nattr & (1U << 1)) ? 'w':'-',
         (nattr & (1U << 0)) ? 'x':'-'
         );

      printf("   uid=%d gid=%d stk=%d\n",
         (nattr & (1U << 11)) ? 1:0,
         (nattr & (1U << 10)) ? 1:0,
         (nattr & (1U <<  9)) ? 1:0
         );
 
      bDone = 1;
   }

   if (!strcmp(pszCmd, "fileinfo"))
   {
      if (argc < 3) return 9;
      char *pszFile = argv[2];

      sfkstat_t ostat;

      int bdir=0,bread=0,bwrite=0;
      num  nmtime=0,nsize=0;
 
      num aExtTimes[2];
      memset(aExtTimes, 0, sizeof(aExtTimes));

      if (getFileStat(pszFile, bdir, bread, bwrite,
          nmtime, nsize, aExtTimes, &ostat, sizeof(ostat))) {
         pferr(pszFile, "cannot read: %s", pszFile);
      } else {
         // num nctime   = aExtTimes[0];
         // num natime   = aExtTimes[1];
         uint nmode  = (uint)ostat.st_mode;
         uint ninode = (uint)ostat.st_ino;
         uint ndev   = (uint)ostat.st_dev;
         uint nrdev  = (uint)ostat.st_rdev;
         printf("mode=%08Xh inode=%u device=%u rdev=%u\n", nmode, ninode, ndev, nrdev);
         printf("   S_IFDIR  %d\n", (nmode & S_IFDIR ) ? 1 : 0);
         printf("   S_IFCHR  %d\n", (nmode & S_IFCHR ) ? 1 : 0);
         printf("   S_IFREG  %d\n", (nmode & S_IFREG ) ? 1 : 0);
         printf("   S_IREAD  %d\n", (nmode & S_IREAD ) ? 1 : 0);
         printf("   S_IWRITE %d\n", (nmode & S_IWRITE) ? 1 : 0);
         printf("   S_IEXEC  %d\n", (nmode & S_IEXEC ) ? 1 : 0);
         #ifndef _WIN32
         printf("   S_IFIFO  %d\n", (nmode & S_IFIFO ) ? 1 : 0);
         printf("   S_IFLNK  %d\n", (nmode & S_IFLNK ) ? 1 : 0);
         printf("   S_IFBLK  %d\n", (nmode & S_IFBLK ) ? 1 : 0);
         printf("   S_IFSOCK %d\n", (nmode & S_IFSOCK) ? 1 : 0);
         #ifdef SFK_LINUX_FULL
         struct passwd *ppass = getpwuid(ostat.st_uid);
         if (ppass)
         printf("   owner    %s\n", ppass->pw_name);
         #endif
         #endif
      }

      bDone = 1;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "rawcol"))
   {
      if (argc < 3) return 9;
      int nval = atol(argv[2]);
      SetConsoleTextAttribute(hGlblConsole, nval);
      bDone = 1;
   }
   #endif

   ifcmd (   !strcmp(pszCmd, "filetime")  // +wref
          || !strcmp(pszCmd, "dirtime")
         )
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk filetime [opts] filename\n"
             "\n"
             "   print times available for a file or directory.\n"
             "\n"
             "   $main options\n"
             "      -mtime    print modification time (default)\n"
             "      -atime    print access time\n"
             #ifdef _WIN2
             "      -ctime    print creation time\n"
             #endif
             "      -all      print all available times\n"
             "      -utc      UTC/GMT instead of local time\n"
             "      -flat     print times like 20130413 065127\n"
             "      -flat2    print times like 20130413065127\n"
             "      -tab      separate output by TAB characters\n"
             "      -full     full technical view with all times,\n"
             "                utc, unix and windows timestamps\n"
             "      -noname   do not print filename in output\n"
             /*
             "\n"
             "   $technical view options\n"
             "      -loc[al]  print local time\n"
             "      -utc      print UTC time.\n"
             "      -ux       print the unix time seconds.\n"
             #ifdef _WIN32
             "      -wft      print the windows file time.\n"
             #endif
             */
             "\n"
             "   $variation:\n"
             "      #sfk dirtime<def>  list times of a single dir\n"
             "                 without contained files or dirs\n"
             "\n"
             "   $see also\n"
             "      #sfk touch<def>  change times of a file\n"
             "      #sfk list<def>   list files with time and size\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk filetime myfile.txt\n"
             "         print modification time for myfile.txt\n"
             "\n"
             "      #sfk dirtime mydir\n"
             "         print time just of mydir, without any\n"
             "         contained files or sub folders\n"
             "\n"
             "      #sfk filetime -all myfile.txt\n"
             "         print all times for myfile.txt\n"
             "\n"
             "      #sfk filetime -full myfile.txt\n"
             "         print all times as local, utc and\n"
             "         internal system timestamp values.\n"
             "\n"
             "      #sfk filetime -all -tab -flat2 mydir .txt\n"
             #ifdef _WIN32
             "         list modify, access and creation time for\n"
             #else
             "         list modification and access time for\n"
             #endif
             "         all .txt files in folder mydir as tab\n"
             "         separated data, with each date and time\n"
             "         combined as a flat timestamp.\n"
             "\n"
             "      #sfk filetime -withdirs mydir\n"
             "         also show times of sub directories\n"
             "         contained in mydir\n"
             "\n"
             "      #sfk filetime -full -justdirs mydir\n"
             "         show all time infos, only of sub dirs\n"
             "         within mydir, but not of files\n"
             );
      ehelp;

      sfkarg;

      bool bDirTime = strcmp(pszCmd, "dirtime") ? 0 : 1;
      char *pSingleDir = 0;

      cs.timemask = 0;
      cs.tabform  = 0;
      cs.flatTime = 0;
 
      uint mzone  = 0;
      uint mtype  = 0;
 
      bool bName  = 1;
      bool bCompact = 1;
      bool bUTC   = 0;

      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];

         // if (strbeg (pszArg, "-loc"  )) { mzone |=  16; continue; } else
         if (strcase(pszArg, "-utc"  )) { bUTC = 1; continue; } else
         // if (strcase(pszArg, "-ux"   )) { mzone |=  64; continue; } else
         // if (strcase(pszArg, "-wft"  )) { mzone |= 128; continue; } else

         if (strcase(pszArg, "-mtime")) { mtype |=   1; continue; } else
         if (strcase(pszArg, "-atime")) { mtype |=   2; continue; } else
         if (strcase(pszArg, "-ctime")) { mtype |=   4; continue; } else
         if (strcase(pszArg, "-all"))   { mtype |=   7; continue; } else

         if (strcase(pszArg, "-flat" )) { cs.flatTime  =   1; continue; } else
         if (strcase(pszArg, "-flat2")) { cs.flatTime  =   2; continue; } else
         if (strbeg (pszArg, "-tab"  )) { cs.tabform   =   1; continue; } else
         if (strbeg (pszArg, "-name" )) { bName        =   1; continue; } else
         if (strbeg (pszArg, "-noname")){ bName        =   0; continue; } else
         if (strcase(pszArg, "-full" )) {
            mzone = 16+32+64+128;
            mtype = 1+2+4;
            bCompact = 0;
            continue;
         }
         else
         if (strbeg (pszArg, "-plain")) {
            mzone = 16;
            mtype =  1;
            cs.flatTime = 1;
            cs.tabform = 1;
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         // process non-option keywords:
         if (bDirTime) {
            if (pSingleDir)
               return 9+perr("too many parameters");
            pSingleDir = pszArg;
            continue;
         }
         break;
      }

      int iDirNext = 0;
      bool bAnyDirParms = 0;
      if (pSingleDir)
         { }
      else
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext, &bAnyDirParms))) return lRC;
      if (btest) return 0;
 
      if (!mzone) mzone = 16;
      if (!mtype) mtype = 1;

      cs.timemask = mzone | mtype;

      // if showing only one time type then list no prefix
      uint n = (cs.timemask & 7);
      if (n==1 || n==2 || n==4)
         cs.timemask = cs.timemask & (0xFFFFUL ^ 8);
      else
         cs.timemask |= 8;

      if (bName   ) cs.timemask |= 256;
      if (bCompact) cs.timemask |= 512;
      if (bUTC    ) cs.timemask |= 1024;

      if (pSingleDir)
         lRC = execFileTime(pSingleDir);
      else
         lRC = walkAllTrees(eFunc_FileTime, lFiles, lDirs, nBytes);

      if (chain.coldata) {
         STEP_CHAIN(iDirNext, 1);
      } else {
         STEP_CHAIN(iDirNext, 0); // filetime
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "loadlib") || !strcmp(pszCmd, "loaddll"))
   {
      int iChainNext = 0;

      for (; iDir<argc; iDir++)
      {
         if (sfkisopt(argv[iDir])) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // load another library:
         #ifdef _WIN32
         char *pszFile = argv[iDir];
 
         HINSTANCE hlib = LoadLibraryA(pszFile);
         if (hlib != NULL)
            printf("loaded: %s   (%p)\n", pszFile, hlib);
         else
         {
            int nerr = GetLastError();
            char buffer[128];
            buffer[0] = '\0';
            FormatMessageA(
               FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
               NULL, nerr,
               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
               buffer, sizeof(buffer)-10, NULL);
            printf("failed to load %s : rc=%d %s\n",pszFile,nerr,buffer);
         }
 
         #else
 
      /*
         #ifdef MAC_OS_X
         NSObjectFileImage himg = 0;
         NSObjectFileImageReturnCode hres = 0;
         hres = NSCreateObjectFileImageFromFile(pszFile, &himg);
         if (hres == NSObjectFileImageSuccess) {
            NSModule hmod = NSLinkModule(himg, pszFile, NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_RETURN_ON_ERROR);
            NSDestroyObjectFileImage(himg);
            if (hmod != NULL)
               printf("loaded: %s\n", pszFile);
            else
               printf("failed to load: %s\n", pszFile);
         } else {
            printf("failed to load: %s\n", pszFile);
         }
         #else
         void *plib = dlopen(pszFile, RTLD_NOW);
         if (plib)
            printf("loaded: %s\n", pszFile);
         else
            printf("failed to load: %s\n", pszFile);
         #endif
      */
 
         #endif
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "readtest"))
   {
      if (argc < 3) return 9;
 
      char *pszSrc = argv[2];

      num nstart = getCurrentTime();
      int nlines = 0;

      Coi ocoi(pszSrc, 0);
      if (ocoi.open("rb"))
         return 9+pferr(pszSrc, "cannot read: %s", pszSrc);
      while (ocoi.readLine(szLineBuf, MAX_LINE_LEN) > 0) {
         nlines++;
         // if (!(nlines & 65535))
         //   { printf("%d lines   \r", nlines); fflush(stdout); }
         printf("%s",szLineBuf);
      }
      ocoi.close();

      num nelaps = getCurrentTime() - nstart;
      fprintf(stderr, "%d lines in %s msec\n",nlines,numtoa(nelaps));

      bDone = 1;
   }

   if (!strcmp(pszCmd, "md5test"))
   {
      SFKMD5 md5;
      uchar adata[] = { 0xFF };
      md5.update(adata, 1);
      uchar *pmd5 = md5.digest();
      mtklog(("test digest: %02X %02X %02X %02X",pmd5[0],pmd5[1],pmd5[2],pmd5[3]));
      printf("test digest: %02X %02X %02X %02X\n",pmd5[0],pmd5[1],pmd5[2],pmd5[3]);
      bDone = 1;
   }

   if (   !strcmp(pszCmd, "noop") || !strcmp(pszCmd, "rem") // +chaining
       || !strcmp(pszCmd, "endif")  // sfk189
      )
   {
      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
      }

      int iDirNext = 0;
      if (processDirParms(pszCmd, argc, argv, iDir, 0, &iDirNext)) return 9;

      STEP_CHAIN(iDirNext, 0); // noop

      bDone = 1;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "coninfo"))
   {
      hGlblConsole = GetStdHandle(STD_OUTPUT_HANDLE);
      CONSOLE_SCREEN_BUFFER_INFO oConInf;
      if (!GetConsoleScreenBufferInfo(hGlblConsole, &oConInf)) {
         printf("no console info available.\n");
      } else {
         WORD nAttrib = oConInf.wAttributes;
         printf("cons.attrib:\t0x%02lx\n", nAttrib);
         printf("cons.width :\t%u\n", oConInf.dwSize.X);
         printf("cons.height:\t%u\n", oConInf.dwSize.Y);
      }
      bDone = 1;
   }
   #endif

   /*
      NOTE:
         Between SystemInWinterTime and SystemInDST,
         -  FAT  mtimes and wft are NOT jumping,
         -  NTFS mtimes ARE jumping, wft are NOT jumping.
      SOLUTION:
         -  on Windows, do not read mtime, but use GetFileTime()
            then either convert this back to mtime (with local-
            dst-conversion)
            or store and use it directly in FileStat::writeTo().
            Also think on what to optimize:
            -  unchanged windows filetime
            -  and/or unchanged displayed filetime,
               which is relative to the current system DST mode.
            -  check also what xcopy does.
      TODOS:
        - /S /H /I /R /K /Y /D
        -  x  .  x  .  x  x  .
        - copy write-protected files
        - copy hidden dirs, files by default
        - do NOT copy empty directories
   */
   ifcmd (   !strcmp(pszCmd, "copy")  || !strcmp(pszCmd, "sync") // +wref +var
          || !strcmp(pszCmd, "xcopy") || !strcmp(pszCmd, "xsync")
         )
   {
      bool bext = 0;
      if (pszCmd[0] == 'x') { bext=1; pszCmd++; }

      ifhelp (!chain.usefiles && (argc < 4))

         printx("<help>$sfk copy srcRoot dstRoot [-dir subdir1 subdir2] [-file .ext1 .ext2]\n"
                "$sfk sync srcRoot dstRoot [-dir subdir1 subdir2] [-file .ext1 .ext2]\n"
                "\n");
         if (bext)
         printx("   Extended tree copy (experimental).\n");
         else
         printx("   Directory tree copy, update copy and synchronization.\n");
         printx("\n"
                "   If destination does not yet exist, whole content of source is copied,\n"
                "   #INCLUDING HIDDEN AND SYSTEM FILES.<def> If destination already exists,\n"
                "   only updates are copied.\n"
                "\n"
                "   #Symbolic links are NOT kept<def>, but their content is duplicated. If this\n"
                "   is a problem, use a copy command of your operating system instead.\n"
                "\n"
                "   $copy<def>   copies files from source to destination if the target file\n"
                "          doesn't exist yet, or if the source is NEWER than the target.\n"
                "          copy will NOT copy OLDER files over NEWER files. furthermore,\n"
                "          files that exist in destination but not in source are not removed,\n"
                "          so copy will ADD and REPLACE, but not DELETE.\n"
                "\n"
                "   $sync<def>   nearly same as copy, however files that exist in destination\n"
                "          but not in the source are called STALE files, and are DELETED\n"
                "          if their age is >= %d days. USE WITH CARE. If you specify wrong\n"
                "          folders or file masks, this may delete files unintentionally.\n"
                "          Take a close look at the output of the simulation mode, which\n"
                "          is active by default.\n"
                ,nGlblActiveFileAgeLimit);
         printx("\n"
            //  "   -cache        try to cache many small files in memory before writing\n"
            //  "                 them to the target directory.\n"
            //  "   -verify       try(!) to verify files after write. not active by default,\n"
            //  "                 as verify may succeed even if files have been corrupted on the\n"
            //  "                 target media (written data is often cached by operating system).\n"
            //  "   -empty        copy empty folders.\n"
                "   -mirror       with sync, copy even older files from source over destination.\n"
                /*
                "   -del          delete files in destination that do not exist in source,\n"
                "                 i.e. cleanup trash files. \"sfk copy -del\" is the same\n"
                "                 as \"sfk sync\". trash files younger than %d days are called\n"
                "                 \"stale\", and are not deleted even with -del specified.\n"
                "   -nodel        do not delete files or directories in destination.\n"
                "                 \"sfk sync -nodel\" is the same as \"sfk copy\".\n"
                */
                );
         printx("   -wipe         delete stale files now (ignoring file ages).\n"
                "   -nocopy       with sync, do not copy files, run only delete cleanup.\n"
                "                 can be used if you want copy files first with a different\n"
                "                 copy program, and then run an sfk sync-delete.\n"
                "   -diff         list files in destination which have been modified after\n"
                "                 last copy. Whenever you get a short info \"n differing files\n"
                "                 in dest\", add -dif to get their names listed.\n"
                "   -since        or -sincedir/dif/add/chg copies only files selected by age\n"
                "                 or difference to another directory. \"sfk list\" for details.\n"
                "   -nohidden     exclude hidden and system files from copy.\n"
                #if (!defined(SFK_LIB5))
                "   -nofollow     do not follow symbolic link directory contents.\n"
                #endif
                "   -nodirtime    since sfk 1.9.7.2 folder times are copied by default.\n"
                "                 to disable it use this, or <exp> SFK_CONFIG=nodirtime\n"
                "   -stat         in simulation: do not list filenames, only size statistics.\n"
                "   -keepstale=n  change the 30 days limit for stale files until deletion.\n"
                "   -noinfo       do not comment on skipped files.\n"
                "   -rel[names]   only with input chaining: strips source root directory names\n"
                "                 from filenames. if not selected, absolute paths starting\n"
                "                 like C:\\ or /tmp will be stripped automatically.\n"
                "                 some chain commands may provide filenames without separate\n"
                "                 directories, in this case -relnames will produce an error.\n"
             // "   -mem=mb       during read, data is cached in memory to reduce head movements\n"
             // "                 on HD. the buffer size (default=100mb) can be changed here.\n"
                "   -ltarg        always list target filenames (instead of source filenames).\n"
                "   -flat[=c]     do not create sub folders in output, but copy all into the\n"
                "                 same single output dir, with long flat names joining path\n"
                "                 parts by '-' or a given character c.\n"
                "   -flat2        like -flat but without path parts. there is no check\n"
                "                 for redundant output names.\n"
                );
         if (bext)
         printx("   -deep         verify content of files with same time and size. this takes\n"
                "                 much time, but is useful if you suspect that some hardware,\n"
                "                 esp. usb sticks, sometimes damages files during write.\n"
                "                 in this case, add an extra sfk sync -deep call (without -yes),\n"
                "                 just to have the files scanned after copy (with usb sticks,\n"
                "                 remove and re-insert them first to clear all file caches).\n"
                "\n");
         if (bext)
         printx("   $special options for use with unreliable media (usb sticks):\n"
                "\n"
                "   -sign[meta]   write signature databases for later verify, in a subdir\n"
                "                 \"zz-shadow-01\" within the target root directory.\n"
                "\n"
                "   -save[meta]   write signature databases AND redundant copies of copied\n"
                "                 files in destination, within the \"zz-shadow-01\" dir.\n"
                "\n"
                "   -load[meta]   reads meta informations from source directory, verifies if\n"
                "                 source files have been modified, and if so, takes redundant\n"
                "                 shadow copies instead.\n"
                "\n"
                "   -shadow=5m    limit creation of shadow files to small files < 5 mbytes.\n"
                /*
                "   same as above, only more detailed:\n"
                "\n"
                "   -signto       with \"-signto filename\", a signature database is created,\n"
                "                 containing content checksums of all source files. it is\n"
                "                 recommended to create a signature directory, e.g. e:\\sign,\n"
                "                 containing all signature files on the target media.\n"
                "   -check        with \"-check filename\", a signature database is loaded, and all\n"
                "                 source files are checked against this database. if the filename\n"
                "                 is not found, or the content differs, the file is NOT copied.\n"
                "   -shadow       with -signto, copies every file twice, creating a \"shadow\"\n"
                "                 of every file in a parallel target directory \"zz-shadow-01\".\n"
                "                 \"sfk sync -check\" will look for shadow files automatically\n"
                "                 in case that a (master) file is corrupted.\n"
                "\n"
                */
                );
         printx("\n"
                "   files with whole content being copied are listed in default color.\n"
                "   files that will be deleted during sync are listed in <warn>warning color<def>.\n"
                "   files with differing time but equal content are listed in <time>time color<def>.\n"
                "\n"
               );
         printx("   $completeness and efficiency:\n"
                "   - under Windows, SFK uses the CopyFileEx API function, which should\n"
                "     be able to copy most file attributes and contents as good and fast\n"
                "     as the XCopy command provided with Windows.\n"
                "   - under Linux, no native copy function is available, therefore SFK may\n"
                "     not be able to copy all attributes, access rights and timestamps\n"
                "     of the original files. Furthermore, copying can be slower than \"cp\".\n"
                "   - Directory attributes, access rights and time stamps may not be\n"
                "     completely reproduced both on Windows and Linux.\n"
                "   - Changes from/to Daylight Saving Time, differing time zones or copies\n"
                "     between FAT and NTFS may always copy files which were copied already.\n"
                "     this is a general problem with all copy commands.\n"
                "\n"
               );
         printx("   $using file system views:\n"
                "      if you want to specify many directory trees and dir/file masks,\n"
                "      you may create a fileset, containing a list of directories.\n"
                "      type \"sfk help fileset\" for details.\n"
                "\n"
                "   #NO WARRANTY FOR DATA INTEGRITY.<def> SFK copy is very convenient to use,\n"
                "   but if you need to copy massive amounts of highly important data, it is\n"
                "   recommended to use the original copy command of your operating system.\n"
                "   Always keep backups of important stuff. After large copies, do some spot\n"
                "   checking if important files were really copied without modifications.\n"
                "   Always double-check the reliability of external media like USB sticks,\n"
                "   e.g. by creating md5 lists (see \"sfk md5gento\").\n"
                "\n"
                );
         printx("   $see also\n"
                "      #sfk move<def>        move files between two folders.\n"
                "      #sfk syncnames<def>   sync file name changes.\n"
                "\n"
                );
         webref("copy");
         printx("   $examples\n"
                "      #sfk copy g:\\myimage.zip .\n"
                "         copy file myimage.zip from drive G: into the current folder.\n"
                "         doing so with sfk will show the progress while copying.\n"
                "      #sfk copy c:\\work d:\\arc\\work -dir . <not>\\tmp\\ <not>\\save\\ -file <not>.bak\n"
                "         copy directory tree c:\\work to d:\\arc\\work, excluding all dirs\n"
                "         called tmp or save, including all files except .bak files.\n"
                "      #sfk copy d:\\proj v:\\team\\proj -dir foosys\\include foosys\\source tools\n"
                "         within directory tree proj, copy subdirectory trees foosys\\include,\n"
                "         foosys\\source and tools, including all files therein.\n"
                "      #sfk filter testfiles -+foo +copy \\tmp\n"
                "         copy all files from testfiles containing \"foo\" to \\tmp.\n"
                "      #sfk copy work archive -fileset myflist.txt\n"
                "         copy the files listed in myflist.txt from work to archive.\n"
                "         note that \"-yes\" must be specified directly after \"copy\".\n"
                "         see also \"sfk help fileset\".\n"
                "      #sfk list mydir .txt .doc code.cpp +copy d:\\save\n"
                "         copies all .txt, .doc and code.cpp files from within mydir,\n"
                "         including all subdirs, to d:\\save. ALSO copies mycode.cpp,\n"
                "         subcode.cpp.1 etc. as \"code.cpp\" ist just a pattern.\n"
                "      #sfk list -sincedir mydir1 -dir mydir2 -subdir <not><sla>save<sla>\n"
                "       #-file <not>.bak +copy mydir3\n"
                "         copies all files that were added or changed between mydir1\n"
                "         and mydir2 to mydir3, excluding files in sub folders \"save\",\n"
                "         and excluding .bak files (type whole command in one line).\n"
                "         type \"sfk list\" for more on -sincedir, -sinceadd or -sincedif.\n"
                "      #sfk sel website .jpg .png .gif +copy tmp -flat\n"
                "         copy all images from all subfolders within website into\n"
                "         a single flat output folder tmp, without any sub folders.\n"
                "         this allows to get an image overview (gallery) by opening\n"
                "         tmp within windows explorer.\n"
                "      #sfk sel a.txt b.txt c.txt +copy <sla>tmp\n"
                "         copy enumerated files to <sla>tmp\n"
                );
         #ifdef _WIN32
         printx("      #sfk fromclip +copy <sla>tmp\n"
                "         copy files listed in the clipboard to <sla>tmp\n"
                );
         #endif
         if (bext)
         printx("      #sfk sync -save x:\\ e:\\ -dir src -wipe\n"
                "         copy directory \"src\" from X: onto usb stick (E:), with checksums\n"
                "         and shadow files, instantly deleting stale files that are found\n"
                "         within E:\\src but not within X:\\src .\n"
                "      #sfk verify e:\\ -all\n"
                "         verifies files on the stick (leave out -all to check only the ones\n"
                "         copied most recently). you must remove and re-insert the stick before\n"
                "         running the verify, otherwise data is taken from cache, leading always\n"
                "         to successful verifies even if files are corrupted.\n"
                "      #sfk sync -load e:\\ z:\\ -dir src\n"
                "         copies files from stick to hard disk (Z:), verifying all source files\n"
                "         before copy. files that fail verification are replaced by shadows.\n"
                "      #sfk copy -save x:\\ e:\\ -dir src -since today\n"
                "         copies today's changed or added files from X:\\src to E:\\src.\n"
                );

      ehelp;

      sfkarg;

      DisableCtrlCProcessExit(); // copy

      bool bchain = chain.usefiles;

      char *pszSrc   = 0;
      char *pszDst   = 0;
      bool  bCopy    = 1;
      int  nDoSave  = 0;
      bool  bDoLoad  = 0;
      int  nBufMB   = 100;
      int iChainNext = 0;

      cs.verifyLate = 0;
      cs.hidden = 1; // include hidden/system by default
      cs.syncFiles = !strncmp(pszCmd, "sync", 4);

      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-mem", &pszParm)) {
            if (!pszParm) return 9;
            nBufMB = atol(pszParm);
            continue;
         }
         if (!strncmp(pszArg, "-nov", 4)) {
            cs.verifyEarly = 0;
            cs.verifyLate  = 0;
            continue;
         }
         if (!strcmp(pszArg, "-ver")  // fix sfk1972 shadowed -verbose
             || !strcmp(pszArg, "-verify")) {
            cs.verifyEarly = 0;
            cs.verifyLate  = 1;
            continue;
         }
         if (!strncmp(pszArg, "-mir", 4)) {
            cs.syncOlder = 1;
            continue;
         }
         if (!strncmp(pszArg, "-noca", 5)) {
            bGlblUseCopyCache = 0;
            continue;
         }
         if (!strncmp(pszArg, "-del", 4)) {
            cs.syncFiles = 1;
            continue;
         }
         if (!strcmp(pszArg, "-wipe")) {
            cs.delStaleFiles = 1;
            continue;
         }
         if (!strncmp(pszArg, "-nodel", 6)) {
            cs.syncFiles = 0;
            continue;
         }
         if (!strncmp(pszArg, "-noco", 5)) {
            bCopy = 0;
            continue;
         }
         if (!strncmp(pszArg, "-dif", 4)) {
            bGlblShowSyncDiff = 1;
            continue;
         }
         if (!strcmp(pszArg, "-cache")) {
            bGlblUseCopyCache = 1;
            continue;
         }
         if (!strcmp(pszArg, "-deep")) {
            bGlblIgnoreTime = 1;
            continue;
         }
         if (!strcmp(pszArg, "-flat")) {
            cs.flat = 1;
            cs.cflatpat = '-';
            cs.listTargets = 1;
            continue;
         }
         if (!strcmp(pszArg, "-flat2")) { // todo: redundant file detection
            cs.flat = 2;
            cs.listTargets = 1;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-flat", &pszParm)) {
            if (!pszParm) return 9;
            if (strlen(pszParm)>1)
               return 9+perr("supply only a single character for -flat\n");
            cs.flat = 1;
            cs.cflatpat = pszParm[0];
            cs.listTargets = 1;
            continue;
         }
         if (!strcmp(pszArg, "-style")) {
            nGlblCopyStyle = 0;
            continue;
         }
         if (strBegins(pszArg, "-link")) {
            cs.copyLinks = 1; // windows only, untested.
            continue;
         }
         if (strBegins(pszArg, "-nobuf")) {
            cs.copyNoBuf = 1; // windows only, untested.
            continue;
         }
         if (strBegins(pszArg, "-decrypt")) {
            cs.copyDecrypt = 1; // windows only, untested.
            continue;
         }
         if (!strcmp(pszArg, "-stat"))      { cs.dostat=1; continue; }
         if (!strncmp(pszArg, "-save", 5))  { nDoSave=2; continue; }
         if (!strncmp(pszArg, "-sign", 5))  { nDoSave=1; continue; }
         if (!strncmp(pszArg, "-load", 5))  { bDoLoad=1; continue; }
         if (!strcmp(pszArg, "-shadow")) {
            nGlblCopyShadows = 1;
            continue;
         }
         if (!strncmp(pszArg, "-shadow=", 8)) {
            nGlblCopyShadows = 1;
            nGlblShadowSizeLimit = atol(pszArg+8) * 1000000;
            continue;
         }
         /*
         if (haveParmOption(argx, argc, iDir, "-signto", &pszParm)) {
            if (!pszParm) return 9;
            pszSignTo = pszParm;
            continue;
         }
         */
         if (haveParmOption(argx, argc, iDir, "-check", &pszParm)) {
            if (!pszParm) return 9;
            if (filedb.openRead(pszParm, 1)) return 9;
            // -> filedb.canRead() is set
            cs.skipOwnMetaDir = 1;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-checksigns", &pszParm)) {
            if (!pszParm) return 9;
            if (filedb.openRead(pszParm, 1)) return 9;
            // -> filedb.canRead() is set
            continue;
         }
         if (!strcmp(pszArg, "-nodirtime")) {
            cs.nodirtime = 1;
            continue;
         }
         if (!strcmp(pszArg, "-move")) 
            { cs.movefiles = 1; continue; }
         if (!strcmp(pszArg, "-empty"))   // sfk1972 internal
            { cs.withempty = 1; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!bchain && !pszSrc) {
            pszSrc = pszArg;
            if (!coiExists(pszSrc, 1)) // 1: or dir
               return 9+pferr(pszSrc, "no such file or directory: %s\n", pszSrc);
            continue;
         }
         if (!pszDst) { pszDst = pszArg; continue; }
         // further parms: file selection masks
         break; // fall through
      }

      // init source and target dirs or files.

      if (!bchain && !pszSrc) return 9+perr("missing source directory or file.\n");
      if (!pszDst) return 9+perr("missing target directory%s.\n", bchain? "":" or file");

      // remember this, have to strip it from full paths
      pszGlblCopySrc = pszSrc; // NULL on chaining

      // num nTime1 = getCurrentTime();

      // parse subdirs and general options
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iChainNext)))
         return lRC;

      // now we know if in simulation or not
      cs.sim = !cs.yes;

      // reset global statistics
      cs.totalbytes = 0;

      // activate source shadow skip implicitely if meta data are found
      if (!bchain && !cs.skipOwnMetaDir) {
         joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszSrc, str("zz-shadow-01"));
         if (isDir(szRefNameBuf)) {
            joinPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, szRefNameBuf, str("zz-sign"));
            if (filedb.isSignatureFile(szRefNameBuf2)) {
               filedb.setMetaDir(szRefNameBuf);
               cs.skipOwnMetaDir = 1;
            }
         }
      }

      if (!bchain)
      {
         // execute aliases: save, load, verify
         if (bDoLoad) {
            // same as -check dstroot\zz-shadow-01\sign.dat -shadow
            // setup signature database name:
            if (filedb.canRead()) return 9+perr("specify -load OR -check, but not both");
            joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszSrc, str("zz-shadow-01"));
            if (!isDir(szRefNameBuf)) return 9+perr("metadb directory not found: %s\n", szRefNameBuf);
            if (filedb.setMetaDir(szRefNameBuf)) return 9;
            joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszSrc, str("zz-sign"));
            // if (!cs.sim)
            if (filedb.openRead(szRefNameBuf2, 1)) return 9;
            // avoid copying of own metadir to target
            cs.skipOwnMetaDir = 1;
         }
         else
         if (nDoSave) {
            // user said -save explicitely
            if (!cs.sim) {
               if (createSubDirTree(pszDst, str("zz-shadow-01")))
                  return 9;
               joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszDst, str("zz-sign"));
               if (filedb.openUpdate(szRefNameBuf2))
                  return 9;
               if (nDoSave >= 2)
                  nGlblCopyShadows = 1;
            }
         } else {
            // no -save: check if a signature db exists in target
            joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszDst, str("zz-shadow-01"));
            if (isDir(szRefNameBuf)) {
               joinPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, szRefNameBuf, str("zz-sign"));
               if (filedb.isSignatureFile(szRefNameBuf2)) {
                  if (!cs.sim) {
                     // user forgot -save: open for update implicitely
                     // setTextColor(nGlblTimeColor);
                     // oprintf("updating signature database: %s-nn.dat\n", szRefNameBuf2);
                     // setTextColor(-1);
                     filedb.openUpdate(szRefNameBuf2); // ignore rc
                  } else {
                     setTextColor(nGlblTimeColor);
                     printf("NOTE: signature database found. say -save to write shadows.\n");
                     setTextColor(-1);
                  }
               }
            }
         }

         // check: -shadow requires explicite -dir name listings
         if (nGlblCopyShadows || nDoSave) {
            if (!cs.sim) {
               if (!filedb.canRead() && !filedb.canUpdate())
                  return 9+perr("-shadow requires -signto or -check\n");
            }
         }
      }  // endif nochain

      // setup work buffer
      if (!cs.sim && nBufMB) {
         nGlblWorkBufSize = (num)nBufMB * 1000000;
         pGlblWorkBuf = new uchar[nGlblWorkBufSize];
         if (!pGlblWorkBuf) return 9+perr("out of memory, cannot allocate working buffer.\n");
         glblCopyCache.setBuf(pGlblWorkBuf, nGlblWorkBufSize);
      }
      // NO RETURN W/O DELETE FROM HERE

      bool bSrcDir = bchain || isDir(pszSrc);
      bool bDstDir = isDirByName(pszDst) || isDir(pszDst);
      int nVerFiles  = 0;
      int nVerFailed = 0;
      int nSignsWritten = 0;
 
      mtklog(("copy: copy=%d chain=%d sdir=%d ddir=%d", bCopy,bchain,bSrcDir,bDstDir));
      mtklog(("copy: src=\"%s\" dir=%d", pszSrc, bSrcDir));
      mtklog(("copy: dst=\"%s\" dir=%d", pszDst, bDstDir));

      if (!bchain && !bSrcDir && !bDstDir) {
         if (!bCopy) return 9+perr("-nocopy not supported with single file operation.\n");
         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         // single conditional file copy.
         createOutDirTree(pszDst);
         lRC = execFileCopySub(pszSrc, pszDst);
         glblCopyCache.flush();
      }
      else
      if (!bchain && !bSrcDir) {
         if (!bCopy) return 9+perr("-nocopy not supported with single file operation.\n");
         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         // src is a file, target a dir.
         strcopy(szRefNameBuf, pszDst);
         int nLen = strlen(szRefNameBuf);
         if ((nLen > 0) && (szRefNameBuf[nLen-1] != glblPathChar))
            strcat(szRefNameBuf, glblPathStr);
         // isolate last part of source name
         char *pszRelName = strrchr(pszSrc, glblPathChar);
         #ifdef _WIN32
         if (!pszRelName) pszRelName = strrchr(pszSrc, ':');
         #endif
         if (pszRelName) pszRelName++;
         else pszRelName = pszSrc;
         // combine target filename
         strcat(szRefNameBuf, pszRelName);
         if (cs.verbose)
            info.print("%s => %s\n",pszSrc,szRefNameBuf);
         createOutDirTree(szRefNameBuf);
         lRC = execFileCopySub(pszSrc, szRefNameBuf);
         glblCopyCache.flush();
      }
      else
      while (bSrcDir) // need to exit by break
      {
         // copy directory tree to a target tree.
         pszGlblPreRoot = pszSrc; // NULL on chaining
         pszGlblCopyDst = pszDst;

         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         if (bCopy) {
            mtklog(("copy: calling walktrees, hasroot.0 = %d", glblFileSet.hasRoot(0)));
            lRC = walkAllTrees(eFunc_Copy, lFiles, lDirs, nBytes);
            if (lRC)
               break;
         }
         glblCopyCache.flush();

         // separate verify pass after copy, to (hopefully)
         // get around file system caching:
         if (!cs.sim && cs.verifyLate) // verify
         {
            glblVerifier.verify();
            nVerFiles  = glblVerifier.matchedFiles();
            nVerFailed = glblVerifier.failedFiles();
            info.clear(); // status output below
         }

         if (!bchain && cs.syncFiles)
         {
            // cleanup pass: check target for trash files

            // 1. reverse copy direction
            pszGlblPreRoot = pszDst;
            pszGlblCopySrc = pszDst;
            pszGlblCopyDst = pszSrc;

            if (nGlblCopyShadows) {
               // 2. meta dir was written on copy, filter it out on reverse scan.
               cs.skipOwnMetaDir = 1;
               joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszGlblCopySrc, str("zz-shadow-01"));
               if (!cs.sim && !isDir(szRefNameBuf)) return 9+perr("metadb directory not found: %s\n", szRefNameBuf);
               filedb.setMetaDir(szRefNameBuf);
            }

            cs.filesScanned = 0;
            cs.dirsScanned  = 0;
            lRC = walkAllTrees(eFunc_Cleanup, lFiles, lDirs, nBytes);
         }

         if (filedb.canUpdate())
            filedb.save(nSignsWritten); // ignore rc

         break;
      }

      glblCopyCache.flush();

      // NO RETURN W/O DELETE UNTIL HERE

      info.clear();

      if (cs.sim && !cs.nohead) {
         if (cs.files || cs.dirs || cs.filesDeleted || cs.dirsDeleted || cs.filesCloned || cs.dirsCloned)
            printx("$[add -yes to execute.]\n");
         else
            printx("$[no differences.]\n");
      }

      bool bsilent = (cs.nohead || cs.quiet);

      // num nTime2 = getCurrentTime();
      bool bTold = 0;
      if (!bSrcDir && !bDstDir)
         { } // single file copy
      else
      if (!bsilent && (cs.files || cs.dirs || cs.filesCloned || cs.dirsCloned))
      {
         const char *pszVerb = cs.sim ? "would copy":"copied";
         if (!cs.filesCloned && !cs.dirsCloned)
            printx("$%s %u files, %u dirs.", pszVerb, cs.files, cs.dirs);
         else {
            printx("$%s %u files, %u dirs (%u/%u attribs", pszVerb, cs.files, cs.dirs, cs.filesCloned, cs.dirsCloned);
            if (nVerFiles > 0)
               printx("$, %d verified",nVerFiles);
            if (nVerFailed > 0)
               printx("$, <err>%d failed",nVerFailed);
            printx("$).");
         }
         if (cs.totalbytes > 0) {
            num nmbytes = cs.totalbytes / 1000000;
            num nkbytes = cs.totalbytes / 1000;
            if (nmbytes > 0)
               printx(" <time>%s mb.<def>",numtoa(nmbytes));
            else
            if (nkbytes > 0)
               printx(" <time>%s kbytes.<def>",numtoa(nkbytes));
            else
               printx(" <time>%s bytes.<def>",numtoa(cs.totalbytes));
         }
         bTold = 1;
      }
      if (!bsilent && (cs.filesDeleted || cs.dirsDeleted)) {
         const char *pszVerb = cs.sim ? "would delete":"deleted";
         setTextColor(nGlblWarnColor, 1);
         printf("%s%s %d files, %d dirs.", bTold?" ":"", pszVerb, cs.filesDeleted, cs.dirsDeleted);
         setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && cs.filesNewerInDst) {
         // setTextColor(nGlblWarnColor, 1);
         printx("%s$(%d differing files in dest)", bTold?" ":"", cs.filesNewerInDst);
         // setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && (cs.numHiddenFilesSkipped || cs.numHiddenDirsSkipped)) {
         setTextColor(nGlblWarnColor, 1);
         printf("%sskipped %d hidden files, %d dirs.", bTold?" ":"", cs.numHiddenFilesSkipped, cs.numHiddenDirsSkipped);
         setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && bTold && (nSignsWritten > 0)) { // && filedb.canUpdate()
         setTextColor(nGlblTimeColor, 1);
         printf(" %d signatures", nSignsWritten);
         if (cs.shadowsWritten)
            printf(", %d shadows", cs.shadowsWritten);
         printf(".");
         setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && filedb.canRead() && filedb.anyEvents())
      {
         cchar *pszpre = " ";
         cchar *pszsub = "signs ";
         if (filedb.numberOfVerFailed() > 0) {
            if (filedb.numberOfVerFailed() == cs.shadowFallbacks)
               setTextColor(nGlblWarnColor, 1);
            else
               setTextColor(nGlblErrColor, 1);
            printf(" %d signatures failed", filedb.numberOfVerFailed());
            if (cs.shadowFallbacks) {
               setTextColor(nGlblWarnColor, 1);
               printf(", %d shadow fallbacks", cs.shadowFallbacks);
            }
            pszpre=", "; pszsub="";
         }
         if (filedb.numberOfVerMissing() > 0) {
            setTextColor(nGlblErrColor, 1);
            printf("%s%d %snot found", pszpre, filedb.numberOfVerMissing(), pszsub);
            pszpre=", "; pszsub="";
         }
         setTextColor(nGlblTimeColor, 1);
         if (filedb.numberOfVerifies() > 0) {
            printf("%s%d %schecked.", pszpre, filedb.numberOfVerifies(), pszsub);
            pszpre=", "; pszsub="";
         }
         setTextColor(-1);
         bTold = 1;
      }
      if (bTold)
         printf("\n");

      if (cs.filesStale) {
         setTextColor(nGlblWarnColor, 1);
         printf("%d stale but recently edited files are kept until deletion limit (%d days).\n", cs.filesStale, nGlblActiveFileAgeLimit);
         setTextColor(-1);
      }

      delete [] pGlblWorkBuf;
      pGlblWorkBuf = 0;

      pszGlblPreRoot = 0;

      STEP_CHAIN(iChainNext, 0); // copy

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "move")) // sfk1914
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk move srcRoot dstRoot [-dir subdir1 subdir2] [-file .ext1 .ext2]\n"
             "\n"
             "   move files between two folders.\n"
             "\n"
             "   can be used only within the same drive/partition.\n"
             "\n"
             "   moving across drives can be done by:\n"
             "   1. select ... +copy\n"
             "   2. select ... +delete\n"
             "\n"
             "   move does not copy folder meta informations like\n"
             "   folder modification time, and it cannot clean up\n"
             "   empty leftover folders.\n"
             "\n"
             "   $options\n"
             "      -rel     do not include srcRoot in output names.\n"
             "               normally used with chained commands like\n"
             "               sfk select ... +move\n"
             "      -nostop  continue on conflicts. normally move\n"
             "               stops on the first file that already\n"
             "               exists in the target folder.\n"
             "      -flat    do not keep folder structure in output,\n"
             "               but move all into one folder with long\n"
             "               unique filenames\n"
             "      -flat2   move filenames without any path info\n"
             "               to out folder. may cause conflicts\n"
             "               on identical filenames.\n"
             "\n"
             "   $command chaining\n"
             "      accepts filename lists from previous commands\n"
             "\n"
             "   $see also\n"
             "      #sfk xrename<def>   flexible rename over all files\n"
             "                    of a folder, also allowing to move\n"
             "                    renamed files to an output folder.\n"
             "\n"
             "   $examples\n"
             "      #sfk move mydir outdir -dir . -subdir trash\n"
             "         move files from mydir to outdir which are\n"
             "         in sub folders like trash, trash2 etc.\n"
             "      #sfk sel mydir .bak +move -rel outdir\n"
             "         select all .bak files in mydir, then move\n"
             "         them to outdir. do not include 'mydir' in\n"
             "         the output path.\n"
             "      #sfk sel a.txt b.txt c.txt +move <sla>tmp\n"
             "         move enumerated files to <sla>tmp\n"
             );
      #ifdef _WIN32
      printx("      #sfk fromclip +move <sla>tmp\n"
             "         move files listed in clipboard to <sla>tmp\n"
             );
      #endif
      ehelp;

      sfkarg;

      bool bchain = chain.usefiles;

      char *pszSrc   = 0;
      char *pszDst   = 0;
      int iChainNext = 0;

      cs.hidden = 1; // include hidden/system by default
      cs.movefiles = 1;

      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (!strcmp(argx[iDir], "-flat")) {
            cs.flat = 1;
            cs.cflatpat = '-';
            cs.listTargets = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-flat2")) {
            cs.flat = 2;
            cs.cflatpat = '-';
            cs.listTargets = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-nostop"))
            { cs.nostop = 1; continue; }
         if (haveParmOption(argx, argc, iDir, "-flat", &pszParm)) {
            if (!pszParm) return 9;
            if (strlen(pszParm)>1)
               return 9+perr("supply only a single character for -flat\n");
            cs.flat = 1;
            cs.cflatpat = pszParm[0];
            cs.listTargets = 1;
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!bchain && !pszSrc) {
            pszSrc = argx[iDir];
            if (!coiExists(pszSrc, 1)) // 1: or dir
               return 9+pferr(pszSrc, "no such file or directory: %s\n", pszSrc);
            continue;
         }
         if (!pszDst) { pszDst = argx[iDir]; continue; }
         // further parms: file selection masks
         break; // fall through
      }

      // init source and target dirs or files.

      if (!bchain && !pszSrc) return 9+perr("missing source directory or file.\n");
      if (!pszDst) return 9+perr("missing target directory%s.\n", bchain? "":" or file");

      // remember this, have to strip it from full paths
      pszGlblCopySrc = pszSrc; // NULL on chaining

      // parse subdirs and general options
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iChainNext)))
         return lRC;

      // now we know if in simulation or not
      cs.sim = !cs.yes;

      bool bSrcDir = bchain || isDir(pszSrc);
      bool bDstDir = isDirByName(pszDst) || isDir(pszDst);

      glblOutFileMap.reset();

      if (!bchain && !bSrcDir && !bDstDir) {
         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         // single file move.
         createOutDirTree(pszDst);
         lRC = execFileMoveSub(pszSrc, pszDst);
      }
      else
      if (!bchain && !bSrcDir) {
         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         // src is a file, target a dir.
         strcopy(szRefNameBuf, pszDst);
         int nLen = strlen(szRefNameBuf);
         if ((nLen > 0) && (szRefNameBuf[nLen-1] != glblPathChar))
            strcat(szRefNameBuf, glblPathStr);
         // isolate last part of source name
         char *pszRelName = strrchr(pszSrc, glblPathChar);
         #ifdef _WIN32
         if (!pszRelName) pszRelName = strrchr(pszSrc, ':');
         #endif
         if (pszRelName) pszRelName++;
         else pszRelName = pszSrc;
         // combine target filename
         strcat(szRefNameBuf, pszRelName);
         if (cs.verbose)
            info.print("%s => %s\n",pszSrc,szRefNameBuf);
         createOutDirTree(szRefNameBuf);
         lRC = execFileMoveSub(pszSrc, szRefNameBuf);
      }
      else if (bSrcDir)
      {
         // copy directory tree to a target tree.
         pszGlblPreRoot = pszSrc; // NULL on chaining
         pszGlblCopyDst = pszDst;

         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         lRC = walkAllTrees(eFunc_Move, lFiles, lDirs, nBytes);
      }

      info.clear();

      if (cs.sim && !cs.nohead) {
         if (cs.files || cs.dirs || cs.filesDeleted || cs.dirsDeleted)
            printx("$[add -yes to execute.]\n");
         else
            printx("$[no differences.]\n");
      }

      bool bsilent = (cs.nohead || cs.quiet);

      bool bTold = 0;
      if (!bSrcDir && !bDstDir)
         { } // single file copy
      else
      if (!bsilent && (cs.files || cs.dirs))
      {
         const char *pszVerb = cs.sim ? "would move":"moved";
         // printx("$%s %u files, %u dirs.", pszVerb, cs.files, cs.dirs);
         printx("$%s %u files.", pszVerb, cs.files);
         bTold = 1;
      }
      if (!bsilent && (cs.filesDeleted || cs.dirsDeleted)) {
         const char *pszVerb = cs.sim ? "would delete":"deleted";
         setTextColor(nGlblWarnColor, 1);
         // printf("%s%s %d files, %d dirs.", bTold?" ":"", pszVerb, cs.filesDeleted, cs.dirsDeleted);
         printf("%s%s %d files.", bTold?" ":"", pszVerb, cs.filesDeleted);
         setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && cs.filesNewerInDst) {
         printx("%s$(%d differing files in dest)", bTold?" ":"", cs.filesNewerInDst);
         bTold = 1;
      }
      if (!bsilent && (cs.numHiddenFilesSkipped || cs.numHiddenDirsSkipped)) {
         setTextColor(nGlblWarnColor, 1);
         printf("%sskipped %d hidden files, %d dirs.", bTold?" ":"", cs.numHiddenFilesSkipped, cs.numHiddenDirsSkipped);
         setTextColor(-1);
         bTold = 1;
      }
      if (bTold)
         printf("\n");
      if (cs.filesRedundant)
         printx("<err>%d output name conflicts found.\n", cs.filesRedundant);

      glblOutFileMap.reset();

      pszGlblPreRoot = 0;

      STEP_CHAIN(iChainNext, 0); // move

      bDone = 1;
   }

   if (!strcmp(pszCmd, "verify") ||!strcmp(pszCmd, "syncver"))
   {
      if (blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      if (argc < 3) {
      printx("<help>$sfk sfk verify [-cleanup] [-all] rootdir\n"
             "\n"
             "   verify contents of directory by a given file meta database,\n"
             "   as it is created by sfk copy -sign ...\n"
             "\n"
             "   $options\n"
             "      -cleanup     cleanup records that fail to verify, and/or\n"
             "                   update records with timestamp mismatches.\n"
             "      -all         by default, only records that have been updated\n"
             "                   recently are checked. say -all to check all.\n"
             "\n"
             "   $see also\n"
             "      sfk copy\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk verify e: -all\n"
             "         verify contents on E:, which could be an USB stick.\n"
             );
      return 9;
      }

      char *pszDBFile = 0;
      pszGlblCopySrc  = 0;
      bool bCheckAll  = 0;
      bool bCleanup   = 0;
      char *pszParm1  = 0;
      char *pszParm2  = 0;

      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-all")) {
            bCheckAll = 1;
            continue;
         }
         if (!strncmp(argv[iDir], "-cle", 4)) {
            bCleanup = 1;
            continue;
         }
         if (sfkisopt(argv[iDir])) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // process non-option keywords:
         if (!pszParm1) { pszParm1 = argv[iDir]; continue; }
         if (!pszParm2) { pszParm2 = argv[iDir]; continue; }
         return 9+pbad(pszCmd, argv[iDir]);
      }

      if (!pszParm2)
         // just one parm: have rootdir
         pszGlblCopySrc = pszParm1;
      else {
         pszDBFile      = pszParm1;
         pszGlblCopySrc = pszParm2;
      }

      if (!pszGlblCopySrc) return 9+perr("missing root directory name\n");

      if (pszDBFile) {
         if (filedb.openRead(pszDBFile, 1))
            return 9;
      } else {
         joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszGlblCopySrc, str("zz-shadow-01"));
         if (!isDir(szRefNameBuf)) return 9+perr("metadb directory not found: %s\n", szRefNameBuf);
         joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszGlblCopySrc, str("zz-sign"));
         if (filedb.openRead(szRefNameBuf2, 1)) return 9;
      }

      int nVerMixRC = 0;
      int nSkipped = 0;
      for (int i=0; i<filedb.numberOfFiles(); i++)
      {
         if (userInterrupt())
            break;
         int nflags = filedb.getFileFlags(i);
         if (bCheckAll || (nflags >= 2)) {
            nVerMixRC |= filedb.verifyFile(i, bCleanup);
         } else {
            nSkipped++;
         }
      }
      info.clear();

      bool bTold = 0;

      if (!cs.quiet) {
         if (!filedb.numberOfVerifies() && !bCheckAll) {
            int ncnt = filedb.numberOfFiles();
            printf("%s contains no recently updated files. say -all to check all %d entries.",pszGlblCopySrc,ncnt);
         } else {
            const char *pxinfo = bCheckAll ? "" : "recently updated ";
            printf("%s %d %sfiles verified.",pszGlblCopySrc,filedb.numberOfVerifies(),pxinfo);
         }
         bTold = 1;
      }

      if (!cs.quiet && filedb.canRead() && filedb.anyEvents())
      {
         cchar *pszpre = " ";
         cchar *pszsub = "signs ";
         if (filedb.numberOfVerFailed() > 0) {
            if (filedb.numberOfVerFailed() == cs.shadowFallbacks)
               setTextColor(nGlblWarnColor, 1);
            else
               setTextColor(nGlblErrColor, 1);
            printf(" %d signatures failed", filedb.numberOfVerFailed());
            if (cs.shadowFallbacks) {
               setTextColor(nGlblWarnColor, 1);
               printf(", %d shadow fallbacks", cs.shadowFallbacks);
            }
            pszpre = ", ";
         }
         if (filedb.numberOfVerMissing() > 0) {
            setTextColor(nGlblErrColor, 1);
            printf("%s%d %snot found", pszpre, filedb.numberOfVerMissing(), pszsub);
            pszpre=", "; pszsub="";
         }
         setTextColor(nGlblTimeColor, 1);
         printf("%s%d %schecked", pszpre, filedb.numberOfVerifies(), pszsub);
         if (nSkipped)
            printf(", %d skipped", nSkipped);
         printf(".");
         setTextColor(-1);
         bTold = 1;
      }
      if (bTold)
         printf("\n");

      if (nVerMixRC && bCleanup) {
         // at least one record failed to verify, and cleanup is selected:
         // rewrite meta db.
         int nRecWritten = 0;
         int nSaveRC = filedb.save(nRecWritten);
         if (!nSaveRC)
            printf("metadb cleaned up, %d records written.\n", nRecWritten);
         // else error was printed within save()
      }

      bDone = 1;
   }

   #ifdef SFK_W64
   ifcmd (!strcmp(pszCmd, "fixfile"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk fixfile [options] dirname\n"
             "\n"
             "   repair file names with invalid characters, add missing\n"
             "   file time from filename, on files created by embedded\n"
             "   devices like personal video recorders (PVR).\n"
             "\n"
             "   #use with care!<def> filenames and times may be changed completely\n"
             "   and this cannot be undone. this command runs in #simulation mode<def>\n"
             "   by default, previewing changes without modifying anything.\n"
             "   add -yes to really apply changes.\n"
             "\n"
             "   $limited file selection\n"
             "      this command is for Windows only and supports only\n"
             "      a few file selection options like -dir and -file.\n"
             "\n"
             "   $options\n"
             "    -dewide    if any unicode 16 bit wide characters are found\n"
             "               in the filename (making the file unusable for\n"
             "               many command line applications) remove them.\n"
             "               careful! use this only if just a few of such\n"
             "               characters exist, otherwise the file may become\n"
             "               completely unusable.\n"
             /*
             "    -rewide    if unicode 16 bit wide characters are found\n"
             "               in the filename replace them by a hex ASCII\n"
             "               rewrite like: {E086}. careful! this means:\n"
             "               1. filenames will no longer look \"correct\"\n"
             "                  in windows explorer as they will no longer\n"
             "                  display their original unicode character(s)\n"
             "                  but look like {E086}foo{E087}bar.txt\n"
             "               2. whenever using the filename as a command\n"
             "                  parameter surround it by quotes \"\".\n"
             "                  shell command completion by TAB key will not\n"
             "                  work on a file starting { but only on \"{\n"
             */
             "    -setftime  if date and time info are found in the name like in\n"
             "                 myfile-01312015-1740-news.mpg\n"
             "               then extract date and time. if the file has no date\n"
             "               or a different date change it to the found date.\n"
             "    -setndate  change date text in filename to normalized\n"
             "               flat format YMD like 20150113\n"
             "    -defull    same as -dewide -setftime -setndate\n"
             "    -withsub   include sub directories (not default)\n"
             "\n"
             "   $see also\n"
             "      the following are normally used after fixfile\n"
             "      as they need plain ASCII filenames to work with.\n"
             "      #sfk rename<def>   flexible mass rename of files\n"
             "      #sfk media<def>    to cut mpeg2 video files\n"
             "\n"
             );
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk fixfile -defull f:\\HBPVR .mts .meta\n"
             "         fix filenames and times of .mts and .meta files\n"
             "         in the recording folder of a XORO HRK 7560.\n"
             "         for example, it will change a filename like\n"
             "            $?S?uper_?R?TL-01312015-0540-SpongeBob.mts\n"
             "         to\n"
             "            $Super_RTL-20150131-0540-SpongeBob.mts\n"
             "         stripping four wide characters and also setting\n"
             "         the file date/time to 31.01.2015 at 05:40.\n"
             "\n"
             "      #sfk fixfile -defull -dir f:\\HBPVR -file .mts .meta\n"
             "         same as above using long file selection syntax.\n"
             "\n"
             );
      ehelp;

      sfkarg;

      cs.subdirs = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];

         if (!strcmp(pszArg, "-dewide"))
            { cs.dewide=1; continue; }
         if (!strcmp(pszArg, "-rewide"))
            { cs.rewide=1; continue; }
         if (!strcmp(pszArg, "-setftime"))
            { cs.setftime=1; continue; }
         if (!strcmp(pszArg, "-setndate"))
            { cs.setndate=1; continue; }
         if (!strcmp(pszArg, "-defull")) {
            cs.dewide=1;
            cs.setftime=1;
            cs.setndate=1;
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         break;
      }

      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1, &iChainNext))) return lRC;
      if (btest) return 0;

      if (!cs.dewide && !cs.rewide && !cs.setftime && !cs.setndate)
         return 9+perr("you must select a processing option like -setftime\n");

      cs.sim = !cs.yes;

      if (!cs.yes) printx("$[simulating:]\n");

      lRC = walkAllTreesW(0);

      if (cs.filesChg) { // fixfile
         printx("%d of %d files %schanged.\n", cs.filesChg, cs.files, cs.yes?"":"would be ");
         if (!cs.yes)
            printx("$[add -yes to execute.]\n");
      } else {
         printf("nothing to do. (%d files checked)\n", cs.files);
      }

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "getcwd") || !strcmp(pszCmd, "cwd"))
   {
      ifhelp (nparm >= 1 && isHelpOpt(argv[iDir]))
      printx("<help>$sfk getcwd\n"
             "\n"
             "   print the current working directory.\n"
             "\n"
             "   $examples\n"
             "      #sfk getcwd +filter -form \"workdir is $$col1\"\n"
             "         print workdir with some additional text.\n"
             );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s", argx[iDir]);
      }

      szLineBuf[0] = '\0';
      if (getcwd(szLineBuf,sizeof(szLineBuf)-10)) { }

      if (chain.colfiles) {
         Coi ocoi(szLineBuf, 0);
         chain.addFile(ocoi); // is copied
      }
      else
      if (chain.coldata) {
         chain.addLine(szLineBuf, str(""), 0);
      } else {
         printf("%s\n", szLineBuf);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "cd")) // +var
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk cd targetdir +nextcmd ...\n"
             "\n"
             "   change the directory for the next chain command.\n"
             "   does NOT change the directory of the command shell.\n"
             "\n"
             "   $options\n"
             "      -echo     echo the command on execution\n"
             "\n"
             "   $examples\n"
             "      #sfk cd testfiles +list -time -size .\n"
             "         enter directory \"testfiles\", then list all files.\n"
             );
      ehelp;

      sfkarg;

      char *pszDir = 0;
      bool  becho  = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argx[iDir], "-echo")) {
            becho = 1;
            continue;
         }
         else
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszDir)
            pszDir = argx[iDir];
         else
            return 9+perr("unexpected: %s", argx[iDir]);
      }

      if (!pszDir) return 9+perr("missing dir name for cd");

      // plausi check
      if (iChainNext <= 0) {
         perr("missing chain commands after \"cd\"");
         pinf("cd can change the dir for subsequent chain commands only.\n");
         pinf("to change the dir of your command shell, use \"cd\" but not \"sfk cd\"\n");
         return 9;
      }

      int nrc = chdir(pszDir);
      if (nrc) return 9+perr("cannot cd into: %s", pszDir);

      if (becho)
         printx("<time>cd %s<def>\n", pszDir);

      STEP_CHAIN(iChainNext, 0); // cd

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "mkdir"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk mkdir path\n"
             "\n"
             "   create a directory, or directory tree.\n"
             "\n"
             "   $options\n"
             "      -echo     echo the command on execution\n"
             "      -forfile  path is a filename, create folder\n"
             "                for that file. does nothing if\n"
             "                path contains no <sla> character.\n"
             "\n"
             "   $see also\n"
             "      #sfk dir -withdirs tmp\n"
             "         list all folder names within tmp\n"
             "\n"
             "   $examples\n"
             "      #sfk mkdir tmp\\foo\\bar\n"
             "         create directory bar within foo within tmp.\n"
             "      #sfk mkdir -forfile tmp\\foo\\index.html\n"
             "         create directory foo within tmp.\n"
             );
      ehelp;

      sfkarg;

      char *pszPathIn=0;
      char szPath[SFK_MAX_PATH+10];
      bool becho=0, bforfile=0;
      szPath[0] = '\0';

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-echo"))
            { becho = 1; continue; }
         if (!strcmp(pszArg, "-forfile"))
            { bforfile = 1; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!szPath[0]) {
            pszPathIn = pszArg;
            strcopy(szPath, pszArg);
         } else {
            return 9+perr("unexpected: %s", pszArg);
         }
      }

      if (!szPath[0])
         return 9+perr("missing name for mkdir");

      if (bforfile) {
         char *psz = strrchr(szPath, glblPathChar);
         if (psz)
            *psz = '\0';
         else
            szPath[0] = '\0'; // nothing to do
      }

      lRC = 0;

      if (szPath[0])
      {
         lRC = createSubDirTree(szPath, str(""));
         if (lRC) return lRC;
   
         if (becho)
            printx("<time>mkdir %s<def>\n", szPath);
      } else {
         if (becho)
            printx("<time>mkdir : skipped for %s<def>\n", pszPathIn);
      }

      STEP_CHAIN(iChainNext, 0); // mkdir

      bDone = 1;
   }

   ifcmd (strBegins(pszCmd, "linelen") || strBegins(pszCmd, "strlen"))
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk linelen [options]\n"
             "$sfk strlen phrase\n"
             "\n"
             "   tell the length of text lines supplied via stdin\n"
             "   or through command chaining, or tell the length\n"
             "   of a single string.\n"
             "\n"
             "   the result is printed to terminal, and supplied\n"
             "   as a return code to the command shell.\n"
             "\n"
             "   \"sfk strlen\" does not accept any options,\n"
             "   allowing to supply a string starting with \"-\".\n"
             "\n"
             "   $options\n"
             "      -i         read lines from standard input,\n"
             "                 tell the longest line length.\n"
             "      -min       tell the minimum, not the maximum length.\n"
             "      -minmax    tell both min and max length.\n"
             "      -verbose   tell minmax, line numbers and line text.\n"
             "                 you may also type -all or -ver\n"
             "      -quiet     do not print anything to terminal,\n"
             "                 just provide the shell return code.\n"
             "\n"
             "   $limitations\n"
             "      if the input contains stream text, i.e. text where\n"
             "      linefeeds are used only for paragraphs (not lines),\n"
             "      the result will be a paragraph length, and it can be\n"
             "      completely wrong if there are paragraphs longer than\n"
             "      4000 characters approx.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk strlen \"foo bar\"\n"
             "         results in a string length of 7.\n"
             "\n"
             "      #sfk filter foo.txt +linelen -all\n"
             "         list the shortest and longest line of foo.txt\n"
             #ifdef _WIN32
             "\n"
             "      #Windows batch: expand short parameter\n"
             "         sfk strlen \"%%1\"\n"
             "         IF %%ERRORLEVEL%% LEQ 3 (\n"
             "            set TARGET=192.168.2.%%1\n"
             "         ) ELSE (\n"
             "            set TARGET=%%1\n"
             "         )\n"
             "         echo \"using: %%TARGET%%\"\n"
             #endif
             );
      ehelp;

      sfkarg;

      bool  braw = strBegins(pszCmd, "strlen");

      char *pphrase = 0;
      bool  bstdin  = 0;
      bool  bdetail = 0;
      bool  bmin    = 0;
      bool  bmax    = 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!braw && !strcmp(argx[iDir], "-i")) {
            bstdin = 1;
            continue;
         }
         else
         if (!braw && !strcmp(argx[iDir], "-min")) {
            bmin = 1; bmax = 0;
            continue;
         }
         else
         if (!braw && !strcmp(argx[iDir], "-max")) {
            bmax = 1;
            continue;
         }
         else
         if (!braw && !strcmp(argx[iDir], "-minmax")) {
            bmin = 1; bmax = 1;
            continue;
         }
         else
         if (!braw && (strBegins(argx[iDir], "-ver") || !strcmp(argx[iDir], "-all")))
         {
            bdetail = 1;
            continue;
         }
         else
         if (!braw && sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pphrase) {
            pphrase = argx[iDir];
            continue;
         }
         return 9+perr("only one phrase can be supplied.\n");
      }

      if (!pphrase && !chain.usedata && !bstdin)
         return 9+perr("missing phrase, chain text or -i option.\n");

      if (pphrase)
         { bmin=0; bdetail=0; }

      int iline = 0;
      int nmin  = -1;
      int nmax  = 0;
      int imin  = 0;
      int imax  = 0;
      mclear(szLineBuf2);  // will contain min line
      mclear(szLineBuf3);  // will contain max line

      if (bstdin)
         myfgets_init();

      if (pphrase) {
         nmax = strlen(pphrase);
         bdetail = 0;
      }
      else
      while (1)
      {
         if (chain.usedata) {
            if (chain.indata->eod())
               break;
            char *psz = chain.indata->read(0);
            mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
         } else {
            if (!myfgets(szLineBuf, MAX_LINE_LEN, stdin))
               break;
         }
         iline++;
         removeCRLF(szLineBuf);
         int nlen = strlen(szLineBuf);
         if (nmin < 0 || nlen < nmin) {
            nmin = nlen;
            imin = iline;
            strcopy(szLineBuf2, szLineBuf);
         }
         if (nlen > nmax) {
            nmax = nlen;
            imax = iline;
            strcopy(szLineBuf3, szLineBuf);
         }
      }

      lRC = nmax;

      if (!cs.quiet) {
         if (bdetail) {
            chain.print("min\t%d\t%d\t\"%s\"", nmin, imin, szLineBuf2);
            chain.print("max\t%d\t%d\t\"%s\"", nmax, imax, szLineBuf3);
         }
         else
         if (bmin && bmax) {
            chain.print("%d\t%d", nmin, nmax);
         }
         else
         if (bmin) {
            chain.print("%d", nmin);
            lRC = nmin;
         }
         else {
            chain.print("%d", nmax);
         }
      }

      if (iChainNext > 0)
         lRC = 0;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "mdfuzzy"))
   {
      if (argc < 3) return 9;
      char *pszFile = argv[2];
      if (getFuzzyTextSum(pszFile, abBuf))
         return 9;
      for (int i=0; i<16; i++)
         printf("%02x ", abBuf[i]);
      printf("\n");
      bDone = 1;
   }

   // create cd batch to current directory
   ifcmd (!strcmp(pszCmd, "mkcd"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("<help>$sfk mkcd cdname\n"
             "\n"
             "   creates an alias batch file, remembering the current directory.\n"
             "   this batch can be used later to re-enter the remembered directory.\n"
             "\n"
             "   $batch file storage path parallel to sfk\n"
             "\n"
             "      this is default. for full details read: sfk alias\n"
             "\n"
             "   $alternative bath file path by SFK_PATH\n"
             "\n"
             "      you may also create a separate folder for your batch files\n"
             "      which must be listed in the PATH environment variable.\n"
             "      then $<exp> SFK_PATH=myfolder<def> to let sfk write into that.\n"
             "\n"
             "   $options\n"
             "      -verbose   tell in detail which batch folder is used\n"
             "\n"
             "   $example:\n"
             "\n"
             "   1. you are currently working in\n"
             "         C:\\Documents And Long Complicated Paths\\Users\\You\\Work\n"
             "\n"
             "   2. now type:\n"
             "         #sfk mkcd cd1\n"
             "            which saves above path in a command \"cd1\".\n"
             "\n"
             "   3. you go into a different directory, e.g.\n"
             "         C:\\Another Project\\Nested Dirs\\Work2\n"
             "\n"
             "   4. now type:\n"
             "         #sfk mkcd cd2\n"
             "\n"
             "   => now, anytime you type:\n"
             "         #cd1\n"
             "            you jump instantly into\n"
             "               C:\\Documents And Long Complicated Paths\\Users\\You\\Work\n"
             "\n"
             "      and anytime you type:\n"
             "         #cd2\n"
             "            you jump instantly into\n"
             "               C:\\Another Project\\Nested Dirs\\Work2\n"
             "\n"
             "   if the creation of the alias fails, please type \"sfk alias\" to read\n"
             "   about the required directories and access rights.\n"
         );
      ehelp;

      sfkarg;

      if (checkArgCnt(argc, 3)) return 9;
      char *pszAlias = argx[2];

      char *pszWritePath=0;
      int   isubrc=0;
      if ((pszWritePath=getWritePath(isubrc))) {
         strcopy(szRefNameBuf, pszWritePath);
         strcat(szRefNameBuf, glblPathStr);
         if (cs.verbose)
            pinf("[nopre] using SFK_PATH %s\n",pszWritePath);
      } else {
         if (isubrc)
            return 9;
         // find ourselves, result in szLineBuf
         char *pszSFKCmd = findPathLocation("sfk" EXE_EXT, 1); // for mkcd. 1=nocwd
         if (!pszSFKCmd) return 9+perr("cannot find location of sfk" EXE_EXT " within PATH.\n");
         if (cs.verbose)
            pinf("[nopre] using sfk.exe path %s\n",pszSFKCmd);
         // create batch filename parallel to sfk.exe
         szRefNameBuf[0] = '\0';
         char *psz1 = strrchr(pszSFKCmd, glblPathChar);
         if (!psz1) return 9+perr("unable to find path of sfk" EXE_EXT "\n");
         sprintf(szRefNameBuf, "%.*s", (int)(psz1-pszSFKCmd+1),pszSFKCmd);
      }

      strcat(szRefNameBuf, pszAlias);
      #ifdef _WIN32
      strcat(szRefNameBuf, ".bat");
      #endif
      char nReply = 'y';
      if (fileExists(szRefNameBuf)) {
         printf("%s exists, overwrite? (yes/no) ",szRefNameBuf);
         fflush(stdout);
         nReply = getYNAchar();
      }
      if (nReply == 'y')
      {
         // determine current directory
         szLineBuf[0] = '\0';
         if (getcwd(szLineBuf,sizeof(szLineBuf)-10)) { }

         // write the batch
         FILE *fout = fopen(szRefNameBuf, "w");
         if (!fout) return 9+tellCannotWriteBatchFile(szRefNameBuf);

         // write alias batch header for later re-identification.
         fprintf(fout, "%s\n", pszGlblAliasBatchHead);

         #ifdef _WIN32
         // include drive change
         char *psz2 = strchr(szLineBuf, ':');
         if (psz2)
            fprintf(fout, "@%.*s\n@cd \"%s\"\n",
               (int)(psz2-szLineBuf+1),szLineBuf,  // e.g. C:
               psz2+1);   // rest of path, relative to drive
         else
            fprintf(fout, "@cd \"%s\"\n", szLineBuf);
         #else
         fprintf(fout, "cd \"%s\"\n", szLineBuf);
         #endif

         fclose(fout);

         #ifndef _WIN32
         chmod(szRefNameBuf, S_IREAD | S_IWRITE | S_IEXEC); // mkcd
         // sfk197: sfk mkcd on linux: file owner correction in case of sudo
         snprintf(szLineBuf2, MAX_LINE_LEN, "chown \"%s\" \"%s\"", getlogin(), szRefNameBuf);
         if (system(szLineBuf2)) { }
         #endif

         printf("batch created: %s\n", szRefNameBuf);
         #ifdef _WIN32
         printf("type \"%s\" to reenter %s\n",pszAlias,szLineBuf);
         #else
         printf("type \". %s\" to reenter %s\n",pszAlias,szLineBuf);
         #endif
      }
      bDone = 1;
   }

   // create alias batch
   ifcmd (!strcmp(pszCmd, "alias")) // +wref
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk alias [-list|-del|-ren] [shortname] [=] [command]\n"
             "\n"
             "   create, list, delete or rename command aliases. aliases are\n"
             "   short command names selected by yourself to save typing effort.\n"
             "\n"
             "   $sfk alias shortname = command ...\n"
             "\n"
             "      create an alias. this actually creates a small batch file\n"
             "      in the directory where sfk itself is located.\n"
             "\n"
             "      requirements:\n"
             "      #-  the sfk executable has been copied into some directory x.\n"
             "      #-  this directory x must be in your PATH.\n"
             "      #-  you must have write permission for directory x.\n"
             "      #-  directory x is NOT the current working directory \".\".\n"
             "\n"
             "      if any of these requirements is not met, the command will fail.\n"
             "      for example, if sfk" EXE_EXT " is located just in your current\n"
             "      working directory \".\", copy sfk" EXE_EXT " into a different\n"
             "      directory of the PATH, and then start aliasing.\n"
             "\n"
             "   $alternative bath file path by SFK_PATH\n"
             "\n"
             "      you may also create a separate folder for your batch files\n"
             "      which must be listed in the PATH environment variable.\n"
             "      then $<exp> SFK_PATH=myfolder<def> to let sfk write into that.\n"
             "\n"
             "   $options\n"
             "      -verbose   tell in detail which batch folder is used\n"
             "\n"
             "   $see also\n"
             "      sfk mkcd : create an alias remembering the current directory.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk alias list = \"sfk list\"\n"
             "         creates the alias named \"list\". from now on, you can\n"
             "         type \"list\" instead of \"sfk list\".\n"
             "\n"
             #ifdef _WIN32
             "      #sfk alias wherc = \"sfk list -arc . .jar filter -+%%1.class\"\n"
             #else
             "      #sfk alias wherc = \"sfk list -arc . .jar filter -+\\$$1.class\"\n"
             #endif
             "         creates alias \"wherc\", searching for class files in jars.\n"
             "         after the alias exists, command \"wherc Foo\" executes the\n"
             "         commands from above, listing all class names with \"Foo\".\n"
             #ifdef _WIN32
             "\n"
             "      #sfk alias tab2c \"sfk fromclip +filt -spat -rep _\\t_,_ +toclip\"\n"
             "         then type tab2c to replace tabs by commas within clipboard.\n"
             #endif
             "\n"
             "      #sfk alias copytoday \"sfk run \\\"copy <run>file c:\\tmp\\\" . -today\"\n"
             "         copy all files changed today to c:\\tmp. if double quotes \"\n"
             "         should be part of your command, they must be escaped as \\\"\n"
             #ifdef _WIN32
             "\n"
             "      #sfk alias wide MODE CON COLS=160\n"
             "         extend the current shell window to a width of 160 columns.\n"
             "\n"
             "      #sfk alias ec \"notepad c:\\app\\bin\\%%1.bat\"\n"
             "         provided that c:\\app\\bin is in your path, creates\n"
             "         a command \"ec\" to instantly edit further commands.\n"
             #else
             "\n"
             "      #sfk alias ec \"vi /home/myuser/tools/\\$$1\"\n"
             "         provided that /home/myuser/tools is in your path, creates\n"
             "         a command \"ec\" to instantly edit further commands.\n"
             #endif
             "\n"
             "      #PARAMETER LIMITATION:<def> note that the created batch files\n"
             #ifdef _WIN32
             "      may accept only a maximum of 9 parameters, called %%1 to %%9.\n"
             #else
             "      may accept only a maximum of 9 parameters. they must be typed\n"
             "      with back slash \\$$1 to \\$$9 and will appear as $$1 to $$9\n"
             "      in the created batch script.\n"
             #endif
             "      Further parameters may be ignored, or cannot be addressed.\n"
             "\n"
             "      #USE SURROUNDING QUOTES<def> whenever your command string contains\n"
             "      special characters like %% \\ ! otherwise these chars may be\n"
             "      removed (or misinterpreted) by the command shell.\n"
             "\n"
             "   $sfk alias -list\n"
             "      list all existing aliases. this actually scans the directory\n"
             "      where sfk is located for batch files containing aliases.\n"
             "\n"
             "   $sfk alias shortname\n"
             "      list definition of an existing alias.\n"
             "\n"
             "   $sfk alias -del aliasname\n"
             "      delete an alias (deletes the associated batchfile).\n"
             "\n"
             "   $sfk alias -ren oldname newname\n"
             "      rename an alias (renames the associated batchfile).\n"
            );
      #ifdef SFINT
      printx("\n"
             "   $COMMAND NAME ALIASING:\n"
             "\n"
             "   another way to avoid typing \"sfk\" on every command is this:\n"
             "\n"
             "   - in the directory where sfk is located, create another executable,\n"
             "     for example \"list.exe\", as a link to sfk.exe:\n"
             #ifdef _WIN32
             "        fsutil hardlink create list.exe sfk.exe\n"
             #else
             "        ln -sf sfk list\n"
             #endif
             "\n"
             "   - now simply type \"list\" instead of \"sfk\": sfk will detect that\n"
             "     its name is no longer \"sfk\", and tries to run the supplied\n"
             "     command name automatically.\n"
             "\n"
             "   - this behaviour can be disabled by " SFK_SETENV_CMD " SFK_CONFIG=ignore-exec-name\n"
             "\n"
             "   if in any doubt what version of sfk is run by the aliased command,\n"
             "   type the new command name with \"-version\" as first parameter.\n"
             );
      #endif
      ehelp;

      sfkarg;

      char *pszWritePath=0;
      int   isubrc=0;
      if ((pszWritePath=getWritePath(isubrc))) {
         strcopy(szRefNameBuf, pszWritePath);
         strcat(szRefNameBuf, glblPathStr);
         if (cs.verbose)
            pinf("[nopre] using SFK_PATH %s\n",pszWritePath);
      } else {
         if (isubrc)
            return 9;
         // find ourselves, result in szLineBuf
         char *pszSFKCmd = findPathLocation("sfk" EXE_EXT, 1); // for alias. 1=nocwd
         if (!pszSFKCmd) return 9+perr("cannot find location of sfk" EXE_EXT " within PATH.\n");
         if (cs.verbose)
            pinf("[nopre] using sfk.exe path %s\n",pszSFKCmd);
         // isolate path of sfk.exe in szRefNameBuf
         szRefNameBuf[0] = '\0';
         char *psz1 = strrchr(pszSFKCmd, glblPathChar);
         if (!psz1) return 9+perr("unable to find path of sfk" EXE_EXT "\n");
         sprintf(szRefNameBuf, "%.*s", (int)(psz1-pszSFKCmd+1),pszSFKCmd);
      }

      if ((nparm >= 1) && !strcmp(argx[iDir], "-list"))
      {
         // list all aliases located parallel to sfk.exe,
         // by scanning the header of all files in its directory.

         // first continue processing real parameters, if any
         for (iDir++; iDir<argc; iDir++)
         {
            if (isChainStart(pszCmd, argx, argc, iDir, 0))
               break;
            return 9+perr("unexpected: %s\n", argx[iDir]);
         }
         if (btest) return 0;

         // fix 1755/1762: only list requires path without trailing slash
         stripTrailingBackSlashes(szRefNameBuf);

         // create virual directory parms
         char *pSubArgv[10];
         pSubArgv[0] = str("sfk-dummy");
         pSubArgv[1] = str("alias-list");
         pSubArgv[2] = str("-norec");
         pSubArgv[3] = szRefNameBuf;
         pSubArgv[4] = str(".bat");
         #ifdef _WIN32
         int nSubArgc = 5; // win: reduce scan to .bat files
         #else
         int nSubArgc = 4; // linux: no specific file extension, scan all files
         #endif
         int iSubDir  = 3;
         printx("$current aliases from the sfk home %s :\n", szRefNameBuf);

         // process and walk virtual directory parameters
         if ((lRC = processDirParms(str("alias-list"), nSubArgc, pSubArgv, iSubDir, 3))) return lRC;
         lRC = walkAllTrees(eFunc_AliasList, lFiles, lDirs, nBytes);

         // complete real parameters, just to find iDirNext
         int iDirNext = 0;
         int lRC2 = 0;
         if ((lRC2 = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext))) return lRC2;

         // now continue chain, e.g. filtering, if any
         if (chain.coldata) {
            STEP_CHAIN(iDirNext, 1);
         } else {
            STEP_CHAIN(iDirNext, 0); // alias
         }

         bDone = 1;
      }
      else
      if ((argc > 3) && !strcmp(argx[2], "-del"))
      {
         // delete one or more aliases
         if (blockChain(str("alias -delete"), iDir, argc, argx, 2)) // 2: no pinf
            return 9;
 
         for (iDir=3; iDir < argc; iDir++)
         {
            char *pszToDel = argx[iDir];
            sprintf(szLineBuf, "%s%s", szRefNameBuf, pszToDel);
            #ifdef _WIN32
            strcat(szLineBuf, ".bat");
            #endif

            // check if it's really an alias batch
            FILE *fin = fopen(szLineBuf, "r");
            if (!fin)
               { perr("%s - no such file\n",szLineBuf); continue; }
            if (!fgets(szLineBuf2, sizeof(szLineBuf2), fin))
               { perr("%s - no data\n",szLineBuf); fclose(fin); continue; }
            fclose(fin);
            if (strncmp(szLineBuf2, pszGlblAliasBatchHead, strlen(pszGlblAliasBatchHead)))
               { perr("%s - no valid alias batch, will not delete.\n",szLineBuf); continue; }

            if (remove(szLineBuf))
               perr("%s - cannot delete file\n",szLineBuf);
            else
               printf("alias deleted: %s\n", szLineBuf);
         }
         bDone = 1;
      }
      else
      if ((argc >= 5) && !strcmp(argx[2], "-ren"))
      {
         // rename an alias
         if (blockChain(str("alias -rename"), iDir, argc, argx, 2)) // 2: no pinf
            return 9;

         char *pszFrom = argx[3];
         char *pszTo   = argx[4];

         sprintf(szLineBuf, "%s%s", szRefNameBuf, pszFrom);
         #ifdef _WIN32
         strcat(szLineBuf, ".bat");
         #endif

         sprintf(szLineBuf2, "%s%s", szRefNameBuf, pszTo);
         #ifdef _WIN32
         strcat(szLineBuf2, ".bat");
         #endif

         if (fileExists(szLineBuf2))
            return 9+perr("%s already exists, rename failed.\n", szLineBuf2);

         // check if it's really an alias batch
         FILE *fin = fopen(szLineBuf, "r");
         if (!fin)
            return 9+perr("%s - no such file\n",szLineBuf);
         if (!fgets((char*)abBuf, sizeof(abBuf), fin))
            { fclose(fin); return 9+perr("%s - no data\n",szLineBuf); }
         fclose(fin);
         if (strncmp((char*)abBuf, pszGlblAliasBatchHead, strlen(pszGlblAliasBatchHead)))
            return 9+perr("%s - no valid alias batch, will not rename.\n",szLineBuf);

         if (rename(szLineBuf, szLineBuf2))
            perr("%s - cannot rename to %s\n",szLineBuf,szLineBuf2);
         else
            printf("alias renamed: %s\n", szLineBuf2);

         bDone = 1;
      }
      else
      if (argc == 3)
      {
         // list single alias
         if (blockChain(str("alias [show]"), iDir, argc, argx, 2)) // 2: no pinf
            return 9;

         char *pszAlias = argx[2];
         strcat(szRefNameBuf, pszAlias);
         #ifdef _WIN32
         strcat(szRefNameBuf, ".bat");
         #endif
         bool bIsAlias = 0;
         execAliasList(szRefNameBuf, &bIsAlias);
         if (!bIsAlias)
         {
            printf("No sfk alias \"%s\" is defined", pszAlias);
            int nhits = listPathAny(pszAlias, 1); // silent
            if (nhits > 0) {
               printf(", but path contains:\n");
               listPathAny(pszAlias, 0); // loud
            }
            else printf(".\n");
         }
         bDone = 1;
      }
      else
      {
         // create new alias
         if (blockChain(str("alias [create]"), iDir, argc, argx, 2)) // 2: no pinf
            return 9;

         if (checkArgCnt(argc, 4)) return 9;
         char *pszAlias = argx[2];
 
         // create batch filename parallel to sfk.exe
         strcat(szRefNameBuf, pszAlias);
         #ifdef _WIN32
         strcat(szRefNameBuf, ".bat");
         #endif
         char nReply = 'y';
         if (fileExists(szRefNameBuf)) {
            printf("%s exists, overwrite? (yes/no) ",szRefNameBuf);
            fflush(stdout);
            nReply = getYNAchar();
         }
         if (nReply == 'y')
         {
            // open output batchfile
            FILE *fout = fopen(szRefNameBuf, "w");
            if (!fout) return 9+tellCannotWriteBatchFile(szRefNameBuf);

            // write alias batch header for later re-identification.
            fprintf(fout, "%s\n", pszGlblAliasBatchHead);

            bool  bHaveAnySubst = 0;
            uchar aHaveSubst[20];
            memset(aHaveSubst, 0, sizeof(aHaveSubst));

            // collect ALL further parameters, add
            iDir = 3;
            int nAdd = 0;
            if (!strcmp(argx[iDir], "="))
                iDir++;
            #ifdef _WIN32
            fprintf(fout, "@"); // silent, don't list command on execution
            #endif
            while (iDir < argc) {
               char *psz3 = argx[iDir];
               // check if user supplies parameter substitution
               for (int i=1; i<10; i++) {
                  #ifdef _WIN32
                  sprintf(szLineBuf, "%%%d", i);
                  #else
                  sprintf(szLineBuf, "$%d", i);
                  #endif
                  if (strstr(psz3, szLineBuf)) {
                     bHaveAnySubst = 1;
                     aHaveSubst[i] = 1;
                  }
               }
               fprintf(fout, "%s ", argx[iDir]);
               iDir++;
               nAdd++;
            }
 
            if (nAdd == 0)
               perr("missing parameters after \"=\"\n");
            else {
               // finalize: add support for not yet used substitution parms
               if (!bHaveAnySubst) {
                  #ifdef _WIN32
                  fprintf(fout, "%%*");   // pass ALL parms (.bat)
                  #else
                  fprintf(fout, "$@");    // pass ALL parms (bash)
                  #endif
               }
               else
               for (int i=1; i<10; i++)
                  if (!aHaveSubst[i])
                     #ifdef _WIN32
                     fprintf(fout, "%%%d ", i);
                     #else
                     fprintf(fout, "$%d ", i);
                     #endif
            }
 
            fclose(fout);

            #ifndef _WIN32
            chmod(szRefNameBuf, S_IREAD | S_IWRITE | S_IEXEC); // alias
            // sfk197: sfk alias on linux: file owner correction in case of sudo
            snprintf(szLineBuf2, MAX_LINE_LEN, "chown \"%s\" \"%s\"", getlogin(), szRefNameBuf);
            if (system(szLineBuf2)) { }
            #endif

            printx("$batch created: %s\n", szRefNameBuf);
            char *pszTmp = loadFile(szRefNameBuf);
            if (pszTmp) {
               printf("%s",pszTmp);
               int nLen = strlen(pszTmp);
               if ((nLen > 0) && (pszTmp[nLen-1] != '\n'))
                  printf("\n");
               delete [] pszTmp;
            }
            printx("$type \"%s\" to use.\n", pszAlias);
         }
         bDone = 1;
      }
   }

   regtest("replace -text /src/dst/ -file xfile1 xfile2");
   regtest("rep -binary /A0A1A2/B5B6B7/ -dir xdir -file .dat -yes");
   regtest("rep -dump -wide -context=20 -bylist xreplist.txt -dir . -file xfile1 xfile2");
   regtest("list xdir .txt +rep /foo/bar/");

   bool bIsFHexFind = 0; // fixed text
   bool bIsFReplace = 0; // fixed text
   bool bIsXExtract = 0; // extract command
   bool bIsXReplace = 0; // xreplace command
   bool bIsHexFind  = 0; // hexfind or xhexfind
   bool bIsAnyFind  = 0;
   bool bIsXPat     = 0;
   bool bExtract    = 0;
   bool bFullHelp   = 0;
   bool bIsReplace  = 0;
   bool bIsXHexFind = 0; // pure alias
   bool bIsXRepDemo = 0;
   int  iIsOFind    = 0;

   bool bIsXFTex    = 0; // just text files
   bool bIsXFBin    = 0; // text and  binary

   bool bXdXe = 0;

   // .
   ifcmd (   !strcmp(pszCmd, "rep") || !strcmp(pszCmd, "replace") // +wref
          || strBegins(pszCmd, "hexfind") // or hexfindle
          || (bXdXe && !strcmp(pszCmd, "xrep"))
          || (bXdXe && !strcmp(pszCmd, "xreplace"))
          || (         !strcmp(pszCmd, "xfind"))
          || (         !strcmp(pszCmd, "xfindbin"))   // sfk194
          || (         !strcmp(pszCmd, "xtext"))      // deprecated
          || (         !strcmp(pszCmd, "xhex") )
          || (         strBegins(pszCmd, "xhexfind")) // or xhexfindle
          || (         !strcmp(pszCmd, "extract"))
          || (bGlblOffice && !strcmp(pszCmd, "ofind"))
         )
   {
      // xhexfind: alias of xfind -arc
      if (strBegins(pszCmd, "xhex")) {
         bIsXHexFind = 1;
      }
      #ifdef SFKOFFICE
      // ofind: alias of xfind -office
      if (strBegins(pszCmd, "ofind"))
         iIsOFind = 1;
      #endif // SFKOFFICE

      bIsFHexFind = strBegins(pszCmd, "hexfind");
      bIsFReplace = strBegins(pszCmd, "rep");
      bIsXExtract = !strcmp(pszCmd, "extract");
      bIsXReplace = strBegins(pszCmd, "xrep");

      bIsXFTex    = !strcmp(pszCmd, "xfind")     // sfk194 just text
                    || iIsOFind
                    || !strcmp(pszCmd, "xtext")  // deprecated
                    || bhelp; // help default
      bIsXFBin    = !strcmp(pszCmd, "xfindbin")  // text and binary
                    || bIsXHexFind;

      bIsHexFind  = bIsFHexFind || bIsXHexFind;
      bExtract    = bIsXFTex || bIsXFBin || bIsXExtract;
      bIsAnyFind  = bIsXFTex || bIsXFBin || bIsHexFind;
      bIsXPat     = strBegins(pszCmd, "x") || bExtract || iIsOFind;
      bFullHelp   = (nparm >= 1 && !strcmp(argv[iDir], "-full"));
      bIsReplace  = strstr(pszCmd, "rep") ? 1 : 0;

      ifhelp ((nparm < 1) || bFullHelp)

      if (bIsFHexFind)
      printx("<help>$sfk hexfind [opts] -pat /pattern/ -dir anydir -file .ext1 [.ext2]\n"
             "\n"
             "   search text or binary data in text and binary files.\n"
             "   if multiple patterns are given then they are searched\n"
             "   independently (pattern1 OR pattern2).\n"
             "\n"
             "   this is a basic command to search only static data.\n"
             "   type sfk xhexfind to use wildcards and expressions.\n"
             );
      else if (bIsFReplace)
      printx("<help>$sfk replace singleFile [-text] /src/dst/ [pattern2] [...] [-yes]\n"
             "$sfk replace -[s]pat -bin[ary] /A0A1A2/B5B6B7/ -dir anydir -file .ext1 [-yes]\n"
             "$sfk rep [-dump [-wide]]]] -bylist words.txt file1 [file2 ...] [-yes]\n"
             "\n"
             "   replace text or binary data in text and binary files.\n"
             "   may replace many different patterns in parallel.\n");
      else if (bIsXHexFind)
      printx("<help>$sfk xhexfind dirName \"/searchtext/totext/\"\n"
             "\n"
             "   search in text and binary files using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [],\n"
             "   creating a hexadecimal dump output.\n"
             );
      else if (bIsXFBin)
      printx("<help>$sfk xfindbin singleDirName \"/searchtext/\"\n"
             "$sfk xfindbin singleFileName \"/searchtext/\" [options]\n"
             "$sfk xfindbin -dir mydir -file .cpp .txt -text \"/from/[totext/]\"\n"
             "\n"
             "   search in text and binary files using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [].\n"
             "\n"
             "   the search text must be $surrounded by a delimiter<def> like / or _\n"
             "   or any other character not part of the search text.\n"
             "\n"
             "   by default, $full text lines<def> containing hits are shown.\n"
             "   use option $-pure<def> to show only the found text.\n"
             "\n"
             "   use $sfk xfind<def> to search in $text files only<def>.\n"
             "\n"
             "   search text can be followed by a $totext<def> to reformat output.\n"
             );
      else if (iIsOFind)
      printx("<help>$sfk ofind singleDirName \"/searchtext/\"\n"
             "$sfk ofind singleFileName \"/searchtext/\" [options]\n"
             "$sfk ofind -dir mydir -file .docx .xlsx -text \"/from/[totext/]\"\n"
             "\n"
             "   search in $office files<def> like $.docx .xlsx .ods .odt<def>\n"
             "   and in plain text files using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [].\n"
             "\n"
             "   the search text must be $surrounded by a delimiter<def> like / or _\n"
             "   or any other character not part of the search text.\n"
             "\n"
             "   by default, $full text lines<def> containing hits are shown.\n"
             "   use option $-pure<def> to show only the found text.\n"
             "\n"
             "   search text can be followed by a $totext<def> to reformat output.\n"
             );
      else if (bIsXFTex)
      printx("<help>$sfk xfind singleDirName \"/searchtext/\"\n"
             "$sfk xfind singleFileName \"/searchtext/\" [options]\n"
             "$sfk xfind -dir mydir -file .cpp .txt -text \"/from/[totext/]\"\n"
             "\n"
             "   search $in text files only<def> using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [].\n"
             "\n"
             "   the search text must be $surrounded by a delimiter<def> like / or _\n"
             "   or any other character not part of the search text.\n"
             "\n"
             "   by default, $full text lines<def> containing hits are shown.\n"
             "   use option $-pure<def> to show only the found text.\n"
             "\n"
             "   use $sfk ofind<def>    to search in $office files like .docx .xlsx<def>.\n"
             "   use $sfk xfindbin<def> to search in $text and binary files<def>.\n"
             "\n"
             "   search text can be followed by a $totext<def> to reformat output.\n"
             );
      else if (bIsXExtract)
      printx("<help>$sfk extract dirName \"/searchtext/totext/\"\n"
             "\n"
             "   extract data from text and binary files using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [].\n"
             "\n"
             "   produces a (binary) data stream that can be\n"
             "   - written to terminal as hex dump (default)\n"
             "   - written to file by option -tofile\n"
             "   - sent to xed by +xed command chaining\n"
             );
      else if (bIsXReplace)
      printx("<help>$sfk xreplace dirName \"/searchtext/totext/\"\n"
             "\n"
             "   replace in text and binary files using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [].\n"
             #ifndef SFKPRO
             "\n"
             #if defined(SFKXDXE)
             "   $demo notice\n" // sfkplus.anno xrep
             "      this command is commercial and part of SFK Plus or XE.\n"
             "      this binary contains a demo of xreplace that gives a full\n"
             "      output preview but which cannot write changes to files.\n"
             #else
             "   $license notice\n"
             "      this command is commercial and part of SFK Plus or XE.\n"
             #endif
             #endif
             );

      printx("\n");

      if (bIsReplace)
      printx("   Multiple search patterns are executed in the given sequence. Mind this\n"
             "   if they overlap, e.g. /foo/bar/ /foosys/thesys/ makes no sense (foo is\n"
             "   replaced by the first expression, so the 2nd one will fail to match).\n"
             "\n"
             "   $by default, replace functions run in SIMULATION mode,\n"
             "      previewing hits without changing anything. add -yes to apply changes.\n"
             "      Changing binaries may lead to unpredictable results, therefore keep\n"
             "      backups of your files in any case.\n"
             "\n"
             );

      #ifndef SFKPRO
      if (bIsFReplace)
      printx("   $license notice\n"
             "      this is the open source version of sfk replace.\n"
             "      replacing source / target patterns #of different length<def> is slower\n"
             "      and may require much memory compared to replacements #of same length<def>.\n"
             "      SFK Plus or XE contain a different implementation with high performance.\n"
             "\n" // sfkplus.anno rep
             );
      #endif

      printx("   $subdirectories are included by default\n"
             "      the sfk default for most commands is to process the given directories,\n"
             "      #as well as all subdirs within them<def>. specify -nosub to disable this.\n"
             "\n");
      printx("   $options\n"
             "      -nosub        do not include files in subdirectories.\n");
      if (!bIsXFTex)
      printx("      -nobin[ary]   skip binary files.\n");
      if (iIsOFind)
      printx("      -verbose      always show which file is currently read.\n"
             "      -justoffice   search only in office files, not in plain text etc.\n"
             );
      if (bIsXPat)
      printx("      -case         case-sensitive text comparison. default is insensitive.\n"
             "                    for details type: sfk help nocase\n"
             );
      else
      printx("      -case         case-sensitive text comparison. default is case-insensitive\n"
             "                    comparison for all -text strings, but NOT for -bin blocks.\n"
             "                    case-sensitive comparison is faster then case-insensitive.\n"
             "                    for further details type: sfk help nocase\n"
             "      -nocase       force case-insensitive comparison ALSO on -bin patterns.\n"
             );
      if (bIsReplace)
      printx("      -pat          starts a list of search or replace patterns of the form\n"
             "                    xsrcxdstx where x is the separator char, src the source\n"
             "                    to search for, and dst the destination to replace it with.\n"
             "                    e.g. /foo/bar/ or _foo_bar_ both replace foo by bar.\n"
             "                    -pat is not required if a single filename is given.\n"
             "      -text         the same as -pat, starting a text pattern list.\n"
             );
      else
      printx("      -text         starts a list of search patterns of the form /src/ or\n"   // sfk182
             "                    /src/totext/ where / is the separator char, src the text\n"
             "                    to search for, and totext a mask to reformat output.\n"
             "                    any separator char can be used which is not part of the\n"
             "                    search text, i.e. /foo/ or _foo_ both search \"foo\".\n"
             "                    -text is not required if a single filename is given.\n"
             "      -pat          the same as -text, starting a pattern list.\n"             // sfk182
             );
      if (!bIsXPat)
      printx("      -spat         same as -pat but also activates slash patterns like \\t .\n"
             "                    type \"sfk help pat\" for the list of possible patterns.\n"
             "      -spats[trict] same as -spat, but stops with error on undefined\n"
             "                    slash patterns like \\m in C:\\myproj. every slash\n"
             "                    must then be escaped, e.g. using C:\\\\myproj.\n"
             );
      if (!bIsXPat)
      printx("      -bin[ary]     starts a list of binary replace patterns, specified\n"
             "                    as hexcode like /0A0D/2020/\n");

      if (bFullHelp)
      printx("      -bylist x.txt read search/replace patterns from a file (see below).\n");
      else
      printx("      -bylist x.txt read search patterns from a file x.txt, supporting\n"
             "                    multiple lines per pattern. (add -full for more.)\n"
             "      -bylinelist x read /from/to/ or just /from/ patterns from a file x\n"
             "                    with one pattern per line. (add -full for more.)\n");
      printx("                    -by(line)list does not support sfk variables.\n"
             "                    to use variables in patterns create an sfk script\n"
             "                    with patterns as parameters. \"sfk script\" for more.\n");
   // printx("      -enddir       to use -dir ... -file ... as first parameters, type:\n" // sfk182
   //        "                    sfk %s -dir ... -file ... -enddir -pat ...\n"
   //        , pszCmd);
      if (!iIsOFind && (bIsAnyFind || bIsXExtract))
         arcinf(10); // hexfind, xfind, xhexfind, extract

             #ifndef SFKXEREP
      if (bIsReplace)
      printx("      -recsize      with same length replacements: set input record size\n"
             "                    for processing (default=100k)\n");
             #endif
      printx("      -firsthit     %s only first found pattern match per file.\n"
             , (bIsXFTex || bIsXFBin) ? "show":"process");
      if (bIsFReplace)
      printx("      -maxscan=nm   stop searching after (approximately) first n megabytes\n"
             "                    per file. can be used only with same length replace.\n");
      if (iIsOFind)
      printx("      -utfin        with -utfout only: search text is already given\n"
             "                    as UTF-8, do not convert internally for search.\n");
      if (bIsXFTex || bIsXFBin)
      printx("      -tracesel     tell in detail which files are searched or ignored.\n"
             "      -quiet        do not show progress infos.\n"
             "      -names        list only names of files containing at least one hit.\n"
             "      -notnames     list only names of files not containing any hit.\n"
             "      -justrc       print no search results, just set return code on hits.\n"
          // "      -showrc       show return code at end of command.\n"
             );
      else
      printx("      -quiet        do not show progress infos.\n"
             "      -stat         show statistics like hits per pattern and no. of files.\n"
             "      -perf         show performance statistics.\n");
             #ifndef SFKXEREP
      if (bIsReplace)
      printx("      -memlimit=nm  with different-length replacements, files must be loaded\n"
             "                    into memory for processing. the default limit for memory\n"
             "                    use is 300 MB. set -memlimit=500m to select 500 MB.\n");
             #endif
      #ifdef WITH_REPEAT
      if (bIsReplace)
      printx("      -repeat=n     XE only: repeat replace on the same file up to n times,\n"
             "                    to also replace hits produced by previous replace runs.\n"
             "                    can be used only when changing files directly, but not\n"
             "                    with -to[file]. if possible, always try to rewrite your\n"
             "                    search patterns to avoid use of this option, as it is\n"
             "                    slower to rewrite the same file over and over. replace-\n"
             "                    ments producing new hits may indicate a logical error\n"
             "                    within your search/replace patterns.\n"
             );
      #endif // WITH_REPEAT
      printx("      -full         print full help text telling about -bylist pattern files,\n"
             "                    special character case sensitivity and nested or repeated\n"
             "                    replace behaviour.\n"
             "\n");

      printx("   $output options\n");
      if (iIsOFind)
      printx("      -utfout       keep raw UTF-8 encoding on output, to use it\n"
             "                    with further commands requiring UTF-8 data.\n");
      if (!bIsHexFind && (bIsXFTex || bIsXFBin))
      printx("      -conlines=n1  show n lines of context around search hits. by default\n"
             "                    only text lines containing one or more hits are shown.\n"
             "                    all lines together cannot hold more than:\n"
             "      -conchars=n2  max. number of characters of all context lines together.\n"
             "                    default is 240 or n1*160. cannot be larger than 32000.\n"
             "      -conresline   show full result line but no further context (default)\n"
             "      -sep[arator]  show \"---\" separator between hits within a file.\n"
             "      -septext s    use separator text s (supports slash patterns \\n etc.)\n"
             "      -nosep        do not show \"---\" separator between hits within a file.\n"
             "      -indent=n     set n chars of indentation for result display.\n"
             "      -pure         extract only searched data, same as -context=0.\n"
             "                    you may also set an environment variable:\n"
             "                    <exp> SFK_CONFIG=xfind:pure,xfindbin:pure\n" // sfk194
             "                    use -pure -tofile x to extract binary content as is.\n"
             "      -fill=c       replace binary null and other unprintable characters\n"
             "                    with character c. default is a dot \".\"\n"
             "      -hex          print output as hex dump instead of plain text.\n");
      if (bIsHexFind)
      printx("      -wide         show 16 bytes per line in output.\n"
             "      -lean         show  8 bytes per line in output.\n"
             "      -context=n    show  n bytes of  context around results.\n"
             "      -fullhead[er] print offset/length of hits both in decimal and hex.\n"
             "      -maxdump=n    show up to n bytes only.\n"
             "      -nodump       do not create a hexdump, list only matching files.\n");
      else
      if (!bIsXFTex && !bIsXFBin)
      printx("      -dump         create hexdump of search hits or replaced text.\n"
             "       -wide        with -dump: show 16 bytes per line.\n"
             "       -lean        with -dump: show  8 bytes per line.\n"
             "      -dumpfrom     always dump search hits but not replaced text.\n"
             "      -dumpall      dump search text and replaced text.\n"
             "      -nodump       do not create a hexdump, list only matching files.\n"
             "      -astext       no hexdump, but print search hits as plain text.\n"
             "                    use this only with plain text files, not binary.\n");
      printx("      -showle       highlight CR/LF line endings in hex dump output\n");
      if (!bIsXFTex && !bIsXFBin)
      printx("      -context=n    with hexdump: show additional n bytes of context.\n"
             "      -reldist      with hexdump: tell relative distances to previous hits.\n");
      if (bExtract)
      printx("      -nofile       do not insert :file header lines in output.\n"
             "      -crlf, -lf    for file headers and default totext: force crlf or lf\n"
             "                    line endings instead of system default\n");
      if (bIsXPat && bExtract && !bIsHexFind)
      printx("      -filehead s   file header to insert on every matching file.\n"
             "                    only [file.name] surrounded by text can be used.\n"
             "                    default is -filehead \":file [file.name]\" unless a\n"
             "                    single file is searched. cannot be used with xhexfind.\n"
             "                    to get result and name in the same line use [file.name]\n"
             "                    in the expression, like: $sfk xfind -pure -nofile mydir\n"
             "                    $\"/foo*bar/[file.name]: [all]\\n/\"\n"
             "      -sep s        define separator s between hits in a file\n");
      if (bIsXFTex || bIsXFBin)
      printx("      -rawterm      on output to terminal do not strip codes below 32.\n"
             "                    null bytes are always stripped.\n");
      if (!bIsHexFind)
      printx("      -to dir<sla><run>file write output files to given path. for details about\n"
             "                    output file masks, type \"sfk help opt\" or \"sfk run\".\n"
             "      -tofile x     write output data to a single output filename x\n"
             "                    (which is not interpreted as a mask but taken as is).\n");
      if (!bIsReplace)
      printx("      +tofile x     as last parameter (command chaining): write text as\n"
             "                    displayed on terminal to a file x.\n");
      printx("      -more[n]      pause output every 30 or n lines.\n");

      printx("\n");
      // if (bFullHelp) // sfk185
      printx("   $return codes for batch files\n"
             "      0 = no matches, 1 = matches found, >1 = major error occurred.\n"
             "      see also \"sfk help opt\" on how to influence error processing.\n"
             "\n");
      if (bFullHelp && bIsXPat)
      printx("   $the -bylist pattern command file\n"
             "      may contain /from/to/ commands as well as remark lines starting\n"
             "      with \":##\" and blank lines. commands can be split into several\n"
             "      lines forming blocks. when doing so, spaces around lines are\n"
             "      stripped, and all lines after the first line must start with\n"
             "      the separator character, or a space (not tab). multi line\n"
             "      commands must end with a dot '.' after the final separator.\n"
             "      search patterns for xfind(bin) must end with /[all]\\n/\n"
             "      if output text is not reformatted.\n"
             "      To keep whitespace at line start use \"\\ \" for a blank.\n"
             "      example: extract ID3v1 data from an .mp3 file\n"
             "        :## id3v1 tag, search for zero byte then 'TAG'\n"
             "        /\\0\\x54\\x41\\x47[30 bytes][30 bytes][30 bytes]\n"
             "        /[file.name]:\n"
             "         \\ [strip(part3,\\0)],[strip(part2,\\0)],[strip(part4,\\0)]\\n/.\n"
             "\n"
             "   $the -bylinelist simplified pattern command file\n"
             "      may contain /from/to/ or just /from/ commands, with exactly\n"
             "      one command per line. the /to/ part is optional, allowing\n"
             "      to search many phrases without typing /[all]\\n/ everytime.\n"
             "\n"
             );
      else
      if (bFullHelp)
      printx("   $the -bylist pattern command file for sfk replace and hexfind\n"
             "      may contain \":text\" or \":binary\" commands followed by any number\n"
             "      of replacement patterns, and remark lines starting with \":##\".\n"
             "      if the first line is no command, a \":text\" section is assumed.\n"
             "      specify -spat before -bylist to enable slash patterns like \\x0d\\x0a.\n"
             "      commands can be split into several lines. when doing so, whitespace\n"
             "      around lines is stripped, and all lines after the first line\n"
             "      must start with the separator or a blank character. multi line\n"
             "      commands must end with a dot '.' after the final separator,\n"
             "      search commands with empty /to/ text should end like //.\n"
             "      example file with single line and multi line formatting:\n"
             "      :text\n"
             "      :## now comes a single line command. this is a remark.\n"
             "      /foobar/barfoo/\n"
             "      _the test_the text_\n"
             "      :## now comes a free formatted command.\n"
             "      /foobar 123 the quick brown fox/\n"
             "       foobar 987 the quick brown fox/.\n"
             "      :binary\n"
             "      /0d0a/200a/\n"
             "\n"
             );
      if (bFullHelp)
      printx("   $case sensitive search with \\xnn, accents and umlauts\n"
             "    - since SFK 1.69, hex codes like \\x41 are not treated as characters\n"
             "      even if they represent a character code, and are therefore not\n"
             "      searched case insensitive. this can be changed by option -xchars.\n"
             "      this can also be set by environment like:\n"
             "         <exp> SFK_CONFIG=xchars\n"
             "    - for case insensitive search details see: sfk help nocase\n"
             /*
             "    - accents and umlauts in -text patterns are searched case insensitive\n"
             "      according to code page ISO 8859-1, e.g. code 0xC0 (small a accent)\n"
             "      is equal to 0xE0. this can be disabled by option -noacc[ents].\n"
             "      options can also be set by environment like:\n"
             "         <exp> SFK_CONFIG=xchars,noaccents\n"
             */
             "\n");
      if (bIsReplace)
      printx("   $about nested replacement patterns\n"
             "      #sfk replace myfile.dat /foo/bar/ /bar/goo/\n"
             "      with SFK base, \"foo\" will be replaced by \"bar\" and then\n"
             "      immediately \"bar\" is replaced again by \"goo\".\n"
             "      with SFK Plus or XE, a replaced part of text is not replaced\n"
             "      again in the same command, so \"foo\" stays replaced by \"bar\".\n"
             #ifdef WITH_REPEAT
             "      this can be changed by option -repeat (read more there).\n"
             #endif
             "\n"
             );
      if (bIsReplace)
      {
      printx("   $unexpected repeat replace behaviour\n"
             "      depending on the input data and search/replace expressions,\n"
             "      it can happen that running the same replace multiple times\n"
             "      on the same file produces further hits that didn't exist\n");
      if (!bFullHelp)
      printx("      in the first run. add option -full to read more on this.\n"
             "\n");
      else
      printx("      in the first run, for example:\n"
             "      -  input file contains #foothenbar\n"
             "      -  patterns are #-text /then// -text /foobar//\n"
             "      then this will happen with SFK Plus or XE:\n"
             "      -  on the first replace run, no \"foobar\" is found, but\n"
             "         \"then\" is removed from text, producing a new \"foobar\".\n"
             "         however, this new \"foobar\" is NOT replaced, because\n"
             "         text processing already reached the position after\n"
             "         \"foo\", i.e. the word \"bar\".\n"
             "      -  on the second replace run, a \"foobar\" is found that\n"
             "         did not exist in the first run, and replaced.\n"
             #ifdef WITH_REPEAT
             "      SFK XE has an option -repeat=n to reiterate on the same file\n"
             "      up to n times. read more under the -repeat help text.\n"
             "      SFK Base behaves slightly different, due to a different\n"
             "      replace implementation, but it also does not reiterate\n"
             "      and has no option to do so. With a pattern sequence\n"
             "      \"/foobar//\" \"/then//\" the same will happen with SFK Base.\n"
             #else
             "      please note that there is no option to reiterate on the\n"
             "      same file in one call of sfk replace, so re-replaces\n"
             "      over newly combined text cannot be done automatically.\n"
             "      SFK Base behaves slightly different, due to a different\n"
             "      replace implementation, but it also does not reiterate.\n"
             "      With a pattern sequence -text /foobar// -text /then//\n"
             "      in the above example the same will happen with SFK Base.\n"
             #endif
             "\n");
      }
      printx("   $quoted multi line parameters are supported in scripts\n" // (x)rep
             "      using full trim. type \"sfk script\" for details.\n"
             "\n");
      if (bIsXPat)
      {
      printSFKMatchHelp(bIsReplace || bExtract, bFullHelp);
      if (bExtract)
      printx("   $chaining support\n"
             "      sfk extract output can be sent only to +xed or +xex.\n"
             "      other commands require an xed conversion step like\n"
             "      #sfk extract ... +xed +view\n"
             "\n"
             );
      }
      else
      {
      if (!bIsHexFind)
      printx("   $performance notice\n"
             "      the system may cache output file(s), writing to disk in\n"
             "      background after sfk has finished. subsequent batch file\n"
             "      commands may execute slower.\n"
             "\n"
             );
      }
      if (!bIsReplace)
      printx("   $aliases\n"
             "      #sfk xhexfind<def> is the same as xfind -hex\n"
             "      to extract unmodified binary data you may use either\n"
             "      #sfk xfind -pure ... -tofile<def> or #sfk extract ... -tofile<def>\n"
             "\n");
      #ifdef SFKOFFICE
      printx("   $office file support\n"
             "      #sfk ofind<def>        search in $.xml text file contents<def> of\n"
             "                       office files like .docx .xlsx .ods .odt.\n"
          // "      #sfk ofind2<def>       search in $all contents<def> of office files,\n"
          // "                       including binary data like image files.\n"
             "      #sfk help office<def>  for more infos and options\n"
             "\n");
      #endif // SFKOFFICE
      if (bhelp || !iIsOFind)
      {
      printSearchReplaceCommands();
      printBewareLean();
      webref(pszCmd);
      if (!bIsXPat)
      printx("   $common usage errors\n"
             "      #sfk hexfind in.txt \"/foo\\r\\n/\"\n"
             "         will not find \"foo\" at line ends, but searches literal\n"
             "         strings like \"slash and r\". add option -spat to enable\n"
             "         slash patterns, converting \\r\\n to real CRLF codes,\n"
             "         or use #xhexfind<def> where slash patterns are default.\n"
             "      #sfk hexfind mydir \"/foo*bar/\"\n"
             "         will not find \"foo\" and \"bar\" with any characters\n"
             "         inbetween, but searches a literal star \"*\".\n"
             "         use #xhexfind<def> to enable search with wildcards.\n"
             #ifndef _WIN32
             "      #sfk hexfind any.exe -spat /\\x00$$version/\n"
             "         will not search for a string \"$$version\" prefixed by\n"
             "         a null byte. the linux console will destroy the \\ and\n"
             "         $$ arguments, giving junk to sfk. type instead:\n"
             "         #sfk hexfind any.exe -spat \"/\\x00\\$$version/\"\n"
             #endif
             "\n"
             );
      if (bIsFHexFind)
      printx("   $examples\n"
             "      #sfk hexfind -text \"/foo/\" \"/bar/\" -dir mydir -file .txt .hpp\n"
             "         find words \"foo\" or \"bar\" case insensitive\n"
             "         in all .txt or .hpp files in a folder mydir.\n"
             "      #sfk hexfind -binary /666f6f/ -dir mydir -file .exe +view\n"
             "         find binary data with hex values 0x66, 0x6f, 0x6f\n"
             "         in all .exe files of mydir and show result in dview.\n"
             "\n");
      else
      if (!bIsXPat)
      {
      printx("   $examples\n"
             "      #sfk replace myfile.dat \"/Lemon/Curry/\"\n"
             "         replace Lemon by Curry within myfile.dat. search is\n"
             "         case-insensitive, therefore \"lemon\" will be replaced as well.\n"
             "         the quotes \"\" are optional here.\n"
             "      #sfk replace -pat /FooCase// -dir . -file .txt\n"
             "         search for FooCase in all .txt files below current directory.\n"
             "         note that if you leave out the single fileOrDir parameter,\n"
             "         you have to say -[s]pat, -bin or -text first to tell clearly\n"
             "         that you will specify the target fileset later on.\n"
             "      #sfk rep -spat \"/The foo/The\\tbar/\" -dir mydocs\n"
             "         replaces \"The foo\" by \"The\" and \"bar\" separated by TAB char,\n"
             "         within all files within mydocs.\n"
             "      #sfk rep -binary /1A/20/ -dir docs -file .txt .info .note\n"
             "         replaces all bytes with code 0x1A by code 0x20, in all .txt,\n"
             "         .info and .note files, in directory docs and all subdirectories.\n"
             "      #sfk replace tmp\\image.dat -bylist patches.txt\n"
             "         searches for source patterns in file tmp\\image.dat,\n"
             "         replaces by patterns specified in patches.txt\n"
             );
      #if defined(SFKXDXE)
      printx("      $SFK Base and XE: swap text in two steps\n");
      #else
      printx("      $SFK Base: swap text in two steps\n");
      #endif
      printx("      #sfk -yes rep io.txt /foo34/foo99/ /foo12/foo34/ +rep /foo99/foo12/\n"
             "         replaces foo12 by foo34 and vice versa. with SFK Base, a word\n"
             "         which is replaced may be replaced again by a following pattern,\n"
             "         therefore the intermediate step: turn foo34 into something\n"
             "         not used anywhere in io.txt, then replace foo12, then replace\n"
             "         the intermediate pattern back in a second replace command\n"
             "         on the same file.\n");
      printx("      #sfk hexfind mydir -pat /FooCase/ +list -late\n"
             "         do not replace, just find binary files containing \"FooCase\",\n"
             "         then list them sorted by time. also accepts -bylist files.\n");
      }
      else
      {
         printXRepExamples(pszCmd, bIsReplace ? 0 : 1, bIsReplace);
      }

      if (bhelp || bIsFReplace)
      printx("      #sfk replace -binary /666f6f/626172/ -dir mydir -file .dat\n"
             "         replace binary data with hex values 0x66, 0x6f, 0x6f\n"
             "         by data with values 0x62, 0x61, 0x72 in all .dat files.\n");

      if (bhelp || bIsXFBin)
      printx("      #sfk xfindbin in.dat \"/foo[0.100 bytes of (a-z0-9_@ )]bar/\"\n"
             "         searches a single input file in.dat for all phrases\n"
             "         starting foo and ending bar, with 0 to 100 characters\n"
             "         inbetween being alphanumeric, @ or _ or space.\n"
             "      #sfk xfindbin -text \"/foo*bar/[part2]\\n\" -dir mydir -file .txt\n"
             "         find foo*bar in all .txt files of folder mydir\n"
             "         but print only the text between foo and bar.\n"
             "      #sfk xfindbin -text \"/\\x66\\x6f\\x6f[0.100 bytes]\\x62\\x61\\x72/\"\n"
             "       #-dir mydir -file .exe +view\n"
             "         find binary data starting with bytes 0x66, 0x6f, 0x6f,\n"
             "         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween\n"
             "         in all .exe files of mydir and show result in dview. [14]\n"
             "      #sfk xfindbin -arc in.zip \"/class*/\"\n"
             "         XE: find phrases starting with \"class\" in .zip contents\n"
             #ifdef _WIN32
             "      #sfk xfindbin -justrc result.txt \"/error/\"\n"
             "      #IF %%ERRORLEVEL%%==1 GOTO foundError\n"
             "         in a batchfile: jump to label foundError if \"error\"\n"
             "         is found in result.txt. with -justrc no output is printed.\n"
             #endif
             );

      if (bhelp || bIsXFTex)
      printx("      #sfk xfind -pure -text \"/foo*bar/[part2]\\n/\"\n"
             "       #-dir mydir -file .txt +view\n"
             "         search foo*bar in all .txt files of folder mydir,\n"
             "         extract the text between foo and bar without any\n"
             "         context (-pure), and display this in dview. [15]\n"
             "      #sfk xfind -arc in.zip \"/class*/\"\n"
             "         XE: find phrases starting with \"class\" in .zip contents\n"
             "      #sfk xfind mydir \"/[lstart]---info---[eol]**/[part4]/\"\n"
             "       #-to out<sla><run>file\n"
             "         from all files within mydir extract text after line\n"
             "            $---info---\n"
             "         writing resulting data to files in the out folder.\n"
             "         the $**<def> will collect up to 4000 bytes by default,\n"
             "         use $[1.100000 bytes]<def> to collect more.\n"
             "      #sfk xfind mydir \"/[skip][3 chars]-foo/\" \"/*/\"\n"
             "         find all lines not matching a pattern in mydir,\n"
             "         i.e. find lines with wrong format in files.\n"
             "      #sfk xfind -pure -nofile mydir\n"
             "       #\"/error:[white][digits]/[file.name]: [all]\\n/\"\n"
             "         finds text like 'error: 12345' in files of mydir,\n"
             "         shows 'mydir<sla>a.txt: error: 12345' in the same line.\n"
             "      #sfk xfind -names mydir \"/foo/\" +xfind \"/bar/\"\n"
             "         run a nested search: in all files containing 'foo'\n"
             "         find the lines containing 'bar'.\n"
             "      #sfk xfind -conlines=20 Mail<sla>provider<sla>Inbox \"/foo 123/\"\n"
             "         search the Inbox file of an email program for all mails\n"
             "         having 'foo 123' in their text, showing 20 lines of context.\n"
             );

      if (bhelp || bIsXHexFind)
      printx("      #sfk xhexfind -text \"/\\x66\\x6f\\x6f[0.100 bytes]\\x62\\x61\\x72/\"\n"
             "       #-dir mydir -file .exe +view\n"
             "         find binary data starting with bytes 0x66, 0x6f, 0x6f,\n"
             "         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween\n"
             "         in all .exe files of mydir and show result in dview. [16]\n"
             "      #sfk xhexfind in.txt \"/[char of \\x01-\\x09\\x0b-\\x0c\\x0e-\\x1f]/\"\n"
             "         find control characters in file except for CR/LF\n"
             "      #sfk xhexfind mydir \"/[bytes of \\x00-\\x08]/\"\n"
             "         search binary code range 0x00 to 0x08 in mydir\n"
             "      #sfk hexfind mydir -bin /01020304/\n"
             "      #sfk xhexfind mydir \"/\\x01\\x02\\x03\\x04/\"\n"
             "         search binary data 0x01020304 in mydir\n"
             );

      #ifdef _WIN32
      if (bhelp || bIsXReplace)
      printx("      #sfk xreplace in.txt \"/foo*bar/other/\"\n"
             "         replace phrases starting with \"foo\" and ending with \"bar\"\n"
             "         by word \"other\" in single file in.txt\n"
             "      #sfk xreplace -text \"/foo*bar/===[part2]===/\" -dir mydir -file .txt\n"
             "         replace foo*bar in all .txt files of folder mydir\n"
             "         with a new pattern containing the text between foo and bar\n"
             "         surrounded by \"===\".\n"
             "      #sfk xrep -text \"/\\x66\\x6f\\x6f[0.100 bytes]\\x62\\x61\\x72/---/\"\n"
             "       #-dir mydir -file .dat\n"
             "         replace binary data starting with bytes 0x66, 0x6f, 0x6f,\n"
             "         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween\n"
             "         by \"---\" within all .dat files of folder mydir. [24]\n");
      #endif

      if (bhelp || bIsXExtract)
      {
      printx("      #sfk extract in.txt \"/foo[0.100 chars of (a-z0-9_@ )]bar/\"\n"
             "         extracts from a single input file in.txt all phrases\n"
             "         starting foo and ending bar, in the same line, with\n"
             "         0 to 100 characters inbetween being alphanumeric or\n"
             "         one of @ _ or a blank character.\n"
             "      #sfk sel mydir .txt +extract \"/foo*bar/\"\n"
             "         extract foo*bar from all .txt files in mydir.\n"
             "      #sfk extract mydir \"/\\x66\\x6f\\x6f[0.100 bytes]\\x62\\x61\\x72/\" -tofile out.dat\n"
             "         find binary data starting with bytes 0x66, 0x6f, 0x6f,\n"
             "         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween\n"
             "         within all files of folder mydir, writing found data\n"
             "         to a single file out.dat\n");
      printx("      #sfk extract -text \"/class [bytes]{[bytes]}/[all]\\n\\n/\"\n"
             "       #-tofile out.txt -dir mydir -file .hpp\n"
             "         collect class definitions from mydir directly to out.txt [10]\n"
             "      #sfk extract -dir mydir -file .cpp -text \"/printf([bytes]);/[all]\\n/\"\n"
             "       #+xed \"/);[eol]/[all]/\" \"/[eol][1.* white]/ /\"\n"
             "         extract all (multi line) printf statements from source code,\n"
             "         convert multi line to single line, stripping whitespace. [11]\n"
             "         the \"/);[eol]/[all]/\" keeps all line endings after \");\"\n"
             "      #sfk extract -text \"/%c%cversion:vernum=*,*name=*,*os=*,/\n"
             "       #[file.name]: [part6] v[part2] for [part10]\\n/\"\n"
             "       #-tofile versions.txt -dir mydir -file .exe -nofilenames\n"
             "         search all .exe files in mydir for a text block like\n"
             "          #%c%cversion:vernum=1.6.9,name=fooprog,os=windows\n"
             "         then extract and reformat version informations,\n"
             "         writing results without :file headers to versions.txt [12]\n"
             ,'$','$','$','$' // to avoid version command error on binary
             );
      }
      } // endif not ofind
      #ifdef SFKOFFICE
      if (bhelp || iIsOFind)
      {
      printx(
         "   $see also\n"
         "      #sfk xfind<def>        for more search pattern examples\n"
         "\n"
         "   $examples\n"
         "      #sfk ofind mydir \"/myword/\"\n"
         "         search office and plain text files in mydir\n"
         "         containing the word 'myword'.\n"
         "      #sfk ofind mydir \"/myword/\" -names +copy out\n"
         "         same as above, but copy the found files\n"
         "         to a folder 'out'.\n"
         "      #sfk ofind mydir \"/foo*bar/\"\n"
         "         search foo followed by bar in the same line.\n"
         "      #sfk ofind -pure mydir \"/foo**bar/[part2]\\n/\"\n"
         "         search text starting with foo, then several\n"
         "         text lines, then ending with bar. print\n"
         "         only the found text between foo and bar.\n"
         );
      }
      #endif // SFKOFFICE

      ehelp;

      sfkarg;

      CommandScope oscope(bIsXPat ? "xfind" : "hexfind");

      char *pszConf = getenv("SFK_CONFIG");
      if (!pszConf) pszConf = str("");

      #ifdef SFKOFFICE
      if (iIsOFind == 1)
         cs.office = 1; // read just .xml subfiles
      #endif // SFKOFFICE

      char *pszRepFile  = 0;
      char *pszFirstPat = 0;
      char *pszChainOutCmd = 0;
      bool  bRevert     = 0;
      int  nstate       = 0;
      bool bGotFileDir  = 0;
      bool bcolpat      = 0;
      bool bforcedump   = 0;
      bool bNoTmp       = 0;
      bool bIncomplete  = 0;
      bool bDumpSingle  = 0;
      int  iShowPreState = 0;
      bool bHaveSingleNames = 0;
      bool bSendNames   = 0;
      bool bGotIndent   = 0;
      bool bGotPure     = 0;
      bool bGotLean     = 0;
      bool bUsedContext = 0;
      bool bGotHex      = 0;
      bool bGotNoDump   = 0;
      bool bGotDump     = 0;
      bool butfin       = 0;

      cs.usefilehead    = 0;
      cs.szfilehead[0]  = '\0';
      cs.placeholder    = '.';

      cs.repDumpHalve   = bIsHexFind;

      if (bIsXRepDemo)
         cs.repDump = 1;

      #ifdef VFILEBASE
      if (bIsAnyFind || bExtract)
         cs.precachezip = 1;
      #endif // VFILEBASE
 
      cs.recordsize     = 100000;
      cs.contextchars   = 240;

      memset(abBuf, 0, sizeof(abBuf)); // for direct patterns

      // autoselect hex dump width by console width
      if (bGlblConsColumnsSet && (nGlblConsColumns >= 120))
         bGlblHexDumpWide = 1;

      // autoselect dump per command
      if (bIsXFTex || bIsXFBin) { // init
         cs.repDump = 1;
         bforcedump = 1;
         cs.astext  = 1;
         cs.noind   = 1;
         cs.xtext   = 1;
         // cs.quiet = 1;  // sfk190 xfind, xtext with progress
         cs.litattr = 'e'; // literal highlight attribute
         cs.xfind   = !strcmp(pszCmd, "xfind");
         cs.execweb = 1; // xfind, xtext
         if (bIsXFTex!=0 && strstr(pszConf, "xfind:pure"))
            { bUsedContext=1; cs.contextlines = 0; }
         else
         if (bIsXFBin!=0 && strstr(pszConf, "xfindbin:pure"))
            { bUsedContext=1; cs.contextlines = 0; }
         else
            cs.contextlines = 1; // current line
      }
      if (bIsHexFind) {
         cs.repDump  = 1;
         cs.astext   = 0;
         cs.xtext    = 0;
         cs.hexfind  = 1;
         if (strEnds(pszCmd, "le"))
            cs.leattr = 'e';
      }
      if (bIsXFTex) // sfk194 new xfind default
         cs.textfiles = 1;
      // changed later in case of -justrc

      cs.xpat    = bIsXPat;
      cs.extract = bExtract;

      char szDefaultTo[100];
      szDefaultTo[0] = '\0';

      int iFirst = iDir;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(argx[iDir], "-dir"))
         {
            // parse initial -dir ... -file ... parameters
            int iDirNext = 0;
            if (cs.debug)
               printf("[processDirParms.1 from idx=%d]\n", iDir);
            if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1+4+8, &iDirNext))) { // rep
               nGlblError=1;
               pinf("try to add -enddir after initial -dir ... -file ...\n");
               return 9;
            }
            // continue with command local parms after that
            if (cs.debug)
               printf("[processDirParms.1 done, inext=%d]\n", iDirNext);
            if (iDirNext <= 0) {
               // sfk rep -dir ... -enddir -text ...
               if (iDir == iFirst)
                  return 9+perr("missing -enddir after initial -dir ... -file ... options\n");
               // sfk rep -text ... -dir ...
               iDir = argc; // fix: 169: [2131217] folders done twice
               break;
            }
            iDir = iDirNext;
         }
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-bylist", &pszParm)) {
            if (!pszParm) return 9;
            pszRepFile = pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-bylinelist", &pszParm)) {
            if (!pszParm) return 9;
            pszRepFile = pszParm;
            cs.fixedbylist = 1;
            continue;
         }
         #ifdef WITH_REPEAT
         if (haveParmOption(argx, argc, iDir, "-repeat", &pszParm)) {
            if (!pszParm) return 9;
            if (!(cs.reprep = atoi(pszParm)))
               return 9+perr("supply -repeat=n or repeat n with a non zero value.");
            continue;
         }
         #endif
         if (haveParmOption(argx, argc, iDir, "-fill", &pszParm)) {
            if (!pszParm) return 9;
            cs.placeholder = *pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-filehead", &pszParm)) {
            if (!pszParm) return 9;
            cs.usefilehead = 1;
            copyFromFormText(pszParm,strlen(pszParm), cs.szfilehead,sizeof(cs.szfilehead)-20);
            if (strchr(cs.szfilehead, '%'))
               return 9+perr("percent \"%%\" is not allowed in file header");
            char *psz = strstr(cs.szfilehead, "[file.name]");
            if (psz) {
               char *psz2 = psz+strlen("[file.name]");
               strcpy(psz, "%s");
               memmove(psz+2, psz2, strlen(psz2)+1);
            }
            continue;
         }
         if (!strcmp(argx[iDir], "-rawterm")) {
            cs.rawterm = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-revert")) {
            bRevert = 1; // internal
            continue;
         }
         if (!strcmp(argx[iDir], "-text")) {
            bcolpat = 1;
            nstate = 1;
            strcat((char*)abBuf, ":text\n");
            continue;
         }
         if (!strncmp(argx[iDir], "-bin", 4)) {
            bcolpat = 1;
            nstate = 2;
            strcat((char*)abBuf, ":binary\n");
            continue;
         }
         if (strBegins(argx[iDir], "-dump")) {
            if (!strcmp(argx[iDir], "-dumpfrom"))
               cs.dumpfrom = 1;
            else
            if (!strcmp(argx[iDir], "-dumpall"))
               cs.dumpboth = 1;
            else
            if (strcmp(argx[iDir], "-dump"))
               return 9+perr("unknown option: %s", argx[iDir]);
            cs.repDump = 1;
            bforcedump = 1;
            bGotDump   = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-wide")) {
            bGlblHexDumpWide = 1;
            continue;
         }
         if (!strncmp(argx[iDir], "-pat", 4)) { // replace
            bcolpat = 1;
            continue;
         }
         if (!strncmp(argx[iDir], "-spats", 6)) {
            bcolpat = 1;
            cs.spat = 2; // strict slash patterns
            continue;
         }
         if (!strncmp(argx[iDir], "-spat", 5)) {
            bcolpat = 1;
            cs.spat = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-reldist")) {
            cs.reldist = 1;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-recsize", &pszParm)) {
            if (!pszParm) return 9;
            cs.recordsize = numFromSizeStr(pszParm, "record size");
            if (cs.recordsize < 1)
               return 9+perr("invalid record size");
            if (cs.verbose)
               printf("using record size: %s bytes\n", numtoa(cs.recordsize));
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-recordsize", &pszParm)) {
            if (!pszParm) return 9;
            cs.recordsize = numFromSizeStr(pszParm, "record size");
            if (cs.recordsize < 1)
               return 9+perr("invalid record size");
            if (cs.verbose)
               printf("using record size: %s bytes\n", numtoa(cs.recordsize));
            continue;
         }
         if (!strcmp(argx[iDir], "-lean") || !strcmp(argx[iDir], "-narrow"))
         {
            bGlblHexDumpWide = 0;
            bGotLean = 1;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-context", &pszParm)) {
            if (!pszParm) return 9;
            nGlblDumpCtx = atoi(pszParm);
            continue;
         }
         if (!strcmp(argx[iDir], "-conresline")) {
            cs.contextlines = 1;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-conlines", &pszParm)) {
            if (!pszParm) return 9;
            int ival = atoi(pszParm);
            if (ival > 0) {
               cs.contextlines = ival + 1;
               cs.contextchars = ival * 160;
               sprintf(cs.szseparator, "---%s", cs.szeol);
            } else {
               cs.contextlines = 0;
            }
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-conchars", &pszParm)) {
            if (!pszParm) return 9;
            int ival = atoi(pszParm);
            if (ival < 1 || ival > SFK_CTX_SIZE)
               return 9+perr("-conchars cannot be larger than %d", SFK_CTX_SIZE-100);
            cs.contextchars = ival;
            continue;
         }
         if (!strcmp(argx[iDir], "-pure")) {
            bGotPure = 1;
            cs.szseparator[0] = 0;
            cs.contextlines = 0;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-indent", &pszParm)) {
            if (!pszParm) return 9;
            cs.indent = atoi(pszParm);
            bGotIndent = 1;
            continue;
         }
         if (strBegins(argx[iDir], "-showle")) {
            cs.leattr   = 'e';
            continue;
         }
         if (strBegins(argx[iDir], "-nole")) {
            cs.leattr   = 0;
            continue;
         }
         if (strcmp(argx[iDir], "-showrc"))  // fix sfk193
         if (strBegins(argx[iDir], "-show")) {
            char *psz = argx[iDir]+5;
            int iwhat = 0;
            if (strBegins(psz, "part"))  iwhat |= 1;
            if (strBegins(psz, "best"))  iwhat |= 2;
            if (strBegins(psz, "list"))  iwhat |= 4;
            if (strBegins(psz, "all" ))  iwhat |= 7;
            if (!iwhat) {
               perr("invalid option: %s", argx[iDir]);
               pinf("use one of -showpart -showbest -showall\n");
               return 9;
            }
            if (iwhat & 1) {
               cs.showpre = 1;
               iShowPreState = 1;
            }
            if (iwhat & 2)
               cs.showpost = 1;
            if (iwhat & 4)
               cs.showlist = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-fixedbylist")) { // inofficial
            cs.fixedbylist = 1; // see -bylinelist instead
            continue;
         }
         if (!strcmp(argx[iDir], "-blank")) { // deprecated since 173
            sprintf(szDefaultTo, "[all]%s%s", cs.szeol, cs.szeol);
            continue;
         }
         if (!strcmp(argx[iDir], "-astext")) { // inofficial
            cs.astext = 1;
            continue;
         }
         if (strBegins(argx[iDir], "-hex")) {
            cs.astext   = 0;
            cs.xtext    = 0;
            cs.hexfind  = 1;
            bGotHex     = 1;
            continue;
         }
         if (strBegins(argx[iDir], "-fullhead")) { // sfk1812
            cs.fullheader = 1;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-maxdump", &pszParm)) { // sfk1812
            if (!pszParm) return 9;
            cs.maxdump = atoi(pszParm);
            continue;
         }
         if (!strcmp(argx[iDir], "-nodump")) {
            if (bGotHex)
               return 9+perr("-nodump excludes -hex. use xhexfind instead.");
            cs.repDump = 0;
            cs.dostat  = 1;
            bGotNoDump = 1;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-septext", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), cs.szseparator, sizeof(cs.szseparator)) < 0)
               return 9;
            continue;
         }
         if (strBegins(argx[iDir], "-sep") || strBegins(argx[iDir], "-separator")) {
            sprintf(cs.szseparator, "---%s", cs.szeol);
            continue;
         }
         if (strBegins(pszArg, "-nosep")) {
            cs.szseparator[0] = 0;
            continue;
         }
         if (!strcmp(pszArg, "-stat")) {
            cs.dostat = 1;
            continue;
         }
         if (strBegins(pszArg, "-prog")) {
            cs.quiet = 0;
            continue;
         }
         if (!strcmp(pszArg, "-fast")) { // no function
            cs.fastopt = 1;
            continue;
         }
         if (iIsOFind && !strcmp(pszArg, "-utfout")) // sfk1942 ofind
            { cs.utfout = 1; continue; }
         if (iIsOFind && !strcmp(pszArg, "-utfin"))  // sfk1942 ofind
            { butfin = 1; continue; }
         if (haveParmOption(argx, argc, iDir, "-maxscan", &pszParm)) {
            if (!bIsFReplace)
               return 9+perr("-maxscan requires sfk replace, not %s", pszCmd);
            if (!pszParm) return 9;
            cs.maxscan = numFromSizeStr(pszParm, "max scan");
            if (cs.maxscan < 1)
               return 9+perr("invalid max scan size");
            if (cs.verbose)
               printf("using max scan: %s bytes\n", numtoa(cs.maxscan));
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir])) {
               break; // fall through
            }
            if (setGeneralOption(argx, argc, iDir)) {
               continue;
            } else {
               return 9+perr("unknown option: %s\n", argx[iDir]);
            }
         }
         if (isChainStart(pszCmd, argx, argc, iDir, 0))
         {
            if (bIsReplace && !strcmp(argx[iDir], "+xed")) {
               perr("(x)replace ... +xed is not supported.");
               pinf("you may use extract ... +xed instead.\n");
               return 9;
            }
            pszChainOutCmd = argx[iDir];
            if (!strcmp(argx[iDir], "+view") && !bGotLean)
               bGlblHexDumpWide = 1;
            break;
         }
 
         // non "-" parms
         if (!bcolpat && !chain.usefiles && !bGotFileDir) // && (iDir == iDirFirst)
         {
            // single dir or file specified.
            bGotFileDir = 1;
            Coi ocoi(argx[iDir], 0);
            if (ocoi.isHttp() && !cs.execweb) // xfind
               return 9; // noweb: xfind with single file parm
            if (ocoi.isTravelDir()) {
               // since 169: support single dir with all commands
               if ((lRC = setProcessSingleDir(argx[iDir])))
                  return lRC;
            } else {
                if (!ocoi.existsFile()) {
                  pferr(argx[iDir], "no such file or dir: %s\n", argx[iDir]);
                  pinf("if this is a pattern, say -pat %s\n", argx[iDir]);
                  return 9;
               }
               if (cs.textfiles && ocoi.isBinaryFile()) {
                  if (cs.quiet < 2)
                     pwarn("skipping binary: %s", ocoi.name());
                  return 9;
               }
               glblSFL.addEntry(ocoi); // is copied
               bHaveSingleNames = 1;
               // cs.pure = 1;
            }
            cs.shortsyntax = 1;
            continue;
         }
 
         // expecting patterns either after fileOrDir or -pat
         if (!pszRepFile) {
            if (nstate == 0) {
               // implicitely guess -text by default
               nstate = 1;
               strcat((char*)abBuf, ":text\n");
               bcolpat = 1;
            }
            if (bcolpat) {
               // add another /src/dst/ pattern string
               if (iGlblInScript) // then argx[iDir] is writeable
                  fixMultiLineParm(argx[iDir], 't'); // (x)rep
               if (!pszFirstPat) pszFirstPat = argx[iDir];
               strcat((char*)abBuf, argx[iDir]);
               strcat((char*)abBuf, "\n");
               continue;
            }
         }
 
         return 9+perr("unexpected: %s\n", argx[iDir]);
         // continue w/next pattern, option or chain cmd.
      }

      if (iIsOFind && cs.travelzips) {
         perr("ofind -arc is not supported.");
         return 9;
      }

      if (btest) return 0;

      if (cs.verbose && bUsedContext)
         pinf("used SFK_CONFIG=%s\n", pszConf);

      if (!cs.usefilehead) {
         cs.usefilehead = 1;
         strcpy(cs.szfilehead, ":file %s");
         strcat(cs.szfilehead, cs.szeol);
      }

      if (bHaveSingleNames==1 && glblSFLNumberOfEntries()==1)
         cs.usefilehead = 0;

      if (cs.nohead || cs.nonames)
         cs.usefilehead = 0;

      if (cs.nonames)
         cs.noind = 1;

      if (bIsXFTex || bIsXFBin) { // init.2
         // chaining to xed: binary only if pure
         if (!bGotPure)
            chain.colbinary = 0;
      }
      if (bIsReplace) {
         // since 174: default dump in simulation mode
         if (!cs.yes && !bGotNoDump)
            cs.repDump = 1;
         if (!cs.quiet && !cs.astext)
            cs.dostat = 1;
      }

      if (!szDefaultTo[0]) {
         bool bUseDumpWithContext = cs.xtext && (cs.contextlines || cs.indent || cs.szseparator[0]);
         if (bUseDumpWithContext)
            sprintf(szDefaultTo, "[all]");
         else
            sprintf(szDefaultTo, "[all]%s", cs.szeol);
      }

      char *pszRepList = 0;

      if (pszRepFile) {
         if (strlen((char*)abBuf))
            return 9+perr("cannot combine patterns on command line with -bylist file. (1)\n");
         if (!(pszRepList = loadRepList(pszRepFile)))
            return 9+perr("unable to load -bylist file \"%s\"\n", pszRepFile);
      } else {
         if (!strlen((char*)abBuf)) {
            perr("no patterns found for processing.\n");
            pinf("say -text /src/dst/ or -binary _src_dst_ or -bylist file.txt\n");
            pinf("specify -dir or -file after patterns only.\n");
            return 9;
         }
         pszRepList = strdup((char*)abBuf);
      }
 
      // apply utfin conversion
      if (cs.utfout && !butfin) {
         // parms need atou
         num nExtSize = getAnsiToUTFSize(pszRepList);
         char *pszExt = new char[nExtSize+100];
         if (!pszExt) return 9+perr("out of memory");
         ansiToUTF(pszExt, nExtSize+10, pszRepList);
         pszExt[nExtSize] = '\0';
         // swap
         delete [] pszRepList;
         pszRepList = pszExt;
      }

      // create replacement expression table
      if (iShowPreState==1) {
         iShowPreState = 2;
         printx("$Pat.  Range  MaxOut Memory FromText\n");
      }

      nBinRepExp = 0; // FIX: 1.69: missing init

      // 1. estimate size, allocate
      int nLines = 0;
      char *psz1 = pszRepList;
      for (; *psz1; psz1++) if (*psz1 == '\n') nLines++;
      // FIX: 1652: crash due to nMaxExp being to small by one.
      nLines++; // ALWAYS add one line in case last one has no LF.
      int nMaxExp = nLines + 10; // max. array entries with tolerance
      apRepSrcExp = new uchar*[nMaxExp];
      apRepDstExp = new uchar*[nMaxExp];
      apRepSrcLen = new int[nMaxExp];
      apRepDstLen = new int[nMaxExp];
      apRepFlags  = new int[nMaxExp];
      apRepOffs   = new num[nMaxExp];
      memset(apRepFlags, 0, sizeof(int)*nMaxExp);
      if (!apRepSrcExp || !apRepDstExp || !apRepSrcLen || !apRepDstLen || !apRepFlags)
         return 9+perr("out of memory\n");

      // FIX: 1683: missing init
      memset(apRepSrcExp, 0, sizeof(uchar*) * nMaxExp);
      memset(apRepDstExp, 0, sizeof(uchar*) * nMaxExp);
      memset(apRepSrcLen, 0, sizeof(int) * nMaxExp);
      memset(apRepDstLen, 0, sizeof(int) * nMaxExp);
      memset(apRepFlags , 0, sizeof(int) * nMaxExp);
      memset(apRepOffs  , 0, sizeof(num) * nMaxExp);

      #ifdef WITH_CASE_XNN
      if (!(apRepSrcBit = new uchar*[nMaxExp]))
         return 9+perr("out of memory\n");
      memset(apRepSrcBit, 0, sizeof(uchar*) * nMaxExp);
      #endif

      if (cs.xpat) {
         if (!(apRepObj = new SFKMatch[nMaxExp]))
            return 9+perr("out of memory (xpat)\n");
         SFKMatch::setOutFNCallback(cbSFKMatchOutFN); // xrep
      }

      // REMEMBER PATTERN MEMORY ON RETURN.
      // In case of parameter errors, nGlblError must be set,
      // to avoid memory leak checks on exit.

      bool bHaveDiffLen = 0;
      bool bVarMode     = 0;

      // 2. parse expressions
      // since 1643: -bylist default is :text
      nstate = pszRepFile ? 1 : 0;
      char *psz2  = 0;
      int nLine  = 0;
      for (psz1 = pszRepList; psz1 && (*psz1); psz1=psz2)
      {
         // fetch and prepare line
         nLine++;
         psz2 = strchr(psz1, '\n');
         if (!psz2) psz2 = psz1+strlen(psz1);
         *psz2++ = '\0';
         char *psz3 = strchr(psz1, '\r');
         if (psz3) *psz3 = '\0';
         if (!*psz1) continue; // empty line
         // extract line number prefix, if any
         if (!strncmp(psz1, ":@", 2)) {
            psz1 += 2;
            nLine = atoi(psz1);
            while (isdigit(*psz1))
               psz1++;
            if (*psz1==' ')
               psz1++;
         }
         if (!strncmp(psz1, ":#", 2)) continue; // remark
         // process line
         if (!strcmp(psz1, ":text"))
            { nstate=1; continue; }
         else
         if (!strcmp(psz1, ":binary"))
            { nstate=2; continue; }
         else
         if (!nstate || (*psz1 == ':')) {
            nGlblError=1;
            return 9+reperr("unexpected command", psz1, pszRepFile, nLine);
         }
         // within expression block /from/to/
         char *pszfs = psz1; // from, start
         char cLimit = *pszfs++;
         if (!cLimit) break;
         if (!*pszfs) return 9+reperr("incomplete search pattern", psz1, pszRepFile, nLine);
         char *pszfe = strchr(pszfs, cLimit);
         if (!pszfe) return 9+reperr("incomplete search pattern", psz1, pszRepFile, nLine);
         char *pszts = pszfe+1;
         char *pszte = strchr(pszts, cLimit);
         if (pszte) {
            apRepFlags[nBinRepExp] |= (1 << 3); // may dump totext
         } else {
            // uncomplete /to/ text
            // accept /foo/ and /foo// but not /foo/any
            // since 174: also with replace
            if (*pszts)
               return 9+reperr("missing last delimiter in pattern", psz1, pszRepFile, nLine);
            if (bIsAnyFind || cs.extract) {
               // empty /to/ with extract
               if (cs.xpat) {
                  pszts = szDefaultTo;
                  pszte = pszts+strlen(pszts);
               } else {
                  pszte = pszts;
               }
            } else {
               #ifndef SFKXEREP
               // convenience preview of incomplete patterns
               // is not provided with replaceVar/replaceFix.
               if (!cs.xpat)
                  return 9+reperr("incomplete search pattern", psz1, pszRepFile, nLine);
               #endif
               apRepFlags[nBinRepExp] |= (1 << 4); // forcedump
               if (!bGotDump)
                  cs.repDump = 0;
               bDumpSingle = 1;
               cs.dostat = 0;
               bIncomplete = 1;
               pszte = pszts;
               *pszte = '\0';
               if (cs.xpat) {
                  if (!cs.showpre) {
                     cs.showpre = 1;
                     printx("$[/.../totext/ is incomplete, showing part infos:]\n");
                     printx("$Pat.  Range  MaxOut Memory FromText\n");
                  }
               } else {
                  printx("$[one or more /.../totext/ are incomplete.]\n");
                  bIncomplete = 2; // do not show "complete all"
               }
            }
         }
         // check for garbage after closing delimiter
         if (pszte && (strlen(pszte) > 1))
            return 9+reperr("wrong pattern, check delimiters", psz1, pszRepFile, nLine);
         // pszfs is exact start of from
         // pszfe is one after end of from
         *pszfe = '\0';
         // same for pszts, pszte
         *pszte = '\0';
         // shrink \\t and the like in both expressions
         uchar *pFromBits=0,**ppFromBits=0;
         uchar *pToBits=0,**ppToBits=0;
         int nFromLen = pszfe-pszfs;
         int nToLen   = pszte-pszts;
         if (!cs.xpat)
         {
            ppFromBits = cs.xpat ? 0 : &pFromBits;
            ppToBits = cs.xpat ? 0 : &pToBits;
            if (shrinkFormTextVar(pszfs, nFromLen, ppFromBits)) return 9+reperr("wrong syntax in pattern", pszfs, pszRepFile, nLine);
            if (shrinkFormTextVar(pszts, nToLen, ppToBits))     return 9+reperr("wrong syntax in pattern", pszts, pszRepFile, nLine);
            // => nFromLen, nToLen may have been reduced.
         }
         if (cs.xpat || (!bIsAnyFind && nFromLen != nToLen))
         {
            // different source / pattern length: select variable mode
            bHaveDiffLen = 1;
            bVarMode = 1;
            cs.repDumpHalve = 1;
         }
         if (bRevert) {
            int nSwap=nFromLen; nFromLen=nToLen; nToLen=nSwap;
            char *pSwap=pszfs; pszfs=pszts; pszts=pSwap;
                  pSwap=pszfe; pszfe=pszte; pszte=pSwap;
            #ifdef WITH_CASE_XNN
            uchar *pBits=pFromBits; pFromBits=pToBits; pToBits=pBits;
            #endif
         }
         #ifdef WITH_CASE_XNN
         if (pToBits) delete [] pToBits;
         #endif
         // store source and target.
         // FIX: 1652: missing array overflow check
         if (nBinRepExp >= nMaxExp) // internal, should not happen
            return 9+reperr("pattern array overflow", pszfs, pszRepFile, nLine);
         if (nstate == 1) {
            // as text
            if (cs.xpat)
            {
               int iSubRC = apRepObj[nBinRepExp].init(pszfs,pszts,cs.litattr ? SFKMATCH_WITHATTRIB : 0);
               if (iSubRC < 9 && cs.showpre != 0)
               {
                  printx("%05d %06d %06d %06d #%s\n",
                     nBinRepExp+1,
                     apRepObj[nBinRepExp].objectFromRange(),
                     apRepObj[nBinRepExp].objectToRange(),
                     apRepObj[nBinRepExp].objectMemory(),
                     (char*)SFKMatch::aClFromCopy
                     );
                  printf("                     parts %s\n",
                     apRepObj[nBinRepExp].recentPartInfo());
                  printx("                     <time>prios %s\n",
                     apRepObj[nBinRepExp].recentPrioInfo());
               }
               if (iSubRC) {
                  if (iSubRC!=10)
                     reperr("invalid source or target pattern", pszfs, pszRepFile, nLine);
                  return 9;
               }
            }
            else
            {
               apRepSrcLen[nBinRepExp] = nFromLen;
               apRepDstLen[nBinRepExp] = nToLen;
               apRepSrcExp[nBinRepExp] = (uchar*)mymemdup(pszfs, nFromLen);
               apRepDstExp[nBinRepExp] = (uchar*)mymemdup(pszts, nToLen);
               // apRepFlags[nBinRepExp]  = (0 << 0); // is text
               bool bUseCase = cs.nocase ? 0 : cs.usecase;
               if (bUseCase)
                  apRepFlags[nBinRepExp] |= (1 << 2); // case sensitive
               #ifdef WITH_CASE_XNN
               apRepSrcBit[nBinRepExp] = pFromBits; // if any
               #endif
            }
            nBinRepExp++;
         } else {
            // as binary
            if (nFromLen & 1) return 9+reperr("wrong length of hex expression", pszfs, pszRepFile, nLine);
            if (nToLen   & 1) return 9+reperr("wrong length of hex expression", pszts, pszRepFile, nLine);
            int nSrcBinLen = nFromLen / 2;
            int nDstBinLen = nToLen   / 2;
            apRepSrcLen[nBinRepExp] = nSrcBinLen;
            apRepDstLen[nBinRepExp] = nDstBinLen;
            apRepSrcExp[nBinRepExp] = new uchar[nSrcBinLen+10];
            apRepDstExp[nBinRepExp] = new uchar[nDstBinLen+10];
            if (hexToBin(pszfs, apRepSrcExp[nBinRepExp], nSrcBinLen))
               return 9+reperr("syntax error in hex expression", pszfs, pszRepFile, nLine);
            if (hexToBin(pszts, apRepDstExp[nBinRepExp], nDstBinLen))
               return 9+reperr("syntax error in hex expression", pszts, pszRepFile, nLine);
            apRepFlags[nBinRepExp] |= (1 << 0); // is binary
            bool bUseCase = cs.nocase ? 0 : 1;
            if (bUseCase)
               apRepFlags[nBinRepExp] |= (1 << 2); // case sensitive
            #ifdef WITH_CASE_XNN
            apRepSrcBit[nBinRepExp] = pFromBits; // if any
            #endif
            nBinRepExp++;
         }
      }  // endfor RepList

      copySFKMatchOptions(); // xfind

      if (bIncomplete) {
         if (cs.yes) {
            perr("option -yes is not possible with incomplete /from/to/ patterns.");
            nGlblError = 1;
            return 9;
         }
         if (!cs.repDump && !bDumpSingle) {
            printx("$[add -dump or complete all /from/to/ patterns to continue.]\n");
            bGlblEscape = 1;
            return 5;
         }
         if (bIncomplete < 2)
            printx("$[complete all /fromtext/totext/ patterns to %s.]\n",
               bIsReplace ? "allow replace":"continue");
      }

      if (!nBinRepExp)
         { nGlblError=1; return 9+perr("no patterns for replacement, nothing to do.\n"); }

      // (re)alloc output buffer
      if (cs.xpat)
         if (SFKMatch::provideBuffer())
            return 9;

      int iDirNext=0;
      if (iDir < argc) {
         if (cs.debug)
            printf("[processDirParms.2 from idx=%d]\n", iDir);
         if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 1+4+8, &iDirNext))) // rep
            { nGlblError=1; return lRC; }
      }
 
      if (!chain.usefiles && !bGotFileDir && !glblFileSet.rootDirs().numberOfEntries()) {
         perr("please specify a fileset using -dir ... -file ...\n");
         if (pszFirstPat)
            pinf("if %s is a filename, specify it BEFORE -spat or -pat.\n", pszFirstPat);
         nGlblError=1;
         return 9;
      }

      cs.sim = !cs.yes;

      // plausi checks:
      #ifndef SFKXEREP
      if (bIsXRepDemo && cs.yes)
         return 9+perr("xreplace with option -yes requires SFK XE.");
      #endif
      if (chain.colfiles) {
         if (cs.sim && !bIsAnyFind) {
            perr("cannot chain output this way. say \"hexfind\" instead.\n");
            nGlblError=1;
            return 9;
         }
         cs.nohead  = 1;
         cs.quiet = 1;
         // if collecting filenames, hexdump only if requested.
         cs.repDump = bforcedump;
      }
      // no replace with hexfind
      if (bIsHexFind && !bIsXHexFind && !cs.xtext) {
         if (!cs.sim) {
            nGlblError=1;
            return 9+perr("option -yes cannot be used with hexfind.");
         }
         cs.nohead = 1;
         if (cs.justrc) {
            cs.repDump = 0;
            cs.quiet = 2;
         }
      }
      if (cs.justrc && !bIsAnyFind)
         return 9+perr("-justrc can be used only with find commands.\n");
      // no sim with output to console or single file
      if (cs.extract) {
         if (!cs.tomask || cs.tomaskfile) {
            // auto correct: extract ... +view instead of +xed
            if (!cs.xtext && chain.coldata && !chain.colbinary) {
               if (cs.verbose)
                  pinf("%s accepts only text, sending hex dump.\n", pszChainOutCmd ? pszChainOutCmd : "next command");
               cs.repDump = 1;
            }
            if (!chain.coldata && !cs.tomaskfile && !bIsHexFind)
               cs.repDump = 1;
            cs.yes = 1;
            cs.sim = 0;
         }
      }
      if (bIsHexFind && cs.tomask) {
         perr("-to[file] cannot be used with (x)hexfind.");
         pinf("use \"+tofile filename\" as last parameter to store hex dump output.\n");
         pinf("use \"sfk extract\" to store binary data with option -tofile.\n");
         nGlblError=1;
         return 9;
      }
      if ((bIsXFTex || bIsXFBin) && cs.hexfind && cs.tomask) {
         perr("-to[file] cannot be used with xfind -hex output.");
         pinf("use \"+tofile filename\" as last parameter to store hex dump output.\n");
         pinf("use \"sfk extract\" to store binary data with option -tofile.\n");
         nGlblError=1;
         return 9;
      }
      #ifndef SFKXEREP
      // -to ... not supported with (x)replace, (x)hexfind
      if (!cs.extract && cs.tomask)
         { nGlblError=1; return 9+perr("replace with -to[file] requires SFK XE.\n"); }
      #endif
      if (cs.maxscan && bHaveDiffLen)
         { nGlblError=1; return 9+perr("-maxscan cannot be used with different length replacements"); }

      if (cs.xpat) {
         int ipat=0;
         bool bFailed=0;
         for (ipat=0; ipat<nBinRepExp; ipat++) {
            // biggest object output size plus post (not pre) context
            int iMaxAmountRaw = apRepObj[ipat].objectFromRange() + SFK_CTX_SIZE;
            if (iMaxAmountRaw+100 > cs.recordsize) {
               cs.recordsize = iMaxAmountRaw + 1000;
               if (cs.verbose)
                  pinf("-recsize extended to %s due to pattern %d input range\n",
                     numtoa(cs.recordsize), ipat+1);
            }
         }
         if (cs.verbose) {
            for (ipat=0; ipat<nBinRepExp; ipat++)
               apRepObj[ipat].verify(ipat+1);
         }
         if (bFailed)
            return 9;
      }

      if (bIsXFTex || bIsXFBin) { // init.3
         if (pGlblDumpBuf) {
            delete [] pGlblDumpBuf;
            iGlblDumpBufSize = 0;
         }
         // PreContext + MatchText + PostContext
         //    4k           any         4k
         int iBufSize1 = mymax(SFKMatch::iClOutSizeMax, 1000);
         int iBufSize2 = (iBufSize1 + SFK_CTX_SIZE) * 2 + 1000;
         pGlblDumpBuf  = new char[iBufSize2+1000];
         if (!pGlblDumpBuf)
            return 9+perr("out of memory, cannot create outbuffer (%d)\n", SFKMatch::iClOutSizeMax);
         iGlblDumpBufSize = iBufSize2;
      }

      if (cs.sim && !cs.nohead) {
         if (bIsXRepDemo)
            printx("$[xreplace demo preview of changes:]\n");
         else if (bDumpSingle && !cs.repDump)
            printx("$[searching for incomplete patterns:]\n");
         else
            printx("$[simulating:]\n");
      }

      if (cs.dostat || cs.verbose)
      {
         if (cs.xpat && (cs.verbose != 0 || SFKMatchDefaultMaxLen < SFKMATCH_DEFAULT_MAXLEN || SFKMatchByteWildCards != 0)) {
            printf("using xmaxlen=%u, case=%u\n", SFKMatchDefaultMaxLen, cs.usecase);
         }
         chain.print('h', 0, "[total hits/matching patterns/non-matching patterns]\n");
      }

      if (bVarMode && cs.sim && cs.repDump) {
         bVarMode = 0;        // varrep in simulation: use replacefix for hexdump
         cs.repDumpHalve = 1; // only source hits, no replacement preview
      }
 
      if (cs.memcheck) sfkmem_checklist("replace.parse");

      #if defined(SFKOSE)

      if (cs.xpat)
      {
         if (bIsXReplace) {
            printf("xreplace demo requires SFK Base+XD.\n");
            return 9;
         }
         lRC = walkAllTrees(eFunc_XFind, lFiles, lDirs, nBytes);
      }
      else
      {
         if (bVarMode || cs.tomask)
            lRC = walkAllTrees(eFunc_ReplaceVar, lFiles, lDirs, nBytes);
         else
            lRC = walkAllTrees(eFunc_ReplaceFix, lFiles, lDirs, nBytes);
      }

      #else

      {
         if (bVarMode || cs.tomask)
            lRC = walkAllTrees(eFunc_ReplaceVar, lFiles, lDirs, nBytes);
         else
            lRC = walkAllTrees(eFunc_ReplaceFix, lFiles, lDirs, nBytes);
      }

      #endif

      info.clear();

      // best match info
      if (cs.showpost && cs.xpat) {
         printx("$Best pattern matches across all input data:\n");
         for (int i=0; i<nBinRepExp; i++) {
            SFKMatch *pObj = &apRepObj[i];
            //     "00006 000527 000318 003515 "
            printx("Pat.%02u matched $%02d<def> parts of: #%s\n", // xrep
               i+1,
               pObj->iClBestMatch,
               pObj->fromText()
               );
            printx("Pat.%02u per part byte match: ", i+1);
            for (int k=0; k<pObj->iClFrom && k<pObj->iClBestMatch; k++)
               printf("%u/%u ", k+1, pObj->aiClBestData[k]);
            printf("\n");
         }
      }

      if (!lRC && (cs.filesChg > 0)) lRC = 1; // xfind,rep: any hits or changes

      if (cs.memcheck) sfkmem_checklist("replace.exec");

      globalExtractOutCleanup();

      if (cs.xtext)
         { }
      else
      if (cs.extract && chain.coldata)
         { }
      else
      if (cs.dostat || cs.verbose)
      {
         if (bIsAnyFind || cs.extract)
            chain.print("%d files checked, %d files matched.\n", cs.files, cs.filesChg);
         else
            chain.print("%d files checked, %d%s %s.\n",
               cs.files, cs.filesChg, cs.sim?" would be":"", cs.extract ? "written":"changed");
      }

      #ifndef SFKXEREP
      if (cs.sim && bVarMode && cs.verbose && !cs.extract) {
         pinf("source and target patterns have %s lengths. replacement may be slow.\n",
            cs.xpat ? "variable":"differing");
      }
      #endif

      if (cs.sim && !cs.nohead) {
         if (bIsXRepDemo)
            printx("$[please purchase XE to allow writing of changes.]\n");
         else if (!bIncomplete)
            printx("$[add -yes to write changes.]\n");
      }

      if (cs.xpat && apRepObj) {
         delete [] apRepObj;
      }

      for (int i=0; i<nBinRepExp; i++) {
         if (apRepSrcExp[i])
            delete [] apRepSrcExp[i];
         if (apRepDstExp[i])
            delete [] apRepDstExp[i];
         #ifdef WITH_CASE_XNN
         if (apRepSrcBit[i])
            delete [] apRepSrcBit[i];
         #endif
      }

      #ifdef WITH_CASE_XNN
      delete [] apRepSrcBit; apRepSrcBit=0;
      #endif
      delete [] apRepSrcExp; apRepSrcExp=0;
      delete [] apRepDstExp; apRepDstExp=0;
      delete [] apRepSrcLen; apRepSrcLen=0;
      delete [] apRepDstLen; apRepDstLen=0;
      delete [] apRepFlags;  apRepFlags=0;
      delete [] apRepOffs;   apRepOffs=0;
      delete [] pszRepList;  pszRepList=0;

      nBinRepExp = 0;

      STEP_CHAIN(iDirNext, cs.justrc ? 0 : 1); // sfk193: justrc check

      bDone = 1;
   }

   bFullHelp = 0;
 
   bool bIsXed = 0;
   bool bIsXex = 0;

   ifcmd (!strcmp(pszCmd, "xed") || !strcmp(pszCmd, "xex")) // +wref +var
   {
      bIsXed = bhelp || (strcmp(pszCmd, "xed") ? 0 : 1);
      bIsXex =          (strcmp(pszCmd, "xex") ? 0 : 1);

      ifhelp (bFullHelp || (chain.usedata == 0 && nparm < 1))
      if (!bIsXex)
      printx("<help>$sfk ... +xed /from/to/ [/from2/to2/]\n"
             "\n"
             "   a stream text editor using SFK Simple Expressions.\n"
             "\n"
             "   - takes text stream input from a previous command,\n"
             "     or a binary stream from sfk extract.\n"
             "   - joins all lines into one large block that can be\n"
             "     changed in complete.\n"
             "   - splits output again into lines for further use,\n"
             "     or passes output as binary to another +xed.\n"
             "   - may also read and write a single file.\n"
             "\n"
             );
      else
      printx("<help>$sfk ... +xex /from/ [/from2/]\n"
             "\n"
             "   a stream text filter using SFK Simple Expressions.\n"
             "\n"
             "   - takes text stream input from a previous command\n"
             "     or a single file.\n"
             "   - joins all lines into one large block that can be\n"
             "     searched in complete.\n"
             "   - splits output again into lines for further use,\n"
             "     or passes output as binary to +xed\n"
             "\n"
             );
      printx("   xed/xex is designed to post process small to medium sized\n"
             "   data streams or files. it is not suitable to edit large files\n"
             "   beyond 100 MB, as the whole content must fit into memory\n"
             #ifdef _WIN32
             "   multiple times. use \"sfk xreplace\" to process large files.\n"
             #else
             "   multiple times.\n"
             #endif
             "\n"
             );
      printSFKMatchHelp(1, bFullHelp);
      printx("   $options\n"
             "      -case        compare case sensitive, default is nocase.\n"
             "                   for further options see: sfk help nocase\n"
             "      -bylist x    read /from/to/ patterns from a file x,\n"
             "                   supporting multiple lines per pattern.\n"
             "                   for details type: sfk rep -full\n"
             "      -bylinelist x  read /from/to/ or just /from/ patterns\n"
             "                   from a file with one pattern per line.\n"
             "                   best for searching many phrases with\n"
             "                   simple or no output reformatting.\n"
             "      -i           process text stream from standard input\n"
             "      -tolines     force output as text lines. use this\n"
             "                   if you get unexpected hex data.\n"
             "      -nomark      do not highlight changes in output\n"
             "      -nocol       no colors at all to allow more memory\n"
             "      -write       if input filename is given, rewrite file\n");
      if (bIsXex)
      printx("                   with the changed data. produces an empty\n"
             "                   file if search patterns are not found.\n");
      else
      printx("                   with the changed data.\n");
      printx("      -tofile f    write output to file f. do not use +tofile\n"
             "                   chaining as it splits data into text lines.\n"
             "      -rawterm     on output to terminal do not strip codes\n"
             "                   below 32. Null bytes are always stripped.\n"
             "      -dump[raw]   create hex dump [raw = w/o eol highlight]\n"
          // "      -blank       add extra blank line on every result output\n"
          // "                   if no totext is given (uses [all]\\n\\n then)\n"
             "      -crlf, -lf   for file headers and default totext: force\n"
             "                   crlf or lf line endings instead of default\n"
             "      -justrc      print no output, just set return code.\n" // sfk181
             "      -firsthit    use only first matching result.\n"
             );
      #ifdef WITH_REPEAT
      if (bIsXed)
      printx("      -repeat=n    with xed, repeat replace on the same data up\n"
             "                   to n times, to also replace hits produced by\n"
             "                   previous replace runs. if possible, always try\n"
             "                   to rewrite your search patterns to avoid use of\n"
             "                   this option, as it is slower to change the whole\n"
             "                   data over and over.\n"
             );
      #endif // WITH_REPEAT
      printx("\n"
             "   $chaining I/O support\n"
             "      $extract ... +xed<def>   supports binary data transfer.\n"
             "      $xed ... +xed<def>       supports binary data transfer.\n"
             "      In all other cases like xed ... +filter data is passed\n"
             "      as text lines without zero bytes and up to 4000 chars\n"
             "      per line. Binary transfer needs four times free memory\n"
             "      available then the actual number of bytes passed.\n"
             "\n"
             "   $unexpected hex data with xed chaining\n"
             "      if you use xed and get an unexpected hex output\n"
             "      like 746573746... it means a following command\n"
             "      cannot handle stream data. use option -tolines then.\n"
             "\n");
      printx("   $unexpected line breaks with +tofile\n"
             "      happen if lines are longer then %d chars.\n"
             "         use -tofile instead.\n"
             "      happen if data contains carriage return chars.\n"
             "         add \"/\\r//\" to remove them.\n"
             "\n", (int)MAX_LINE_LEN);
      printx("   $see also\n"
             "      #sfk swap<def>     change single line character order\n"
             "\n");
      printx("   $web access support\n"
             "      extracting the head section from a web page can be done like:\n"
             "      #sfk xex http://192.168.1.100/ \"_\\<head>**</head>_\"\n"
             "      #sfk xex http://.100/ \"_\\<head>**</head>_\"\n"
             "      #sfk web .100 +xex \"_\\<head>**</head>_\"\n"
             "\n");
      printx("   $archive file reading\n"
             "      xed may directly read archive file entries like\n"
             "      src.zip\\\\sub1.bz2\\\\sub2.tar.gz. for details and\n"
             "      limitations type \"sfk help xe\".\n"
             "\n");
      printBewareLean();
      printx("   $unexpected repeat replace behaviour\n"
             "      depending on the input data and search/replace expressions,\n"
             "      it can happen that running the same replace multiple times\n"
             "      on the same stream produces further hits that didn't exist\n"
             "      in the first run. read the sfk replace extended help text\n"
             "      by \"sfk replace -full\" for details.\n"
             "\n");
      printx("   $quoted multi line parameters are supported in scripts\n" // xed
             "      using full trim. type \"sfk script\" for details.\n"
             "\n");
      printx("   $return codes for batch files\n"
             "      0 = no matches, 1 = matches found, >1 = major error occurred.\n"
             "      see also \"sfk help opt\" on how to influence error processing.\n"
             "\n");
      printAboutBracketExamples();
      webref(pszCmd);
      printx("   $more in the SFK Book\n"
             "      the #SFK Book<def> contains a 60 page tutorial, including\n"
             "      detailed xed examples with input, script and output.\n"
             "      type \"#sfk book<def>\" for details.\n"
             "\n"
             );
      printx("   $examples\n");
      if (bIsXex)
      printx("      Note: also see \"sfk xed\" for further examples.\n");
      else
      printx("      Note: also see \"sfk xex\" for further examples.\n");
      if (bIsXed)
      printx("      #sfk xed in.txt \"/foo*bar/goo/\" -tofile out.txt\n"
             "         read from file in.txt, replace \"foo\" and \"bar\" with\n"
             "         up to 4000 characters inbetween, in the same line,\n"
             "         by the word \"goo\". write output to a file out.txt.\n"
             "      #sfk xed in.txt \"/foo*bar/goo/\" -write\n"
             "         same as above, but replace within file in.txt\n" 
             "      #sfk xed in.html \"/<!--**-->//\" -tofile out.html\n"
             "         remove all remark blocks starting with \"<!--\" and\n"
             "         ending with \"-->\", across any number of lines,\n"
             "         with up to 4000 bytes, from the HTML code.\n");
      if (bIsXex)
      printx("      #sfk xex in.txt \"_foo*bar_[part2]\\n_\"\n"
             "         extract any text found within the same line between\n"
             "         foo and bar, using \"_\" as separator character instead\n"
             "         of \"/\". you may leave out the third \"_\" to get\n"
             "         an info text listing part numbers.\n"
             "      #sfk xex in.txt \"_\\qfoo\\q[.100 bytes]\\qbar\\q_[all]\\n_\"\n"
             "         extract any text starting with \"foo\" enclosed by double\n"
             "         quotes, then having up to 100 bytes (including CR or LF,\n"
             "         i.e. across multiple text lines), then ending with bar\n"
             "         enclosed by double quotes, and print all parts.\n"
             "      #sfk xex in.cpp \"/printf([bytes]);/[all]\\n/\"\n"
             "       #+xed \"/);[eol]/[all]/\" \"/[eol][.100 bytes of \\x20]/ /\"\n"
             "         collect all (multi line) printf statements from a text\n"
             "         and reformat them as one statement per line. notice\n"
             "         that \"/);[eol]/[all]/\" is a cover pattern, meaning\n"
             "         it does not change anything, but keeps line endings\n"
             "         after \");\" from being changed by other patterns. [1]\n"
             );
      if (bIsXex)
      printx("      #sfk xex in.xml \"_<row>[xwhite]<artist>*</[bytes]<album>*</\n"
             "       #[bytes]<track>*</_[part4]\\t[part8]\\t[part12]\\n_\"\n"
             "         if in.xml contains simple xml data like:\n"
             "            <row><artist>foo</artist><album>bar</album>\n"
             "            <track>foobar</track></row>\n"
             "         then reformat this to tab separated csv data. [2]\n"
             "      #sfk xex in.csv \"_[lstart]*\\t*\\t*_<row>\\n <artist>[part2]\n"
             "       #</artist>\\n <album>[part4]</album>\\n <track>[part6]</track>\\n\n"
             "       #</row>\\n_\"\n"
             "         if in.csv contains tab separated data like:\n"
             "            #artistname{TAB}albumname{TAB}trackname\n"
             "         then reformat this to xml data. [3]\n");
      if (bIsXex)
      printx("      #dir | sfk xex -i -bylist dirtags.txt\n"
             "         reformat windows 'dir' command output like:\n"
             "           05.12.2013  19:17  <DIR>      myproj\n"
             "           28.01.2010  22:08         197 readme.txt\n"
             "         using a bylist file dirtags.txt like:\n"
             "           /??.??.????[white]??:??[white]<dir>[white]*\n"
             "           /DIR : [part13]\\n/.\n"
             "           /??.??.????[white]??:??[white][digit][* not ( )][white]*\n"
             "           /file: [part14]\\n/.\n"
             "         producing output:\n"
             "           DIR : myproj\n"
             "           file: readme.txt\n");
      if (bIsXex)
      printx("      #sfk xex in.hpp \"/bool[xwhite]bCl*;/\" \"/int[xwhite]iCl*;/\"\n"
             "         extract variable declarations like \"bool bClDone;\"\n"
             "         or \"int iClCounter;\" from source code, including\n"
             "         statements across multiple lines.\n"
             "      #sfk xex in.html \"_\\<head>**</head>_\"\n"
             "         extract head section from an html. notice that \"_\" is\n"
             "         used as the separator, as \"/\" is part of the text.\n"
             "      #sfk xex in.txt \"/[lstart][4 chars][15 chars][15 chars]*/\n"
             "       #[part2]\\t[part3]\\t[part4]\\n/\"\n"
             "       #+xed \"/[white][char of (\\t\\r\\n)]/[part2]/\" +tabtocsv\n"
             "         extract from fixed column data like below: [4]\n"
             "            7936JAMES FOO      ATLANTA        20140129\n"
             "         the first three columns as comma separated data like\n"
             "            7936,JAMES FOO,ATLANTA\n");
      if (bIsXed)
      printx("      #sfk xed in.txt /foo12/foo34/ /foo34/foo12/ -tofile out.txt\n"
             "         swaps foo12 and foo34. with xed, replaced text is not\n"
             "         replaced again by further patterns in the same command.\n"
             "      #sfk xed in.dat -dump\n"
             "       #\"/\\x66\\x6f\\x6f[0.100 bytes]\\x62\\x61\\x72/---/\"\n"
             "         replace binary data starting with bytes 0x66, 0x6f, 0x6f,\n"
             "         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween\n"
             "         by \"---\" and show a hex dump of the output data. [5]\n"
             "         add -tofile out.dat to write the output data to a file.\n"
             "      #sfk xed in.csv \"/*\\t*\\t*Genway Rd*/[parts 1,2,5,6,7,2,3]/\"\n"
             "         a tab separated CSV file with name, road, city like\n"
             "           Bemond Furn. Ltd    147 Elney Rd      Hertford NY 83058\n"
             "           Candale Design Ltd  Seattle KS 51028  868 Genway Rd\n"
             "           Betree Furn. Ltd    311 Napton Rd     Portland NC 97702\n"
             "         contains wrong records with \"Genway Rd\" in the 3rd column.\n"
             "         fix only these records by swapping column 2 and 3.\n"
             "         part 2 is just a tab character, used twice in output.\n");
      #ifdef SFK_LOR
      if (bIsXed)
      printx("      #sfk xed in.txt \"/\\r//\" +xed \"_[lstart]\\\\* [bytes]\n"
             "       #[keep]\\n\\\\* [ortext]\\n\\n_<li>[part3]</li>_\"\n"
             "         change a plain text enumeration like    [6]  \n"
             "            * first item is\n"
             "              a double line text\n"
             "            * second\n"
             "            * third\n"
             "\n"
             "         followed by an empty line to HTML code like\n"
             "            <li>first item is\n"
             "                a double line text</li>\n"
             "            <li>second</li>\n"
             "            <li>third</li>\n"
             "         things to consider:\n"
             "         - each enum paragraph ends at another line\n"
             "           starting with #*<def> or at an empty line #\\n\\n<def>\n"
             "         - windows text files use #\\r\\n<def> line endings,\n"
             "           so to allow a convenient #\\n\\n<def> search for\n"
             "           empty lines use #/\\r//<def> first. this must be\n"
             "           done as a separate +xed, otherwise the edited\n"
             "           line ends are skipped in further searches.\n"
             "         - we cannot search the line ends by #[eol]<def>\n"
             "           as #[ortext]<def> requires pure literals like #\\n<def>.\n"
             "         - the #[keep]<def> tells to search until #\\n*<def> but\n"
             "           not to consume this, i.e. further searches\n"
             "           can re-find and replace it as #[lstart]*<def>\n"
             );
      #endif // SFK_LOR
      if (bIsXex)
      printx("      #sfk xex in.txt \"/rel: [02 digits].[02 digits].[04 digits]\n"
             "       #/[setvar date][parts 2,3,4,5,6][endvar]/\" +getvar\n"
             "         searches a phrase like \"rel: 03.09.2016\" within in.txt\n"
             "         and stores it as an sfk variable \"date\". the +getvar\n"
             "         prints all defined variables with their content. [7]\n");
      if (bIsXed)
      printx("      #sfk version -own +filter -stabform \"<run>col5\" +setvar ver\n"
             "       #+then xed info.xml \"=<program_version>**</program_version>\n"
             "       #=[part1][getvar ver][part3]=\"\n"
             "         get the version number from sfk, store it in an sfk\n"
             "         variable \"var\" and fill this into info.xml by changing\n"
             "         the text within the program_version tag. because both /\n"
             "         and _ chars are used in the xml data we use another\n"
             "         delimiter character \"=\".   [8]  \n");
      if (bIsXex)
      printx("      #sfk xex in.xml \"_<zone>**<id>*</id>_[part\"\n"
             "         type this incomplete command to get part number infos.\n"
             "         then complete the command like:\n"
             "      #sfk xex in.xml \"_<zone>**<id>*</id>_[part4]\\n_\" +filt -line=3\n"
             "       #+setvar zoneid +echo -var \".100/start.php?zone=##(zoneid)\"\n"
             "         from an xml file like\n"
             "            <zone><id>3</id></zone><zone><id>1</id></zone>\n"
             "            <zone><id>8</id></zone><zone><id>2</id></zone>\n"
             "         get the 3rd id and create an http URL using echo.\n"
             "         add +tweb to execute the web request. [9]\n"
             );
      if (bIsXed)
      printx("      #sfk xed in.txt \"/[eol]/, /\" +xed \"/[60 chars]*, /[all]\\n/\"\n"
             "         if in.txt contains only one short word per line\n"
             "         reformat this as a comma separated text using\n"
             "         at least 60 characters per line.\n"
             "      #sfk xed in.txt \"/" "*[eol]/\\q[part1]\\q, /\"\n"
             "       #+xed \"/[60 chars]*, /[all]\\n/\"\n"
             "         same as above, but surrounding words by quotes.\n"
             );
      printx("      #sfk xex foo.h +setvar a +then xed bar.c\n"
             "       #\"/[lstart]##include \\qfoo.h\\q*[eol]/[getvar a]/\"\n"
             "         replace a text line: ##include \"foo.h\"\n"
             "         within file bar.c by the file content of foo.h\n"
             );
      if (bIsXex)
      printx("      #sfk -var setvar a=\"foo bar\" +echo -pure \"##(a)\"\n"
             "       #+xex -justrc \"_foo_\" +if \"rc=1\" tell \"got foo\"\n"
             "         check if variable a contains 'foo' by xex.\n"
             "         can be extended to check for multiple, flexible\n"
             "         expression patterns in parallel.\n"
             "      #sfk -var setvar a=\"foo bar\"\n"
             "       #+if \"##(contains(a,'foo')) = 1\" tell \"got foo\"\n"
             "         check if variable a contains 'foo' directly.\n"
             "         fast but only one static text pattern.\n"
             "         for details, type: sfk help var\n"
             "      #sfk xex in.xml \"/[skip]<[chars not >]>/\" /work/\n"
             "         search 'work' in text data of in.xml but\n"
             "         not in tag names like <workbook>\n"
             );
      printx("      #sfk echo aabbccdd +xed \"/[2 chars][2 chars]\n"
             "       #[2 chars][2 chars]/[parts 4,3,2,1]/\"\n"
             "         produces ddccbbaa, i.e. it swaps 4 blocks of\n"
             "         2 chars each. (little endian conversion)\n"
             );
      ehelp;

      sfkarg;

      // Note: a -callpermatch label cannot work as the
      // SFKMatch design massively uses statics.
      // A label called by permatch using xed again
      // would realloc buffers, reset states, and reset cs.*,
      // causing chaos in the upper xed loop.

      CommandScope ocmd(pszCmd);

      lRC = 0; // fix sfk189

      SFKMatch *apExp = 0;
      int   iExp  = 0;
      int   nstate = 0;
      bool  bstdin = 0;
      bool  bHexDump = 0;
      bool  bIncomplete = 0;
      bool  bReWrite = 0;
      char *pszRepFile = 0;
      char *pszInFile = 0;
      int   iShowPreState = 0;

      int  nMaxExp   = argc + 10; // approx.
      char cHighAttr = 'a';   // nGlblRepColor
      char cCoverAttr= 'i';   // nGlblHitColor

      cs.xpat = 1;

      cs.sim = 0;

      cs.rawterm     = 0;
      cs.placeholder = 0;

      cs.execweb     = 1; // xex

      if (bIsXex)
      {
         cs.extract = 1;
         cHighAttr = '\0';
      }

      SFKMatch::setOutFNCallback(cbSFKMatchOutFN); // xed

      char szDefaultTo[100];
      szDefaultTo[0] = '\0';

      int iChainNext = 0;
      int iStart=iDir;
      for (int ipass=0; ipass<2; ipass++)
      {
         if (ipass==1)
            copySFKMatchOptions(); // xed sfk190 moved here

       for (iDir=iStart; iDir<argc; iDir++)
       {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-mark", &pszParm)) {
            if (!pszParm) return 9;
            cHighAttr = *pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-cover", &pszParm)) {
            if (!pszParm) return 9;
            cCoverAttr = *pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-bylist", &pszParm)) {
            if (!pszParm) return 9;
            pszRepFile = pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-bylinelist", &pszParm)) {
            if (!pszParm) return 9;
            pszRepFile = pszParm;
            cs.fixedbylist = 1;
            continue;
         }
         if (!strcmp(pszArg, "-nomark")) {
            cHighAttr = '\0';
            continue;
         }
         if (!strcmp(argx[iDir], "-text")) {
            nstate = 0;
            continue;
         }
         if (strBegins(argx[iDir], "-dump")) {
            bHexDump = 1;
            if (!strcmp(argx[iDir], "-dumpraw"))
               cs.leattr = 0;
            else
               cs.leattr = 'e';
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-fill", &pszParm)) {
            if (!pszParm) return 9;
            cs.placeholder = *pszParm;
            continue;
         }
         if (!strcmp(argx[iDir], "-rawterm")) {
            cs.rawterm = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-write"))
            { bReWrite = 1; continue; }
         if (strBegins(argx[iDir], "-show")) {
            char *psz = argx[iDir]+5;
            int iwhat = 0;
            if (strBegins(psz, "part"))  iwhat |= 1;
            if (strBegins(psz, "best"))  iwhat |= 2;
            if (strBegins(psz, "list"))  iwhat |= 4;
            if (strBegins(psz, "all" ))  iwhat |= 7;
            if (iwhat & 1) {
               cs.showpre = 1;
               iShowPreState = 1;
            }
            if (iwhat & 2)
               cs.showpost = 1;
            if (iwhat & 4)
               cs.showlist = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-blank")) { // deprecated since 173
            sprintf(szDefaultTo, "[all]%s%s", cs.szeol, cs.szeol);
            continue;
         }
         #ifdef WITH_REPEAT
         if (bIsXed && haveParmOption(argx, argc, iDir, "-repeat", &pszParm)) {
            if (!pszParm) return 9;
            if (!(cs.reprep = atoi(pszParm)))
               return 9+perr("supply -repeat=n or repeat n with a non zero value.");
            continue;
         }
         #endif
         if (!strcmp(argx[iDir], "-i")) {
            bstdin = 1;
            continue;
         }
         if (!strcmp(argx[iDir], "-tolines")) { // sfk193 xed
            cs.collines = 1;
            continue;
         }

         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;

         if (!ipass)
            continue;

         // process non-option keywords:
         if (!bstdin && !chain.usedata && !pszInFile) {
            pszInFile = pszArg;
            continue;
         }

         if (iShowPreState==1) {
            iShowPreState = 2;
            printx("$Pat.  Range  MaxOut Memory FromText\n");
         }

         if (nstate) {
            // within from=to of a define
            strcopy(szLineBuf, pszArg);
            char *pszf = szLineBuf;
            char *pszt = strchr(pszf, '=');
            if (!pszt) return 9+perr("missing '=' on -define %s", szLineBuf);
            *pszt++ = '\0';
            if (SFKMatch::define(pszf,pszt)) return 9+perr("cannot use -define %s", szLineBuf);
            continue;
         }

         if (pszArg[0] == 0) continue; // sfk193 empty pattern

         // e.g. /foo*bar/[all]/
         // TODO: use reperr
         if (strlen(pszArg) < 3)
            return 9+perr("pattern too short: %s\n", pszArg);

         if (iGlblInScript) // then pszArg is writeable
            fixMultiLineParm(pszArg, 't'); // xed, xex

         strcopy(szLineBuf, pszArg);

         char cLimit = szLineBuf[0];
         char *pszfs = szLineBuf+1;
         char *pszfe = pszfs;
         while (*pszfe!=0 && *pszfe!=cLimit)
            pszfe++;
         if (!*pszfe) {
            perr("missing end of from part: %s\n", pszArg);
            if (chain.usedata) // sfk1852
               pinf("if %s is a filename use +then %s\n", pszArg, pszCmd);
            return 9;
         }

         *pszfe++ = '\0';
         char *pszts = pszfe;
         char *pszte = pszts;
         while (*pszte!=0 && *pszte!=cLimit)
            pszte++;
         if (!*pszte)
         {
            if (cs.extract!=0 && pszte==pszts) {
               // this must be done HERE.
               if (!szDefaultTo[0])
                  sprintf(szDefaultTo, "[all]%s", cs.szeol);
               pszts = szDefaultTo;
            } else {
               bIncomplete = 1;
               if (!cs.showpre) {
                  cs.showpre = 1;
                  printx("$[/.../to/ part(s) incomplete, showing info:]\n"); // xed.parm
                  //      12345 123456 123456 123456
                  printx("$Pat.  Range  MaxOut Memory FromText\n");
               }
            }
         } else {
            *pszte++ = '\0';
         }

         if (!apExp) {
            if (!(apExp = new SFKMatch[nMaxExp]))
               return 9+perr("out of memory\n");
         }

         int iSubRC = apExp[iExp].init(pszfs,pszts,SFKMATCH_WITHATTRIB);

         if (iSubRC < 9 && cs.showpre != 0)
         {
            printf("%05d %06d %06d %06d ",
               iExp+1,
               apExp[iExp].objectFromRange(),
               apExp[iExp].objectToRange(),
               apExp[iExp].objectMemory());
            setTextColor(nGlblExampColor);
            printf("%s\n",(char*)SFKMatch::aClFromCopy);
            setTextColor(-1);
            printf("                     parts %s\n",
               apExp[iExp].recentPartInfo());
            printx("                     <time>prios %s\n",
               apExp[iExp].recentPrioInfo());
         }

         if (iSubRC)
            return 9;

         iExp++;
       }
      }

      if (bReWrite && !pszInFile) {
         perr("-write requires single file reading.\n");
         pinf("e.g. sfk xed in.txt -write\n");
         return 9;
      }

      cs.sim = !cs.yes;

      if (bReWrite && bIsXex && cs.sim)
         pinf("xex -write may cause massive changes.\n");

      // if -bylist is loaded, text has a scope until this
      // commands end, to keep pattern text for later info output.
      char *pszRepList = 0;
      CharAutoDelPP odel(&pszRepList);

      if (pszRepFile)
      {
         if (apExp || iExp)
            return 9+perr("cannot combine patterns on command line with -bylist file. (2)\n");

         if (!(pszRepList = loadRepList(pszRepFile)))
            return 9+perr("unable to load -bylist file \"%s\"\n",pszRepFile);

         if (iShowPreState==1) {
            iShowPreState = 2;
            printx("$Pat.  Range  MaxOut Memory FromText\n");
         }

         int nLines = 0;
         char *psz1 = pszRepList;
         for (; *psz1; psz1++) if (*psz1 == '\n') nLines++;
         nLines++; // ALWAYS add one line in case last one has no LF.
         int nMaxExp = nLines + 10; // max. array entries with tolerance

         if (!(apExp = new SFKMatch[nMaxExp]))
            return 9+perr("out of memory\n");

         bool bHaveDiffLen = 0;
         bool bVarMode     = 0;
 
         int nstate = 1;
         char *psz2 = 0;
         int nLine  = 0;
         for (psz1 = pszRepList; psz1 && (*psz1); psz1=psz2)
         {
            // fetch and prepare line
            nLine++;
            psz2 = strchr(psz1, '\n');
            if (!psz2) psz2 = psz1+strlen(psz1);
            *psz2++ = '\0';
            char *psz3 = strchr(psz1, '\r');
            if (psz3) *psz3 = '\0';
            if (!*psz1) continue; // empty line
            // extract line number prefix, if any
            if (!strncmp(psz1, ":@", 2)) {
               psz1 += 2;
               nLine = atoi(psz1);
               while (isdigit(*psz1))
                  psz1++;
               if (*psz1==' ')
                  psz1++;
            }
            if (!strncmp(psz1, ":#", 2)) continue; // remark
            // process line
            if (!strcmp(psz1, ":text"))
               { nstate=1; continue; }
            else
            // if (!strcmp(psz1, ":define"))
            //    { nstate=3; continue; }
            // else
            if (!nstate || (*psz1 == ':')) {
               nGlblError=1;
               return 9+reperr("unexpected command", psz1, pszRepFile, nLine);
            }
            if (nstate==3) {
               // within from=to of a define
               char *pszf = psz1;
               char *pszt = strchr(pszf, '=');
               if (!pszt) return 9+reperr("missing '=' on define", psz1, pszRepFile, nLine);
               *pszt++ = '\0';
               if (SFKMatch::define(pszf,pszt)) return 9+reperr("cannot define", psz1, pszRepFile, nLine);
               continue;
            }
            // within expression block /from/to/
            char *pszfs = psz1; // from, start
            char cLimit = *pszfs++;
            if (!cLimit) break;
            if (!*pszfs) return 9+reperr("incomplete search pattern", psz1, pszRepFile, nLine);
            char *pszfe = strchr(pszfs, cLimit);
            if (!pszfe) return 9+reperr("incomplete search pattern", psz1, pszRepFile, nLine);
            char *pszts = pszfe+1;
            char *pszte = strchr(pszts, cLimit);
            if (!pszte) {
               // uncomplete /to/ text
               if (cs.extract) {
                  // accept /foo/ and /foo// but not /foo/any
                  if (*pszts)
                     return 9+reperr("wrong find pattern, missing delimiter", psz1, pszRepFile, nLine);
                  // empty /to/ with extract
                  pszts = szDefaultTo;
                  pszte = pszts+strlen(pszts);
               } else {
                  bIncomplete = 1;
                  if (!cs.showpre) {
                     cs.showpre = 1;
                     printx("$[/.../to/ part(s) incomplete, showing info:]\n"); // xed.list
                     printx("$Pat.  Range  MaxOut Memory FromText\n");
                  }
                  pszte = pszts;
                  *pszte = '\0';
               }
            }
            // check for garbage after closing delimiter
            if (pszte && (strlen(pszte) > 1))
               return 9+reperr("wrong pattern, check delimiters", psz1, pszRepFile, nLine);
            // pszfs is exact start of from
            // pszfe is one after end of from
            *pszfe = '\0';
            // same for pszts, pszte
            *pszte = '\0';
            // shrink \\t and the like in both expressions
            uchar *pFromBits=0,**ppFromBits=0;
            uchar *pToBits=0,**ppToBits=0;
            int nFromLen = pszfe-pszfs;
            int nToLen   = pszte-pszts;
            {
               // different source / pattern length: select variable mode
               bHaveDiffLen = 1;
               bVarMode = 1;
               cs.repDumpHalve = 1;
            }
            if (iExp >= nMaxExp) // internal, should not happen
               return 9+reperr("pattern array overflow", pszfs, pszRepFile, nLine);
            if (nstate == 1) {
               // as text
               int iSubRC = apExp[iExp].init(pszfs,pszts,SFKMATCH_WITHATTRIB);
               if (iSubRC < 9 && cs.showpre != 0)
               {
                  printx("%05d %06d %06d %06d #%s\n",
                     iExp+1,
                     apExp[iExp].objectFromRange(),
                     apExp[iExp].objectToRange(),
                     apExp[iExp].objectMemory(),
                     (char*)SFKMatch::aClFromCopy
                     );
                  printf("                     parts %s\n",
                     apExp[iExp].recentPartInfo());
                  printx("                     <time>prios %s\n",
                     apExp[iExp].recentPrioInfo());
               }
               if (iSubRC) {
                  if (iSubRC!=10)
                     reperr("invalid source or target pattern", pszfs, pszRepFile, nLine);
                  return 9;
               }
               iExp++;
            }
         }  // endfor RepList
      }

      bool bColor = cs.usecolor;

      if (cs.tomask && cs.tomaskfile && !chain.colany())
         bColor = 0;

      // copySFKMatchOptions(); // xed

      if (bIncomplete) {
         printx("$[complete all /from/to/ patterns to continue.]\n");
         bGlblEscape = 1;
         return 5;
      }
      if (cs.showpre) {
         if (cs.verbose || cs.debug)
            printx("$[remove -showparts to continue]\n");
         bGlblEscape = 1;
         return 5;
      }

      if (SFKMatch::provideBuffer())
         return 9;

      // if (cs.debug)
      //    SFKMatch::setGlobalOption(SFKMatchTrace, 3);

      uchar *pInText = 0;
      char  *pInAttr = 0;
      num    nInSize = 0;

      uchar *pOutText= 0;
      char  *pOutAttr= 0;
      num    nOutSize= 0;

      #define SFK_CLEANUP_XED                \
         if (apExp   ) delete [] apExp;      \
         if (pOutText) delete [] pOutText;   \
         if (pOutAttr) delete [] pOutAttr;   \
         if (pInText)  delete [] pInText;    \
         if (pInAttr)  delete [] pInAttr;

      // ------- collect input -------

      // for [file.*] evaluation:
      Coi oNameWrapper(pszInFile ? pszInFile : str(""), 0);
      ExecFileScope oScope(&oNameWrapper);

      if (loadInput(&pInText, &pInAttr, &nInSize, bstdin, pszInFile, 1)) {
         SFK_CLEANUP_XED;
         return 9;
      }

      if (cs.verbose)
         printf("xed uses %d input bytes: %s\n", (int)nInSize, dataAsTrace(pInText,mymin(60,nInSize)));

      if (nInSize > nGlblMemLimit)
      {
         perr("input too large, exceeds current memory limit (%d MB).\n", (int)(nGlblMemLimit/1048576));
         pinf("xed/xex is not designed for large data. you may raise the memory limit\n");
         pinf("to n mbytes by option -memlimit=n but xed may then become slow\n");
         pinf("or may even crash. if you need to process large files at high\n");
         pinf("speed then sfk xreplace is recommended.\n");
         SFK_CLEANUP_XED;
         return 9;
      }

      nOutSize = 0;

      if (bReWrite) {
         if (cs.yes) {
            cs.tomask = pszInFile;
            cs.tomaskfile = 1;
         } else {
            printx("$[simulating:]\n");
         }
      }

      // ------- search/replace -------

      num    nStart2 = getCurrentTime();

      bool   bAnyMatch=0,bAnyLocalMatch=0,bInPassMatch=0;
      int    iLocalMatches=0;

      uchar *pSrcCur=0,*pSrcMax=0,*pDstCur=0,*pDstMax=0;
      int    bStart=1, bLineStart=1, bLastRec=1;

      for (int irep=0; irep<=cs.reprep; irep++)
      {
         if (irep)
         {
            delete [] pInText;

            pInText  = pOutText;
            nInSize  = nOutSize;
            pOutText = 0;
            nOutSize = 0;

            if (pOutAttr)
               delete [] pOutAttr;
            pOutAttr = 0;
         }

         bAnyLocalMatch = 0;
         iLocalMatches  = 0;

         for (int ipass=0; ipass<2; ipass++)
         {
            pSrcCur = pInText;
            pSrcMax = pInText + nInSize;
 
            if (ipass)
            {
               if (!(pOutText = new uchar[nOutSize+100]))
                  return 9+perr("out of memory");
               if (pInAttr)
                  if (!(pOutAttr = new char[nOutSize+100]))
                     return 9+perr("out of memory");
               pDstCur = pOutText;
               pDstMax = pOutText + nOutSize;
            }
 
            bStart = 1;
            bLineStart = 1;
            bInPassMatch = 0;
 
            while (pSrcCur <= pSrcMax)
            {
               int nRemain = pSrcMax - pSrcCur;
 
               int iStepped = 0;

               if (!iExp)
               {
                  // no patterns: pass through for i/o test
                  if (pSrcCur == pSrcMax)
                     break;
                  if (ipass) {
                     *pDstCur++ = *pSrcCur++;
                     if (pInAttr && pOutAttr) // fix sfk194 xed nopat unwanted color
                        pOutAttr[pDstCur-pOutText] = pInAttr[pSrcCur-pInText];
                  } else {
                     pSrcCur++;
                     nOutSize++;
                  }
                  continue;
               }

               for (int ipat=0; ipat<iExp; ipat++)
               {
                  if (cs.useFirstHitOnly && bInPassMatch)
                     break;

                  int iMatchRC = 0;
                  int nSrcLen = nRemain;
                  if ((iMatchRC = apExp[ipat].matches(pSrcCur, nSrcLen, bStart, &bLineStart, bLastRec,
                       pInAttr ? pInAttr+(pSrcCur-pInText) : 0))) {
                     if (cs.verbose > 2)
                        printf("%d = check offset=%03d ipat=%d maxlen=%03d %c\n",
                           iMatchRC, (int)(pSrcCur-pInText), ipat, nRemain, *pSrcCur);
                     continue;
                  }

                  bool bskip = apExp[ipat].bClIsSkipPattern; // sfk193
                  bool buse = bskip ? 0 : 1; // sfk193

                  if (buse)
                  {
                     bAnyMatch = 1;
                     bAnyLocalMatch = 1;
                     bInPassMatch = 1;
                     if (ipass)
                        iLocalMatches++;
    
                     if (cs.verbose > 2)
                        printf("%d = check offset=%03d ipat=%d maxlen=%03d %c\n",
                           iMatchRC, (int)(pSrcCur-pInText), ipat, nRemain, *pSrcCur);
                  }

                  uchar *pObjOut=0;
                  int nDstLen=0,iSubRC=0;
 
                  // flags: on pass 0 variables are not set, for clean traces
                  if (!(pObjOut = apExp[ipat].renderOutput(nDstLen, iSubRC, ipass ? 0 : 1)))
                     return 9+perr("output rendering failed");

                  int iSizeDiff = nDstLen - nSrcLen;
 
                  if (buse == 1 && cs.verbose > 1)
                  {
                     char szInfoBuf1[100],szInfoBuf2[100];
                     printf("xed: pattern=%d hit at index=%d size=%+d from=\"%s\"... out=\"%s\"...\n",
                        ipat+1, (int)(pSrcCur-pInText), iSizeDiff,
                        dataAsTrace(pSrcCur,mymin(nRemain,16),szInfoBuf1,sizeof(szInfoBuf1)),
                        dataAsTrace(pObjOut,mymin(nDstLen,16),szInfoBuf2,sizeof(szInfoBuf2))
                        );
                  }
 
                  if (bskip && bIsXex)
                     { }
                  else
                  if (ipass) {
                     // replace data
                     if (pDstCur+nDstLen > pDstMax)
                        return 9+perr("xed buffer overflow (%d/%d)",(int)nDstLen,(int)(pDstMax-pDstCur));
                     memcpy(pDstCur, pObjOut, nDstLen);
                     if (pOutAttr)
                        memcpy(pOutAttr+(pDstCur-pOutText), apExp[ipat].outAttr(), nDstLen);
                     // mark replaced part?
                     if (buse && pOutAttr && cHighAttr) {
                        char cAttr = apExp[ipat].bClToTextIsCover ? cCoverAttr : cHighAttr;
                        int iOff = pDstCur-pOutText;
                        for (int i=0; i<nDstLen; i++)
                           if (pOutAttr[iOff+i]==' ')
                              pOutAttr[iOff+i] = cAttr;
                     }
                     pDstCur += nDstLen;
                  } else {
                     // just count data
                     nOutSize += nDstLen;
                  }
 
                  // on zero length hit, continue with further patterns
                  if (nSrcLen == 0)
                     continue;
 
                  iStepped += nSrcLen;
                  pSrcCur  += nSrcLen;
 
                  bStart = 0;
 
                  // restart with first pattern
                  break;
 
               }  // endfor patterns
 
               bStart = 0;
 
               if (pSrcCur == pSrcMax)
                  break;   // zero length run for [eod]

               if (!iStepped)
               {
                  if (!cs.extract) {
                     if (ipass) {
                        *pDstCur = *pSrcCur;
                        if (pInAttr && pOutAttr)
                           pOutAttr[pDstCur-pOutText] = pInAttr[pSrcCur-pInText];
                        pDstCur++;
                     } else {
                        nOutSize++;
                     }
                  }
 
                  if (*pSrcCur == '\n')
                     bLineStart = 1;
                  else
                     bLineStart = 0;

                  pSrcCur++;
               }
 
            }  // endwhile pSrcCur
 
         }  // endfor pass
 
         *pDstCur++ = '\0'; // safety

         if (cs.reprep==0 || bAnyLocalMatch==0)
            break;

         if (cs.verbose)
            pinf("replace repeat %d after %d matches\n", irep+1, iLocalMatches);
      }

      if (cs.perf)
         printf("%d msec to search/replace with %d hits\n", (int)(getCurrentTime()-nStart2), (int)iLocalMatches);

      // ------- handle output -------

      num nStart3 = getCurrentTime();

      if (bReWrite) {
         info.setStatus("write", pszInFile);
         info.setAddInfo("%5d %s", iLocalMatches, bIsXex ? "results":"changes");
         info.printLine(1<<2);
         if (cs.yes)
            dumpOutput(pOutText, pOutAttr, nOutSize, bHexDump);
      } else {
         dumpOutput(pOutText, pOutAttr, nOutSize, bHexDump);
      }

      if (cs.perf)
         printf("%d msec to handle %d output bytes\n", (int)(getCurrentTime()-nStart3), (int)nOutSize);

      // best match info
      if (cs.showpost) {
         printx("$Best pattern matches across all input data:\n");
         for (int i=0; i<iExp; i++) {
            SFKMatch *pObj = &apExp[i];
            //     "00006 000527 000318 003515 "
            printx("Pat.%02u matched $%02d<def> parts of: #%s\n", // xed
               i+1,
               pObj->iClBestMatch,
               pObj->fromText()
               );
            printx("Pat.%02u per part byte match: ", i+1);
            for (int k=0; k<pObj->iClFrom && k<pObj->iClBestMatch; k++)
               printf("%u/%u ", k+1, pObj->aiClBestData[k]);
            printf("\n");
         }
      }

      if (cs.sim && bReWrite) {
         printx("$[add -yes to really write changes.]\n");
      }

      // cleanup
      SFK_CLEANUP_XED;

      if (bAnyMatch)
         lRC = 1;

      #if 1

      // producing command
      STEP_CHAIN(iChainNext, 1); // xed sfk193 always

      #else
      if (iChainNext) {
         // producing command
         if (chain.colany()) {
            STEP_CHAIN(iChainNext, 1); // xed
         } else {
            STEP_CHAIN(iChainNext, 0); // xed
         }
      }
      #endif

      bDone = 1;
   }
 
   int iIsOLoad = 0;

   ifcmd (   !strcmp(pszCmd, "load")
          || (bGlblOffice && !strcmp(pszCmd, "oload"))
         )
   {
      #ifdef SFKOFFICE
      if (!strcmp(pszCmd, "oload"))
         iIsOLoad = 1;
      #endif // SFKOFFICE

      ifhelp (nparm < 1)
      if (iIsOLoad)
      {
      printx("<help>$sfk oload in.docx +...\n"
             "\n"
             "   load office file content as plain text,\n"
             "   for easy display or further processing.\n"
             "\n");
      printx("   $about line wrapping\n"
             "\n"
             "   - when sending to a command that expects\n"
             "     text lines like\n"
             "        $sfk oload in.xlsx +filter ...\n"
             "     then long lines or stream text will be\n"
             "     hard wrapped at %d characters.\n"
             "\n"
             "   - when sending to stream capable commands\n"
             "     like xed and xex data is not wrapped.\n"
             "\n"
             , (int)MAX_LINE_LEN);
      printx("   $options\n"
             "   -utfout    keep raw UTF-8 encoding on output, to use it\n"
             "              with further commands requiring UTF-8 data.\n"
             "   -raw       get raw xml data, for content analysis.\n"
             "              implies -utfout.\n"
             "   -subnames  with .xlsx files only: add header lines\n"
             "              with sheet subfile names.\n"
             "\n");
      printx("   $see also\n"
             "      #sfk help office<def>  supported office file types\n"
             "      #sfk xex<def>          extract phrases from text\n"
             "      #sfk ofilter<def>      get lines from office file\n"
             "\n");
      printx("   $examples\n"
             "      #sfk oload in.docx\n"
             "         display contents of a .docx word file\n"
             "      #sfk oload in.xlsx\n"
             "         display spreadsheet table data as plain text\n"
             "      #sfk oload in.xlsx +filter -+foo\n"
             "         get all lines with 'foo' from a table\n"
             "      #sfk oload in.docx +xex \"/foo**bar/\"\n"
             "         extract multi line blocks from a word file\n"
             "         starting with foo and ending with bar\n"
             "      #sfk oload in.xlsx +filt -no-empty-lines +tabtocsv\n"
             "         get records from a table, drop empty lines,\n"
             "         then convert from tabs to comma separated data.\n"
             "      #sfk oload -raw in.docx +xmlform +view\n"
             "         reformat and display xml content using dview.\n"
             );
      }
      else
      {
      printx("<help>$sfk load in.txt +...\n"
             "\n"
             "   load text or binary data for further processing\n"
             "   within a command chain.\n"
             "\n"
             "   use oload to load a single office file content\n"
             "   like .docx .xlsx .ods .odt as plain text.\n"
             "\n");
      printx("   $about line wrapping\n"
             "\n"
             "   - when sending to a command that expects\n"
             "     text lines like\n"
             "        $sfk oload in.xlsx +filter ...\n"
             "     then long lines or stream text will be\n"
             "     hard wrapped at %d characters.\n"
             "\n"
             "   - when sending to stream capable commands\n"
             "     like xed and xex data is not wrapped.\n"
             "\n"
             , (int)MAX_LINE_LEN);
      printx("   $see also\n"
             "      #sfk xex<def>     load and extract any data\n"
             "      #sfk filter<def>  load and filter text lines\n"
             "\n");
      printx("   $examples\n"
             "      #sfk -var load in.txt +setvar a +tell \"the ##(a) test\"\n"
             "         load in.txt content into variable a,\n"
             "         then use variable a in a combined string\n"
             "      #sfk load in.txt +sort\n"
             "         sort the text lines of in.txt\n"
             );
      }
      ehelp;

      sfkarg;

      #ifdef SFKOFFICE
      if (iIsOLoad == 1) {
         cs.office    = 1;
         cs.textfiles = 1;
         cs.hidezipcomment = 1; // oload
      }
      #endif // SFKOFFICE

      bool   bstdin = 0;
      char *pszFile = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (!strcmp(argx[iDir], "-i")) {
            bstdin = 1;
            continue;
         }
         if (iIsOLoad && !strcmp(pszArg, "-utfout")) // sfk1942 oload
            { cs.utfout = 1; continue; }
         if (iIsOLoad && !strcmp(pszArg, "-raw"))    // sfk1942 internal
            { cs.office = 2; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!pszFile) {
            pszFile = pszArg;
            continue;
         }
         return 9+perr("unexpected: %s\n",pszArg);
      }

      if (iIsOLoad && pszFile) {
         Coi ocoi(pszFile, 0);
         if (ocoi.isZipSubEntry()) // sfk194
            return 9+perr("oload cannot be used with nested archive contents.");
      }

      uchar *pData = 0;
      num    nSize = 0;

      if (loadInput(&pData, 0, &nSize, bstdin, pszFile, 0))
         return 9;

      dumpOutput(pData, 0, nSize, 0);

      delete [] pData;

      if (iChainNext) {
         if (chain.colany()) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "swap"))
   {
      ifhelp (argc < 3)
      printx("<help>$sfk ... +swap ...\n"
             "\n"
             "   swap single line chain text characters,\n"
             "   to make the last character the first one.\n"
             "\n"
             );
      printx("   $examples\n"
             "      #sfk echo test +swap\n"
             "         produces 'tset'\n"
             );
      ehelp;

      sfkarg;

      bool bstdin = 0;
      cs.szeol[0] = '\0';

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (!strcmp(argx[iDir], "-i")) {
            bstdin = 1;
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         return 9+perr("unexpected: %s\n",pszArg);
      }

      if (   chain.nClInBinarySize == 0
          && chain.indata->numberOfEntries() > 1)
         return 9+perr("cannot swap multiple input lines.");

      uchar *pData = 0;
      num    nSize = 0;

      if (loadInput(&pData, 0, &nSize, bstdin, 0, 0))
         return 9;

      swapchars((char*)pData, nSize);

      // dumpOutput(pData, 0, nSize, 0);
      if (chain.coldata && chain.colbinary) {
         if (chain.addBinary(pData, nSize))
            return 9;
      } else if (chain.colany()) {
         chain.addLine((char*)pData, str(""));
      } else {
         chain.print("%s", (char*)pData);
      }

      delete [] pData;

      if (iChainNext) {
         if (chain.colany()) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "testrep"))
   {
      int iTestCases = 1;
 
      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (sfkisopt(argv[iDir])) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         iTestCases = atoi(argv[iDir]);
      }
 
      printf("Running %d test cases ...\n", iTestCases);
 
      for (int i=0; i<iTestCases; i++)
      {
         printf("[%d]\r", i+1); fflush(stdout);
 
         int irc = testReplace(1);
         if (irc)
            { lRC = irc; break; }
      }
 
      printf("Done with RC=%d.\n", lRC);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "csvtotab") || !strcmp(pszCmd, "csvtab")) // +wref
   {
      ifhelp (bFullHelp || (chain.usedata == 0 && nparm < 1))
      printx("<help>$sfk csvtotab infile.csv [options]\n"
             "\n"
             "   convert csv data to plain tab separated.\n"
             "\n"
             "   $default input/output format\n"
             "   - input fields are separated by a comma \",\"\n"
             "   - input fields can be surrounded by double quotes \"\n"
             "     and may contain escaped double quotes as \"\"\n"
             "   - output fields are separated by TAB characters\n"
             "   - surrounding quotes are stripped, and escaped\n"
             "     quotes are reduced to normal quotes\n"
             "   - if input contains any TABs they are changed to\n"
             "     a single blank character\n"
             "   - input fields cannot contain line breaks\n"
             "\n"
             "   $options\n"
             "     -tofile x     write output to file x\n"
             "     -insep=\"x\"    set input separator to character x\n"
             "                   e.g. ; or \\t\n"
             "     -outsep=\"x\"   change output separator\n"
             "     -quote=\"x\"    change quote character, e.g. \\x27\n"
             "                   uses single quote.\n"
             "     -tabrep=\"x\"   change tab replacement character\n"
             "\n"
             "   $see also\n"
             "     #sfk ascii<def>     list of ASCII codes for characters\n"
             "     #sfk tabtocsv<def>  further conversion examples\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "     #sfk csvtotab in.csv -tofile out.txt\n"
             "        convert to tab separated out.txt\n"
             "     #sfk filter in.csv -+foo +csvtotab\n"
             "        convert only lines with word \"foo\"\n"
             "     #sfk csvtotab in.csv +filter \"-<not>[warning]\"\n"
             "        drop all lines with [warning] from output\n"
             #ifdef _WIN32
             "     #sfk csvtotab in.csv +view -tab 10\n"
             "        view in.csv in Depeche View for convenient browse\n"
             "        and search of contents, with a tab size of 10.\n"
             "        Within DView press Ctrl+Tab to change tab size\n"
             "        in small steps, or Ctrl+Shift+Tab for large tabs.\n"
             #endif
             );
      ehelp;

      sfkarg;

      char *pszInFile = 0;
      char *pszOutFile = 0;
      char  szInSep[20];
      char  szOutSep[20];
      char  szQuote[20];
      char  szOutEsc[20];

      strcpy(szInSep , ",");
      strcpy(szOutSep, "\t");
      strcpy(szQuote , "\"");
      strcpy(szOutEsc, " ");

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-insep", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szInSep, sizeof(szInSep)) != 1) {
               perr("invalid or too long input separator: %s", pszParm);
               if (pszParm[0]=='\"' && pszParm[1])
                  pinf("try \"-insep=%c\" or -spat -insep=\\x%02x\n", pszParm[1], pszParm[1]);
               pinf("use only a single char like ; or a valid slash pattern like \\t\n");
               return 9;
            }
            continue;
         }
         else
         if (haveParmOption(argx, argc, iDir, "-outsep", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szOutSep, sizeof(szOutSep)) != 1) {
               perr("invalid or too long output separator: %s", pszParm);
               return 9;
            }
            continue;
         }
         else
         if (haveParmOption(argx, argc, iDir, "-quote", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szQuote, sizeof(szQuote)) != 1) {
               perr("invalid quote: %s", pszParm);
               return 9;
            }
            continue;
         }
         else
         if (haveParmOption(argx, argc, iDir, "-tabrep", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szOutEsc, sizeof(szOutEsc)) != 1) {
               perr("invalid tab replacement: %s", pszParm);
               return 9;
            }
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszInFile) {
            pszInFile = pszArg;
            continue;
         }
         return 9+pbad(pszCmd, pszArg);
      }

      if (cs.tomask && cs.tomaskfile)
         pszOutFile = cs.tomask;

      cs.cinsep     = szInSep[0];
      cs.coutsep    = szOutSep[0];
      cs.cquote     = szQuote[0];
      cs.coutsepesc = szOutEsc[0];

      if (pszInFile) {
         Coi ocoi(pszInFile, 0);
         lRC = execCsvConv(0, &ocoi, 0, 0, -1, pszOutFile);
      } else {
         lRC = execCsvConv(0, 0, stdin, chain.usedata ? chain.indata : 0, -1, pszOutFile);
      }

      if (iChainNext) {
         // producing command
         STEP_CHAIN(iChainNext, chain.coldata); // sfk181 csvtotab always
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "tabtocsv") || !strcmp(pszCmd, "tabcsv")) // +wref
   {
      ifhelp (bFullHelp || (chain.usedata == 0 && nparm < 1))
      printx("<help>$sfk tabtocsv infile.txt [options]\n"
             "\n"
             "   convert plain tab separated data to csv.\n"
             "\n"
             "   $default input/output format\n"
             "   - input fields are separated by a tab and should\n"
             "     not be surrounded by quotes, as these are not\n"
             "     interpreted. input fields themselves cannot\n"
             "     contain TAB characters.\n"
             "   - output fields are separated by comma \",\"\n"
             "   - output fields are surrounded by quotes \"\n"
             "     if input contains a comma or quote\n"
             "   - if input contains quotes it is escaped as \"\"\n"
             "\n"
             "   $options\n"
             "     -tofile x     write output to file x\n"
             "     -quotetext    surround all text by quotes\n"
             "     -quoteall     surround all output by quotes\n"
             "     -outsep=\"x\"   change output separator to\n"
             "                   character x, e.g. ; or \\t\n"
             "     -quote=\"x\"    change quote character\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "     #sfk tabtocsv in.txt -tofile out.csv\n"
             "        convert tab separated to csv in default format\n"
             "     #sfk csvtotab -quote=\"\\x27\" -insep=\";\" in.csv -tofile tmp.tsv\n"
             "        reads a CSV with input fields separated by semicolon and\n"
             "        surrounded by single quotes ' with ASCII code hex 27\n"
             "     #sfk tabtocsv -outsep=\";\" -quote=\"\\x27\" tmp.tsv -tofile out.csv\n"
             "        converts tab separated to an output CSV, with output fields\n"
             "        separated by semicolon and surrounded by single quotes\n"
             );
      ehelp;

      sfkarg;

      char *pszInFile  = 0;
      char *pszOutFile = 0;
      char  szInSep[20];
      char  szOutSep[20];
      char  szQuote[20];
      char  szOutEsc[20];

      strcpy(szInSep , "\t");
      strcpy(szOutSep, ",");
      strcpy(szQuote , "\"");
      strcpy(szOutEsc, " ");

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-insep", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szInSep, sizeof(szInSep)) != 1) {
               perr("invalid or too long input separator: %s", pszParm);
               pinf("use only a single char like ; or a valid slash pattern like \\t\n");
               return 9;
            }
            continue;
         }
         else
         if (haveParmOption(argx, argc, iDir, "-outsep", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szOutSep, sizeof(szOutSep)) != 1) {
               perr("invalid or too long output separator: %s", pszParm);
               return 9;
            }
            continue;
         }
         else
         if (haveParmOption(argx, argc, iDir, "-quote", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szQuote, sizeof(szQuote)) != 1) {
               perr("invalid quote: %s", pszParm);
               return 9;
            }
            continue;
         }
         else
         if (!strcmp(pszArg, "-quotetext")) {
            cs.quotetext = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-quoteall")) {
            cs.quoteall = 1;
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszInFile) {
            pszInFile = pszArg;
            continue;
         }
         return 9+pbad(pszCmd, pszArg);
      }

      if (cs.tomask && cs.tomaskfile)
         pszOutFile = cs.tomask;

      cs.cinsep     = szInSep[0];
      cs.coutsep    = szOutSep[0];
      cs.cquote     = szQuote[0];
      cs.coutsepesc = szOutEsc[0];

      if (pszInFile) {
         Coi ocoi(pszInFile, 0);
         lRC = execCsvConv(1, &ocoi, 0, 0, -1, pszOutFile);
      } else {
         lRC = execCsvConv(1, 0, stdin, chain.usedata ? chain.indata : 0, -1, pszOutFile);
      }

      if (iChainNext) {
         // producing command
         STEP_CHAIN(iChainNext, chain.coldata); // sfk181 tabtocsv always
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "touch")) // +wref
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk touch [-date n] [opts] file\n"
             "$sfk touch -from srcfile [opts] file\n"
             "\n"
             "   change date and time of file(s) or directories.\n"
             "   if just a file- or directory name is given then\n"
             "   the access and modification time is set to the\n"
             "   current time. with SFK for windows, creation time\n"
             "   is not changed by default.\n"
             "\n"
             "   $options\n"
             "      -force   create empty file if it doesn't exist\n"
             "      -date n  set file date/time to this value\n"
             "               given like YYYYMMDDhhmmss,\n"
             "               for example 20130412063015.\n"
             #ifdef _WIN32
             "               year 2038 and further may work only\n"
             "               with newer file systems like NTFS.\n"
             "               NTFS second fractions are set to 0\n"
             "               unless option -nsec is given.\n"
             "      -nsec n  specify nanoseconds part for -date\n"
             "               as a 9 digit number. the last 2 digits\n"
             "               are not used and should be 00.\n"
             #endif
             "      -from f  copy file date/time from another file\n"
             "      -atime   change only access time\n"
             "      -mtime   change only modification time\n"
             #ifdef _WIN32
             "      -ctime   change only creation time (Windows only)\n"
          // "      -amtime  change access and modification time\n"
             "      -full    set or copy atime, mtime and ctime\n"
             "      -copyctom  do not use current time but copy every\n"
             "               file's creation time into mod. time.\n"
             "               may also use -copymtoc, -copyctoa etc.\n"
             #endif
             "\n"
             "   $command chaining support\n"
             "      multiple files can be touched through chaining:\n"
             "      #sfk select mydir .ext +touch ...\n"
             "\n"
             "   $see also\n"
             "      #sfk filetime<def>   print times of a file\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk touch foo.txt\n"
             "         sets access and modification time of foo.txt\n"
             "         to the current time.\n"
             "\n"
             "      #sfk touch mydir\n"
             "         touch only mydir, without any contents,\n"
             "         e.g. mydir<sla>file1.txt stays unchanged.\n"
             "\n"
             "      #sfk touch -date 20130412063015 foo.txt\n"
             "         sets access and modification time of foo.txt\n"
             "         to 12-Apr-2013 at 06:30:15.\n"
             "\n"
             "      #sfk touch -from src.txt myfile.txt\n"
             "         reads access and modification time of src.txt\n"
             "         and copies it to myfile.txt\n"
             "\n"
             "      #sfk select mydir .cpp .hpp +touch\n"
             "         touch all .cpp and .hpp files from mydir.\n"
             "\n"
             "      #sfk sel -withdirs mydir +touch\n"
             "         touch all files and sub folders of mydir\n"
             "         and mydir itself.\n"
             #ifdef _WIN32
             "\n"
             "      #sfk select -justdirs mydir +touch -copyctom\n"
             "         for folder mydir itself, and all sub folders\n"
             "         therein, copy creation time to modification\n"
             "         time, leaving files unchanged. to view times\n"
             "         use: sfk filetime -full -justdirs mydir\n"
             #endif
             );
      ehelp;

      sfkarg;

      char *pszDate = 0;
      char *pszDst  = 0;
      char *pszFrom = 0;
      bool  bATime  = 1;
      bool  bMTime  = 1;
      bool  bCTime  = 0; // windows only
      num   nNanoSec= 0;
      bool  bMake   = 0;
      int   copySrc = 0;
      int   copyDst = 0;
      bool  bTouchSelf = 0;
      bool  bUTC    = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-date", &pszParm)) {
            if (!pszParm) return 9;
            if (pszFrom) return 9+perr("-date cannot be combined with -from\n");
            pszDate = pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-from", &pszParm)) {
            if (!pszParm) return 9;
            if (pszDate) return 9+perr("-date cannot be combined with -from\n");
            pszFrom = pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-nsec", &pszParm)) {
            if (!pszParm) return 9;
            if (strlen(pszParm) != 9)
               return 9+perr("need a 9 digits value for -nsec\n");
            nNanoSec = atonum(pszParm);
            continue;
         }
         if (!strcmp(pszArg, "-force"))
            { bMake = 1; continue; }
         if (!strcmp(pszArg, "-utc"))
            { bUTC = 1; continue; }
         if (!strcmp(pszArg, "-atime")) {
            bATime = 1;
            bMTime = 0;
            bCTime = 0;
            continue;
         }
         if (!strcmp(pszArg, "-mtime")) {
            bATime = 0;
            bMTime = 1;
            bCTime = 0;
            continue;
         }
         if (!strcmp(pszArg, "-amtime")) {
            bATime = 1;
            bMTime = 1;
            bCTime = 0;
            continue;
         }
         if (!strcmp(pszArg, "-ctime")) {
            bATime = 0;
            bMTime = 0;
            bCTime = 1;
            continue;
         }
         if (!strcmp(pszArg, "-full")) {
            bATime = 1;
            bMTime = 1;
            bCTime = 1;
            continue;
         }
         if (strBegins(pszArg, "-copy")) {
            // copyctom etc.
            pszArg += 5;
            switch (*pszArg++) {
               case 'a': copySrc = 1; break;
               case 'm': copySrc = 2; break;
               case 'c': copySrc = 3; break;
               default:
                  return 9+perr("wrong -copyxtox source given");
            }
            if (strncmp(pszArg, "to", 2))
               return 9+perr("wrong -copyxtox given");
            pszArg += 2;
            switch (*pszArg) {
               case 'a': copyDst = 1; break;
               case 'm': copyDst = 2; break;
               case 'c': copyDst = 3; break;
               default:
                  return 9+perr("wrong -copyxtox target given");
            }
            bTouchSelf = 1;
            continue;
         }
         if (sfkisopt(pszArg)) {
            // if (isDirParm(pszArg))
            //    break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszDst) {
            pszDst = pszArg;
            continue;
         }
         return 9+pbad(pszCmd, pszArg);
      }

      if (!chain.usefiles && !pszDst)
         return 9+perr("missing target filename\n");

      // int iDirNext = 0;
      // bool bAnyDirParms = 0;
      // if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext, &bAnyDirParms))) return lRC;
      // if (btest) return 0;
 
      glblTouchSrc.reset();
      mclear(glblTouchOpt);

      glblTouchOpt.iCopySrc = copySrc;
      glblTouchOpt.iCopyDst = copyDst;

      num nTmpTime = 0;

      #ifdef _WIN32
      FILETIME nWinTime; mclear(nWinTime);
      #endif
 
      if (pszFrom) {
         if (glblTouchSrc.readFrom(pszFrom))
            return 9+pferr(pszFrom, "cannot read: %s\n", pszFrom);
         #ifdef _WIN32
         glblTouchOpt.bUseWFT = glblTouchSrc.src.nHaveWFT;
         #endif
         bTouchSelf = 0;
      }
      else if (pszDate || !pszFrom) {
         if (pszDate) {
            if (timeFromString(pszDate, nTmpTime, 0, bUTC)) // local touch
               return 9;
            if (cs.debug) printf("using timestamp %s\n",numtoa(nTmpTime));
            // 20200501120101 = UTC 1588334461
            // 20200101120101 = UTC 1577880061
            bTouchSelf = 0;
         } else {
            nTmpTime = (num)getSystemTime();
         }
         if (bATime) glblTouchSrc.src.nATime = nTmpTime;
         if (bMTime) glblTouchSrc.src.nMTime = nTmpTime;
         if (bCTime) glblTouchSrc.src.nCTime = nTmpTime;
         #ifdef _WIN32
         if (makeWinFileTime(nTmpTime, nWinTime, nNanoSec)) // touch
            return 9;
         if (bATime) memcpy(&glblTouchSrc.src.ftATime, &nWinTime, sizeof(nWinTime));
         if (bMTime) memcpy(&glblTouchSrc.src.ftMTime, &nWinTime, sizeof(nWinTime));
         if (bCTime) memcpy(&glblTouchSrc.src.ftCTime, &nWinTime, sizeof(nWinTime));
         glblTouchOpt.bUseWFT = 1;
         #endif
      }
      else
         return 9+perr("missing parameters for touch\n");

      glblTouchOpt.bSelf  = bTouchSelf;
      glblTouchOpt.bATime = bATime;
      glblTouchOpt.bMTime = bMTime;
      glblTouchOpt.bCTime = bCTime;

      if (pszDst) {
         if (bMake && !fileExists(pszDst, 1)) {
            FILE *fout = fopen(pszDst, "wb");
            if (!fout)
               return 9+perr("cannot create: %s\n", pszDst);
            fclose(fout);
         }
         lRC = execTouch(pszDst, 1);
      } else {
         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         lRC = walkAllTrees(eFunc_Touch, lFiles, lDirs, nBytes);
         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");
      }

      if (iChainNext) {
         STEP_CHAIN(iChainNext, 0);
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "sysinfo"))
   {
      ifhelp (nparm >= 1 && isHelpOpt(argv[iDir]))
      printx("<help>$sfk sysinfo\n"
             "\n"
             #ifdef _WIN32
             "   show system informations like the codepage.\n"
             #else
             "   show system informations.\n"
             #endif
             "\n"
             );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
      }

      // chain.print("clib time_t  size: %u\n", sizeof(time_t));
      chain.print("sfk  time_t  size: %u\n", sizeof(mytime_t));
      chain.print("void pointer size: %u\n", sizeof(void*));
      chain.print("file fpos_t  size: %u\n", sizeof(fpos_t));

      bool bdummy=0;
      int icallstackload = submain(0,0,0,str("sfkstackloadint"),0,bdummy); // sysinfo
      chain.print("stack load / call: %d\n", icallstackload);

      #ifdef _WIN32
      sfkchars.init();
      chain.print("ANSI codepage    : %u%s\n",
         sfkchars.iclacp,
         sfkchars.bsysacp ? "":"   (fixed)"
         );
      chain.print("OEM  codepage    : %u%s\n",
         sfkchars.iclocp,
         sfkchars.bsysocp ? "":"    (fixed)"
         );
      #endif

      char *psz = getenv("SFK_CONFIG"); // sysinfo
      if (psz)
      chain.print("SFK_CONFIG       : %s\n", psz);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "ansitooem"))
   {
      char szBuf[20];
      for (uint i=0; i<256; i++) {
         uchar cansi = (uchar)i;
         szBuf[0] = (char)cansi;
         szBuf[1] = '\0';
         CharToOemA(szBuf, szBuf+10);
         uchar coem = szBuf[10];
         printf("0x%02lX,0x%02lX, ", (uint)cansi, (uint)coem);
      }
      return 0;
   }
   #endif

   if (!strcmp(pszCmd, "fileage"))
   {
      if (argc < 3) return 9;
      char *pszFile = argv[2];
      num nage = getFileAge(pszFile);
      printf("%s sec, %d days\n", numtoa(nage), (int)(nage / (24 * 3600)));
      return 0;
   }

   #ifdef _WIN32
   if (!strcmp(pszCmd, "clipinfo")) // internal
   {
      sfkarg;

      int iChainNext = 0;
      int nlocktime = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-locktime", &pszParm)) {
            if (!pszParm) return 9;
            nlocktime = atol(pszParm);
            continue;
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         return 9+perr("unknown: %s",pszArg);
      }

      if (!OpenClipboard(GetDesktopWindow())) // clipinfo
         return 5+perr("failed to open clipboard\n");

      HGLOBAL hglb = 0;
      uchar *pdata = 0;
      int    ndata = 0;
      if (IsClipboardFormatAvailable(CF_TEXT)) {
         if (hglb = GetClipboardData(CF_TEXT)) {
            char *pMem = (char*)GlobalLock(hglb);
            if (pMem) {
               printf("CF_TEXT: %.50s\n", pMem);
               printf(" as hex: %.50s\n", dataAsHex(pMem,strlen(pMem)));
            }
            GlobalUnlock(hglb);
         }
      }

      if (IsClipboardFormatAvailable(CF_UNICODETEXT)) {
         if (hglb = GetClipboardData(CF_UNICODETEXT)) {
            char *pMem = (char*)GlobalLock(hglb);
            if (pMem) {
               ushort *pwtext = (ushort *)pMem;
               printf("CF_UNI : ");
               int ilen=0;
               for (; pwtext[ilen]!=0 && ilen<10; ilen++)
                  printf("U+%04X ", pwtext[ilen]);
               printf("\n");
            }
            GlobalUnlock(hglb);
         }
      }

      if (nlocktime)
         Sleep(nlocktime);

      CloseClipboard();

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "toclip")) // +wref
   {
      ifhelp ((iDir < argc) && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?")))
      printx("<help>$sfk toclip [options|-h]<def>\n"
             "\n"
             "   copy text to clipboard.\n"
             "\n"
             "   $options\n"
             "      -noline[s]   strip linefeeds from line ends\n"
             "      -rtrim       strip whitespace at line ends\n"
             "      -ltrim       strip whitespace at line starts\n"
             "      -trim        strip whitespace around lines\n"
             /*
             "\n"
             "   $aliases\n"
             "      #sfk toclipw<def>  copy binary data as wide character\n"
             "                   unicode text into the clipboard.\n"
             "                   for help type: sfk toclipw -h\n"
             */
             "\n");
      webref("clip");
      printx("   $examples\n"
             "      #echo hello | sfk toclip -rtrim -noline\n"
             "         copy the word hello to clipboard\n"
             "\n"
             "      #sfk echo hello +toclip -noline\n"
             "         same as above, but shorter\n"
             "\n"
             "      #sfk sel mydir +toclip\n"
             "         copy a directory listing to clipboard\n"
            );
      ehelp;

      sfkarg;

      bool bnoline = 0;
      int  itrim   = 0;
      int  iDirIn  = iDir; // 2 if first command

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (!strcmp(pszArg, "-noeol") || strBegins(pszArg, "-noline"))
         {
            bnoline = 1;
            continue;
         }
         else if (!strcmp(pszArg, "-ltrim")) { itrim |= 1; continue; }
         else if (!strcmp(pszArg, "-rtrim")) { itrim |= 2; continue; }
         else if (!strcmp(pszArg, "-trim"))  { itrim |= 3; continue; }  // toclip
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break;
      }

      // calling this only for chaining support:
      int iDirNext=0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 0, &iDirNext)))
         return lRC;

      StringTable st;
      int nSize = 0;
      int neol = bnoline ? 0 : 2;

      if (chain.usedata) {
         // take text from chain
         while (!chain.indata->eod()) {
            char *psz = chain.indata->read(0);
            mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
            removeCRLF(szLineBuf);
            if (itrim)
               trimLine(szLineBuf, itrim);
            st.addEntry(szLineBuf);
            nSize += strlen(szLineBuf) + neol;
         }
      } else if (iDirIn > 2) {
         // sfk1833: do not simply block without info
         return 9+perr("+toclip requires input data from a previous command.");
      } else {
         myfgets_init();
         while (myfgets(szLineBuf, MAX_LINE_LEN, stdin))
         {
            szLineBuf[MAX_LINE_LEN] = '\0';
            removeCRLF(szLineBuf);
            if (itrim)
               trimLine(szLineBuf, itrim);
            st.addEntry(szLineBuf);
            nSize += strlen(szLineBuf) + neol;
         }
      }

      char *pszTmp = new char[nSize+1000];
      if (!pszTmp) return 9+perr("out of memory\n");
      pszTmp[0] = '\0';
      int nLines = st.numberOfEntries();
      int iout=0;
      for (int i=0; i<nLines; i++)
      {
         char *psz = st.getEntry(i, __LINE__);
         int nLen = (int)strlen(psz);
         if (iout+nLen <= nSize)
         {
            strcat(pszTmp, psz);
            if (!bnoline)
               strcat(pszTmp, "\r\n");
            iout = strlen(pszTmp);
         }
         else
            break;
      }
      putClipboard(pszTmp);
      delete [] pszTmp;

      STEP_CHAIN(iDirNext, 0); // toclip

      bDone = 1;
   }

   if (!strcmp(pszCmd, "toclipw")) // internal
   {
      ifhelp ((iDir < argc) && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?")))
      printx("<help>$sfk toclipw [-h]<def>\n"
             "\n"
             "   copy wide character text to clipboard.\n"
             "\n"
             "   requires binary data from a previous command,\n"
             "   like load or xed.\n"
             "\n"
             "   $examples\n"
             "\n"
             "      #sfk load in.txt +toclipw\n"
             "         if in.txt contains unicode wide character text\n"
             "         then this is put into the clipboard.\n"
             "\n");
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break;
      }

      // calling this only for chaining support:
      int iDirNext=0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 0, &iDirNext)))
         return lRC;

      uchar *pInText = 0;
      num    nInSize = 0;

      if (loadInput(&pInText, 0, &nInSize, 0, 0, 0))
         return 9;

      // will be UN-terminated binary data!
      // if size is unaligned last char will be dropped.

      putClipboardW((ushort*)pInText, nInSize/2);

      delete [] pInText;

      STEP_CHAIN(iDirNext, 0); // toclip

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "fromclip") || !strcmp(pszCmd, "rawclip") // +wref
          || !strcmp(pszCmd, "lclip")
          || !strcmp(pszCmd, "fromclipw") // sfk1841
         )
   {
      ifhelp ((iDir < argc) && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?")))
      printx("<help>$sfk fromclip [-wait] [-clear]<def>\n"
             "\n"
             "   dump plain text from clipboard to terminal.\n"
             "\n"
             "   $options\n"
             "      -wait         wait until plain text is available.\n"
             "      -clear        empty clipboard after use.\n"
             "      -ltrim        remove whitespace at start of lines.\n"
             "      -tofile x     write text to file x.\n"
             "      -cliptries=n  try up to n times if clipboard is locked\n"
             "         by another app. default is 6, waiting up to 500 msec.\n"
             "         this option can also be set globally.\n"
             "      -quiet        tell nothing on console if access failed\n"
             "\n"
             "   $return codes\n"
             "      rc=0 : ok got text\n"
             "      rc=1 : no text available\n"
             "      rc=2 : failed to open clipboard\n"
             "\n"
             "   $aliases\n"
             "      #sfk lclip<def>      same as #sfk fromclip -ltrim<def>\n"
             "                     to get text left side trimmed\n"
             "      #sfk rawclip<def>    same as #sfk fromclip +toclip<def>\n"
             "                     to remove unwanted formatting when copying\n"
             "                     text from a web page into a word processor.\n"
             /*
             "      #sfk fromclipw<def>  get wide character (unicode) text\n"
             "                     as binary data. add +hexdump for display.\n"
             */
             "\n");
      webref("clip");
      printx("   $examples\n"
             "      #sfk fromclip +filter -rep x/x\\x +toclip\n"
             "         change all / into \\ within the clipboard text\n"
             "\n"
             "      #sfk fromclip -wait -clear +tee toterm\n"
             "       #+tofile -append cliplog.txt +loop\n"
             "         appends every plain text change to a file cliplog.txt.\n"
             "         while doing so the clipboard cannot be used to paste\n"
             "         elsewhere as it is reset by -clear on every change. [26]\n"
             /*
             "\n"
             "      #for /f \"tokens=*\" %%%%a in ('sfk fromclip') do (set myvar=%%%%a)\n"
             "         within a windows .bat file this sets environment variable\n"
             "         myvar with a single line text from the clipboard.\n"
             "\n"
             "      #for /f \"tokens=*\" %%a in ('sfk fromclip') do (set myvar=%%a)\n"
             "         same as above, but for direct use in the command line\n"
             "         without a batch file.\n"
             */
            );
      ehelp;

      sfkarg;

      bool bWait  = 0;
      bool bClear = 0;
      bool bRaw   = strcmp(pszCmd, "rawclip")   ? 0 : 1;
      bool bltrim = strcmp(pszCmd, "lclip")     ? 0 : 1;
      bool bbin   = strcmp(pszCmd, "fromclipw") ? 0 : 1;
      int  nchars = 0;
      int  iForm  = bbin ? CF_UNICODETEXT : CF_TEXT;

      int  iChainNext = 0;

      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argx[iDir], "-wait"))
            { bWait = 1; continue; }
         if (!strcmp(argx[iDir], "-clear"))
            { bClear = 1; continue; }
         if (!strcmp(argx[iDir], "-ltrim"))
            { bltrim = 1; continue; }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         else {
            // process non-option keywords:
            return 9+perr("unexpected: %s\n", argx[iDir]);
         }
      }

      if (btest) return 0;

      // now get the clipboard data:

      char *pszClip = 0;
      ushort *pWClip = 0;

      lRC = 0;

      while (!IsClipboardFormatAvailable(iForm)) {
         if (!bWait)
            { lRC = 1; break; }
         Sleep(250);
      }

      if (lRC == 1)
         { }
      else
      if (!safeOpenClipboard(0,cs.quiet)) // fromclip
         lRC = 2;
      else
      do
      {
         HGLOBAL hglb = GetClipboardData(iForm);
         if (hglb == NULL) {
            perr("no clipboard data available\n");
         } else {
            char *pMem = (char*)GlobalLock(hglb);
            if (pMem != NULL) {
               if (bbin)
                  pWClip = mystrwdup((ushort*)pMem,&nchars);
               else
                  pszClip = strdup(pMem);
            }
            GlobalUnlock(hglb);
         }
   
         // clear the clipboard?
         if (bClear)
            EmptyClipboard();
   
         CloseClipboard();
   
         if (!pszClip && !pWClip)
            { lRC = 1; break; }
   
         // we're now owner of pszClip.
         if (bltrim && pszClip)
         {
            char *psrc = pszClip;
            char *pdst = pszClip;
            while (*psrc) {
               // line start
               while (*psrc!=0 && (*psrc==' ' || *psrc=='\t'))
                  psrc++;
               // line text
               while (*psrc!=0 && (*psrc!='\r' && *psrc!='\n'))
                  *pdst++ = *psrc++;
               // eol
               while (*psrc!=0 && (*psrc=='\r' || *psrc=='\n'))
                  *pdst++ = *psrc++;
            }
            *pdst = '\0';
         }
    
         if (pWClip) {
            if (cs.tomask && cs.tomaskfile)
               saveFile(cs.tomask, (uchar*)pWClip, nchars*2);
            else
            if (chain.colany())
               chain.addBinary((uchar*)pWClip, nchars*2);
            else for (num i=0; i<nchars; i++) {
               ushort c=pWClip[i];
               if (c == '\r')
                  continue;
               // if (c >= 0x0080)
               //    printf("{%04x}",c);
               // else
                  putwchar(c);
            }
         }
         else if (cs.tomask && cs.tomaskfile) {
            saveFile(cs.tomask, (uchar*)pszClip, strlen(pszClip));
         } else if (bRaw) {
            putClipboard(pszClip);
            if (cs.verbose)
               printf("converted %d bytes.\n", strlen(pszClip));
         }
         else if (chain.colany()) {
            // do not dump to terminal, but to chain buffer:
            num nlen = strlen(pszClip);
            num iin  = 0;
            // split into buffer records.
            while (iin<nlen) {
               int ibuf = 0;
               for (; iin<nlen; iin++) {
                  char c = pszClip[iin];
                  if (c == '\r')
                     continue;
                  if (c == '\n')
                     { iin++; break; }
                  szLineBuf[ibuf++] = c;
                  if (ibuf >= MAX_LINE_LEN-10)
                     break; // hard line wrap
               }
               szLineBuf[ibuf] = '\0';
               chain.addLine(szLineBuf, str(""));
            }
         } else {
            // pszClip MAY contain 0D0A format, but writing to stdout
            // also converts every 0A to 0D0A. filter 0D's out.
            num nlen = strlen(pszClip);
            for (num i=0; i<nlen; i++) {
               char c = pszClip[i];
               if (c == '\r')
                  continue;
               putchar(c);
            }
         }
    
         if (pWClip)
            delete [] pWClip;
         else
            delete [] pszClip;
      }
      while (0);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "sleep")) // +chaining
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk sleep msec\n"
             "\n"
             "   delay execution for a number of milliseconds.\n"
             "\n");
      webref("sleep");
      printx("   $usage example:\n"
             "\n"
             "      runapache.bat:\n"
             "      #start sfk sleep 3000 +tail -f logs\\access.log -pat \"GET * 404 \"\n"
             "      #apache.exe\n"
             "\n"
             "         creates an error log viewer, and runs apache in parallel.\n"
             "         sfk will wait 3 seconds before tail goes active.\n"
             );
      ehelp;

      sfkarg;

      int nmsec = -1;

      for (; iDir<argc; iDir++)
      {
         if (isChainStart(pszCmd, argx, argc, iDir, 0))
            break;
         else
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
         }
         else
         if (nmsec < 0) {
            // process non-option keywords
            char *psz = argx[iDir];
            if (!isdigit(*psz))
               return 9+perr("wrong number format: %s\n", psz);
            nmsec = atol(psz);
            continue;
         }
         return 9+pbad(pszCmd, argx[iDir]);
      }

      doSleep(nmsec);

      // calling this only for chaining support:
      int iDirNext=0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext))) return lRC;

      // we haven't collected any filenames, but maybe previous
      // commands have, so keep chain list as it is.
      STEP_CHAIN(iDirNext, 0); // sleep

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "pause")) // +chaining +var
   {
      ifhelp ((iDir < argc) && isHelpOpt(argv[iDir]))
      printx("<help>$sfk pause [options] [text]<def>\n"
             "\n"
             "   wait for user input before continuing command execution.\n"
             "\n"
             "   $options\n"
             "      -keyrc       set shell return code to ascii code\n"
             "                   of pressed key. cannot be combined with\n"
             "                   command chaining. without this option\n"
             "                   the shell rc is always 0.\n"
             "\n"
             "   $see also\n"
             "      sfk sleep    delay execution for a given time.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk echo hello +pause\n"
             "         prints hello and then waits.\n"
            );
      ehelp;

      sfkarg;

      char *pszText = 0;
      int  ntimeout = 0;
      bool bkeyrc   = 0;

      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-maxwait", &pszParm)) { // pause
            if (!pszParm) return 9;
            ntimeout = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(pszArg, "-keyrc")) {
            bkeyrc = 1;
            continue;
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, 0))
            break;
         else
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
         }
         else
         if (!pszText) {
            pszText = argx[iDir];
            continue;
         }
         return 9+pbad(pszCmd, argx[iDir]);
      }

      if (!pszText && !cs.quiet) {
         #ifdef _WIN32
         pszText = str("Press any key to continue, CTRL+C or ESC to stop.");
         #else
         pszText = str("Press ENTER to continue, or CTRL+C to stop.");
         #endif
      }

      // wait for user input:
      int nkey   = 0;
      #ifdef _WIN32
      num  nstart = getCurrentTime();
      if (pszText)
         { printf("%s\r", pszText); fflush(stdout); }
      while (true) {
         nkey = getKeyPress(1); // only DOWN events
         if (nkey > 0) {
            if (cs.verbose) printf("[key 0x%x]\n", (uint)nkey);
            if (nkey >= 0x20) break;
            if (nkey == '\n' || nkey == '\r' || nkey == '\t' || nkey == 0x1B)
               break;
            // else ignore non-printable keys, esp. CTRL (0x11)
         }
         int ndelay = ntimeout ? 500 : 100;
         doSleep(ndelay);
         num nelapsed = getCurrentTime() - nstart;
         if (ntimeout) {
            if (nelapsed > ntimeout) break;
            num nremain = ntimeout - nelapsed;
            printf("[%d] - %s\r",(int)(nremain/1000),pszText);
            fflush(stdout);
         }
      }
      printf("\n");
      #else
      if (pszText) printf("%s\n", pszText);
      nkey = (int)getchar(); // requires enter
      #endif

      // calling this only for chaining support:
      int iDirNext=0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, 3, &iDirNext))) return lRC;

      // chg 1770: rc only on option -keyrc.
      // cannot be combined with command chaining.
      if (bkeyrc!=0 && iDirNext==0) {
         lRC = nkey;
      }

      // continue chain processing only if no ESCAPE pressed
      if (nkey != 0x1B) {
         STEP_CHAIN(iDirNext, 0); // pause
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "prompt")) // sfk189
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk prompt [text]<def>\n"
             "\n"
             "   get user input and pass it to the next command\n"
             "   in the command chain. text formatting is possible\n"
             "   using [[Red]] or [[def]], for details see sfk echo.\n"
             "\n"
             #ifdef _WIN32
             "   default since sfk 1.9 is to convert typed chars\n"
             "   from the current OEM to Ansi codepage.\n"
             "\n"
             "   $options\n"
             "      -nocconv   do not convert input from dos\n"
             "                 to ansi codepage.\n"
             "\n"
             #endif
             );
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk -var prompt \"enter your name\" +setvar name\n"
             "       #+tell \"hello ##(name)\"\n"
             "         ask the user to enter his name, then store\n"
             "         it in variable name, and say hello.\n"
            );
      ehelp;

      sfkarg;

      char *pszText = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!pszText) {
            pszText=pszArg;
            continue;
         }
         return 9+pbad(pszCmd, argx[iDir]);
      }

      if (pszText)
         printEcho(4, "%s", pszText);

      int ichars=0,nkey=0;
      while (nkey!='\n' && ichars<MAX_LINE_LEN)
      {
         nkey = (int)getchar(); // requires enter
         #ifdef _WIN32
         if (cs.outcconv)
            nkey = sfkchars.oemtoansi(nkey); // sfk190
         #endif
         szLineBuf[ichars++] = nkey;
      }
      szLineBuf[ichars]='\0';

      chain.print("%s",szLineBuf);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   regtest("tail -lines=10 -follow -quiet -polltime=500 xfile");

   ifcmd (   !strcmp(pszCmd, "head") // +wref
          || !strcmp(pszCmd, "thead")
         )
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk head [-lines=n] [-f[ollow]] [filename]\n"
             "$sfk ... +[t]head [-lines=n]\n"
             "\n"
             "   1. print first lines of a file, optionally following changes.\n"
             "      to use file content processing, provide a single filename.\n"
             "\n"
             "   2. print first text lines procuded by a previous command.\n"
             "      to process chain text thead is recommended.\n"
             "\n"
             "   $options\n"
             "      -lines=n     print first n lines (default is 10).\n"
             "      -follow      or -f waits for file changes, rereading from start.\n"
             "                   to post-process head output, e.g. with +filter, always\n"
             "                   add +loop at the end of the command sequence.\n"
             "                   head checks both file size and time for changes.\n"
             "      -altsize     use a different method to determine the file size\n"
             "                   (stat instead of seek). may help if the default method\n"
             "                   fails to read the file, or to improve performance.\n"
             "\n"
             "   $see also\n"
             "      #sfk filter -head=n<def>  read and search first n lines of text files.\n"
             #ifdef _WIN32
             "      #sfk view<def>     GUI tool to view all text files of a folder, then jump\n"
             "                   through file heads by ctrl+pageDown.\n"
             #endif
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk head readme.txt\n"
             "         print first 10 lines of readme.txt\n"
             "      #type myfile.txt | sfk filter +thead -lines=50\n"
             "         filter first 50 lines from stdin, via sfk filter.\n"
             "      #sfk head -follow status.txt +filt -high Red error +loop\n"
             "         show changes in status.txt, highlight \"error\" in red.\n"
             );
      ehelp;

      sfkarg;

      CommandScope oscope("head");

      char *pszFile   =     0;
      int nLastLines  =    10;
      int nPollTime   =   500;
      bool bFollow    =     0;
      int nMaxLines   = 10000;
      int  iChainNext =     0;
      bool bUseSeek   =     1;

      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-lines", &pszParm)) {
            if (!pszParm) return 9;
            nLastLines = atol(pszParm);
            continue;
         }
         else
         if (haveParmOption(argx, argc, iDir, "-polltime", &pszParm)) {
            if (!pszParm) return 9;
            nPollTime = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argx[iDir], "-f", 2)) {
            if (chain.usedata) {
               perr("-f[ollow] not supported with chain text input");
               pinf("check if previous commands produce filenames or text");
               return 9;
            }
            bFollow = 1;
            continue;
         }
         else
         if (!strcmp(argx[iDir], "-altsize")) {
            bUseSeek = 0;
            if (cs.verbose) pinf("using fseek file size detect\n");
            continue;
         }
         else
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszFile) {
            pszFile = argx[iDir];
            continue;
         }
         return 9+pbad(pszCmd, argx[iDir]);
      }

      if (btest) return 0;

      if (chain.usedata)
      {
         // head or tail the chain text
         int nsize = chain.indata->numberOfEntries();
         int nfrom = 0, nto = nsize;
         nto = nLastLines;
         if (nto > nsize) nto = nsize;
         for (int i=nfrom; i<nto; i++) {
            char *ptext=0, *pattr=0;
            ptext = chain.indata->getEntry(i, __LINE__, &pattr);
            if (!ptext) return 9+perr("int. #168281112");
            if (chain.coldata)
               chain.addLine(ptext, pattr);
            else
               printColorText(ptext, pattr, 1); // with lf
         }
      }
      else
      {
         // head or tail file contents
         if (!pszFile) {
            if (chain.usefiles && chain.numberOfInFiles() == 1) {
               Coi *pcoi = chain.getFile(0);
               if (!pcoi) return 9;
               pszFile = pcoi->name();
            } else {
               cchar *pcmd = "head";
               perr("too many input filenames for %s (%d)",pcmd,chain.numberOfInFiles());
               pinf("%s can only process a single input filename.\n",pcmd);
               pinf("use +t%s instead of %s if you want to process text.\n",pcmd,pcmd);
               pinf("try +ftt to convert filenames to text. see also \"sfk help chain\".\n");
               return 9;
            }
         }
 
         int bIsDir=0,bCanRead=0,bCanWrite=0;
         num nFileTime=0,nFileSize=0;

         if (!cperm.tailnsize) {
            nFileSize = -1;
            nFileTime =  0;
            getFileStat(pszFile, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize);
            cperm.tailnsize = bUseSeek ? getFileSizeSeek(pszFile) : nFileSize;
            cperm.tailtime  = nFileTime;
            if (cperm.tailnsize < 0) return 9+pferr(pszFile, "cannot read: %s\n", pszFile);
         }
 
         // keyword +loop supplied?
         bool bHaveLoop = 0;
         if (argc > 0) {
            for (int iback=argc-1; iback > 0; iback--)
               if (!strcmp(argx[iback], "+loop"))
                  {  bHaveLoop = 1; break; }
         }
 
         if (!bHaveLoop && bFollow && iChainNext && !cs.quiet)
            pwarn("chain commands after tail -follow may not work as expected without +loop.\n");
 
         bool bFirstLoop = (cperm.tailnpos > 0) ? 0 : 1;
         char szTime[100];

         do
         {
            int nrc = 0;

            if (bFollow && !bFirstLoop)
            {
               bool bTold  = 0;
               int iturn  = 0;
               cchar *aturn = "\\|/-";
               while (!userInterrupt())
               {
                  doSleep(nPollTime);
                  nFileSize = -1;
                  nFileTime =  0;
                  getFileStat(pszFile, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize);
                  num nsize2 = bUseSeek ? getFileSizeSeek(pszFile) : nFileSize;
                  if (nsize2 < 0) {
                     if (!cs.quiet && !bTold)
                        printf("[file removed, waiting for recreation]\n");
                     bTold = 1;
                     continue;
                  }
                  if (nsize2 != cperm.tailnsize || nFileTime != cperm.tailtime)
                  {
                     if (!cs.quiet)
                        printf("-----\n");
                     cperm.tailnsize = nsize2;
                     cperm.tailtime  = nFileTime;
                     break;
                  }
                  bTold = 0;
                  if (cs.verbose)
                     printf("[%c %s bytes filesize]\r",aturn[iturn++%4],numtoa(nsize2));
               }
            }
            bFirstLoop = 0;
 
            // dump new content, from pos to end
            FILE *fin = fopen(pszFile, "rb");
            if (!fin) return 9+perr("unable to read: %s\n", pszFile);
 
            // dump from current position until end (if tail)
            int nLocLine = 0;
            myfgets_init();
            while (myfgets(szLineBuf, MAX_LINE_LEN-10, fin))
            {
               szLineBuf[MAX_LINE_LEN-10] = '\0';
               removeCRLF(szLineBuf);
               nLocLine++;
 
               if (chain.coldata)
                  chain.addLine(szLineBuf, str(""));
               else
                  printf("%s\n", szLineBuf);
 
               if (nLocLine >= nLastLines)
                  break;
            }
 
            // remember end position of read.
            // can NOT use nGlblGetFPos here as it's relative.
            nrc = mygetpos(fin, cperm.tailnpos, pszFile);
            fclose(fin);
            if (nrc) return 9+perr("unable to read position: %s\n", pszFile);
         }
         while (bFollow && !bHaveLoop && !userInterrupt());
      }
 
      // if -follow is not selected
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "tail") // +wref
          || !strcmp(pszCmd, "ttail")
         )
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk tail [-lines=n] [-f[ollow]] [filename]\n"
             "$sfk ... +[t]tail [-lines=n]\n"
             "\n"
             "   1. print last lines of a file, optionally following changes.\n"
             "      to use file content processing, provide a single filename.\n"
             "\n"
             "   2. print last text lines procuded by a previous command.\n"
             "      to process chain text ttail is recommended.\n"
             "\n"
             "   $options\n"
             "      -lines=n     print last n lines (default is 10).\n"
             "      -follow      or -f waits for file changes, printing them endlessly.\n"
             "                   if file is recreated or shrunk, rereads the last lines.\n"
             "                   to post-process tail output, e.g. with +filter, always\n"
             "                   add +loop at the end of the command sequence.\n"
             "      -nowait      if tail is reached multiple times in a chain by +loop\n"
             "                   then do not wait for a file size change but force\n"
             "                   stepping of the command chain.\n"
             "      -quiet       do not tell verbosely about read restarts.\n"
             "      -polltime=n  with -follow, specifies the delay in milliseconds before\n"
             "                   the file is checked again for changes. default is 500.\n"
             "      -altsize     use a different method to determine the file size\n"
             "                   (stat instead of seek). may help if the default method\n"
             "                   fails to read the file, or to improve performance.\n"
             "      -verbose     tell in detail what is done.\n"
             "\n"
             "   $see also\n"
             "      #sfk filter -tail=n<def>  read and search last n lines of text files.\n"
             #ifdef _WIN32
             "      #sfk view<def>     GUI tool to view all text files of a folder, then jump\n"
             "                   through file ends by ctrl+end.\n"
             #endif
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk tail -follow logs\\access.log\n"
             "         immediately lists last lines, then all added lines over time.\n"
             "      #sfk tail -f c:\\temp\\log.txt +filter -+error: -+warning: +loop\n"
             "         endless filter of error and warning messages from log.txt.\n"
             "\n"
             "   $example sfk script with conditional execution\n"
             "     #file logfilter.txt:\n"
             "       sfk label checklog\n"
             "          +tail -follow logfile.txt\n"
             "          +tee toterm +storetext\n"
             "          +filter -+error: -justrc\n"
             "          +if \"rc>0\" call myalert\n"
             "          +gettext +filter -+alldone: -justrc\n"
             "          +if \"rc>0\" stop\n"
             "          +loop +end\n"
             "       sfk label myalert\n"
             "          +then run -yes \"myalert.bat\" +end\n"
             "     #sfk script logfilter.txt\n"
             "        will run myalert.bat whenever errors appear in logfile.txt.\n"
             "        the script stops as soon as \"alldone\" appears in the log.\n"
             "        to allow double filtering of the chain text it must be\n"
             "        stored before the first filter, then restored.\n"
             );
      ehelp;

      sfkarg;

      CommandScope oscope("tail");

      char *pszFile   =     0;
      int nLastLines  =    10;
      int nPollTime   =   500;
      bool bFollow    =     0;
      int nMaxLines   = 10000;
      int  iChainNext =     0;
      bool bUseSeek   =     1;
      bool bNoWait    =     0;

      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-lines", &pszParm)) {
            if (!pszParm) return 9;
            nLastLines = atol(pszParm);
            if (!chain.usedata && (nLastLines > nMaxLines))
               pwarn("tail supports only %d -lines at maximum.\n", nMaxLines);
            continue;
         }
         else
         if (haveParmOption(argx, argc, iDir, "-polltime", &pszParm)) {
            if (!pszParm) return 9;
            nPollTime = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argx[iDir], "-f", 2)) {
            if (chain.usedata) {
               perr("-f[ollow] not supported with chain text input");
               pinf("check if previous commands produce filenames or text");
               return 9;
            }
            bFollow = 1;
            continue;
         }
         else
         if (!strcmp(argx[iDir], "-altsize")) {
            bUseSeek = 0;
            if (cs.verbose) pinf("using fseek file size detect\n");
            continue;
         }
         else
         if (!strcmp(argx[iDir], "-nowait")) {
            bNoWait = 1;
            continue;
         }
         else
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszFile) {
            pszFile = argx[iDir];
            continue;
         }
         return 9+pbad(pszCmd, argx[iDir]);
      }

      if (btest) return 0;

      if (chain.usedata)
      {
         // tail the chain text
         int nsize = chain.indata->numberOfEntries();
         int nfrom = 0, nto = nsize;
         nfrom = nsize - nLastLines;
         if (nfrom < 0) nfrom = 0;
         for (int i=nfrom; i<nto; i++) {
            char *ptext=0, *pattr=0;
            ptext = chain.indata->getEntry(i, __LINE__, &pattr);
            if (!ptext) return 9+perr("int. #168281112");
            if (chain.coldata)
               chain.addLine(ptext, pattr);
            else
               printColorText(ptext, pattr, 1); // with lf
         }
      }
      else
      {
         // tail file contents
         if (!pszFile) {
            if (chain.usefiles && chain.numberOfInFiles() == 1) {
               Coi *pcoi = chain.getFile(0);
               if (!pcoi) return 9;
               pszFile = pcoi->name();
            } else {
               cchar *pcmd = "tail";
               perr("too many input filenames for %s (%d)",pcmd,chain.numberOfInFiles());
               pinf("%s can only process a single input filename.\n",pcmd);
               pinf("use +t%s instead of %s if you want to process text.\n",pcmd,pcmd);
               pinf("try +ftt to convert filenames to text. see also \"sfk help chain\".\n");
               return 9;
            }
         }
 
         num nCurFileSize = bUseSeek ? getFileSizeSeek(pszFile) : getFileSize(pszFile);

         if (!cperm.tailnsize) {
            cperm.tailnsize = nCurFileSize;
            if (cperm.tailnsize < 0) return 9+pferr(pszFile, "cannot read: %s\n", pszFile);
         }
 
         // keyword +loop supplied?
         bool bHaveLoop = 0;
         if (argc > 0) {
            for (int iback=argc-1; iback > 0; iback--)
               if (!strcmp(argx[iback], "+loop"))
                  {  bHaveLoop = 1; break; }
         }
 
         if (!bHaveLoop && bFollow && iChainNext && !cs.quiet)
            pwarn("chain commands after tail -follow may not work as expected without +loop.\n");
 
         do
         {
            bool bDump = 1;

            if (!cperm.tailnpos)
            {
               // find initial position of nLastLines from end
               num *ppos = new num[nMaxLines+10]; // with tolerance
               if (!ppos) return 9+perr("out of memory\n");
               memset(ppos, 0, sizeof(num)*nMaxLines);
               int nbufpos = 0;

               // scan all line positions
               FILE *fin = fopen(pszFile, "rb");
               if (!fin) return 9+perr("unable to read: %s\n", pszFile);

               myfgets_init();

               // sfk 1751: jump near end of file on large files
               num nMaxTailRange = (nLastLines + 2) * (MAX_LINE_LEN + 4);
               if (nCurFileSize > nMaxTailRange)
               {
                  num nStartOffset = nCurFileSize - nMaxTailRange;
                  mysetpos(fin, nStartOffset, pszFile);
                  nGlblGetFPos = nStartOffset;
               }

               while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin))
               {
                  removeCRLF(szLineBuf);
                  // cannot use mygetpos here, as myfgets caches.
                  num npos2 = nGlblGetFPos;
                  memmove(&ppos[1], &ppos[0], sizeof(num) * nbufpos);
                  ppos[0] = npos2;
                  if (nbufpos < nMaxLines)
                     nbufpos++;
                  if (cs.debug)
                     printf("line %d pos %s \"%s\"\n",nbufpos,numtoa(npos2),szLineBuf);
               }
               fclose(fin);

               // fetch requested line position
               if (nLastLines > nbufpos)
                  nLastLines = nbufpos;
               if (nLastLines > nMaxLines)
                  return 9+perr("overflow, too many lines from file end specified.\n");
               cperm.tailnpos = ppos[nLastLines];

               if (cs.debug)
                  printf("\ntake pos %s from offset %d\n",numtoa(cperm.tailnpos),nLastLines);

               delete [] ppos;
            }
            else
            {
               // wait until file changes, then proceed
               bool bTold  = 0;
               int iturn  = 0;
               cchar *aturn = "\\|/-";
               while (!userInterrupt())
               {
                  doSleep(nPollTime);
                  num nsize2 = bUseSeek ? getFileSizeSeek(pszFile) : getFileSize(pszFile);
                  if (nsize2 < 0) {
                     if (!cs.quiet && !bTold)
                        printf("[file removed, waiting for recreation]\n");
                     bTold = 1;
                     continue;
                  }
                  if (nsize2 != cperm.tailnsize) {
                     if (nsize2 < cperm.tailnsize) {
                        if (!cs.quiet)
                           printf("[file %srecreated, rereading last %d lines]\n", bTold?"":"shrunk or ",nLastLines);
                        cperm.tailnsize = nsize2;
                        cperm.tailnpos = 0;
                        break;
                     }
                     cperm.tailnsize = nsize2;
                     break;
                  }
                  bTold = 0;
                  if (bNoWait) { // sfk1814
                     bDump = 0;
                     break;
                  }
                  if (cs.verbose)
                     printf("[%c %s bytes size, waiting for change]\r",aturn[iturn++%4],numtoa(nsize2));
               }
            }
 
            if (bDump)
            {
               int nrc = 0;
    
               // dump new content, from pos to end
               FILE *fin = fopen(pszFile, "rb");
               if (!fin) return 9+perr("unable to read: %s\n", pszFile);
    
               nrc = mysetpos(fin, cperm.tailnpos, pszFile);
               if (nrc) {
                  fclose(fin);
                  return 9+perr("unable to set position: %s\n", pszFile);
               }
    
               // dump from current position until end
               int nLocLine = 0;
               myfgets_init();
               while (myfgets(szLineBuf, MAX_LINE_LEN-10, fin))
               {
                  szLineBuf[MAX_LINE_LEN-10] = '\0';
                  removeCRLF(szLineBuf);
                  nLocLine++;
    
                  if (chain.coldata)
                     chain.addLine(szLineBuf, str(""));
                  else
                     printf("%s\n", szLineBuf);
               }
    
               // remember end position of read.
               // can NOT use nGlblGetFPos here as it's relative.
               nrc = mygetpos(fin, cperm.tailnpos, pszFile);
               fclose(fin);
               if (nrc) return 9+perr("unable to read position: %s\n", pszFile);
            }
         }
         while (bFollow && !bHaveLoop && !userInterrupt());
      }
 
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "view") || !strncmp(pszCmd, "fv", 2))
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk ... +view [-noshl|-nocol] [\"-...\"]\n"
             "\n"
             "   Show SFK command text output #interactively in Depeche View,<def>\n"
             "   #a high speed text browser and filter tool<def> for Windows which\n"
             "   also runs on Linux/Mac if WINE is installed.\n"
             "\n"
             "   The tool allows #browsing of text with soft scrolling<def>\n"
             "   and #instant search<def> as you type or click on words.\n"
             "\n"
             "   Depeche View can also be used #standalone<def>, to browse and\n"
             "   search #all text from office 2007 files of a folder<def>.\n"
             "\n"
             "   Type #sfk getdv<def> to download Depeche View Lite now,\n"
             "   or visit #www.depecheview.com<def> for more infos.\n"
             "   The tool is fully portable and needs no installation.\n"
             "\n"
             "   Many SFK commands allow to add #+view<def> to have their output\n"
             "   shown instantly in DView. This requires #dview, dview.exe\n"
             "   or #dview.bat<def> being located in the PATH. If you have downloaded\n"
             "   an executable like dview155.exe, rename it before use.\n"
             "\n");
      printx("   DView can be run under #Linux and Mac<def>, but this is experimental\n"
             "   and unsupported. The latest #WINE<def> version must be installed.\n"
             "   Google for \"linux wine\", or search it in your package manager.\n"
             "\n"
             "   $use as a chain command, or to display stdin:\n"
             "\n"
             "      +[f]view can be used only #after another command<def>\n"
             "      producing a list of filenames or plain text data:\n"
             "\n"
             "         #+view<def>  expects text as input.\n"
             "         #+fview<def> expects a list of filenames or HTTP URLs.\n"
             "\n"
             "      or use \"sfk view -i\" to display text from stdin.\n"
             "\n");
      printx("   $options\n"
             "      -nocol[or]   disable colored output and display.\n"
             "                   set this if you're using dview < 1.1.4\n"
             "                   or any other viewer.\n"
             "      -wrap[=n]    wrap lines at column n. currently, this feature\n"
             "                   disables colors (implies -nocol), but depending\n"
             "                   on the content processed, dview may still show\n"
             "                   colors based on syntax highlighting.\n"
             "      -noshl       disable syntax highlighting at dview.\n"
             "      \"-x1 -x2\"    all other options are passed through unchanged\n"
             "                   to the viewer application. if multiple parameters\n"
             "                   have to be passed, surround them by double quotes.\n"
             "      -verbose     tell verbosely which target binary is invoked.\n"
             #ifdef _WIN32
             "      -noback      by default, dview is run as a background process,\n"
             "                   by prefixing the overall command with \"start \".\n"
             "                   say -noback to let sfk wait until dview is stopped.\n"
             #else
             "      -noback      by default, dview is run as a background process,\n"
             "                   by appending ampersand & to the overall command.\n"
             "                   say -noback to let sfk wait until dview is stopped.\n"
             "      -nowine      sfk for linux creates a command \"wine dview ...\" to\n"
             "                   make sure Depeche View is run in the wine environment.\n"
             "                   specify -nowine to disable this.\n"
             "      -nolinux     sfk for linux adds option -linux when calling dview\n"
             "                   or dview.exe. specify -nolinux to disable this.\n"
             "      -plain       combines -nowine, -nolinux.\n"
             #endif
             "\n"
             "   $dview options and parameters\n"
             "      all non sfk options and parameters are passed through, like:\n"
             "\n"
             "      -tab n                set tab size n (dview 1.6.3 or higher)\n"
             "      -area 20:20:600:400   open at position 20,20 with size 600x400\n"
             "      -find \"a text\"        search a text instantly\n"
             "      -sfind \"a \\qtext\\q\"   search text given with slash patterns\n"
             "\n"
             "      for all dview options try: dview -help -find \"all*options\"\n"
             "\n");
      printx("   $temporary files\n"
             "      this command #creates a temporary file<def> which is currently\n"
             "      not deleted. type \"sfk help options\" for options on that.\n"
             "\n"
             "   $using a different viewer\n"
             "      when viewing a list of files, this command runs\n"
             "         \"dview -flist tmpfilename\"\n"
             "      with tmpfilename containing a list of filenames.\n"
             "\n"
             "      when viewing text line output, this command runs\n"
             "         \"dview tmpfilename\"\n"
             "      with tmpfilename containing ascii text data.\n"
             "\n"
             "      specify -verbose to see what is invoked in detail.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk list docs .txt +fview\n"
             "         view content of all .txt files in directory docs.\n"
             "\n"
             "      #sfk echo x +view -verbose\n"
             "         tell verbosely which dview(.exe?) executable is actually used.\n"
             "\n"
             "      #sfk list docs .txt +ffilter -+foo -hitfiles +fview \"-max -over\"\n"
             "         view all .txt $files<def> from docs containing \"foo\", pass options\n"
             "         -max -over to the viewer, showing a maximized window in overscan\n"
             "         mode (without any title bar).\n"
             "\n"
             "      #sfk list docs .txt +ffilter -+foo +view \"-space 0:0:40\"\n"
             "         view only text $lines<def> from docs containing \"foo\", in a window\n"
             "         covering the whole desktop, except for 40 pixels at the bottom.\n"
             #ifdef _WIN32
             "\n"
             "      #sfk fromclip +view\n"
             "         display current clipboard content (plain text only).\n"
             #endif
             "\n"
             "      #tar tvf foo.tar | sfk view -i\n"
             "         display a tar file's content listing.\n"
             "\n"
             "      #sfk larc -size -time -withdirs foo.tar +view\n"
             "         the same, with sfk reading the .tar directly.\n"
             "\n"
             "      #sfk filter urls.txt +fview\n"
             "         if urls.txt contains HTTP URLs like\n"
             "            $http://.100/sys/status.xml\n"
             "            $http://.100/sys/trace.xml\n"
             "            $http://.100/sys/errors.xml\n"
             "         then dview 1.7.1 or higher will load them,\n"
             "         allowing interactive search and filtering.\n"
             "\n"
             "      #sfk filt calls.txt -form \"http://.100<run>col1\" +fview\n"
             "         if calls.txt contains paths like\n"
             "             $/sys/status.xml\n"
             "             $/sys/trace.xml\n"
             "             $/sys/errors.xml\n"
             "         expand them like http://192.168.1.100/sys/status.xml\n"
             "         and load these into dview for interactive filtering.\n"
             );
      ehelp;

      sfkarg;

      bool bback    = 0;
      bool bcolor   = 1;
      int bcompact = 1;
      #ifdef _WIN32
      char *pszsopt = str("start ");
      char *pszwopt = str("");
      char *pszxopt = str("");
      #else
      char *pszsopt = str(" &");
      char *pszwopt = str("wine ");
      char *pszxopt = str(" -linux");
      #endif
      bool  bShowGetDV = 0;

      // additional dview options are collected in abBuf:
      strcpy((char*)abBuf, " ");

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argx[iDir], "-back")) {
            bback = 1;
            continue;
         }
         if (!strncmp(argx[iDir], "-nocol", 6)) {
            bcolor = 0;
            continue;
         }
         if (!strncmp(argx[iDir], "-col", 4)) {
            bcolor = 1;
            continue;
         }
         if (!strncmp(argx[iDir], "-snap", 5)) {
            bcompact = 0; // normal snapfile format
            continue;
         }
         if (!strncmp(argx[iDir], "-comp", 5)) {
            bcompact = 2; // leave out blank lines before files
            continue;
         }
         if (!strncmp(argx[iDir], "-noba", 5)) {
            pszsopt = str("");
            continue;
         }
         if (!strncmp(argx[iDir], "-noli", 5)) {
            pszxopt = str("");
            continue;
         }
         if (!strncmp(argx[iDir], "-nowi", 5)) {
            pszwopt = str("");
            continue;
         }
         if (!strcmp(argx[iDir], "-plain")) {
            pszwopt = str("");
            pszxopt = str("");
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (setGeneralOption(argx, argc, iDir))
               continue;
            // collect and pass through to dview
            if (myrchar((char*)abBuf) != ' ')
               strcat((char*)abBuf, " ");
            strcat((char*)abBuf, argx[iDir]);
            continue;
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // collect and pass through to dview
         if (myrchar((char*)abBuf) != ' ')
            strcat((char*)abBuf, " ");
         // enquote all non option parameters
         bool bquote = strchr(argx[iDir], ' ') ? 1 : 0;
         if (bquote)
            strcat((char*)abBuf, "\"");
         strcat((char*)abBuf, argx[iDir]);
         if (bquote)
            strcat((char*)abBuf, "\"");
      }

      // render extra options for dview
      if (cs.wrapcol) {
         char *psz = (char*)abBuf;
         sprintf(&psz[strlen(psz)], " -wrap=%d", cs.wrapcol);
         bcolor = 0; // todo: -wrap with color support
      }
      // if (bnoshl) {
      //   strcat((char*)abBuf, " -noshl");
      // }

      // find the target executable:
      // dview, dview.bat, dview.exe [but not dview120.exe]
      // does not search for other extensions like .cmd.
      char *pszTarg    = str("dview");
      char *pszTargAbs = findPathLocation(pszTarg, 0);

      if (!pszTargAbs)
         pszTargAbs = findPathLocation("dview.exe", 0);

      if (!pszTargAbs)
         if ((pszTargAbs = findPathLocation("dview.bat", 0))) {
            pszwopt    = str("");
            pszxopt    = str("");
         }

      if (pszTargAbs)
         pszTarg = pszTargAbs;

      if (cs.verbose) {
         if (!pszTargAbs) {
            pinf("dview, dview.exe or dview.bat not found directly, but trying\n");
            pinf("anyway, in case another extensions is present within PATH.\n");
         }
      }

      if (chain.usefiles)
      {
         if (chain.numberOfInFiles())
         {
            SFTmpFile tmp(".txt", 1, 1); // 1: nodelete, 1: fixed file number
            char *pszTmpFile = tmp.name();
            if (!pszTmpFile) return 9;
 
            FILE *fout = fopen(pszTmpFile, "w");
            if (!fout) return 9+perr("cannot write temporary file: %s\n", pszTmpFile);
 
            for (int i=0; i<chain.numberOfInFiles(); i++) {
               Coi *pcoi = chain.getFile(i);
               if (!pcoi) return 9+perr("int. #141271853\n");
               fprintf(fout, "%s\n", pcoi->name());
            }
            fclose(fout);
 
            #ifdef VFILEBASE
            // cleanup possible connections to sfk ftp server
            mtklog(("view: cleanup connections"));
            resetLoadCaches(0, "ls");
            #endif // VFILEBASE

            #ifdef _WIN32
            sprintf(szLineBuf2, "%s%s%s -flist %s", pszsopt, pszTarg, (char*)abBuf, pszTmpFile);
            #else
            sprintf(szLineBuf2, "%s%s%s%s -flist %s%s", pszwopt, pszTarg, pszxopt, (char*)abBuf, pszTmpFile, pszsopt);
            #endif
            if (cs.verbose) pinf("[nopre] running: %s\n", szLineBuf2);
            int iRC = system(szLineBuf2);
            if (iRC) {
               printf("failed to run, rc=%d: %s\n", iRC, szLineBuf2);
               bShowGetDV = 1;
            }
         } else {
            printf("%s: received no input files for viewing.\n", pszCmd);
         }
      }
      else
      if (   (chain.usedata && chain.indata->numberOfEntries())
          ||  bGlblStdInAny
         )
      {
         SFTmpFile tmp(".txt", 1, 1); // 1: nodelete, 1: fixed file number
         char *pszTmpFile = tmp.name();
         if (!pszTmpFile) return 9;

         // write text data to temporary file
         FILE *fout = fopen(pszTmpFile, "w");
         if (!fout) return 9+perr("cannot write temporary file: %s\n", pszTmpFile);

         if (chain.usedata)
         {
            if (bcolor)
               fprintf(fout, "<interleaved-attributes-text version=\"1.0\" prefix=\"\">\n");
 
            bool bsnap = 0;
 
            for (int i=0; i<chain.indata->numberOfEntries(); i++)
            {
               char *pattr = 0;
               strcopy(szLineBuf2, chain.indata->getEntry(i, __LINE__, &pattr));
               removeCRLF(szLineBuf2);
 
               // if the first text record is a :file header
               bool bsubhead = 0;

               // :file text records with 'f' in rightmost extended attribute area
               // are real subfile headers.
               if (pattr) {
                  int natrlen = strlen(pattr);
                  if (natrlen > 0 && pattr[natrlen-1] == 'f' && !strncmp(szLineBuf2, ":file ", 6))
                     bsubhead = 1;
               }

               if (i==0 && bsubhead)
               {
                  // create snapfile format.
                  if (bcompact) {
                     fprintf(fout, ":snapfile sfk,1.1,prefix=:file: ,\n");
                     if (bcolor)
                     fprintf(fout, "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n");
                  } else {
                     fprintf(fout, ":snapfile sfk,1.1,lprefix=:file:\n");
                     if (bcolor)
                     fprintf(fout, "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n");
                  }
                  bsnap = 1;
               }
 
               // if creating snapfile, reformat every file header
               if (bsnap && bsubhead) {
                  if (bcompact) {
                     // 1. optional blank line
                     // 2. :file: filename
                     if (bcompact < 2) {
                        fprintf(fout, "\n"); if (bcolor) fprintf(fout, "\n");
                     }
                     fprintf(fout, ":file: %s\n", szLineBuf2+6);
                     if (bcolor) {
                        for (int k=7+strlen(szLineBuf2+6); k>0; k--)
                           fputc('b',fout);
                        fputc('\n',fout);
                     }
                  } else {
                     // 1. blank line
                     // 2. :file:
                     // 3. filename
                     fprintf(fout, "\n");       if (bcolor) fprintf(fout, "\n");
                     fprintf(fout, ":file:\n"); if (bcolor) fprintf(fout, "\n");
                     fprintf(fout, "%s\n", szLineBuf2+6);
                     if (bcolor) {
                        for (int k=strlen(szLineBuf2+6); k>0; k--)
                           fputc('b',fout);
                        fputc('\n',fout);
                     }
                  }
               } else {
                  mtklog(("vtext: %04d \"%s\"",(int)strlen(szLineBuf2),szLineBuf2));
                  fprintf(fout, "%s\n", szLineBuf2);
                  if (bcolor) {
                     // map and print color attribute codes. dview displays only:
                     // r,g,b,y,c,m for red,green,blue,yellow,cyan,magenta
                     // therefore logical attributes must be mapped.
                     szAttrBuf[0] = '\0';
                     if (pattr) strcopy(szAttrBuf, pattr);
                     for (char *psz=szAttrBuf; *psz; psz++)
                        switch (*psz) {
                           case 'f': *psz = 'g'; break; // nGlblFileColor  sfk185
                           case 'l': *psz = 'C'; break; // nGlblLinkColor
                           case 'h': *psz = 'g'; break; // nGlblHeadColor
                           case 'i': *psz = 'M'; break; // nGlblHitColor   sfk185
                           case 'a': *psz = 'R'; break; // nGlblRepColor   sfk185
                           case 'x': *psz = 'M'; break; // nGlblExampColor
                           case 'e': *psz = 'R'; break; // nGlblErrColor
                           case 'w': *psz = 'M'; break; // nGlblWarnColor
                           // sfk197: +view warn color change Yellow -> Magenta
                           case 't': *psz = 'B'; break; // nGlblTimeColor
                           case 'p': *psz = 'B'; break; // nGlblPreColor
                           // map white codes to default
                           case 'v': *psz = ' '; break;
                           case 'V': *psz = ' '; break;
                        }
                     mtklog(("vattr: %04d \"%s\"",(int)strlen(szAttrBuf),szAttrBuf));
                     fprintf(fout, "%s\n", szAttrBuf);
                  }
               }
            }
         }
         else
         {
            // copy from stdin
            size_t nread = 0;
            while ((nread = fread(szAttrBuf, 1, MAX_LINE_LEN, stdin)) > 0)
               myfwrite((uchar*)szAttrBuf, nread, fout);
         }

         fclose(fout);

         #ifdef _WIN32
         sprintf(szLineBuf3, "%s%s%s %s", pszsopt, pszTarg, (char*)abBuf, pszTmpFile);
         #else
         sprintf(szLineBuf3, "%s%s%s%s %s%s", pszwopt, pszTarg, pszxopt, (char*)abBuf, pszTmpFile, pszsopt);
         #endif
         if (cs.verbose) pinf("[nopre] running: %s\n", szLineBuf3);
         int iRC = system(szLineBuf3);
         if (iRC) {
            printf("failed to run, rc=%d: %s\n", iRC, szLineBuf3);
            bShowGetDV = 1;
         }
      }
      else
      {
         printf("%s: received no input text for viewing.\n", pszCmd);
      }

      if (bShowGetDV) {
         if (!pszTargAbs) {
            perr("dview.exe was not found within folders of PATH:\n");
            char *pszPath = getenv("PATH");
            if (pszPath)
               printf("%s\n", pszPath);
            printx("To download Depeche View Lite now, type:\n"
                   "\n"
                   "   #sfk getdv\n"
                   "\n"
                   );
            printx("Then retry your command.\n");
         }
      }

      if (iChainNext) {
         STEP_CHAIN(iChainNext, 0);
      }

      bDone = 1;
   }

   #ifdef _WIN32
   if (!strcmp(pszCmd, "beep")) // +chaining
   {
      if (nparm < 1) {
      printx("<help>$sfk beep messageid\n"
             "\n"
             "   play a system sound. possible ids are:\n"
             "\n"
             "       0  default sound\n"
             "      10  SystemHand\n"
             "      20  SystemQuestion\n"
             "      30  SystemExclamation\n"
             "      40  SystemAsterisk\n"
             );
      return 9;
      }
      int nid = -1; // default id
      bool breadid = 0;
      for (; iDir<argc; iDir++)
      {
         if (   !strncmp(argv[iDir], "-", 1)
             && strcmp(argv[iDir], "-1")
            )
         {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
         // process non-option keywords:
         if (!breadid) {
            breadid = 1;
            char *psz = argv[iDir];
            if (strlen(psz) == 1 || psz[0] == '-')
               nid = atol(argv[iDir]);
            else
               nid = getTwoDigitHex(argv[iDir]); // -1 on error
         }
         else
            return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) return lRC;
      if (btest) return 0;

      MessageBeep(nid);

      STEP_CHAIN(iDirNext, 0); // beep

      bDone = 1;
   }
   #endif

   regtest("filefind -time -size foo bar");

   // easy dir lister: sfk :pattern
   ifcmd (   !strcmp(pszCmd, "filefind") || !strcmp(pszCmd, "ff") // +wref
          || (iDir == 2 && pszCmd[0] == ':')
         )
   {
      ifhelp (!strcmp(pszCmd, ":") || (pszCmd[0] != ':' && nparm < 1))
      printx("<help>$sfk filefind [or ff] pattern [pattern2 <not>pattern3 ...] [opts]\n"
             "\n"
             "   easy file name finder for the current directory tree.\n"
             "   if you remember any words of a filename, or its path,\n"
             "   type \"sfk ff \" and the words to find matching filenames.\n"
             "   to type even less, try \"sfk :\" followed by the first word,\n"
             "   without blank: \"sfk :word1 word2 ...\"\n"
             "\n"
             "   $note:\n"
             "   - searches the current directory \".\" and all subdirectories.\n"
             "   - the full filename paths, including relative filenames,\n"
             "     are compared (not just the relative filenames).\n"
             "   - the patterns are AND combined (not OR as with list),\n"
             "     meaning that ALL given patterns must appear in a path\n"
             "     to have it listed. the pattern sequence is ignored.\n"
             "   - options may appear anywhere.\n"
             "   - exclude patterns starting with <not> are also supported.\n"
             "\n"
             "   $options\n"
             "      -time      list also file times.\n"
             "      -size[=n]  show size of files [n characters wide]\n"
             "      -kbytes    or -kb lists sizes in kbytes instead of bytes\n"
             "      -mbytes    or -gbytes lists sizes in mbytes or gbytes\n"
             "      -kbpure    list without \"kb\" postfix\n"
             );


      printx("\n"
             "   $chaining support\n"
             "      output chaining is supported.\n"
             "\n");
      webref("filefind");
      printx("   $examples\n"
             "      #sfk filefind foo bar <not>save\n"
             "         lists all files in the current directory tree having both\n"
             "         foo and bar in their path+filename, regardless of sequence.\n"
             "         files having \"save\" in their path (or name) are excluded.\n"
             "\n"
             "      #sfk ff foo<wild>bar thing +fview\n"
             "         similar to the above, lists all files having bar AFTER foo\n"
             "         in their path+filename. thing must also be present.\n"
             "         resulting files are loaded and shown in Depeche View.\n"
             "\n"
             "      #sfk :.pdf\n"
             "         list all .pdf files down somewhere in the directory tree.\n"
             "\n"
             "      #sfk :debug<wild>.o +del\n"
             "         delete all debug executables in the current directory tree.\n"
             );
      ehelp;

      sfkarg;

      // .
      bool bShortForm = (pszCmd[0] == ':');
      bool bTime=0, bSize=0, bCRC=0, bPure=0, bOptErr=0;

      if (glblFileSet.beginLayer(false, __LINE__)) return 9;
      if (glblFileSet.addRootDir(str("."), __LINE__, false)) return 9;
      if (bShortForm) {
         char *pszpat = pszCmd+1;
         sprintf(szLineBuf, "*%s*", pszpat);
         glblFileSet.addDirMask(szLineBuf);
      }
      glblFileSet.addFileMask(str("*")); // dummy

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (parseListOpt(0, argc, argx, iDir, bTime, bSize, bCRC, bPure, bOptErr)) {
            if (bOptErr)
               return 9;
            continue;
         }
         else
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         char *pszmask = argx[iDir];
         if (isNotChar(pszmask[0])) {
            // mask parts starting with "!" are negative dir AND file masks.
            glblFileSet.addDirMask(pszmask);
            glblFileSet.addFileMask(pszmask);
         } else {
            // anything else is a PATH mask.
            sprintf(szLineBuf, "*%s*", pszmask);
            glblFileSet.addDirMask(szLineBuf);
         }
      }

      if (btest) return 0;

      glblFileSet.setBaseLayer();

      if (chain.colany())
         cs.nohead = 1;

      nGlblListMode = 2;
      cs.dirMaskAndMatch = 1;
      cs.incFNameInPath  = 1;
      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);
      info.clear();

      if (!cs.quiet) {
         if (cs.noFiles)
            printf("%u non-regular files skipped.\n", cs.noFiles);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "data"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk data [options] col \"<run>namecom,<run>stradr,<run>city\" [numrec]\n"
             "\n"
             "   create numrec records of random text\n"
             "   to produce synthetic test or example data.\n"
             "\n"
             "   $formal syntax\n"
             "     sfk data format template [numrec]\n"
             "\n"
             "   $supported template formats\n"
             "     #col[umns]<def>  a list of data columns, with each column\n"
             "                content type prefixed by <run>.\n"
             "     #text<def>       create a text, keeping commas as is\n"
             "\n"
             "   $template format details\n"
             "     #col<def>  format:\n"
             "     - column types must be prefixed by <run>\n"
             "     - columns are separated by comma on input\n"
             "       which is replaced by TAB character on output\n"
             "     #text<def> format:\n"
             "     - symbols must be prefixed by <run>\n"
             "     - comma \",\" is kept within text as is\n"
             "\n"
             "   $predefined column types\n"
             "     #nameper<def>    name of a person\n"
             "     #namecom<def>    name of a company\n"
             "     #stradr<def>     street address\n"
             "     #city<def>       city name\n"
             "     #statecode<def>  two character string\n"
             "     #zip<def>        five digit string\n"
             "     #person<def>     person address record\n"
             "     #company<def>    company address record\n"
             "     #date<def>       $$year$$month$$day\n"
             "     #time<def>       $$hour$$minute$$second\n"
             "     #timemin<def>    $$hour$$minute\n"
             "     #dig<def>        single digit\n"
             "\n"
             "   $options\n"
             "     -makedb db.txt  export database to out.txt for editing\n"
             "     -from   db.txt  load phrase database from db.txt\n"
             "     -seed   n       set random seed to a fixed value\n"
             "\n");
      printx("   $quoted multi line parameters are supported in scripts\n" // data
             "      using full trim. type \"sfk script\" for details.\n"
             "\n");
      printx("   $chaining support\n"
             "      cannot use chain input data.\n"   // sfk1833
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "     #sfk data col \"<run>namecom,<run>stradr,<run>city <run>statecode <run>zip\" 20\n"
             "       create 20 records with random company data\n"
             "\n"
             "     #sfk data col \"<run>company\" 20 +tabtocsv -quoteall\n"
             "       same as above, but using the predefined company type\n"
             "       and with comma separated fully quoted output\n"
             "\n"
             "     #sfk label begin\n"
             "     # +data col \"<run>namecom,<run>stradr,<run>city\" 20\n"
             "     #  +filter -stabform \"\n"
             "     #    <company>\\n\n"
             "     #    \\x20  <name><run>col1</name>\\n\n"
             "     #    \\x20  <street><run>col2</street>\\n\n"
             "     #    \\x20  <city><run>col3</city>\\n\n"
             "     #    </company>\"\n"
             "       produce xml data in an sfk script. the \\x20 keeps\n"
             "       initial spaces in the line.\n"
             "\n"
             "     #sfk data text \"<run>news\"\n"
             "       create a california business news text\n"
             "\n"
             );
      ehelp;

      sfkarg;

      char *pszAll   =  0;
      int  iNumRec   = -1;
      int  iTemplate =  0;
      uint nSeed     = (uint)time(NULL);
      bool bForceSeed = 0;

      char *pszSrc   = strdup((char*)szGlblPhraseData);

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-from", &pszParm)) {
            if (!pszParm) return 9;
            delete [] pszSrc;
            if (!(pszSrc = loadFile(pszParm, 0)))
               return 9;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-makedb", &pszParm)) {
            if (!pszParm) return 9;
            delete [] pszSrc;
            if (saveFile(pszParm, (uchar*)szGlblPhraseData, strlen(szGlblPhraseData)))
               return 9;
            printf("saved to: %s\n", pszParm);
            return 0;
         }
         if (haveParmOption(argx, argc, iDir, "-seed", &pszParm)) {
            if (!pszParm) return 9;
            nSeed = atoi(pszParm);
            bForceSeed = 1;
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!iTemplate) {
            if (!strncmp(pszArg, "col", 3))
               { iTemplate=1; continue; }
            if (!strcmp(pszArg, "text"))
               { iTemplate=2; continue; }
            return 9+perr("invalid command: %s", pszArg);
         }
         if (!pszAll) {
            if (iGlblInScript) // then pszArg is writeable
               fixMultiLineParm(pszArg, 't'); // sfk187
            pszAll = pszArg;
            continue;
         }
         if (iNumRec < 0) {
            iNumRec = atoi(pszArg);
            continue;
         }
         return 9+pbad(pszCmd, pszArg);
      }

      CharAutoDel odel(pszSrc);

      if (!pszAll)
         return 9+perr("missing template text");

      if (!strBegins(pszSrc, "#:sfk-phrase-db:")) {
         perr("invalid or missing phrase database header\n");
         pinf("file must start with: #:sfk-phrase-db:\n");
         return 9;
      }

      if (iNumRec < 0)
         iNumRec = 1;

      if (bGlblRandSeeded==0 || bForceSeed==1) {
         bGlblRandSeeded = 1;
         srand(nSeed); // data, checks seeded
      }

      // convert , to tab for all
      char *psrc = pszAll;
      char *pdstcur = (char*)abBuf;
      char *pdstmax = pdstcur + MAX_ABBUF_SIZE;
      while (*psrc != 0 && pdstcur < pdstmax)
      {
         if (iTemplate==1 && *psrc == ',') {
            *pdstcur++ = '\\';
            *pdstcur++ = '\t';
         }
         else
         if (iTemplate==2 && *psrc == ',') {
            *pdstcur++ = '\x01';
         }
         else
         if (*psrc == '#')
            *pdstcur++ = '$';
         else
            *pdstcur++ = *psrc;
         psrc++;
      }
      *pdstcur = '\0';
      pszAll = (char*)abBuf;

      // convert , to tab for data
      psrc = pszSrc;
      pdstcur = pszSrc;
      for (; *psrc; psrc++) {
         if (!strncmp(psrc, "\\,", 2)) {
            *pdstcur++ = '\\';
            *pdstcur++ = '\t';
            psrc++;
            continue;
         }
         if (!strncmp(psrc, "\\;", 2)) {
            *pdstcur++ = ';';
            psrc++;
            continue;
         }
         if (*psrc == ';') {
            *pdstcur++ = '\x01';
            continue;
         }
         *pdstcur++ = *psrc;
      }
      *pdstcur = '\0';

      execPhraser(pszAll, (char*)pszSrc, iNumRec);

      if (iChainNext) {
         STEP_CHAIN(iChainNext, 1);
      }

      bDone = 1;
   }

   /*
   if (strBegins(pszCmd, "tobase64") || strBegins(pszCmd, "frombase64"))
   {
      if (nparm < 1) {
         printx("<help>$sfk tobase64 infile [outfile]\n"
            "$sfk frombase64 infile outfile\n"
            );
         return 9;
      }

      sfkarg;

      bool bencode = strBegins(pszCmd, "tobase64");

      char *pszInFile  = 0;
      char *pszOutFile = 0;
      int iChainNext   = 0;

      for (; iDir<argc; iDir++)
      {
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszInFile)  pszInFile = argx[iDir];
         else
         if (!pszOutFile) pszOutFile = argx[iDir];
         else
            return 9+perr("unexpected: %s\n", argx[iDir]);
      }

      if (!pszInFile)  return 9+perr("missing input filename.\n");
      if (!bencode && !pszOutFile) return 9+perr("missing output filename.\n");

      num nFileSize = 0;
      uchar *pdata = loadBinaryFile(pszInFile, nFileSize);
      if (!pdata) return 9;

      num nOutSize = nFileSize * 2; // approx.
      uchar *pout = new uchar[nOutSize+100];
      if (!pout) return 9+perr("out of memory.\n");

      int nrc = 0;
      int nsave = -1;
      if (bencode) {
         nrc = encode64(pdata, nFileSize, pout, nOutSize, 40);
         if (nrc)
            perr("encoding failed, rc %d\n", nrc);
         else
            nsave = strlen((char*)pout);
      } else {
         nrc = decode64(pdata, nFileSize, pout, nOutSize);
         if (nrc < 0)
            perr("decoding failed.");
         else
            nsave = nrc;
      }

      if (nsave >= 0)
      {
         if (!pszOutFile) {
            printf("%s",pout);
         } else {
            FILE *fout = fopen(pszOutFile, "wb");
            if (fout) {
               int ndone = myfwrite(pout, nsave, fout);
               if (ndone != nsave)
                  perr("failed to fully write output file");
               fclose(fout);
            }
         }
      }

      delete [] pdata;
      delete [] pout;

      bDone = 1;
   }
   */

   ifcmd (!strcmp(pszCmd, "encode") || !strcmp(pszCmd, "decode"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk encode|decode [infile] format [options]\n"
             "\n"
             "   en- or decode text or data.\n"
             "\n"
             "   $formats\n"
             "      -base64    encode all chars as a-z A-Z 0-9 +/\n"
             "                 with = used as padding character.\n"
             "                 add -nowrap to keep the output\n"
             "                 as one long line.\n"
             "      -hex       encode all chars as hexadecimal\n"
             "      -_hex      encode non-alphanumeric characters\n"
             "                 as prefix _ and hex value\n"
             "      -\\x25hex   encode non-alnum chars as %% and hex\n"
             "      -url       same as -\\x25hex\n"
             "\n"
             "   $options\n"
             "      -all       encode all chars, not just non-alnum\n"
             "      -noeol     if text lines are received from a previous\n"
             "                 command then strip line end characters.\n"
             "                 default on encode with single input line\n"
             "                 and on hex decode without prefix.\n"
             "                 does nothing when loading from a file.\n"
             "      -tofile x  write output to file x.\n"
             "      -dump      show output data as hexdump.\n"
             "\n"
             "   $see also\n"
             "      #sfk hexdump<def>   produce hex data in many formats\n"
             "      #sfk hextobin<def>  convert many hex formats to binary\n"
             "      #sfk uuencode<def>  encode many files as plain text\n"
             "      #sfk md5<def>       create checksum of file(s)\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk encode in.jpg -base64 -tofile out.txt\n"
             "         encodes in.jpg as base64, writing to out.txt\n"
             "      #sfk decode in.txt -base64 -tofile out.dat\n"
             "         decodes in.txt from base64, writing to out.dat\n"
             "      #sfk echo -spat \"foo bar\" +encode -url\n"
             "         produces: foo%%20bar\n"
             "      #sfk echo \"foo_20bar\" +decode -_hex\n"
             "         produces: foo bar\n"
             #ifdef _WIN32
             "      #sfk fromclip +decode -url\n"
             "         make an url copied from a web page readable\n"
             "         by changing \"foo%%20bar\" to \"foo bar\".\n"
             #endif
             "\n"
             );
      ehelp;

      sfkarg;

      bool bencode  = strcmp(pszCmd, "encode") ? 0 : 1;
      int  imode    = 0;
      bool bstdin   = 0;
      bool bHexDump = 0;
      int  nlinechars = 40;
      char szPat[100]; mclear(szPat);
      char abToEncode[256];

      // encode default for _hex: selected chars
      memset(abToEncode, 1, sizeof(abToEncode));
      for (char c='a';c<='z';c++) abToEncode[c]=0;
      for (char c='A';c<='Z';c++) abToEncode[c]=0;
      for (char c='0';c<='9';c++) abToEncode[c]=0;

      char *pszInFile  = 0;

      if (bencode && (chain.indata->numberOfEntries() < 2))
         cs.szeol[0]='\0';

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-i")) {
            bstdin = 1;
            continue;
         }
         if (strBegins(pszArg, "-dump")) {
            bHexDump = 1;
            if (!strcmp(pszArg, "-dumpraw"))
               cs.leattr = 0;
            else
               cs.leattr = 'e';
            continue;
         }
         if (strBegins(pszArg, "-noeol")) {
            cs.szeol[0]='\0';
            continue;
         }
         if (strBegins(pszArg, "-all")) {
            memset(abToEncode, 1, sizeof(abToEncode));
            continue;
         }
         // format options
         if (!strcmp(pszArg,"-base64"))
            { imode=1; continue; }
         if (!strcmp(pszArg,"-nowrap"))
            { nlinechars=0; continue; }
         if (pszArg[0]=='-' && (!strcmp(pszArg,"-url") || strstr(pszArg,"hex")))
         {
            if (imode)
               return 9+perr("unexpected: %s",pszArg);
            copyFormStr(szPat,sizeof(szPat),pszArg+1,strlen(pszArg+1),2);
            // hex or _hex
            imode=2;
            // hex all chars
            if (!strcmp(szPat,"hex")) {
               memset(abToEncode, 1, sizeof(abToEncode));
               szPat[0]='\0';
               continue;
            }
            // url convenience
            if (!strcmp(szPat,"url")) {
               strcpy(szPat, "%hex");
               continue;
            }
            // prefixed hex selected chars
            if (strlen(szPat)<4 || strcmp(szPat+1,"hex")!=0)
               return 9+perr("unexpected mode: %s\n", pszArg);
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszInFile)
            { pszInFile = pszArg; continue; }
         return 9+perr("unexpected: %s\n", pszArg);
      }

      uchar *pInText = 0;
      char  *pInAttr = 0;
      num    nInSize = 0;

      uchar *pOutText= 0;
      char  *pOutAttr= 0;
      num    nOutSize= 0;

      // input
      if (loadInput(&pInText, &pInAttr, &nInSize, bstdin, pszInFile, 0))
         return 9;
      if (cs.verbose) {
         printf("[%s loaded %d input bytes:]\n",pszCmd,(int)nInSize);
         termHexdump(pInText, nInSize);
      }

      // processing
      nOutSize = (nInSize + 10) * 3; // approx.
      pOutText = new uchar[nOutSize+100];
      if (!pOutText) return 9+perr("out of memory.\n");

      int nrc = 0;
      int nOutLen = 0;
      if (bencode) {
         if (imode==2)
            nrc = encodeHex(pInText, nInSize, (char*)pOutText, nOutSize, szPat[0], abToEncode);
         else
            nrc = encode64(pInText, nInSize, pOutText, nOutSize, nlinechars);
         if (nrc < 0)
            return 9+perr("encoding failed\n");
         nOutLen = strlen((char*)pOutText);
      } else {
         if (imode==2)
            nrc = decodeHex((char*)pInText, nInSize, (char*)pOutText, nOutSize, szPat[0]);
         else
            nrc = decode64(pInText, nInSize, pOutText, nOutSize);
         if (nrc < 0)
            return 9+perr("decoding failed");
         nOutLen = nrc;
      }
      if (cs.verbose) {
         printf("[%s produced %d output bytes:]\n",pszCmd,(int)nOutLen);
         termHexdump(pOutText, nOutLen);
      }

      // output
      if (dumpOutput(pOutText, pOutAttr, nOutLen, bHexDump) == 1)
         printf("\n");

      if (pOutText) delete [] pOutText;
      if (pOutAttr) delete [] pOutAttr;
      if (pInText)  delete [] pInText;
      if (pInAttr)  delete [] pInAttr;

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "chars") || !strcmp(pszCmd, "char")) // +wref
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk chars word [word2]\n"
             "$sfk ... +chars\n"
             "\n"
             "   print character codes of all chars of a word,\n"
             "   or print chars for the given code(s).\n"
             #ifdef _WIN32
             "\n"
             "   under Windows this lists both Ansi and OEM codes\n"
             "   as decimal and hexadecimal (0x) value.\n"
             "   if you see a decimal OEM code like 097 you can\n"
             "   keep Alt pressed, then type 097, release Alt\n"
             "   to produce this character in the console.\n"
             #endif
             "\n"
             "   $options\n"
             #ifdef _WIN32
             "      -nohead   do not show table header\n"
             "      -min      minimal format as under linux\n"
             #endif
             "      -codes    force listing of character codes,\n"
             "                do not check if word is a number.\n"
             "      -literal  or -lit stops interpretation of any further\n"
             "                options or chain commands. required if you\n"
             "                need the code of \"-\" or \"+\".\n"
             "      -hexlist  print flat list of hex codes\n"
             "      -hexsrc   print as hex source code\n"
             "      -fromutf  decode utf8 sequence from hexadecimal\n"
             "                input like 0xe28098\n"
             "\n"
             "   $command chaining support\n"
             "      accepts text or binary from a previous command.\n"
             "\n");
      webref("chars");
      printx("   $examples\n"
             "      #sfk chars hello\n"
             "         prints 5 lines of codes, one for each char.\n"
             "      #sfk chars 0x53464b\n"
             "         prints 'SFK', the letters for these hex codes.\n"
             "         any number of hex values can be provided.\n"
             "      #sfk chars -fromutf 0x54657374e28098e28099\n"
             "         decodes ASCII characters and UTF-8 sequences,\n"
             "         listing code points of each character found.\n"
             "      #sfk char 65\n"
             "         prints 'A', the letter for that decimal code.\n"
             "         only a single decimal value can be provided.\n"
             "      #sfk char -lit +\n"
             "         print the code of the plus char.\n"
             #ifdef _WIN32
             "      #sfk fromclip +chars\n"
             "         show codes from the word in the clipboard.\n"
             #endif
             "      #sfk chars 84 101 115 116 105 110 103\n"
             "         show characters for these ascii codes.\n"
             );
      ehelp;
 
      sfkarg;

      char *pword  = 0;
      bool bdecode = 0;
      bool blit    = 0;
      bool butf    = 0;
      int  iFormat = 0;
      uint uixor   = 0;
      int  iutf    = 0;
      #ifdef _WIN32
      bool boem    = 1;
      bool bmin    = 0;
      #else
      bool boem    = 0;
      bool bmin    = 1;
      #endif
      int  ifirst  = 0;
      int  ilast   = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (!blit) {
            if (!strcmp(argx[iDir], "-min"))  { bmin=1; continue; }
            if (!strcmp(argx[iDir], "-full")) { bmin=0; continue; }
            if (!strcmp(argx[iDir], "-oem"))  { boem=1; continue; }
            if (strBegins(argx[iDir], "-code")) {
               bdecode = 1;
               continue;
            }
            if (strBegins(argx[iDir], "-lit")) {
               blit = 1;
               continue;
            }
            if (strBegins(argx[iDir], "-fromutf")) {
               butf = 1;
               continue;
            }
            if (!strcmp(argx[iDir], "-hexlist")) {
               iFormat = 1;
               continue;
            }
            if (!strcmp(argx[iDir], "-hexsrc")) {
               iFormat = 2;
               continue;
            }
            if (haveParmOption(argx, argc, iDir, "-xor", &pszParm)) {
               if (!pszParm) return 9;
               uixor = (uint)myatonum(pszParm);
               continue;
            }
            if (sfkisopt(argx[iDir])) {
               if (isDirParm(argx[iDir]))
                  break; // fall through
               if (setGeneralOption(argx, argc, iDir))
                  continue;
               else
                  return 9+perr("unknown option: %s\n", argx[iDir]);
            }
            if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
               break;
         }
         // process non-option keywords:
         if (!pword) {
            ifirst=iDir; ilast=iDir;
            pword = argx[iDir]; continue; 
         }
         ilast=iDir;
         // return 9+pbad(pszCmd, argx[iDir]);
      }

      uchar *pInText = 0;
      num    nInSize = 0;
      if (chain.useany()) {
         if (pword)
            return 9+perr("conflicting input, found chain input data and data parameter.");
         if (loadInput(&pInText, 0, &nInSize, 0,0,0))
            return 9;
         pword = (char*)pInText;
      }
      UCharAutoDel odel(pInText);

      if (!pword)
         return 9+perr("missing argument\n");

      #ifdef _WIN32
      char   szlean[50]; mclear(szlean);
      ushort awide[50];  mclear(awide);
      #endif

      if (!iFormat && !butf && !bmin && !cs.nohead) {
         if (boem) {
            chain.print("Ansi\t\tChar\tOEM\t\tUnicode\n");
            chain.print("----\t\t----\t---\t\t-------\n");
         } else {
            chain.print("Ansi\t\tChar\tUnicode\n");
            chain.print("----\t\t----\t-------\n");
         }
      }

      while (1)
      {
         bool bjustdigits = 1;
         for (char *psz=pword; *psz; psz++)
            if (!isdigit(*psz))
               bjustdigits = 0;
   
         if (!bdecode && (bjustdigits || strBegins(pword, "0x")))
         {
            if (bjustdigits) {
               int npre = atol(pword);
               if (npre > 255)
                  return 9+perr("value too large");
               uchar uc = (uchar)npre;
               printCharInfoRow(uc, boem, bmin);
            } else {
               pword += 2;
               for (; *pword; pword+=2) {
                  if (strlen(pword) == 0)
                     break;
                  if (strlen(pword) == 1)
                     return 9+perr("unexpected character: %s\n", pword);
                  uchar uc = (uchar)getTwoDigitHex(pword);
                  if (butf) {
                     if (iutf > MAX_LINE_LEN)
                        return 9+perr("overflow");
                     szLineBuf[iutf++] = uc;
                  } else {
                     printCharInfoRow(uc, boem, bmin);
                  }
               }
               if (butf) {
                  UTF8Codec utf(szLineBuf, iutf);
                  while (utf.hasChar()) {
                     uint n = utf.nextChar();
                     chain.print("U+%04X\t%c\n", n, unicodeToIso(n));
                  }
               }
            }
         }
         else
         {
            for (; *pword; pword++)
            {
               uchar uc = ((uchar)*pword) ^ uixor;
               switch (iFormat)
               {
                  case 1:
                     chain.print(' ', 0, "%02X", uc);
                     break;
                  case 2:
                     chain.print(' ', 0, "0x%02X%s", uc, pword[1]?",":"");
                     break;
                  default:
                     printCharInfoRow(uc, boem, bmin);
                     break;
               }
            }
         }

         if (ifirst>0 && ifirst<ilast) {
            ifirst++;
            pword=argx[ifirst];
            continue;
         }

         break;
      }
 
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strncmp(pszCmd, "hextobin", 9)) // +wref
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk ... +hextobin outfile\n"
             "\n"
             "   convert lines of text containing hexdump to binary.\n"
             "\n"
             "   $chain-only command\n"
             "      hextobin can be used only #after another command<def>,\n"
             "      typically filter, which reads and prepares the input data.\n"
             "\n"
             "   $options\n"
             "      -fuzzy    ignore >< and ## characters\n"
             "      -verbose  tell conversion statistics\n"
             "\n"
             "   $supported input formats since SFK 1.6.9:\n"
             "\n"
             "      - if >...< is found then only hex data inside that is used.\n"
             "      - if ## is found then only hex data before that is used.\n"
             "      - else any hex characters are used, and with\n"
             "        option -fuzzy any >< or ## characters are ignored.\n"
             "      - whitespace at line start is ignored.\n"
             "\n"
             "   $1. sfk hexdump full bracket delimited format:\n"
             "\n"
             "      :file test.dat\n"
             "       >6578616D 706C6520 77697468 206E6F6E< example with non 00000000\n"
             "       >20616C6E 756D0D0A 63686172 61637465<  alnum..characte 00000010\n"
             "       >73202D2B 28295C2F 2E0D0A<            s -+()\\/...      00000020\n"
             "\n"
             "   $2. sfk postdump minimal format, for forums and wiki:\n"
             "\n"
             "      :file test.dat\n"
             "      65 78 61 6D 70 6C 65 20 77 69 74 68 20 6E 6F 6E ## example.with.non 0000\n"
             "      20 61 6C 6E 75 6D 0D 0A 63 68 61 72 61 63 74 65 ## .alnum..characte 0010\n"
             "      73 20 2D 2B 28 29 5C 2F 2E 0D 0A                ## s..........      0020\n"
             "\n"
             "   $3. any text with hex data inbetween that does not contain\n"
             "      $the >< or ## characters (else -fuzzy must be used):\n"
             "\n"
             "      --== 6578616D 706C6520 77697468 ==--\n"
             "      // 0x65, 0x78, 0x61, 0x6D ::\n"
             "\n"
             "   $input line length limitation:\n"
             "      text lines in the input file should not be longer than\n"
             "      4000 characters or sfk filter will split them, causing\n"
             "      hextobin to produce errors like \"wrong hex format\".\n"
             "\n");
      webref("hextobin");
      printx("   $examples\n"
             "      #sfk filter dump.txt +hextobin out.dat\n"
             "         convert file dump.txt and write to out.dat\n"
             #ifdef _WIN32
             "\n"
             "      #sfk fromclip +hextobin %%TEMP%%\\tmp1.dat +hexdump\n"
             "         takes a hex sequence like 22737769 73732066 from clipboard,\n"
             "         printing its text via a temporary file and hexdump.\n"
             #endif
            );
      ehelp;

      sfkarg;

      if (!chain.usedata) {
         perr("%s needs input data from a previous command.\n", pszCmd);
         pinf("type \"sfk hextobin\" for help.\n");
         return 9;
      }

      char *pszOutFile = 0;
      bool bFuzzy = 0;
      bool bverbose = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-fuzzy")) {
            bFuzzy = 1;
            continue;
         }
         if (!strcmp(pszArg, "-verbose")) {
            bverbose=1;
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         pszOutFile = argx[iDir];
      }

      FILE *fout=0;

      if (chain.coldata && chain.colbinary) {
         // no file output
      } else {
         if (!pszOutFile)
            return 9+perr("hextobin: missing output filename.\n");
         if (!(fout = fopen(pszOutFile, "wb")))
            return 9+perr("hextobin: cannot write: %s\n", pszOutFile);
      }

      SFKMD5 outmd;

      uchar *poutmax = abBuf + sizeof(abBuf) - 100;
      bool berr=0,bprefix=0;
      int nConvLines=0, nSkippedLines=0;
      num nTotalBytes = 0;
      for (int i=0; !berr && i<chain.indata->numberOfEntries(); i++)
      {
         // fetch another hex input line
         char *pszLine = chain.indata->getEntry(i, __LINE__);
         // skip initial whitespace
         while (*pszLine!=0 && (*pszLine==' ' || *pszLine=='\t'))
            pszLine++;
         // auto-skip filename header
         if (!strncmp(pszLine, ":file ", 6)) {
            pinf("skipping filename line on input\n");
            continue;
         }
         // >3135302E 38343820 42797465 73206672<
         char  *psz  = pszLine;
         uchar *pout = abBuf;
         char szByte[10];
         int iLineState=0;
         while (*psz)
         {
            // skip over noise like " > "
            while (*psz && !isxdigit(*psz)) {
               if (!bFuzzy)
               switch (iLineState) {
                  case 0:
                     if (*psz=='>') iLineState=1;
                     if (*psz=='#') iLineState=2;
                     break;
                  case 1:
                     if (*psz=='<') iLineState=2;
                     break;
               }
               psz++;
            }
            if (iLineState==2)
               break;
            bprefix = 0;
            if (!strncmp(psz, "0x", 2)) {
               bprefix = 1;
               psz += 2; // 0x12,0x15, 0x19
            }
            if (!*psz) break;
            szByte[0] = psz[0];
            if (isxdigit(psz[1])) {
               // two hex chars: 00 57 38 29
               szByte[1] = psz[1];
               szByte[2] = '\0';
               psz += 2;
            }
            else if (bprefix) {
               // FIX 163R5: accept single hex char expression "0xa "
               szByte[1] = '\0';
               psz += 1;
            }
            else {
               perr("wrong hex format: \"%s\"\n", psz);
               berr=1;
               break;
            }
            *pout++ = (uchar)strtol(szByte, 0, 0x10);
            if (pout >= poutmax) { perr("buffer overflow: input lines too large\n"); berr=1; break; }
         }
         // flush collected binary line
         int nBinSize = pout-abBuf;
         if (nBinSize > 0) {
            if (chain.coldata && chain.colbinary) {
               if (chain.addBinary(abBuf, nBinSize))
                  return 9;
            } else {
               if ((int)myfwrite(abBuf, nBinSize, fout) != nBinSize) {
                  esys("fwrite", "failed to write %s   \n", pszOutFile);
                  berr=1;
                  break;
               }
            }
            outmd.update(abBuf, nBinSize);
            nTotalBytes += pout-abBuf;
            nConvLines++;
         } else {
            nSkippedLines++;
         }
      }

      if (fout)
         fclose(fout);

      if (cs.quiet || (chain.coldata && !bverbose))
         { } // sfk1841
      else
      {
         printf("%d lines converted, %d skipped, %s output bytes.\n", nConvLines, nSkippedLines, numtoa(nTotalBytes));
         unsigned char *pmd5 = outmd.digest();
         for (int i=0; i<16; i++)
            sprintf(&szLineBuf[i*2], "%02x", pmd5[i]);
         printf("md5: %s\n", szLineBuf);
      }

      // pass output filename if requested
      if (chain.colfiles) {
         Coi ocoi(pszOutFile, 0);
         chain.addFile(ocoi); // is copied
         STEP_CHAIN(iChainNext, 1);
      } else {
         // producing command
         STEP_CHAIN(iChainNext, chain.coldata); // sfk181 hextobin always
      }

      bDone = 1;
   }

   regtest("dupfind -listorg -minsize=3m");

   ifcmd (!strncmp(pszCmd, "dupfind", 3)
          || !strncmp(pszCmd, "syncname", 8)) // sfk197
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      if (bhelp || !strncmp(pszCmd, "syncname", 8))
         printHelpText("syncnames", bhelp);
      if (bhelp ||  strncmp(pszCmd, "syncname", 8))
         printHelpText("dupfind", bhelp);
      ehelp;

      sfkarg;

      glblDupScan.reset();

      if (!strncmp(pszCmd, "syncname", 8))
      {
         glblDupScan.clSyncNames = 1;
         glblDupScan.clDiffDirs = 1;
         cs.crcmd5 = 1;
      }

      bool blistorg  = 0;
      int  nsyncdirs = 0;
      bool bgotdirs  = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-minsize", &pszParm)) {
            if (!pszParm) return 9;
            cs.selMinSize = numFromSizeStr(pszParm, "-minsize");
            if (cs.selMinSize < 0) return 9;
            continue;
         }
         if (!strcmp(pszArg, "-diffdir")) {
            glblDupScan.clDiffDirs = 1;
            continue;
         }
         if (!strcmp(pszArg, "-listorg")) {
            blistorg = 1;
            continue;
         }
         if (!strcmp(pszArg, "-byname")) { // internal
            glblDupScan.clByName = 1;
            continue;
         }
         if (!strcmp(pszArg, "-bytime")) { // internal
            glblDupScan.clByTime = 1;
            continue;
         }
         if (!strcmp(pszArg, "-unsafe")) { // internal
            glblDupScan.clUnsafe = 1;
            cs.crcmd5 = 1;
            continue;
         }
         if (glblDupScan.clSyncNames
             && haveParmOption(argx, argc, iDir, "-log", &pszParm)) {
            if (!pszParm) return 9;
            glblDupScan.pszClLog = pszParm;
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (glblDupScan.clSyncNames) {
            if (nsyncdirs >= 2) {
               perr("too many folder names for syncnames");
               pinf("for detailed selection you may use -dir name1 name2 ...\n");
               return 9;
            }
            glblFileSet.addRootDir(pszArg, __LINE__, false, false);
            nsyncdirs++;
            bgotdirs = 1;
            continue;
         }
         break;
      }
 
      num nstart = getCurrentTime();

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argx, iDir, bgotdirs ? 0 : 3, &iDirNext)))
         return lRC;
      if (btest) return 0;

      if (glblDupScan.clDiffDirs && (glblFileSet.numberOfRootDirs() < 2))
         return 9+perr("need at least two -dir parameters with option -diffdir.");

      if (glblDupScan.clSyncNames && (glblFileSet.numberOfRootDirs() != 2))
         return 9+perr("need two -dir parameters with syncnames");

      cs.sim = !cs.yes; // sfk1944

      if (glblDupScan.clSyncNames) {
         // get target root
         glblDupScan.pszClSrcRoot = glblFileSet.clRootDirs.getString(0, 0);
         glblDupScan.pszClDstRoot = glblFileSet.clRootDirs.getString(0, 1);
         if (!glblDupScan.pszClSrcRoot || !glblDupScan.pszClDstRoot)
            return 9+perr("int. #2195276");
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         if (cs.yes && glblDupScan.pszClLog)
            glblDupScan.pClLog = fopen(glblDupScan.pszClLog, "a");
      }

      lRC = walkAllTrees(eFunc_DupScan, lFiles, lDirs, nBytes);
      info.clear();
 
      int nelapsed1 = (int)(getCurrentTime() - nstart);

      glblDupScan.analyze(blistorg);
      info.clear();

      int nelapsed2 = (int)(getCurrentTime() - nstart);

      if (glblDupScan.clSyncNames) { // sfk1944 internal
         if (!cs.quiet) {
            printx("$%s %d files in target dir. <time>skipping %d identical files.\n", cs.sim?"would move":"moved", cs.filesMoved, glblDupScan.clSkipMatch);
         }
      } else {
         if (!chain.colany() && !cs.quiet) {
            printx("$%d duplicates with %d mb.", glblDupScan.clNumDups,(int)(glblDupScan.clDupBytes/1000000));
            if (blistorg)
               printx(" $%d originals with %d mb.\n",glblDupScan.clNumOrgs,(int)(glblDupScan.clOrgBytes/1000000));
            else
               printf("\n");
         }
         if (cs.verbose) {
            printf("scanned %d file infos in %d msec.\n", glblDupScan.clSizes.numberOfEntries(), nelapsed1);
            printf("total duplicate scan took %d msec.\n", nelapsed2);
         }
      }

      if (glblDupScan.clSyncNames && cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      if (glblDupScan.pClLog)
         fclose(glblDupScan.pClLog);

      glblDupScan.reset();
      glblOutFileMap.reset();

      STEP_CHAIN(iDirNext, 1);
 
      bDone = 1;
   }

   ifcmd (!strncmp(pszCmd, "samp", 4) || !strncmp(pszCmd, "examp", 5)) // +wref
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk sample java|cpp|... [outfile.java|.cpp|...]\n"
             "\n"
             "   print a short example code in a programming language.\n"
             "\n"
             "   $supported parameters\n"
             "      sfk          create a simple sfk script\n"
             "      sfkbat       sfk script embedded in a .bat or .cmd\n"
             "      sfkbash      sfk script embedded in a bash script\n"
             "      http         automated http access example script\n"
             "      http -bat    ... as a windows .bat file\n"
             "      http -bash   ... as a linux .sh file\n"
             "      httpdata     create a .zip file with webdemo files\n"
             "                   for local use with sfk httpserv\n"
             "\n"
             "      cmd          create generic windows .cmd or .bat file\n"
             "      bash         create generic linux bash script\n"
             "      html         simple html page with css and javascript\n"
             "      java         create a java class doing text  file I/O\n"
             "      javaimg      create a java class doing image file I/O\n"
             "      javahex      create a hexdump of binary data in java\n"
             "      javagui      create a simple java gui application\n"
             "      cpp          create a c++ text file I/O example\n"
             "      cppnetlog    how to send UDP network text in C++\n"
             "      javanetlog   how to send UDP network text in Java\n"
             "      php          create command line php code for text I/O\n"
             "      phpimg       create php example for image processing\n"
         //  "      sfkcmdphp    mixture of windows .bat, sfk and php,\n"
         //  "                   to list pixel sizes of images in a dir.\n"
             "\n"
             "   $options\n"
             "      -force    if output file exists already, overwrite it.\n"
             "\n"
             "   $command shortcut\n"
             #ifdef _WIN32
             "      #sfk batch myscript.bat\n"
             "         does the same as \"sfk samp sfkbat myscript.bat\"\n"
             #else
             "      #sfk batch myscript\n"
             "         does the same as \"sfk samp sfkbash myscript\"\n"
             #endif
             "\n");
      webref("sample");
      printx("   $more in the SFK Book\n"
             "      the #SFK Book<def> contains a 60 page tutorial, including\n"
             "      long sfk script examples with input, output and\n"
             "      detail explanations. type \"#sfk book<def>\" for more.\n"
             "\n");
      printx("   $examples\n"
             "      #sfk samp sfkbat foo.bat\n"
             "         creates batch file foo.bat with embedded sfk script.\n"
             "         type \"foo.bat\" to run the created script. note that\n"
             "         foo.bat must be created in a directory of your PATH,\n"
             "         or in the current directory.\n"
             "\n"
             "      #sfk batch foo.bat -force\n"
             "         the same as above, and overwrites an existing file.\n"
             "\n"
             "      #sfk batch foo.sh\n"
             "         create a bash script file, with lf only line endings.\n"
             "         can also be used under windows for mingw environments.\n"
             "\n"
             "      #sfk samp java foo.java\n"
             "         create a java class foo. if the java JDK is available,\n"
             "         type \"javac foo.java\" and then \"java foo\" to run it.\n"
             "\n"
             "      #sfk samp phpimg doimg.php\n"
             "         create image processing script that can be run by:\n"
             "         #php doimg.php\n"
             "         if php.exe is in your PATH (read remarks in the script).\n"
             "\n"
             #ifdef _WIN32
             "      #sfk samp javahex +toclip\n"
             "         copy example for java hexdump creation to the clipboard.\n"
             "\n"
             #endif
             #ifdef _WIN32
             "      #sfk samp http tmp.bat\n"
             #else
             "      #sfk samp http tmp.sh\n"
             #endif
             "         create an example script for automated web/http access.\n"
             #ifdef _WIN32
             "\n"
             "      #sfk samp http -bash tmp.sh\n"
             "         the same, but using bash in a Windows Cygwin environment.\n"
             #endif
             );
      ehelp;

      sfkarg;

      bool bbatch        = 0;
      bool bWriteFile    = 0;
      int nlang          = 0;
      char *pszLang      = str("");
      char *pszOutFile   = 0;
      char *pszClassName = str("fileio");
      bool bLocalFile    = 0;
      int  iSystem       = 0;
      #ifdef _WIN32
      int  iDefaultSystem = 1;
      #else
      int  iDefaultSystem = 2;
      #endif

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-bat")) {
            iSystem = 1;
            continue;
         }
         if (!strcmp(pszArg, "-bash")) {
            iSystem = 2;
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // template keywords are non-option keywords
         char *pszkey = argx[iDir];
         if (nlang == 0) {
            // expecting language as next key
            if (!strcmp(pszkey, "java"))      nlang =  1; else
            if (!strcmp(pszkey, "cpp"))       nlang =  2; else
            if (!strcmp(pszkey, "cmd"))       nlang =  3; else // allow path begin
            if (!strcmp(pszkey, "bash"))      nlang =  4; else
            if (!strcmp(pszkey, "sfk"))       nlang =  5; else
            if (!strcmp(pszkey, "sfkcmd"))    nlang =  6; else
            if (!strcmp(pszkey, "sfkbat"))    nlang =  6; else
            if (!strcmp(pszkey, "sfkbash"))   nlang =  7; else // allow path end
            if (!strcmp(pszkey, "javaimg"))   nlang =  8; else
            if (!strcmp(pszkey, "php"))       nlang =  9; else
            if (!strcmp(pszkey, "phpimg"))    nlang = 10; else
            if (!strcmp(pszkey, "html"))      nlang = 11; else
            if (!strcmp(pszkey, "sfkcmdphp")) nlang = 12; else
            if (!strcmp(pszkey, "javahex"))   nlang = 13; else
            if (!strcmp(pszkey, "javagui"))   nlang = 14; else
            if (!strcmp(pszkey, "cppnetlog")) nlang = 16; else
            if (!strcmp(pszkey, "javanetlog")) nlang = 17; else
            if (!strcmp(pszkey, "http"))     { nlang = 18;
               if (iSystem==0) iSystem=iDefaultSystem;
            }
            else if (!strcmp(pszkey, "httpdata")) { nlang = 19;
               if (!pszOutFile)
                  pszOutFile = str("web-demo-data.zip");
            }
            else
               return 9+perr("unknown example: %s\n", pszkey);
         } else {
            pszOutFile = pszkey;
         }
      }

      if (nlang == 19) {
         printSamp(nlang, pszOutFile, 0, 0, 0);
         return 0;
      }

      // sfk181: batch language from file extension
      cchar *pszFileMode = "w";
      if (bbatch && pszOutFile) {
         if (strEnds(pszOutFile, ".bat"))
            nlang = 6;
         if (strEnds(pszOutFile, ".sh"))
            nlang = 7;
      }
      if (iSystem==2 || (pszOutFile && strEnds(pszOutFile, ".sh")))
         pszFileMode = "wb";

      if (!bLocalFile && pszOutFile) {
         switch (nlang) {
            // sfk181: allow path with these
            case 3: case 4: case 5: case 6: case 7:
               break;
            default:
               if (strchr(pszOutFile, glblPathChar))
                  return 9+perr("no path allowed in output filename.\n");
         }
         // isolate class name from output filename
         strcopy(szLineBuf, pszOutFile);
         char *psz = strchr(szLineBuf, '.');
         if (psz) {
            *psz = '\0';
            pszClassName = szLineBuf;
         }
         else
         if (nlang < 3)
            return 9+perr("need an output filename like x.java or x.cpp\n");
         if (!cs.force && fileExists(pszOutFile)) {
            perr("file already exists: %s\n", pszOutFile);
            pinf("add -force to overwrite.\n");
            return 9;
         }
         if (!(cs.outfile = fopen(pszOutFile, pszFileMode)))
            return 9+perr("cannot write: %s\n", pszOutFile);
      }

      if (bLocalFile && pszOutFile) {
         if (!strcmp(pszOutFile, "write"))
            bWriteFile = 1;
         else
            return 9+perr("specify \"write\" or nothing after %s\n", pszLang);
      }

      printSamp(nlang, pszOutFile, pszClassName, bWriteFile, iSystem);

      if (cs.outfile) {
         fclose(cs.outfile);
         cs.outfile = 0;
         if (!bLocalFile)
            printf("written: %s\n", pszOutFile);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "batch")) // sfk197 separate
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk batch outfile.[bat|sh] [options]\n"
             "\n"
             "   create a default sfk script batch file.\n"
             "\n"
             #ifdef _WIN32
             "      use a filename ending with .bat to create\n"
             "      a normal windows batch file.\n"
             "\n"
             "      use a filename ending with .sh to create\n"
             "      a bash script file for use with linux\n"
             "      or a windows cygwin environment.\n"
             "\n"
             #endif
             "   $options\n"
          // "      -min      create a minimal script example. (default)\n"
             "      -full     create a full file backup example script\n"
             "                with different commands on the same file set.\n"
             "      -force    if output file exists already, overwrite it.\n"
             "\n"
             "   $see also\n"
             "      #sfk samp[def]  print examples for all kinds of script and\n"
             "                programming languages.\n"
             "\n");
      printx("   $more in the SFK Book\n"
             "      the #SFK Book<def> contains a 60 page tutorial, including\n"
             "      long sfk script examples with input, output and\n"
             "      detail explanations. type \"#sfk book<def>\" for more.\n"
             "\n");
      printx("   $examples\n"
             "      #sfk batch tmp.bat\n"
             "         creates batch file tmp.bat with embedded sfk script.\n"
             "         type \"tmp.bat\" to run the created script.\n"
             "\n"
             "      #sfk batch tmp.bat -full -force\n"
             "         create a large file backup example script.\n"
             "         overwrite an existing tmp.bat file.\n"
             "\n"
             "      #sfk batch foo.sh\n"
             "         create a bash script file, with lf only line endings.\n"
             "         can also be used under windows for mingw environments.\n"
             );
      ehelp;

      sfkarg;

      bool bbatch        = 1;
      bool bWriteFile    = 0;
      int nlang          = 0;
      char *pszLang      = str("");
      char *pszOutFile   = 0;
      char *pszClassName = str("fileio");
      bool bLocalFile    = 0;
      int  iSystem       = 0;
      #ifdef _WIN32
      int  iDefaultSystem = 1;
      #else
      int  iDefaultSystem = 2;
      #endif
      int  ibatchoffset  = 0;

      if (bbatch) {
         #ifdef _WIN32
         nlang = 6;
         #else
         nlang = 7;
         #endif
      }

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-bat")) {
            iSystem = 1;
            continue;
         }
         if (!strcmp(pszArg, "-bash")) {
            iSystem = 2;
            continue;
         }
         if (bbatch && !strcmp(pszArg, "-min"))
            { ibatchoffset = 0; continue; }
         if (bbatch && !strcmp(pszArg, "-full"))
            { ibatchoffset = 100; continue; }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!pszOutFile) {
            pszOutFile = pszArg; 
            continue; 
         }
         return 9+perr("unexpected: %s", pszArg);
      }

      cchar *pszFileMode = "w";
      if (bbatch && pszOutFile) {
         if (strEnds(pszOutFile, ".bat"))
            nlang = 6;
         if (strEnds(pszOutFile, ".sh"))
            nlang = 7;
         if (!strcmp(pszOutFile, "tcp.bat"))
            { nlang = 20; iSystem = 1; }
         if (!strcmp(pszOutFile, "tcp.sh"))
            { nlang = 20; iSystem = 2; }
         if (!strcmp(pszOutFile, "vedit.bat"))
            { nlang = 21; iSystem = 1; }
         if (!strcmp(pszOutFile, "proxy.bat"))
            { nlang = 22; iSystem = 1; }
         if (!strcmp(pszOutFile, "proxy.sh"))
            { nlang = 22; iSystem = 2; }
         if (!strcmp(pszOutFile, "webreq.bat"))
            { nlang = 23; iSystem = 1; }
         if (!strcmp(pszOutFile, "webreq.sh"))
            { nlang = 23; iSystem = 2; }
      }
      if (iSystem==2 || (pszOutFile && strEnds(pszOutFile, ".sh")))
         pszFileMode = "wb";

      if (!bLocalFile && pszOutFile) {
         switch (nlang) {
            // sfk181: allow path with these
            case 3: case 4: case 5: case 6: case 7:
               break;
            default:
               if (strchr(pszOutFile, glblPathChar))
                  return 9+perr("no path allowed in output filename.\n");
         }
         // isolate class name from output filename
         strcopy(szLineBuf, pszOutFile);
         char *psz = strchr(szLineBuf, '.');
         if (psz) {
            *psz = '\0';
            pszClassName = szLineBuf;
         }
         else
         if (nlang < 3)
            return 9+perr("need an output filename like x.java or x.cpp\n");
         if (!cs.force && fileExists(pszOutFile)) {
            perr("file already exists: %s\n", pszOutFile);
            pinf("add -force to overwrite.\n");
            return 9;
         }
         if (!(cs.outfile = fopen(pszOutFile, pszFileMode)))
            return 9+perr("cannot write file: %s\n", pszOutFile); 
      }

      if (bLocalFile && pszOutFile) {
         if (!strcmp(pszOutFile, "write"))
            bWriteFile = 1;
         else
            return 9+perr("specify \"write\" or nothing after %s\n", pszLang);
      }

      printSamp(nlang+ibatchoffset, pszOutFile, pszClassName, bWriteFile, iSystem);

      if (cs.outfile) {
         fclose(cs.outfile);
         cs.outfile = 0;
         if (!bLocalFile)
            printf("written: %s\n", pszOutFile);
         #ifndef _WIN32
         chmod(pszOutFile, S_IREAD | S_IWRITE | S_IEXEC); // sfk197 with batch
         #endif
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "memerrtest"))
   {
      char *p = new char[1024];
      (void)p;
      // fall through, expect mem leak message
      bDone=1;
   }

   if (!strcmp(pszCmd, "zipdump"))
   {
      if (nparm < 1) return -1;

      cs.travelzips = 1;

      // ZipReader ozip;
      // ozip.list(argv[2]);
      // ozip.dump(argv[2], argv[3]);

      Coi ozip(argv[2], 0);
      if (!ozip.isTravelDir())
         {  perr("no directory: %s",argv[2]); return 9; }

      if (ozip.openDir())
         {  perr("cannot open"); return 9; }

      for (Coi *psub=0; (psub=ozip.nextEntry());)
      {
         // psub is owned by caller!
         printf("entry: %s dir=%d size=%d time=%u\n", psub->name(), psub->isTravelDir(), (int)psub->getSize(), (int)psub->getTime());
         if (!psub->isTravelDir()) {
            int nrc = psub->open("rb");
            if (nrc) {
               printf("   ... open rc %d\n", nrc);
            } else {
               char abtmp[1024];
               int nread = psub->readLine(abtmp, 100);
               if (nread >= 4) {
                  execHexdump(0, (uchar*)abtmp, nread);
               } else {
                  printf("   ... nread %d\n", nread);
               }
               psub->close();
            }
         }
         delete psub;
      }

      ozip.closeDir();

      bDone = 1;
   }

   if (!strcmp(pszCmd, "errortest"))
   {
      if (nparm < 1) {
      printx("<help>$sfk [options] errortest mask\n"
             "\n"
             "   produces test error(s), showing return codes.\n"
             "   this command implies -showrc.\n"
             "\n"
             "   $mask\n"
             "   may contain one or more characters to select\n"
             "   a test case from:\n"
             "\n"
             "      n   normal file processing (no error).\n"
             "      e   produce a syntax error.\n"
             "      w   produce a general warning.\n"
             "      f   simulate (skipped) unreadable file.\n"
             "      m   simulate out of memory.\n"
             "      l   simulate general error with low rc.\n"
             "\n"
             "   $options\n"
             "      -rcfromerr   on skipped errors, pass rc to shell.\n"
             "      -stoponerr   stop on first unreadable file.\n"
             "\n"
             "   $example\n"
             "      #sfk -rcfromerr errortest nnnfnn\n"
             "         simulates five successful and one erroneous file\n"
             "         processings, changing the shell rc on any errors.\n"
             );
      return 9;
      }

      char *pmask = str("");
      gs.showrc   = 1;

      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unexpected: %s\n", argv[iDir]);
         }
         pmask = argv[iDir];
      }

      bool bstop = 0;
      while (!bstop && *pmask)
      {
         switch (*pmask++)
         {
            case 'n':
            {
               int nFuncRC = 0;
               printf("file processed, ");
               bstop = cs.stopTree(nFuncRC);
               printf("processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%d)\n",bstop,nFuncRC);
               break;
            }
            case 'e': lRC = 9+perr("syntax test error"); break;
            case 'w': lRC = 5+pwarn("general test warning"); break;
            case 'f':
            {
               int nFuncRC = 9+perr("file unreadable.\n");
               bstop = cs.stopTree(nFuncRC);
               printf("   processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%d)\n",bstop,nFuncRC);
               break;
            }
            case 'm':
            {
               int nFuncRC = 19+perr("out of memory.\n");
               bstop = cs.stopTree(nFuncRC);
               printf("   processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%d)\n",bstop,nFuncRC);
               break;
            }
            case 'l':
            {
               int nFuncRC = 5+perr("non-fatal fn error.\n");
               bstop = cs.stopTree(nFuncRC);
               printf("   processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%d)\n",bstop,nFuncRC);
               break;
            }
         }
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "tcping")) // sfk1973
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk tcping host:port [options]\n"
             "\n"
             "   check if a host accepts tcp/ip connections.\n"
             "\n"
             "   can be used to check if you are behind a firewall\n"
             "   that blocks outgoing connections on specific ports.\n"
             "\n"
             "   $options\n"
             "      -justrc   tell nothing, set just return code\n"
             "      -loop     retry endlessly until connect\n"
             "      -delay=n  delay seconds between tries\n"
             "\n"
             "   $return code\n"
             "      0   cannot connect\n"
             "      1   connection success\n"
             "      9   other error\n"
             "\n"
             "   $examples\n"
             "\n"
             "      #sfk tcping myhost:80\n"
             "         check if myhost listens on port 80\n"
             "\n"
             "      #sfk tcping -justrc myhost:80 +if \"rc=1\" tell \"ok\"\n"
             "         conditional output in a script\n"
             "\n"
             "      #sfk tcping -justrc myhost:80 +if \"rc<>1\" tell \"fail\"\n"
             "         conditional output in a script\n"
             );
      ehelp;

      sfkarg;

      char *phostport = 0;
      bool bloop      = 0;
      int ndelay      = 1000;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-delay", &pszParm)) {
            if (!pszParm) return 9;
            ndelay = atol(pszParm) * 1000;
            if (ndelay < 1000)
                ndelay = 1000;
            continue;
         }
         if (!strcmp(argx[iDir], "-loop")) {
            bloop = 1;
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!phostport) {
            phostport = argx[iDir];
            continue;
         }
         return 9+pbad(pszCmd, argx[iDir]);
      }

      if (!phostport)
         return 9+perr("missing host:port\n");

      lRC = 0; // default: cannot connect

      int nPort = 80;

      char szHost[200];
      strcopy(szHost, phostport);
      char *psz1 = strchr(szHost, ':');
      if (psz1) {
         *psz1++ = '\0';
         nPort = atol(psz1);
      }

      SOCKET hSock = 0;

      prepareTCP();
 
      hSock = socket(AF_INET, SOCK_STREAM, 0);
      if (hSock == INVALID_SOCKET) {
         if (!cs.justrc)
            perr("cannot create socket (2)\n");
         lRC = 9;
      }

      struct sockaddr_in oaddr;
      oaddr.sin_family = AF_INET;
      oaddr.sin_port = htons((unsigned short)nPort);

      if (lRC < 9) {
         if (setaddr(&oaddr,szHost)) {
            if (!cs.justrc)
               perr("cannot set address\n");
            lRC = 9;
         }
      }

      if (lRC < 9)
      {
         int ncnt = 1;
         while (!userInterrupt())
         {
            if (connect(hSock, (struct sockaddr *)&oaddr, sizeof(oaddr)) != -1) {
               lRC = 1;
               break;
            }
   
            if (bloop) {
               printf("not yet available, retrying (%d)   \r",ncnt++);
               fflush(stdout);
               doSleep(ndelay);
            } else {
               if (!cs.justrc)
                  perr("cannot connect to %s:%u, %s\n", szHost, nPort, netErrStr());
               lRC = 0;
               break;
            }
         }
         if (lRC == 1) {
            if (!cs.justrc)
               printf("connected.                              \n");
            closesocket(hSock);
         }
      }

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "cmptime"))
   {
      if (nparm < 2) return 9;
      char *pszFile1 = argv[iDir+0];
      char *pszFile2 = argv[iDir+1];
      FileStat fs1; if (fs1.readFrom(pszFile1)) return 9+perr("1");
      FileStat fs2; if (fs2.readFrom(pszFile2)) return 9+perr("2");

      cs.verbose = 9;
      bool bSrcIsOlder = 0;
      int nrc = fs1.differs(fs2, 1, &bSrcIsOlder);
      printf("rc %d srcio %d\n",nrc,bSrcIsOlder);

      bDone = 1;
   }

   #ifndef _WIN32
   if (!strcmp(pszCmd, "tellnode"))
   {
      if (nparm < 1) return 9;
      char *pszFile = argv[iDir];

      struct stat64 buf;
      if (stat64(pszFile, &buf)) return 9;
      num nnode = (num)buf.st_ino;
      printf("%s (%u) %s\n", numtohex(nnode,16),(uint)nnode,pszFile);

      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "script") || !strcmp(pszCmd, "fscript")) // +wref +var
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk script [opts] file [-from=label] [parm1] [parm2] [...]\n"
             "\n"
             "   execute sfk command(s) from a script file, which can be\n"
             "    - an absolute filename, e.g. C:\\scripts\\thescript.txt\n"
             "    - a relative filename. in this case, the file is searched\n"
             "      in the current dir \".\" first, and then in the PATH.\n"
             "\n"
             "   $parameters:\n"
             "    - if \"-from=label\" is given, the script file is searched\n"
             "      for a statement \"label mylabel\", and script execution runs\n"
             "      from this point until +end is reached.\n"
             "\n"
             "    - all other words after -from, or instead of from, are passed\n"
             "      as parameters to the script, with one exception:\n"
             "      a word starting with a \"+\" continues the sfk command chain.\n"
             "      if you need to pass words starting with \"+\" to the script,\n"
             "      set option -literal (disallowing further chain commands).\n"
             "\n"
             "   $command chaining:\n"
             "      with ...  +script name, text data is passed to the script.\n"
             "      with ... +fscript name, filenames are passed to the script.\n"
             "\n"
             "   $script file syntax:\n"
             "      - text after // followed by one whitespace is a remark\n"
             "        and therefore ignored. (UNC paths starting like //mydir\n"
             "        should be placed into double quotes.)\n"
             "      - command line parameters 1 to 9 can be addressed both\n"
             "        by expressions %%1 to %%9, or $$1 to $$9.\n"
             "      - the current script filename and text data can be\n"
             "        retrieved by variables. for more see: sfk help var\n"
             "      - character ## at column 1 of any line is skipped, which\n"
             "        allows bash-embedded scripts to have sfk statements\n"
             "        outcommented if necessary.\n"
             "      - escaped quotes \\\" are changed into normal quotes \"\n"
             "      - line ends are ignored. in general, lines are combined\n"
             "        into one large command chain, just like typing them all\n"
             "        into one line of unlimited length.\n"
             "      - any whitespace is skipped unless surrounded by quotes \"\n"
             "        however this may or may not apply with the following:\n"
             "\n");
      printx("   $about quoted multi line parameters:\n"
             "     a command in a script like\n"
             "\n"
             "       #+echo \"\n"
             "             #Help chapter 01\n"
             "             #---------------\n"
             "             #The quick brown fox\n"
             "             #\"\n"
             "\n"
             "     gets one large parameter spread across multiple lines,\n"
             "     called a $quoted multi line parameter<def>. this contains\n"
             "     many whitespaces at line starts, and invisible end of\n"
             "     line characters at line ends, which often cause commands\n"
             "     like echo, run or (x)replace not to work as expected.\n"
             "\n"
             "     - add option -qtrim after \"sfk label labelnam\" to have\n"
             "       whitespaces reduced automatically depending on command.\n"
             "       #this is default since SFK 1.8.0.\n"
             "       sfk will auto apply one of these trimming modes:\n"
             "\n"
             "       $full trim<def>  : all whitespace and eol are dropped.\n"
             "                    -> used with most commands\n"
             "\n"
             "       $parm trim<def>  : single blank is left between words.\n"
             "                    -> used with run\n"
             "\n"
             "       $auto indent<def>: some blanks and eol are kept to keep\n"
             "                    an indentation relative to 1st line.\n"
             "                    -> used with echo\n"
             "\n"
             "     - add option -qraw  after \"sfk label labelnam\" to keep\n"
             "       all whitespace as it is. #this is no longer default\n"
             "       #since SFK 1.8.0, and may be required with old scripts.\n"
             "       you may also <exp> SFK_CONFIG=qraw\n"
             "\n"
             "     also type \"sfk label\" for infos.\n"
             "\n");
      printx("   $parameter name collisions:\n"
             "     if your script contains commands like\n"
             "         #+filter -form \"$$10.10col1 ...\"\n"
             "     then \"$$1\" will be misinterpreted as an input parameter\n"
             "     into the script. to avoid this use one of\n"
             "         #+filter -form \"$$(10.10col1) ...\"\n"
             "     or  #+filter -form \"$$$$10.10col1 ...\"\n"
             "     or disable #$$<def> as a parameter name prefix\n"
             "     by option -prefix. see \"sfk label\" for more on that.\n"
             "\n"
             "   $options\n"
             #ifdef _WIN32
             "      -dos       script file is OEM codepage encoded.\n"
             "                 default is to assume Ansi encoding.\n"
             #endif
             "      -verbose   tell in detail which words are used from script.\n"
             "      -anyparms  or -literal also passes words to the script\n"
             "                 that start with \"+\". does not allow further\n"
             "                 chain processing after the script command.\n"
             "\n"
             "   $see also\n"
             "       #sfk help chain<def>  command chaining overview\n"
             "       #sfk help var<def>    about script parameters and variables\n"
             "       #sfk label<def>       further options given after label\n"
             "       #sfk load<def>        load text or data for chaining\n"
             "\n"
             "   $setting global options for all commands within a script:\n"
             "      supply them directly after \"sfk\" of the calling command:\n"
             "      #sfk -var script myscript.txt -from=mylabel\n"
             "         runs myscript.txt with sfk variable support\n"
             "         active in every command.\n"
             "      some options like -var can also be given after sfk label.\n"
             "      see \"sfk label\" for more.\n"
             "\n"
             "   $for script examples, type:\n"
             "      sfk samp sfk       - show an sfk sample script\n"
             "      sfk batch tmp.bat  - sample script embedded in windows batch\n"
             "      sfk batch tmp.sh   - sample script embedded in bash script\n"
             "      sfk samp           - more about the sfk sample syntax\n"
             "\n");
      printx("   $more in the SFK Book\n"
             "      the #SFK Book<def> contains a 60 page tutorial, including\n"
             "      long script examples with input, output and explanations.\n"
             "      type \"#sfk book<def>\" for details.\n"
             "\n"
             );
      webref("script");
      printx("   $recommended use:\n"
             "      if you want to create an easy-to-use script on the fly,\n"
             "      1. create an embedded script in a batch file:\n"
             #ifdef _WIN32
             "         #sfk batch myscript.bat\n"
             "      2. edit myscript.bat with any text editor.\n"
             "      3. run the script by typing \"myscript.bat\".\n"
             #else
             "         #sfk batch myscript.sh\n"
             "      2. edit myscript.sh with any text editor.\n"
             "      3. run the script by typing \"bash myscript.sh\".\n"
             #endif
             );
      ehelp;

      sfkarg;

      char *pszScriptFile = 0;
      char *pszLabel      = 0;

      int  iChainNext =  0;
      int  iLocalParm = -1;
      int  nLocalParm =  0;
      int  nState     =  0;
      bool bliteral=0, bdos=0;

      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (nState < 2 && haveParmOption(argx, argc, iDir, "-from", &pszParm)) {
            if (!pszParm) return 9;
            pszLabel = pszParm;
            nState = 2;
            continue;
         }
         if (!strcmp(pszArg, "-dos")) { // internal
            bdos = 1;
            continue;
         }
         if (nState < 1 && sfkisopt(pszArg)) {
            // general options are interpreted only before script name,
            // i.e. as int as nState == 0.
            if (strBegins(pszArg, "-lit")
                || strBegins(pszArg, "-anyparm")) // sfk197
            {
               bliteral = 1;
               continue;
            }
            if (setGeneralOption(argx, argc, iDir))
               continue;
            return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (!bliteral && isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszScriptFile) {
            pszScriptFile = argx[iDir];
            nState = 1;
         }
         else
         if (iLocalParm < 0) {
            iLocalParm = iDir;
            nLocalParm = 1;
            nState = 2;
         }
         else
            nLocalParm++;
      }

      if (!pszScriptFile) return 9+perr("missing script file name.");

      char *pszAbsScript = pszScriptFile;
      if (!fileExists(pszAbsScript) && !isAbsolutePath(pszAbsScript)) {
         pszAbsScript = findPathLocation(pszScriptFile, 0);
         if (!pszAbsScript) return 9+perr("%s not found in current dir or PATH.\n", pszScriptFile);
      }

      char *pScriptRaw = loadFile(pszAbsScript);
      if (!pScriptRaw)
         return 9+perr("failed to load script file: %s\n", pszAbsScript);
      #ifdef _WIN32
      if (bdos)
         sfkchars.stroemtoansi(pScriptRaw);
      #endif

      // pScriptRaw is the original script data.
      // pScript will be stuffed with terminators
      // and therefore is not reusable.
      char *pScript = strdup(pScriptRaw);

      // auto delete all script data on return.
      CharAutoDel odel1(pScriptRaw);
      CharAutoDel odel2(pScript);

      // in case "call" is used inside script:
      CharAutoRestore oclear1(&pGlblCurrentScript);
      CharAutoRestore oclear2(&pGlblCurScriptName);   // sfk196
      pGlblCurrentScript = pScriptRaw;
      pGlblCurScriptName = pszAbsScript;               // sfk196
      // on return, pGlbl will have its old value set.

      lRC = 0;

      int iExecRC = callLabel(pScript, argc, argx, penv, // script
            pszLabel, iLocalParm, nLocalParm, lRC, bFatal);
      // pScript is modified with zero terms.

      if (iExecRC) // fatal errors that stop chaining
         return iExecRC;

      // pScript is auto deleted.

      // pGlblCurrentScript is auto restored to old value,
      // in case that nested script commands are used.
      // same for pGlblCurScriptName.

      if (lRC >= 9) return lRC;

      STEP_CHAIN(iChainNext, 1); // sfk1933 script chaining

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "pingdiff")) // sfk198 macro
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk pingdiff mynet\n"
             "\n"
             "   ping local network two times, listing the differences,\n"
             "   to find the IP of new devices.\n"
             "\n"
             #ifdef _WIN32
             "   may require admin rights with Windows 7.\n"
             "   if you get an error, right click on cmd.exe\n"
             "   and select \"run as admin\" to enable sfk ping.\n"
             #else
             "   REQUIRES ADMIN RIGHTS. if (and only if) you are\n"
             "   admin then use \"sudo su\" or \"su username\"\n"
             "   to enable sfk ping.\n"
             #endif
             "\n"
             "   $how to use\n"
             "      1. disconnect the embedded device from network.\n"
             "      2. start sfk pingdiff. it runs the first scan.\n"
             "      3. when asked, connect the embedded device\n"
             "         and press enter.\n"
             "      4. sfk runs a second scan and shows differences.\n"
             "\n"
             "   $limitations\n"
             "      experimental command. may not correctly find\n"
             "      all pingable IP addresses. may list more\n"
             "      differences then actually exist.\n"
             "      scans only class C networks with 254 ip's,\n"
             "      for example 192.168.178.1 to 192.168.178.254.\n"
             "\n"
             "   $examples\n"
             "      #sfk pingdiff mynet\n"
             "         starts scan. follow on-screen instructions.\n"
             "      #sfk ping -pure mynet +setvar a +pause\n"
             "       #+ping -pure mynet +setvar b +difflines -fromvar a b\n"
             "         basic command sequence used by pingdiff\n"
             );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
      }

      char *pScriptRaw = str(
         "sfk tell \"ping mynet, pass 1. please wait.\" "
         "+ping -pure mynet +setvar a "
         "+pause \"now (dis)connect a device, then press enter.\" "
         "+tell \"pass 2. please wait.\" "
         "+ping -pure mynet +setvar b "
         "+difflines -fromvar a b\n"
         );

      char *pScript = strdup(pScriptRaw);
      CharAutoDel odel(pScript);

      CharAutoRestore oclear(&pGlblCurrentScript);
      pGlblCurrentScript = pScriptRaw;

      int iExecRC = callLabel(pScript, argc, argx, penv, // pingdiff
            0, -1, 0, lRC, bFatal);

      if (iExecRC) // fatal errors that stop chaining
         return iExecRC;

      if (lRC >= 9) return lRC;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   // since sfk180: documented by bin-to-src. no own help text.
   ifcmd (   !strcmp(pszCmd, "clipsrc")
       || !strcmp(pszCmd, "clipxml")
       || !strcmp(pszCmd, "clipphp")
       || !strcmp(pszCmd, "clipjava")
      )
   {
      ifhelp (nparm >= 1 && isHelpOpt(argv[iDir]))
      printx("<help>$sfk [-cmd] clipsrc [-h]\n"
             "\n"
             "   convert clipboard text to source code.\n"
             "\n"
             "   $limited chaining support\n"
             "      this command is for interactive use only.\n"
             "      within scripts use instead the internal\n"
             "      command sequence as shown by -cmd\n"
             "\n"
             "   $options\n"
             "      -cmd   just print the internally executed\n"
             "             command sequence. you may have to add\n"
             "             some quotes \"\", depending on your\n"
             "             environment.\n"
             "\n"
             "   $examples\n"
             "      #sfk clipsrc\n"
             "         create C compatible source\n"
             "         and print to terminal.\n"
             "      #sfk clipphp\n"
             "         create PHP compatible source\n"
             "      #sfk clipjava +toclip\n"
             "         create Java compatible source\n"
             "         and copy back to clipboard.\n"
             );
      ehelp;

      sfkarg;

      bool bprintcmd=0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-cmd"))
            { bprintcmd=1; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         return 9+perr("unexpected: %s",pszArg);
      }

      char szBuf[1024];

      cchar *pext = bprintcmd ? "\"" : "";

      if (!strcmp(pszCmd, "clipsrc"))
         sprintf(szBuf, "fromclip +filter -rep _\\_\\\\\\_ -srep _\\q_\\\\" "\\q_ -srep _\\x25_\\x25\\x25_ -sform %s\\q%ccol1\\\\" "n\\q%s", pext, glblRunChar, pext);
      else
      if (!strcmp(pszCmd, "clipxml"))
         sprintf(szBuf, "fromclip +xmlform");
      else
      if (!strcmp(pszCmd, "clipphp"))
         sprintf(szBuf, "fromclip +filter -rep _\\_\\\\\\_ -srep _\\q_\\\\" "\\q_ -sform %s.\\q%ccol1\\\\" "n\\q%s", pext, glblRunChar, pext);
      else
      if (!strcmp(pszCmd, "clipjava"))
         sprintf(szBuf, "fromclip +filter -rep _\\_\\\\\\_ -srep _\\q_\\\\" "\\q_ -sform %s+\\q%ccol1\\\\" "n\\q%s", pext, glblRunChar, pext);

      if (bprintcmd)
         { printf("sfk %s\n", szBuf); return 0; }

      char *asubarg[100];
      int   isubarg = 0;

      char *psz = szBuf;

      asubarg[isubarg++] = psz;

      for (; *psz; psz++) {
         if (*psz == ' ') {
            *psz++ = '\0';
            asubarg[isubarg++] = psz;
         }
      }

      // +toclip is appended HERE.
      // Full chaining is NOT supported.
      for (; iDir<argc; iDir++)
         asubarg[isubarg++] = argv[iDir];

      lRC = submain(isubarg, asubarg, penv, asubarg[0], 1, bFatal); // clipsrc

      // NO step_chain supported.

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "getcol")    // sfk1914
       || !strcmp(pszCmd, "getcolumn")
       || !strcmp(pszCmd, "tabcol")
      )
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk ... +getcol n\n"
             "$sfk ... +tabcol n\n"
             "\n"
             "   get column n of space or tab separated text.\n"
             "   see alias section of sfk filter for more.\n"
             "\n"
             );
      ehelp;

      sfkarg;

      // one parameter
      char szBuf[1024];

      int iValue = -1;
      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (iValue == -1) {
            iValue = atoi(pszArg);
            continue;
         }
         return 9+perr("unexpected: %s", pszArg);
      }

      if (strBegins(pszCmd, "get"))
         sprintf(szBuf, "filter -blocksep _ -form %ccol%d", glblRunChar, iValue);
      if (strBegins(pszCmd, "tab"))
         sprintf(szBuf, "filter -stabform %ccol%d", glblRunChar, iValue);

      char *asubarg[100];
      char *psz = szBuf;
      int   isubarg = 0;
      asubarg[isubarg++] = psz;
      for (; *psz; psz++) {
         if (*psz == ' ') {
            *psz++ = '\0';
            asubarg[isubarg++] = psz;
            if (*psz=='_')
               *psz=' ';
         }
      }
      // fix sfk1932: do NOT copy rest of argv here!

      lRC = submain(isubarg, asubarg, penv, asubarg[0], 1, bFatal); // getcol

      STEP_CHAIN(iChainNext, 1); // sfk1932 getcol: producing command

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "num")
          || !strcmp(pszCmd, "number")
          || !strcmp(pszCmd, "numbers")
          || !strcmp(pszCmd, "numle")
         )
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk num[bers] [options] n1 [0xn2 0bn3 ...]\n"
             "\n"
             "   print associated numbers in all kinds of formats,\n"
             "   like decimal, hexadecimal, binary and ASCII chars\n"
             "   and in little endian format.\n"
             "\n"
             "   $accepted parameter formats\n"
             "       1234           a decimal number\n"
             "       0x1234         a hexadecimal number\n"
             "       0b1101         a binary number\n"
             "       192.168.1.10   four decimal numbers\n"
             "                      joined as one 32 bit value\n"
             "       0b1101.0110    two binary numbers\n"
             "                      joined as one value\n"
             "       fe237801       hex number (auto detected)\n"
             "       0tfe23         4 ASCII chars \"fe23\"\n"
             "\n"
             "   $options\n"
             "      -hex      all given numbers are hexadecimal\n"
             "      -nocol    print without colors\n"
             "      -single   don't show little endian format\n"
             "      -show x   print just a single format of:\n"
             "                dec   hex   ip   bin\n"
             "                decle hexle iple binle\n"
             "      -small    convert little endian for numbers\n"
             "                below 65536 as 16 bits. default is\n"
             "                to convert all as 32 bits.\n"
             "      -noneg    do not show negative numbers.\n"
             "\n"
             "   $see also\n"
             "      #sfk hex<def>   convert decimal to hex\n"
             "      #sfk dec<def>   convert hexadecimal to decimal\n"
             "\n");
      webref("number");
      printx("   $examples\n"
             "      #sfk num 0x48454C4F\n"
             "         prints all representations of hex value 0x48454C4F\n"
             "      #sfk num -2\n"
             "         prints all forms of 32-bit signed value -2\n"
             "      #sfk num -show hexle 317705643\n"
             "         prints ABCDEF12, the little endian hex value\n"
             );
      ehelp;

      sfkarg;

      bool bFirst = 1;
      bool bLE    = 1;
      bool bHex   = 0;
      bool bSmall = 0;
      bool bnoneg = 0;
      int  ishow  = 0;

      cs.nohead   = 1;

      int iFirstVal = 0;
      int iLastVal  = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-show", &pszParm)) {
            if (!pszParm) return 9;
            if (!strcmp(pszParm, "dec"))   { ishow=1; continue; }
            if (!strcmp(pszParm, "hex"))   { ishow=2; continue; }
            if (!strcmp(pszParm, "ip"))    { ishow=3; continue; }
            if (!strcmp(pszParm, "bin"))   { ishow=4; continue; }
            if (!strcmp(pszParm, "decle")) { ishow=5; continue; }
            if (!strcmp(pszParm, "hexle")) { ishow=6; continue; }
            if (!strcmp(pszParm, "iple"))  { ishow=7; continue; }
            if (!strcmp(pszParm, "binle")) { ishow=8; continue; }
            return 9+perr("unknown: %s",pszParm);
         }
         if (!strcmp(pszArg, "-single")) { bLE = 0; continue; }
         if (!strcmp(pszArg, "-small"))  { bSmall = 1; continue; }
         if (!strcmp(pszArg, "-nole"))   { bLE = 0; continue; }
         if (!strcmp(pszArg, "-lean")) {
            bLE = 0;
            cs.nohead = 1;
            continue;
         }
         if (!strcmp(pszArg, "-hex"))
            { bHex = 1; continue; }
         if (!strcmp(pszArg, "-noneg"))
            { bnoneg = 1; continue; }
         if (sfkisopt(pszArg)
             && !alldigits(pszArg+1)   // sfk1934
            )
         {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            { iLastVal=iDir; break; }
         if (!iFirstVal)
            { iFirstVal=iDir; iLastVal=iDir+1; continue; }
         iLastVal=iDir+1;
      }

      for (int iVal=iFirstVal; iVal<iLastVal; iVal++)
      {
         char *pszArg = argx[iVal];

         // process non-option keywords:
         num nsign=0;
         if (pszArg[0]=='-')
            { pszArg++; nsign=-1; }

         uint nBE = (uint)getFlexNum(pszArg, bHex);
         uint nLE = 0;

         if (nsign)
            nBE   = (uint)(nsign * (num)nBE);

         int sBE = (nBE & (1U << 31)) ? nBE : 0;
 
         if (bSmall == 1 && nBE < 65536U)
              nLE =     ( ((nBE >>  0) & 0xFFU) <<  8 )
                     |  ( ((nBE >>  8) & 0xFFU) <<  0 )
                     ;
         else
              nLE =     ( ((nBE >>  0) & 0xFFU) << 24 )
                     |  ( ((nBE >>  8) & 0xFFU) << 16 )
                     |  ( ((nBE >> 16) & 0xFFU) <<  8 )
                     |  ( ((nBE >> 24) & 0xFFU) <<  0 )
                     ;

         int sLE  = (nLE & (1U << 31)) ? nLE : 0;

         if (ishow >= 5)
            { nBE = nLE; ishow -= 4; }

         uchar b0 = (uchar)((nBE >>  0) & 0xFFU);
         uchar b1 = (uchar)((nBE >>  8) & 0xFFU);
         uchar b2 = (uchar)((nBE >> 16) & 0xFFU);
         uchar b3 = (uchar)((nBE >> 24) & 0xFFU);
         uchar c0 = b0;
         uchar c1 = b1;
         uchar c2 = b2;
         uchar c3 = b3;

         if (!isprint(b0)) c0 = '.';
         if (!isprint(b1)) c1 = '.';
         if (!isprint(b2)) c2 = '.';
         if (!isprint(b3)) c3 = '.';
 
         char szbin[100];
         memset(szbin, 0, sizeof(szbin));

         szLineBuf[0] = '\0';

         switch (ishow) 
         {
            case 1: sprintf(szLineBuf, "%u"  , nBE); break;
            case 2: sprintf(szLineBuf, "%08X", nBE); break;
            case 3: sprintf(szLineBuf, "%03u.%03u.%03u.%03u", b3,b2,b1,b0); break;
            case 4: { for (uint i=0; i<32; i++)
                        szLineBuf[i] = (nBE & (1U << i)) ? '1':'0';
                      szLineBuf[32] = '\0';
                     }
                     break;
         }
         if (szLineBuf[0]) {
            chain.print("%s\n", szLineBuf);
         }
         else
         {
            if (!cs.quiet && !cs.nohead && bFirst) {
               bFirst = 0;
               chain.print(   "  ====---- =---===---                 ====----====----====----====----\n");
            }

            strcpy(szAttrBuf, "  ==--==-- =---===---                 ====----====----====----====---- =----= bbbbbbbbbbb");
            for (int i=0; szAttrBuf[i]; i++) {
               if (szAttrBuf[i]=='=')
                  szAttrBuf[i] = 'x';
               else
               if (szAttrBuf[i]=='-')
                  szAttrBuf[i] = 'h';
            }

            for (int i=7; i>=0; i--) szbin[ 7-i] = (b3 & (1U << i)) ? '1':'0';
            for (int i=7; i>=0; i--) szbin[15-i] = (b2 & (1U << i)) ? '1':'0';
            for (int i=7; i>=0; i--) szbin[23-i] = (b1 & (1U << i)) ? '1':'0';
            for (int i=7; i>=0; i--) szbin[31-i] = (b0 & (1U << i)) ? '1':'0';

            sprintf(szLineBuf, "0x%08X %10u %03u.%03u.%03u.%03u %s >%c%c%c%c<",
               nBE,nBE, b3,b2,b1,b0, szbin, c3,c2,c1,c0);

            if (!bnoneg && sBE)
               mystrcatf(szLineBuf, MAX_LINE_LEN, " %d", sBE);

            if (chain.coldata)
               chain.addLine(szLineBuf, szAttrBuf);
            else
               printColorText(szLineBuf, szAttrBuf);

            if (bLE)
            {
            for (int i=7; i>=0; i--) szbin[ 7-i] = (b0 & (1U << i)) ? '1':'0';
            for (int i=7; i>=0; i--) szbin[15-i] = (b1 & (1U << i)) ? '1':'0';
            for (int i=7; i>=0; i--) szbin[23-i] = (b2 & (1U << i)) ? '1':'0';
            for (int i=7; i>=0; i--) szbin[31-i] = (b3 & (1U << i)) ? '1':'0';

            sprintf(szLineBuf, "0x%08X %10u %03u.%03u.%03u.%03u %s >%c%c%c%c<",
               nLE,nLE, b0,b1,b2,b3, szbin, c0,c1,c2,c3);

            if (!bnoneg && sLE)
               mystrcatf(szLineBuf, MAX_LINE_LEN, " %d", sLE);

            if (chain.coldata)
               chain.addLine(szLineBuf, szAttrBuf);
            else
               printColorText(szLineBuf, szAttrBuf);
            }
         }
      }

      if (iChainNext) {
         // producing command
         STEP_CHAIN(iChainNext, chain.coldata); // sfk181 num always
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "hex") || !strcmp(pszCmd, "dec")) // +wref
   {
      ifhelp (!chain.usedata && nparm < 1)
      printx("<help>$sfk hex value1 [value2] [...]\n"
             "$sfk dec value1 [value2] [...]\n"
             "$sfk ... +dec [+hex] -digits=n\n"
             "\n"
             "   convert numbers between decimal and hexadecimal.\n"
             "   largest convertable number is ((2 << 64) - 1).\n"
             "\n"
             "   $options\n"
             "      -digits=n  format output numbers with n digits\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk hex 1048576 98765 234567\n"
             "         convert 3 decimal numbers.\n"
             "\n"
             "      #sfk filt csv.txt -ssep \"\\t\" -form \"$$col3\" +hex\n"
             "         convert 3rd column from csv.txt to hex.\n"
             );
      ehelp;

      sfkarg;

      bool btodec = !strcmp(pszCmd, "dec");

      int  iChainNext = 0;
      int  iVal       = iDir;
      int  iValMax    = iDir;
      int ndigits    = 1;

      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-digits", &pszParm)) {
            if (!pszParm) return 9;
            ndigits = atol(pszParm);
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               return 9+perr("unexpected option: %s\n", argx[iDir]);
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // skip number parms, maybe until a chain cmd
         iValMax = iDir;
      }

      if (chain.usedata) {
         // convert chain text
         for (int i=0; i<chain.indata->numberOfEntries(); i++) {
            szLineBuf[0]  = '\0';
            char *psz = chain.indata->getEntry(i, __LINE__);
            if (!psz) return 9+perr("int. #58282010");
            if (btodec) {
               // hex to dec
               num nval = hextonum(psz);
               numtoa(nval, ndigits, szLineBuf);
            } else {
               // dec to hex
               num nval = atonum(psz);
               numtohex(nval, ndigits, szLineBuf);
            }
            if (chain.coldata) {
               if (szLineBuf[0])
                  chain.addLine(szLineBuf, str(""));
            } else {
               printf("%s\n", szLineBuf);
            }
         }
      } else {
         // convert direct parameters
         nparm = (iValMax - iVal) + 1;
         for (; nparm > 0; nparm--)
         {
            szLineBuf[0]  = '\0';
            char *psz = argx[iVal++];
            if (btodec) {
               // hex to dec
               num nval = hextonum(psz);
               numtoa(nval, ndigits, szLineBuf);
            } else {
               // dec to hex
               if (!isdigit(*psz))
                  return 9+perr("cannot convert to hex, not a number: %s", psz);
               num nval = atonum(psz);
               numtohex(nval, ndigits, szLineBuf);
            }
            if (chain.coldata) {
               if (nparm >= 2) strcat(szLineBuf, " ");
               chain.addToCurLine(szLineBuf, str(""));
            } else {
               printf("%s ", szLineBuf);
            }
         }
         if (!chain.coldata)
            printf("\n");
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "dropvar"))
   {
      sfkarg;

      char *pszName=0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszName) {
            pszName = pszArg;
            continue;
         }
         return 9+pbad(pszCmd,pszArg);
      }

      if (!pszName)
         return 9+perr("missing variable name");

      sfksetvar(pszName, 0, 0);

      STEP_CHAIN(iChainNext, 0); // dropvar

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "setvar")
          || !strcmp(pszCmd, "addtovar")  // sfk1922
         )
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk setvar name[=value]\n"
             "\n"
             "   store data in an sfk internal variable\n"
             "   for later use in subsequent chain commands.\n"
             "\n"
             "   all variable contents are lost when sfk exits.\n"
             "   sfk does not set any environment variables.\n"
             "\n"
             "   $options\n"
             "     -spat      support slash patterns\n"
             "     -noline    with addtovar: do not append\n"
             "                extra linefeeds\n"
             "     -debug     tell what is done\n"
             "\n"
             "   $aliases\n"
             "      #addtovar<def>       append chain text as lines\n"
             "                     to existing variable text\n"
             "\n"
             "   $see also\n"
             "      #sfk help var<def>   how to use sfk variables\n"
             "      #sfk getvar<def>     print variable(s)\n"
             "\n");
      webref("helpvar");
      printx("   $examples\n"
             "      #sfk setvar a=\"foo bar\" +echo -var \"test: ##(a)\"\n"
             "         set variable a directly with a given string\n"
             "         then use it in another command.\n"
             "      #sfk echo foo +setvar a +getvar\n"
             "         set variable a with text line(s) passed from\n"
             "         a previous command, then list all variables.\n"
             "      #sfk setvar -spat a=\"foo \\qbar\\q goo\" +getvar\n"
             "         set a string containing quotes.\n"
             "      #sfk -var setvar a=foobar +setvar a=\"##(substr(a,3))\" +getvar\n"
             "         drop first 3 chars of variable 'a', with simple text.\n"
             "      #sfk -var setvar -spat a=foo\\qbar +setvar a=\"##(substr(a,3))\"\n"
             "         fails because text of a contains double quotes \"\".\n"
             "      #sfk -var setvar -spat a=foo\\qbar\n"
             "       #+getvar a +xed \"/[start][3 chars]//\" +setvar a +getvar\n"
             "         drop first 3 chars of 'a' safely, even with quotes.\n"
             );
      ehelp;

      sfkarg;

      char *pszName = 0;
      bool busedata = chain.usedata;
      int  nadd     = strcmp(pszCmd, "addtovar") ? 0 : 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (!strcmp(pszArg, "-addline"))
            { nadd = 1; continue; }
         if (strcmp(pszArg, "-noline")==0 && nadd!=0)
            { nadd |= 2; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszName) {
            pszName = pszArg;
            continue;
         }
         return 9+pbad(pszCmd,pszArg);
      }

      if (!pszName)
         return 9+perr("missing variable name");

      // foo=bar -> var "foo" value "bar"
      if (nadd==0 && strchr(pszName, '=') != 0)
      {
         if (busedata)
            return 9+pcon(pszCmd,pszName);

         strcopy(szLineBuf, pszName);
         pszName = szLineBuf;
         char *psep = strchr(pszName, '=');
         if (!psep) return 9+perr("int. #216942");
         *psep++ = '\0';
         char *pszVal = psep;

         // strip quotes
         if (*pszVal=='\"') {
            pszVal++;
            char *psz=pszVal;
            while (*psz!=0 && *psz!='\"') psz++;
            if (!*psz) return 9+perr("missing end quote: %s",pszVal);
            *psz='\0';
         }

         if (cs.spat) {
            if (copyFormStr(szLineBuf2, MAX_LINE_LEN, pszVal, strlen(pszVal), 2)) // 2:strict
               return 9;
            pszVal = szLineBuf2;
         }

         sfksetvar(pszName, (uchar*)pszVal, strlen(pszVal));
      }
      else
      {
         if (!chain.usedata)
            return 9+perr("no chain input data on: %s %s", pszCmd, pszName);
 
         if (   chain.nClInBinarySize == 0
             && chain.indata->numberOfEntries() == 1
            )
         {
            // single value without EOL
            char *pattr = 0;
            char *ptext = chain.indata->getEntry(0, __LINE__, &pattr);
            if (ptext)
               sfksetvar(pszName, (uchar*)ptext, strlen(ptext), nadd);
         }
         else
         {
            // multi line value
            uchar *pInText = 0;
            char  *pInAttr = 0;
            num    nInSize = 0;
 
            if (loadInput(&pInText, &pInAttr, &nInSize, 0, 0, 1))
               return 9;
 
            if (pInText)
               sfksetvar(pszName, (uchar*)pInText, nInSize, nadd);
 
            if (pInText) delete [] pInText;
            if (pInAttr) delete [] pInAttr;
         }
      }

      if (chain.colany()) {
         // sfk193 allow: sfk echo a +setvar b +setvar c.
         // the last setvar tells it wants the data.
         STEP_CHAIN(iChainNext, 0); // setvar
      } else {
         // sfk193 allow: sfk echo a +setvar b +setvar c=1.
         // the last setvar tells it wants no data.
         STEP_CHAIN(iChainNext, cs.keepdata ? 0 : 1); // setvar
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "getvar"))
   {
      ifhelp (argc < 3 && iGlblInScript == 0)
      printx("<help>$sfk getvar name\n"
             "\n"
             "   get an sfk internal variable content\n"
             "   which was set by a previous command.\n"
             "\n"
             "   without parameters: list contents of all defined\n"
             "   sfk variables, up to 160 bytes each, with control\n"
             "   and binary characters shown as {nn} hex codes.\n"
             "\n"
             "   $options\n"
             "      -opt[ional]    if variable does not exist\n"
             "                     print no error but set it empty\n"
             "      -def[ault]=s   if variable does not exist\n"
             "                     use default value s\n"
             "      -raw           print long variable contents raw\n"
             "                     and with full length\n"
             "      -prelf         insert linefeed before header\n"
             "      -tofile x      write content to file x\n"
             "\n");
      printx("   $fast line lookup\n"
             "      if variable contains many text lines:\n"
             "      -line pat      get first line containing pattern\n"
             "      -linestart p   get first line starting like pattern\n"
             "      -spat          enable slash patterns with -line\n"
             "      -case          use case sensitive search with -line\n"
             "                     which is much faster\n"
             "      -sline p       same as -spat -line\n"
             "      -slinestart p  same as -spat -linestart\n"
             "      -numline=n     get a line by number, first is 1\n"
             "\n");
      printx("   $see also\n"
             "      #sfk help var<def>  all about sfk variables\n"
             "\n");
      webref("helpvar");
      printx("   $examples\n"
             "      #sfk echo foo +setvar a +echo \"test:\" +getvar a\n"
             "         the first echo passes word \"foo\" to setvar\n"
             "         where it is stored. then the second echo\n"
             "         prints \"test:\", then the variable content\n"
             "         is retrieved and printed.\n"
             "      #sfk getvar env.tmp\n"
             "         get content of the environment variable \"tmp\"\n"
             "      #sfk ... +getvar comp -case -slinestart \"1234\\t\"\n"
             "         if comp contains a tab separated CSV table,\n"
             "         with many text lines like\n"
             "            $id{tab}company{tab}address{tab}...\n"
             "         then get the first line starting with id 1234,\n"
             "         as fast as possible, using -case search.\n"
             "      #sfk ... +getvar foo -tofile out.txt\n"
             "         write content of variable foo to file out.txt\n"
             "\n"
             );
      ehelp;

      sfkarg;

      char *pszName=0;
      char *pszDef=0;
      char *pszPrefix=str("");
      char *toFileName=0;
      bool  bfull=0;
      num   iNumLine=-1;

      szRefNameBuf[0] = '\0';
      char *pszLinePat = szRefNameBuf;

      // .
      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-def", &pszParm)) {
            if (!pszParm) return 9;
            pszDef = pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-default", &pszParm)) {
            if (!pszParm) return 9;
            pszDef = pszParm;
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-numline", &pszParm)) {
            if (!pszParm) return 9;
            iNumLine = atonum(pszParm);
            if (iNumLine < 1)
               return 9+perr("use 1 for first line.");
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-tofile", &pszParm)) { // sfk1934
            if (!pszParm) return 9;
            toFileName = pszParm;
            continue;
         }
         if (!strcmp(pszArg, "-opt")) {
            pszDef = str("");
            continue;
         }
         if (!strcmp(pszArg, "-optional")) {
            pszDef = str("");
            continue;
         }
         if (!strcmp(pszArg, "-raw")) {
            bfull = 1;
            continue;
         }
         if (!strcmp(pszArg, "-prelf")) {
            pszPrefix=str("\n");
            continue;
         }
         if (   haveParmOption(argx, argc, iDir, "-line", &pszParm)
             || haveParmOption(argx, argc, iDir, "-sline", &pszParm))
         {
            if (!pszParm) return 9;
            if (pszArg[1]=='s') cs.spat=1;
            if (cs.spat) {
               if (copyFromFormText(pszParm, strlen(pszParm), szRefNameBuf, MAX_LINE_LEN) < 1)
                  return 9+perr("invalid -line pattern: %s", pszParm);
               if (strchr(szRefNameBuf, '\n'))
                  return 9+perr("no linefeed allowed in pattern: %s", pszParm);
            } else {
               strcopy(szRefNameBuf, pszParm);
            }
            continue;
         }
         if (   haveParmOption(argx, argc, iDir, "-linestart", &pszParm)
             || haveParmOption(argx, argc, iDir, "-slinestart", &pszParm))
         {
            if (!pszParm) return 9;
            if (pszArg[1]=='s') cs.spat=1;
            if (cs.spat) {
               if (copyFromFormText(pszParm, strlen(pszParm), szRefNameBuf+1, MAX_LINE_LEN-1) < 1)
                  return 9+perr("invalid -line pattern: %s", pszParm);
               if (strchr(szRefNameBuf+1, '\n'))
                  return 9+perr("no linefeed allowed in pattern: %s", pszParm);
            } else {
               mystrcopy(szRefNameBuf+1, pszParm, MAX_LINE_LEN-1);
            }
            szRefNameBuf[0] = '\n';
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszName) {
            pszName = pszArg;
            continue;
         }
         return 9+pbad(pszCmd,pszArg);
      }

      if (pszName)
      {
         int isize = 0;
         char *ptext = (char*)sfkgetvar(pszName, &isize);
         if (!ptext)
         {
            if (!pszDef)
               return 9+perr("undefined variable: %s\n", pszName);
            ptext = pszDef;
            isize = strlen(pszDef);
         }

         if (iNumLine != -1 || pszLinePat[0] != 0)
         {
            char *phit = 0;
            if (iNumLine > 0) {
               phit = ptext;
               iNumLine--;
               for (; iNumLine > 0; iNumLine--) {
                  while (*phit!=0 && *phit!='\n')
                     phit++;
                  if (!*phit)
                     { phit=0; break; }
                  phit++;
               }
            } else {
               if (pszLinePat[0] == '\n') {
                  // searching for line start:
                  // extra text start comparison.
                  if (cs.usecase) {
                     if (!strncmp(ptext, pszLinePat+1, strlen(pszLinePat+1)))
                        phit = ptext;
                  } else {
                     if (!mystrnicmp(ptext, pszLinePat+1, strlen(pszLinePat+1)))
                        phit = ptext;
                  }
               }
               if (phit == 0) {
                  if (cs.usecase)
                     phit = strstr(ptext, pszLinePat);
                  else
                     phit = mystrstri(ptext, pszLinePat);
               }
            }
            if (phit != 0) {
               // extract whole line. consider \n at start.
               if (*phit == '\n')
                  phit++;
               else
                  while (phit > ptext && phit[-1] != '\n')
                     phit--;
               for (isize=0; phit[isize]!=0 && phit[isize]!='\r' && phit[isize]!='\n'; isize++)
                  ;
               // sfk193: do NOT append CR or LF.
               // if (phit[isize]!=0) isize++;
               // make this new ptext.
               ptext = phit;
            } else {
               // no match: pass no text
               isize = 0;
            }
         }

         if (toFileName) {
            saveFile(toFileName, (uchar*)ptext, isize);
         }
         else if (isize < 1)
            { }
         else if (chain.coldata) {
            if (chain.colbinary) {
               if (chain.addBinary((uchar*)ptext, isize))
                  return 9;
            } else {
               // if (chain.addLine(ptext, str("")))
               //   return 9;
               if (chain.addBlockAsLines(ptext, isize))
                  return 9;
            }
         }
         else if (chain.colfiles) {
            Coi ocoi(ptext, 0);
            if (chain.addFile(ocoi)) // is copied
               return 9+perr("out of memory");
         } else {
            printf("%.*s\n", (int)isize, ptext);
         }
      }
      else
      {
         // this is for tracing/debugging, not for further processing.
         if (!cs.nohead)
            printx("%s#--- list of sfk variables: ---\n", pszPrefix);

         for (int i=0; ; i++)
         {
            char *pname  = 0;
            int   isize  = 0;
            uchar *ptext = (uchar*)sfkgetvar(i, &pname, &isize);
            if (!pname || !ptext)
               break;
            int   osize  = isize;
            if (!bfull)
                  osize  = mymin(160,isize);
            printx("$%s<def>\t", pname);
            if (bfull) {
               fwrite((uchar*)ptext, 1, osize, stdout);
               printf("\n");
            } else {
               printf("%s\n", dataAsTrace(ptext,osize));
            }
            if (osize<isize)
               printx("<time>[add option -raw to print all %d bytes]<def>\n",isize);
         }
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "env"))
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk env [-all] [word] [word2] [...] +...\n"
             "\n"
             "   list contents of environment variables having\n"
             "   all supplied words in their name or content.\n"
             "\n"
             "   $options\n"
             "      -all   dump contents of all env variables. when chaining\n"
             "             output to another command, and no words are given,\n"
             "             specifying -all is optional (see example below).\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk env sfk\n"
             "         list all environment variables containing \"sfk\"\n"
             "         for a quick overview of current sfk configuration.\n"
             "\n"
             "      #sfk env path\n"
             "         lists anything with PATH in name or content,\n"
             "         e.g. CLASSPATH, HOMEPATH, or PATHEXT.\n"
             "\n"
             "      #sfk env +filter -ls+path=\n"
             "         lists content of the PATH variable.\n"
             );
      ehelp;

      sfkarg;

      int iPatMin = 0;
      int iPatMax = 0;
      bool ball   = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) {
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!strcmp(argx[iDir], "-all"))
            { ball = 1; continue; }
         // take all non-chaining parms as patterns
         if (!iPatMin) iPatMin = iDir;
         iPatMax = iDir;
      }

      // dump environment variables to chain text output
      if (!penv) return 9+perr("missing environment");

      memset(szAttrBuf, 0, sizeof(szAttrBuf));
      for (int i=0; penv[i] != 0; i++)
      {
         char *psz = penv[i];

         int nlen = strlen(psz);
         memset(szAttrBuf, ' ', nlen);
         szAttrBuf[nlen] = '\0';

         bool bbail = 0;
         if (iPatMin)
         for (int ipat=iPatMin; !bbail && (ipat<=iPatMax); ipat++)
         {
            char *pszPat = argx[ipat];
            int ipos = 0;
            int ibas = 0;
            bool bhit = (bool)mystrstrip(psz+ibas, pszPat, &ipos);
            if (!bhit) { bbail=1; continue; }
            while (bhit) {
               memset(szAttrBuf+ibas+ipos, 'i', strlen(pszPat));
               ibas += ipos+strlen(pszPat);
               bhit  = (bool)mystrstrip(psz+ibas, pszPat, &ipos);
            }
         }
         if (bbail) continue;

         if (chain.coldata)
            chain.addLine(psz, szAttrBuf);
         else
            printColorText(psz, szAttrBuf);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "label"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk label name [options] +...\n"
             "$sfk ... +label name +...\n"
             "\n"
             "   define a label at the beginning or within an sfk script.\n"
             "   a label is a user-defined name that can be jumped to\n"
             "   by the sfk script command.\n"
             "\n"
             "   $prefix option\n"
             "\n"
             "      $-prefix=s<def>    set user-defined input parameter name prefix.\n"
             "\n"
             "      by default, parameters passed into sfk scripts are called $$1 to $$9,\n"
             "      or %%1 to %%9. with -prefix, you can define your own parameter names,\n"
             "      e.g. if you rewrite the sfk label line like this:\n"
             "\n"
             "         sfk label begin -prefix=$$parm\n"
             "\n"
             "      then the input parameters are renamed to $$parm1, $$parm2, ...\n"
             "      accepting no other names. or simply say\n"
             "\n"
             "         sfk label begin -prefix=%%\n"
             "\n"
             "      to accept ONLY %%1 to %%9 but NOT $$1 to $$9, to get around conflicts\n"
             "      with script commands using expressions like \"$$10.10col1\".\n"
             "\n"
             "   $global options\n"
             "\n"
             "      these options after \"label\" are #global<def> and therefore\n"
             "      valid for #all following commands<def>. Use them only\n"
             "      at the #first label in a script<def> for clarity.\n"
             "\n"
             "      $-var<def>         enable use of variables like ##(name)\n"
             "\n"
             "      $-qtrim<def>       automatic reformatting of quoted multi line\n"
             "                   parameters depending on target command.\n"
             "                   #this is default since SFK 1.8.0.\n"
             "                   e.g. +echo will keep line ends and some leading\n"
             "                   spaces to apply auto indentation, while +xed\n"
             "                   will strip all leading spaces and line ends.\n"
             "                   see \"sfk script\" for details.\n"
             "\n"
             "      $-qraw<def>        do not reformat quoted multi line parameters.\n"
             "                   this was default with sfk up to 1.7.7.\n"
             "                   since sfk 1.8.0 some old scripts may need:\n"
             "                      #sfk label labelname -qraw\n"
             "                   or via environment variable:\n"
             "                      #<exp> SFK_CONFIG=qraw\n"
             "\n"
             "      $-keepdata<def>    use old sfk 1.9.2 data passing.\n"
             "                   for details see: sfk help chain\n"
             "\n"
             "      for further options see: $sfk help opt\n"
             "\n"
             "      options must be given after the label name.\n"
             "      if -prefix is used it must be the first option.\n"
             "\n"
             "   $examples\n"
             "      #sfk samp sfkbat mytest.bat\n"
             "         creates a windows batch file mytest.bat\n"
             "         with an embedded sfk command script.\n"
             "\n"
             "      #sfk samp sfkbash mytest\n"
             "         creates a linux batch file mytest\n"
             "         with an embedded sfk command script.\n"
             "\n"
             "   $see also\n"
             "      #sfk script<def>   how to run sfk scripts.\n"
             "      #sfk if<def>       about conditional execution.\n"
             "      #sfk goto<def>     jump to a local label.\n"
             "      #sfk setglobalopt<def>   change global options.\n"
             );
      ehelp;

      sfkarg;

      char *pszName = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         // do NOT use generic isChainStart here:
         // any "+command" is allowed after labelname to enable
         // easy starting of sfk scripts.

         char *pszArg = argx[iDir];

         if (sfkisopt(pszArg)) 
         {
            // this writes to GLOBAL options, which are COPIED below.
            /*
            if (   strBegins(pszArg, "-qraw")
                || strBegins(pszArg, "-qtrim")
                || strBegins(pszArg, "-upat")
                || strBegins(pszArg, "-verbose") // internal with label
                || !strcmp(pszArg, "-var")
                || !strcmp(pszArg, "-keepdata")
                )
            */
            // sfk1933: all options available with label
            if (setGeneralOption(argx, argc, iDir, 1))
               continue;
            return 9+pbad(pszCmd, pszArg);
         }
         if (pszArg[0] == '+') {
            if (!pszName)
               return 9+perr("missing labelname before %s\n",pszArg);
            iChainNext = iDir;
            break;
         }

         if (!pszName)
            { pszName=pszArg; continue; }

         pbad(pszCmd, pszArg);
         pinf("if %s is a command, try +%s\n", pszArg, pszArg);
         return 9;
      }
      // copy GLOBAL options into LOCAL.
      // important for first sfk label in a script.
      memcpy(&cs, &gs, sizeof(cs));

      if (cs.verbose > 1)
         pinf("[nopre] label: %s\n", pszName);

      STEP_CHAIN(iChainNext, 0); // label

      bDone = 1;
   }

   ifcmd (strbeg(pszCmd, "setglobalopt")) // sfk1933
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk setglobalopt opt1 [opt2] ...\n"
             "\n"
             "   set option(s) which are globally valid for all\n"
             "   following commands, even after returning from\n"
             "   a function called by sfk call. for the list of\n"
             "   possible options type:\n"
             "\n"
             "      #sfk help opt\n"
             "\n"
             );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (setGeneralOption(argx, argc, iDir, 1))
               continue;
            return 9+pbad(pszCmd, pszArg);
         }
         if (pszArg[0] == '+') {
            iChainNext = iDir;
            break;
         }
         return 9+pbad(pszCmd, pszArg);
      }
      // copy GLOBAL options into LOCAL.
      memcpy(&cs, &gs, sizeof(cs));
 
      STEP_CHAIN(iChainNext, 0); // setglobalopt

      bDone = 1;
   }

   bool bTeeMode = 0;

   ifcmd (!strcmp(pszCmd, "tee") || !strcmp(pszCmd, "ftee"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk ... +tee [tofile] filename.txt\n"
             "$sfk ... +tee toterm\n"
             "\n"
             "   split current command chain data into two streams.\n"
             "   stream one is passed to the next command in the chain.\n"
             "   stream two is written to file, or printed to terminal.\n"
             "\n"
             "   $see also\n"
             "      sfk tofile      for file output options\n"
             "      sfk toterm      for terminal output options\n"
             "\n"
             "   $examples\n"
             "      #sfk list testfiles .txt +tee toterm +fview\n"
             "         list selected files on terminal AND open in dview.\n"
             );
      ehelp;

      sfkarg;

      // tee tofile filename OR tee toterm
      bTeeMode = 1;
      pszCmd = argx[iDir];
      if (pszCmd[0] == '+') pszCmd++;
      if (strcmp(pszCmd, "tofile") && strcmp(pszCmd, "toterm"))
         pszCmd = str("tofile"); // expecting immediate filename
      else
         iDir++;
      // fall through
   }

   ifcmd (   !strcmp(pszCmd, "tofile") || !strcmp(pszCmd, "toterm")
          || !strcmp(pszCmd, "append") || !strcmp(pszCmd, "appendto")
         )
   {
      ifhelp (!chain.useany())
      printx("<help>$sfk ... +tofile filename\n"
             "$sfk ... +toterm\n"
             "\n"
             "   save current command chain data in a file, or print it to terminal,\n"
             "   and then clear the chain. (next command in the chain will start\n"
             "   without any chain input data).\n"
             "\n"
             "   $options\n"
             "      -append       append to output file, instead of overwriting.\n"
             "\n"
             "   $aliases\n"
             "      +append[to]   same as +tofile -append.\n"
             "\n"
             "   $see also\n"
             "      sfk addtovar  append text as lines to a variable\n"
             "      sfk tee       same as tofile, toterm but also passes chain data\n"
             "                    to the next chain command (no clearing of chain).\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk list testfiles +toterm +run \"sfk echo [[Blue]]done[[def]]\" -yes\n"
             "         list selected files on terminal, then run a completely\n"
             "         independent command which does NOT use chain input.\n"
             "\n"
             "      #sfk echo hello1 +tofile output.txt\n"
             "      #sfk echo hello2 +append output.txt\n"
             "         create a new textfile output.txt with the first command,\n"
             "         then append further output with subsequent commands.\n"
             );
      ehelp;

      sfkarg;

      bool btofile   = !strcmp(pszCmd, "tofile");
      char *pszFile  = 0;
      cchar *pszMode = "w";

      if (!strcmp(pszCmd, "append") || !strcmp(pszCmd, "appendto")) {
         btofile = 1;
         pszMode = "a";
      }

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (!strcmp(pszArg, "-append")) {
            pszMode = "a";
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (btofile && !pszFile)
            pszFile = pszArg;
         else
            return 9+perr("unexpected: %s\n", pszArg);
      }

      if (btofile && !pszFile)
         return 9+perr("+tofile: missing output filename.\n");

      if (!bTeeMode) {
         chain.coldata  = 0;
         chain.colfiles = 0;
      }

      Coi ocoi(1);

      if (pszFile) {
         ocoi.setName(pszFile);
         if (ocoi.open(pszMode))
            return 9+perr("cannot write: %s\n", pszFile);
      }

      if (chain.usedata) {
         for (int i=0; i<chain.indata->numberOfEntries(); i++) {
            char *pattr = str("");
            char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
            if (ptext) {
               if (ocoi.hasName())
                  ocoi.writeLine(ptext);
               else
                  printColorText(ptext, pattr, 1); // with lf
               if (bTeeMode)
                  chain.addLine(ptext, pattr);
            }
         }
      }
      else
      if (chain.usefiles) {
         for (int i=0; i<chain.numberOfInFiles(); i++) {
            Coi *pcoi = chain.getFile(i);
            if (pcoi) {
               if (ocoi.hasName())
                  ocoi.writeLine(pcoi->name());
               else
                  oprintf("%s\n", pcoi->name());
               if (bTeeMode)
                  chain.addFile(*pcoi);
            }
         }
      }

      if (ocoi.hasName())
         ocoi.close();

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "tovoid")) // sfk181
   {
      ifhelp (!chain.useany())
      printx("<help>$sfk ... +tovoid\n"
             "\n"
             "   drop current chain text produced by a previous command.\n"
             "\n"
             "   $examples\n"
             "      #sfk xex in.txt \"/foo*bar/\" +if \"rc=0\" end +tovoid +echo found\n"
             "         if in.txt contains the searched pattern then print \"found\",\n"
             "         but without printing the actual found text to terminal.\n"
             "\n"
             );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s\n", pszArg);
      }

      chain.indata->resetEntries();
      chain.outdata->resetEntries();
      chain.infiles->resetEntries();
      chain.outfiles->resetEntries();

      STEP_CHAIN(iChainNext, 0); // tovoid

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "storetext"))
   {
      ifhelp (!chain.usedata && nparm < 1)
      printx("<help>$sfk ... +storetext\n"
             "\n"
             "   store current chain text for later use by gettext.\n"
             "   see \"sfk tail\" for a script example.\n"
             "\n"
             "   $options\n"
             "     -append    do not reset previously stored text\n"
             "                but append current chain text to it.\n"
             "\n"
             "   $see also\n"
             "     #sfk gettext<def>   retrieve stored text\n"
             "\n"
             "   $examples\n"
             "     #sfk load in.txt +storetext +filter -+foo\n"
             "      #+gettext +filter -+bar\n"
             "       content of in.txt is stored in memory, then two\n"
             "       different filterings are done on the same text.\n"
             );
      ehelp;

      sfkarg;

      bool bAppend = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (!strcmp(pszArg, "-append")) {
            bAppend = 1;
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+pbad(pszCmd, pszArg);
      }

      if (!bAppend)
         chain.storedata->resetEntries();

      for (int i=0; i<chain.indata->numberOfEntries(); i++) {
         char *pattr = str("");
         char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
         if (!ptext)
            break;
         chain.storedata->addEntry(ptext, pattr ? pattr : str(""));
         chain.outdata->addEntry(ptext, pattr ? pattr : str(""));
      }

      chain.storetextdone = 1;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "gettext"))
   {
      ifhelp (!chain.storetextdone)
      printx("<help>$sfk ... +gettext\n"
             "\n"
             "   get chain text stored by +storetext.\n"
             "   also see \"sfk tail\" for a script example.\n"
             "\n"
             "   $options\n"
             "      -verbose  tell number of input records\n"
             "                stored by previous +storetext\n"
             "\n"
             "   $examples\n"
             "     type \"sfk tail\" for a script example.\n"
             );
      ehelp;

      sfkarg;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+pbad(pszCmd, pszArg);
      }

      if (cs.verbose)
         printf("[gettext: storedata has %d records]\n", chain.storedata->numberOfEntries());

      for (int i=0; i<chain.storedata->numberOfEntries(); i++)
      {
         char *pattr = str("");
         char *ptext = chain.storedata->getEntry(i, __LINE__, &pattr);
         if (!ptext)
            break;
         if (chain.coldata)
            chain.outdata->addEntry(ptext, pattr ? pattr : str(""));
         else
         if (pattr && pattr[0])
            printColorText(ptext, pattr, 1); // fix sfk181
         else
            printf("%s\n", ptext);
      }
 
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "stop"))
   {
      ifhelp (argc <= 2)
      printx("<help>$sfk ... +stop [rc] [text]\n"
             "\n"
             "   stop command chain execution.\n"
             "   returns with code 0 or given rc.\n"
             "\n"
             "   add a text within \"\" quotes to print it.\n"
          // "   supporting sfk echo format.\n"
             "\n"
             "   rc 0 to 8 stops current function only.\n"
             "   rc 9 or higher also stops calling code\n"
             "   and produces a dump of chain text data.\n"
             "\n"
             "   $options\n"
             "      -all      alias for return code 9,\n"
             "                to stop whole sfk execution.\n"
             "      -text s   specify text s\n"
             "\n"
             "   $examples\n"
             "      see \"sfk tail\" for a script example.\n"
             "      #sfk -showrc echo \"hello\" +stop 3\n"
             "         produces shell return code 3.\n"
             );
      ehelp;

      sfkarg;

      // +stop should NEVER pass text further in the chain.
      chain.coldata = 0;
      chain.colbinary = 0;

      int iRC = -1;
      int istate = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (!strcmp(pszArg, "-text")) {
            istate = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-all")) {
            iRC = 9;
            istate = 1;
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         switch (istate) {
            case 0:
               if (isdigit(*pszArg)) {
                  iRC = atoi(pszArg);
                  istate = 1;
                  continue;
               }
            case 1:
               if (strchr(pszArg, '['))
                  printEcho(0, "%s", pszArg);
               else
                  printEcho(0, "[Red]%s[def]", pszArg);
               istate = 2;
               continue;
            default:
               break;
         }
         return 9+pbad(pszCmd, pszArg);
      }

      if (iRC == -1)
         iRC = 0;

      // force dump of chain content on rc
      if (iRC >= 9 && chain.useany()) {
         // may contain a stream, therefore
         uchar *pInText = 0;
         char  *pInAttr = 0;
         num    nInSize = 0;
         if (loadInput(&pInText, &pInAttr, &nInSize, 0, 0, 1))
            return 9;
         CharAutoDel odel1((char*)pInText);
         CharAutoDel odel2(pInAttr);
         printx("#--- chain text on stop rc %d: ---<def>\n", iRC);
         char *psrccur = (char*)pInText;
         char *psrcmax = psrccur+nInSize;
         while (psrccur<psrcmax) {
            char *pnext = psrccur;
            while (pnext<psrcmax && *pnext!='\r' && *pnext!='\n') pnext++;
            int  ilen=pnext-psrccur;
            printf("%s\n",dataAsTrace(psrccur,ilen));
            if (pnext<psrcmax && *pnext=='\r') pnext++;
            if (pnext<psrcmax && *pnext=='\n') pnext++;
            psrccur=pnext;
         }
      }

      return iRC;
   }

   ifcmd (   strBegins(pszCmd, "xmlform") // +wref
          || !strcmp(pszCmd, "xf")
         )
   {
      ifhelp (bFullHelp || (chain.usedata == 0 && nparm < 1))
      printx("<help>$sfk ... +xmlform[3]\n"
             "$sfk xmlform in.xml\n"
             "\n"
             "   simple XML text reformatter to allow easy reading\n"
             "   and searching of XML data.\n"
             "\n"
             "   this command is experimental and may not be suitable\n"
             "   to reformat XML data intended for further processing,\n"
             "   as lines longer than 3900 characters may be hard wrapped!\n"
             "   furthermore output of multi line tags may contain\n"
             "   wrong indentation in some cases.\n"
             "\n"
             "   $options\n"
             "     -i         read text from stdin.\n"
             "     -indent=3  or typing \"sfk xmlform3\" selects an\n"
             "                indent of 3 instead of the default 2.\n"
             "\n"
             "   $aliases\n"
             "     #sfk xf<def>        same as xmlform\n"
             "\n"
             "   $see also\n"
             "     #sfk jsonform<def>  reformat JSON data\n"
             "\n");
      webref("xmlform");
      printx("   $examples\n"
             "     #sfk xmlform in.xml\n"
             "       read the file in.xml and print it reformatted\n"
             "\n"
             "     #sfk xmlform in.xml +view\n"
             "       display in.xml reformatted in Depeche View\n"
             "       to allow easy browsing and searching\n"
             "\n"
             "     #sfk filter in.xml +xmlform\n"
             "       reformat output of a previous sfk command\n"
             "\n"
             #ifdef _WIN32
             "     #type in.xml | sfk xmlform -i\n"
             #else
             "     #cat in.xml | sfk xmlform -i\n"
             #endif
             "       reformat output of a non-sfk command\n"
             "\n"
             "     #sfk xex in.xml \"x<web_info>**</web_info>x[part2]x\"\n"
             "      #+xmlform +view\n"
             "       extract a web_info multi line text block,\n"
             "       reformat and display it in Depeche View. [22]\n"
             "       this uses 'x' as a separator character as '/'\n"
             "       and '_' are already part of the search text.\n"
             "\n"
             "     #sfk web http://myserver/getxml.php +xf\n"
             "       call a web URL that sends an xml reply\n"
             "       and reformat output for easy reading.\n"
             );
      ehelp;

      sfkarg;

      CommandScope oscope("xmlform");

      int   itabsize = 2;
      bool  bstdin   = 0;
      char *pszInFile= 0;

      char *psz = pszCmd+strlen("xmlform");
      if (isdigit(*psz))
          itabsize=atoi(psz);

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-indent", &pszParm)) {
            if (!pszParm) return 9;
            itabsize = atol(pszParm);
            continue;
         }
         if (!strcmp(argx[iDir], "-i")) {
            bstdin = 1;
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:
         if (!bstdin && !chain.usedata && !pszInFile) {
            pszInFile = pszArg;
            continue;
         }

         return 9+perr("unexpected: %s\n", argx[iDir]);
      }

      if (!bstdin && !pszInFile && !chain.usedata)
         return 9+perr("missing input");

      cchar *acol = "xh";
      int icol = strlen(acol);
 
      int inest=0,inest2=0,itmpnest=0;
      int btag=0;

      char szEndTag[300];

      uchar *pInText = 0;
      char  *pInAttr = 0;
      num    nInSize = 0;

      if (loadInput(&pInText, &pInAttr, &nInSize, bstdin, pszInFile, 1))
         return 9;

      CharAutoDel odel1((char*)pInText);
      CharAutoDel odel2(pInAttr);

      char *ptextcur=(char*)pInText;
      char *pattrcur=pInAttr;

      int iHardWrap = 0;
      bool bGlue = 0;

      while (ptextcur && *ptextcur && pattrcur && *pattrcur)
      {
         char *pnext = ptextcur+1;
         for (; *pnext; pnext++) {
            if (!strncmp(pnext, "</", 2)) {
               if (!bGlue)
                  break;
               bGlue = 0;
               continue;
            }
            if (*pnext == '<')
               break;
         }
         int iLineLen = pnext-ptextcur;
         if (iLineLen > MAX_LINE_LEN) {
             iLineLen = MAX_LINE_LEN;
             iHardWrap++;
         }

         memcpy(szLineBuf2, ptextcur, iLineLen);
         memcpy(szAttrBuf2, pattrcur, iLineLen);
         szLineBuf2[iLineLen] = '\0';
         szAttrBuf2[iLineLen] = '\0';
 
         // -----

         char *pSrcCur = szLineBuf2;
         char *pSrcMax = szLineBuf2+strlen(szLineBuf2);
         char *pDstCur = szLineBuf;
         char *pDstMax = szLineBuf+MAX_LINE_LEN;
         char *pAttCur = szAttrBuf;
         char *pAttMax = szAttrBuf+MAX_LINE_LEN;

         int istate=0;

         if (striBegins(pSrcCur, "<?xml"))
         {
            strcopy(szLineBuf, pSrcCur);
            szAttrBuf[0] = '\0';
         }
         else
         {
          while (pSrcCur<pSrcMax && pDstCur<pDstMax)
          {
            char c1 = pSrcCur[0];
            char c2 = c1 ? pSrcCur[1] : 0;
            // itmpnest=0;
            if (c1=='<' && c2!='/') {  // start tag
               // check for <footag/>
               // TODO: fails with multi line tags
               char *pszKet = strchr(pSrcCur+1, '>');
               bool bSelfClosed = (pszKet!=0 && pszKet[-1]=='/') ? 1 : 0;
               if (!bSelfClosed)
                  bGlue = 1;
               // FROM <footag any="123" ...>
               // TO   </footag> for quick lookup
               szEndTag[0] = '<';
               szEndTag[1] = '/';
               mystrcopy(szEndTag+2, pSrcCur+1, sizeof(szEndTag)-20);
               char *psz = szEndTag+2;
               while (*psz!=0 && *psz!='/' && *psz!='>' && *psz!=' ' && *psz!='\t')
                  psz++;
               if (*psz) {
                  *psz++ = '>';
                  *psz++ = '\0';
               }
               // only if such end tag(s) exist, count nesting
               if (bSelfClosed==0 && strstr((char*)pInText, szEndTag)!=0) {
                  // printf("endtag-hit : \"%s\"\n", szEndTag);
                  inest++;
                  inest2=inest;
               } else {
                  // printf("endtag-miss: \"%s\"\n", szEndTag);
                  itmpnest=1;
               }
               btag=1;
            }
            else
            if (c1=='<' && c2=='/') {  // end tag
               // see below
               btag=1;
            }
            // else
            // if (c1=='/' && c2=='>') {  // end of tag
            //    inest--;
            // }

            if (istate==0) {
               if (isspace(c1)) {
                  pSrcCur++;
                  continue;
               }
               int itmp=inest+itmpnest;
               int indec=itmp?(itmp-1):0;
               for (int i=0; i<indec*itabsize; i++) {
                  if (pDstCur>=pDstMax)
                     break;
                  *pDstCur++=' ';
                  *pAttCur++=' ';
               }
               istate=1;
            }

            char cattr = ' ';
            if (btag)
                 cattr = acol[(inest2+itmpnest)&1];

            *pDstCur=c1;
            *pAttCur=cattr;

            if (c1=='<' && c2=='/') {  // end tag
               inest--;
            }
            else
            if (c1=='>') {
               btag=0;
               inest2=inest;
               itmpnest=0;
            }

            pSrcCur++;
            pDstCur++;
            pAttCur++;
          }
          *pDstCur='\0';
          *pAttCur='\0';
         }

         {
            // sfk180: fix: unwanted blank lines
            char *p  = szLineBuf;
            int ilen = strlen(p);
            while (    ilen > 0
                   && (   p[ilen-1] == '\r'
                       || p[ilen-1] == '\n'
                       || p[ilen-1] == ' '
                       || p[ilen-1] == '\t'
                      )
                  )
            {
               p[ilen-1] = '\0';
               ilen--;
            }
         }

         if (chain.coldata)
            chain.addLine(szLineBuf, szAttrBuf, 1);  // split by lf
         else
            printColorText(szLineBuf, szAttrBuf, 1); // with lf

         // -----

         ptextcur += iLineLen;
         pattrcur += iLineLen;
      }

      if (iHardWrap && !cs.nowarn)
         pwarn("%d lines(s) were hard wrapped.\n", iHardWrap);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "jsonform")  // sfk1952
          || !strcmp(pszCmd, "jform")
         )
   {
      ifhelp (bFullHelp || (chain.usedata == 0 && nparm < 1))
      printx("<help>$sfk ... +jsonform\n"
             "$sfk jform in.json\n"
             "\n"
             "   simple JSON text reformatter to allow easy reading\n"
             "   and searching of JSON data.\n"
             "\n"
             "   this command is experimental and may not be suitable\n"
             "   to reformat JSON data intended for further processing,\n"
             "   as lines longer than 3900 characters may be hard wrapped.\n"
             "\n"
             "   $options\n"
             "     -i             read text from stdin\n"
             "     -allocmb=n     use n mbytes output buffer\n"
             "\n"
             "   $aliases\n"
             "     #sfk jform<def>      same as jsonform\n"
             "\n"
             "   $see also\n"
             "     #sfk xmlform<def>    reformat XML data\n"
             "\n");
      printx("   $examples\n"
             "     #sfk jform in.json\n"
             "       read the file in.json and print it reformatted\n"
             "\n"
             "     #sfk load in.json +jform\n"
             "       the same, but get data from a previous command\n"
             "\n"
             "     #sfk load in.json +jform +view\n"
             "       display in.json reformatted in Depeche View\n"
             "       to allow easy browsing and searching\n"
             "\n"
             "     #sfk web http://myserver/mycall +jform\n"
             "       call a web URL that sends a JSON reply\n"
             "       and reformat output for easy reading.\n"
             );
      ehelp;

      sfkarg;

      bool bstdin = 0;
      int  nalloc = 0;
      char *pszInFile= 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-allocmb", &pszParm)) {
            if (!pszParm) return 9;
            nalloc = atol(pszParm);
            continue;
         }
         if (!strcmp(pszArg, "-i"))
            { bstdin = 1; continue; }
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!bstdin && !chain.usedata && !pszInFile) {
            pszInFile = pszArg;
            continue;
         }
         return 9+perr("unexpected: %s",pszArg);
      }

      if (!bstdin && !pszInFile && !chain.usedata)
         return 9+perr("missing input");

      uchar *pData = 0, *pOut = 0, *pAtt = 0;
      num    nSize = 0,  nOutSize = 0;

      if (loadInput(&pData, 0, &nSize, bstdin, pszInFile, 0))
         return 9;

      if (pData != 0 && nSize > 0)
      {
         if (nalloc)
            nOutSize = nalloc * 1000000;
         else
            nOutSize = (nSize+100) * 3;
   
         pOut = new uchar[nOutSize+10];
         pAtt = new uchar[nOutSize+10];

         if (!pOut || !pAtt)
            return 9+perr("out of memory (%d mb)", (int)(nOutSize/1000000));
   
         if (reformatjson((char*)pData, (char*)pOut, (char*)pAtt, nOutSize))
            return 9+perr("buffer overflow %d %d",(int)nSize,(int)nOutSize);
   
         nOutSize = strlen((char*)pOut);
   
         if (nOutSize > 0)
            dumpOutput(pOut, (char*)pAtt, nOutSize, 0);
      }

      if (pData) delete [] pData;
      if (pOut)  delete [] pOut;
      if (pAtt)  delete [] pAtt;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "sort")) // +wref
   {
      ifhelp (!chain.usedata || (nparm >= 1 && isHelpOpt(argv[iDir])))
      printx("<help>$sfk ... +sort\n"
             "\n"
             "   sort text lines, case insensitive by default.\n"
             "   requires a previous command producing text output.\n"
             "\n"
             "   $options\n"
             "      -case        case sensitive text comparison\n"
             "      -rev[erse]   reverse sorting order\n"
             "      -skiphead    first line is a table header,\n"
             "                   exclude this from sorting\n"
             "      -head=n      keep first n lines unsorted\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk filter csv.txt +sort\n"
             "         print sorted contents of csv.txt\n"
             #ifdef _WIN32
             "      #sfk filter csv.txt +sort +view<def>\n"
             "         shows output with the dview GUI tool\n"
             #endif
             );
      ehelp;

      sfkarg;

      if (!chain.usedata) {
         perr("missing chain text input for +sort");
         pinf("need a previous command producing text output\n");
         return 9;
      }

      bool brev = 0;
      int ihead = 0;
      cchar *ptabcol = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-tabcol", &pszParm)) {
            if (!pszParm) return 9;
            ptabcol = pszParm;
            continue;
         }
         if (strBegins(pszArg, "-rev")) {
            brev = 1;
            continue;
         }
         if (   !strcmp(pszArg, "-head")
             || !strcmp(pszArg, "-header")
             || !strcmp(pszArg, "-skiphead")
            )
         {
            ihead=1;
            continue;
         }
         if (strBegins(pszArg, "-head=")) {
            ihead=atoi(pszArg+6);
            continue;
         }
         if (sfkisopt(argx[iDir])) {
            if (isDirParm(argx[iDir]))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argx[iDir]);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s\n", argx[iDir]);
      }

      if (groupChainText(pszCmd, brev, 0, 0, ihead, ptabcol)) return 9;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }
 
   ifcmd (!strcmp(pszCmd, "count"))
   {
      // ifhelp (!chain.usedata || (nparm >= 1 && isHelpOpt(argv[iDir])))
      ifhelp (argc < 3)
      printx("<help>$sfk count [-same[lines]] infile\n"
             "\n"
             "   count total number of text lines, or group identical\n"
             "   text lines, counting the number of occurences per line.\n"
             "\n"
             "   may read chain text from a previous command,\n"
             "   or text lines from a given input filename.\n"
             "   lines larger than %d characters are hard wrapped.\n"
             "\n"
             "   $options\n"
             "      -samelines  count number of occurences per line, then\n"
             "                  prefix lines by TAB separated counter.\n"
             "      -digits=n   with -samelines, change no. of counter digits\n"
             "      -case       case sensitive text comparison\n"
             "\n"
             "   $see also\n"
             "      #sfk filter<def>  with -unique, to strip duplicate lines.\n"
             #ifdef _WIN32
             "      #sfk view<def>    a GUI tool that can filter text just by\n"
             "                  typing or clicking on a word, telling\n"
             "                  the number of result lines instantly.\n"
             #endif
             "\n"
             , (int)MAX_LINE_LEN
             );
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk count in.txt\n"
             "         tell number of lines in file in.txt\n"
             "      #sfk filter words.txt +count -same -digits=10\n"
             "         tell how often each line occurs in words.txt,\n"
             "         and format the occurence counter with 10 digits.\n"
             "      #sfk -var filter in.txt +setvar a +count +setvar n\n"
             "       #+for i from 5 to ##(n) +getvar -numline=##(i) a +endfor\n"
             "         stores in.txt in variable a, the number of lines\n"
             "         in variable n, then prints line 5 to end.\n"
             );
      ehelp;

      sfkarg;

      bool bsame = 0;
      int  ndig  = 5;
      char *pszInFile = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         char *pszParm = 0;
         if (!strncmp(pszArg, "-same", 5)) {
            bsame = 1;
            continue;
         }
         else
         if (haveParmOption(argx, argc, iDir, "-digits", &pszParm)) {
            if (!pszParm) return 9;
            ndig = atol(pszParm);
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!chain.usedata && !pszInFile) {
            pszInFile = pszArg;
            continue;
         }
         return 9+perr("unexpected: %s\n", pszArg);
      }

      if (pszInFile)
      {
         num  nLines = 0;
         uchar *pnul = 0;
         uchar *pone = pnul+1;
         // read lines from file
         KeyMap omap;
         omap.setcase(cs.usecase);
         StringMap oout;
         Coi ocoi(pszInFile, 0);
         if (ocoi.open("rb"))
            { pferr(pszInFile, "cannot read: %s\n", pszInFile); return 9; }
         while (ocoi.readLine(szLineBuf, sizeof(szLineBuf)-10) > 0)
         {
            nLines++;
            if (!bsame)
               continue;
            szLineBuf[sizeof(szLineBuf)-10] = '\0';
            removeCRLF(szLineBuf);
            uchar *pcnt = (uchar*)omap.get(szLineBuf);
            if (pcnt) {
               pcnt++;
               omap.put(szLineBuf, pcnt);
            } else {
               omap.put(szLineBuf, (void*)1);
            }
         }
         ocoi.close();
         if (bsame) {
            // dump sorted statistic
            for (int i=0; i<omap.size(); i++)
            {
               char  *ptxt = 0;
               uchar *pcnt = (uchar*)omap.iget(i, &ptxt);
               snprintf(szLineBuf2, MAX_LINE_LEN, "%0*u\t%s", ndig,(uint)(pcnt-pnul),ptxt);
               oout.put(szLineBuf2, 0);
            }
            for (int k=0; k<oout.size(); k++) {
               char *pkey = 0;
               void *ptmp = oout.iget(k, &pkey);
               int   idig = 0;
               while (pkey[idig]!=0 && pkey[idig]!='\t')
                     idig++;
               memset(szAttrBuf, 'p', idig);
               for (; pkey[idig]; idig++)
                  szAttrBuf[idig] = ' ';
               szAttrBuf[idig] = '\0';
               if (chain.colany())
                  chain.addLine(pkey, szAttrBuf);
               else
                  printColorText(pkey, szAttrBuf, 1); // with lf
            }
         } else {
            chain.print("%s\n", numtoa(nLines));
         }
      }
      else
      {
         if (!chain.usedata) {
            perr("missing chain text input for +count");
            pinf("need a previous command producing text output\n");
            return 9;
         }
   
         if (!bsame) {
            sprintf(szLineBuf, "%d", chain.indata->numberOfEntries());
            if (chain.colany())
               chain.addLine(szLineBuf, str(""));
            else
               printColorText(szLineBuf, str(""), 1); // with lf
         } else {
            if (groupChainText(pszCmd, 0, bsame, ndig)) return 9;
         }
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "perline")) // +var
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk ... +perline \"command ##text\"\n"
             "\n"
             "   for every chain text line run sfk commands(s)\n"
             "   like a sub function, passing the text as parameters.\n"
             "\n"
             "   $options\n"
             "      -yes        really execute. default is just to simulate\n"
             "                  what would be done.\n"
             "      -setvar x   put whole line text into variable x,\n"
             "                  for easy use in a call without parameters.\n"
             "      -nohead     does not display the [simulating:] info text.\n"
             "      -stoprc=n   stop on return code >= n instead of default 9.\n"
             "      -nostop     do not stop on errors regardless of rc.\n"
             "\n");
      printx("   $command string format\n"
             "      each word, separated by whitespace, is a parameter.\n"
             #ifdef SFK_BOTH_RUNCHARS_HELP
             "      to fill in the current chain text line use <head>$$text<def> or <head>##text<def>.\n"
             "      perline uses a strict command format by default.\n"
             "      to insert characters $$ or ## as is type <head>$$$$<def> or <head>####<def>\n"
             #else
             "      to fill in the current chain text line use <head>##text<def>.\n"
             "      perline uses a strict command format by default.\n"
             "      to insert character ## as is type <head>####<def>\n"
             #endif
             "      with option $-spat<def>, slashpatterns like $\\t \\q \\xnn<def> are supported.\n"
             "      to use multiple words as one parameter use $-spat<def> and $\\q ... \\q<def>\n"
             "\n");
      printx("   $quoted multi line parameters are supported in scripts\n" // perline
             "      using parm trim. type \"sfk script\" for details.\n"
             "\n"
             "   $recursion limit\n"
             "      if the called function calls another function by call\n"
             "      or perline this should not be nested too often,\n"
             "      otherwise sfk may crash.\n"
             "\n");
      printx("   $see also\n"
             "     #sfk run<def>        for the full command string format\n"
             "     #sfk stacksize<def>  test available stack size\n"
             "\n");
      webref("perline");
      printx("   $examples\n"
             "     #sfk echo -lines 100 101 102\n"
             "      #+perline -spat \"web -nodump \\q.<run>text/xml/restart.xml\\q\"\n"
             "        on local ip's .100 .101 and .102\n"
             "        call a web command /xml/restart.xml.   [17]\n"
             "     #sfk sel mydir .jpg +perline -spat \"echo <img src=\\q##ufile\\q \n"
             "      #width=\\q400\\q> +tofile -append print.html\"\n"
             "        create a file print.html containing all .jpg files of\n"
             "        folder mydir, shown with 400 pixels width. [28]\n"
             "     #sfk load in.txt +perline -setvar l \"call doline\" -yes +end\n"
             "        within a script: on every line set variable l with\n"
             "        the full line text, then call label doline.\n"
             "     #sfk load foldernames.txt +perline \"sfk list ##qtext\" -yes\n"
             "        load a file with folder names and list contained files.\n"
             "        qtext adds quotes around the names for safety.\n"
             );
      ehelp;

      sfkarg;

      cs.strict = 2;

      char *pszMask = 0;
      char *pszSetVar = 0;
      bool  bNoStop = 0;
      int   iStopRC = 9;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         char *pszParm = 0;
         if (haveParmOption(argx, argc, iDir, "-stoprc", &pszParm)) {
            if (!pszParm) return 9;
            iStopRC = atol(pszParm);
            continue;
         }
         if (haveParmOption(argx, argc, iDir, "-setvar", &pszParm)) {
            if (!pszParm) return 9;
            pszSetVar = pszParm;
            continue;
         }
         if (!strcmp(pszArg, "-nostop")) {
            bNoStop = 1;
            continue;
         }
         if (sfkisopt(pszArg)) {
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszMask) {
            if (iGlblInScript) // then argx[iDir] is writeable
               fixMultiLineParm(argx[iDir], 'p'); // perline
            pszMask = argx[iDir];
            continue;
         }
         return 9+pbad(pszCmd, pszArg);
      }
      if (!pszMask)
         return 9+perr("missing command string");

      cs.sim = !cs.yes;

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      StringPipe *pinraw = chain.indata;
      StringPipe *pinput = new StringPipe(); // leak on error
      StringPipe *pinvar = new StringPipe(); // leak on error
      chain.indata       = new StringPipe();

      char *pScript = new char[MAX_LINE_LEN+100];
      CharAutoDel odel(pScript);

      char *pszLine   = 0;

      // sfk filter in.txt +perline "echo $text"
      // sfk filter in.txt +perline "call mylabel $text"

      lRC = 0;

      while ((pszLine = pinraw->read(0)))
      {
         // mask: "echo $text"
         // line: "foo bar goo"
         Coi ocoi(pszLine, 0);

         int isubrc=0;
         if ((isubrc=renderOutMask(pScript, &ocoi, pszMask, "perline"))) // perline
         {
            if (pszSetVar!=0 && isubrc==1) {
               // ok, need no token
            } else {
               if (isubrc<10)
                  perr("missing #text or $text in perline command\n");
               lRC = 9;
               break;
            }
         }

         if (cs.sim) {
            if (pszSetVar)
               printf("%s, set %s=\"%s\"\n", pScript, pszSetVar, pszLine);
            else
               printf("%s\n", pScript);
         }

         pinput->addEntry(pScript, 0);

         if (pszSetVar)
            pinvar->addEntry(pszLine, 0);
      }

      delete pinraw;
      pinraw = 0;

      // NOTE: do NOT use ANY cs. variable while running submain()
      //       as the wholse cs. state will be reset! store all here:
      bool bSim     = cs.sim;
      bool bYes     = cs.yes;
      bool bDebug   = cs.debug;
      bool bVerbose = cs.verbose;
      bool bNoHead  = cs.nohead;
 
      // === stop using cs. begin ===

      while ((pszLine = pinput->read(0)))
      {
         if (pszSetVar) {
            char *pszVarText = pinvar->read(0);
            sfksetvar(pszSetVar, (uchar*)pszVarText, strlen(pszVarText));
         }

         pScript = pszLine;

         // script: "echo foo bar goo".
         // NOTE: the script will change the whole sfk score,
         //       like cs settings, input/output data etc. !
         // It's just like normal commands being inserted.

         {
            StringTable oDynaStrings;
            char **psubargx = 0;
            int    isubargc = 0;
            int    nsubargc = 0;
            for (int npass=0; npass<2; npass++)
            {
               char *psz1 = pScript;
               char  cold = 0; // old char before current one
 
               // main processing, until +end token. (perline)
               while (*psz1)
               {
                  bool bnewline = 0;

                  // note: (1) bnewline is no longer detected in 2nd pass
                  nextToken(&psz1, cold, bnewline);

                  if (*psz1)
                  {
                     // on next (non-blank) token
                     char *ptok = psz1;
                     if (   (bnewline==1 || npass==1) // (1)
                         && isRemarkStart(ptok)
                        )
                     {
                        // skip remark line
                        while (*ptok && *ptok != '\n') ptok++;
                        // do NOT skip lf, set newline on next cycle
                        psz1 = ptok;
                        continue;
                     }
 
                     // find end of token
                     skipPastToken(&psz1, cold);
                     int ntoklen = psz1 ? (psz1-ptok) : 0;

                     int nrc = 0;
                     if (npass)
                     {
                        cold = *psz1;     // sfk181: can be NULL if on EOD
                        if (*psz1 != 0)   // else stay on EOD
                           *psz1++ = '\0';
                        // post-process token: strip quotes, transform inner quotes.
                        // no parameters!
                        // uses: szLineBuf
                        if (bDebug && npass)
                           printf(" tok: <<<%s>>>\n", ptok);
                        nrc = postProcessToken(&ptok, oDynaStrings, // perline
                           0, 0, 0, 0);
                        if (nrc >= 9) return 9+perr("unexpected format: \"%s\"\n", ptok);
                        // nrc==1 means skip EMPTY token.
                     }
 
                     // count and register token (perline)
                     if (!nrc) {
                        if (!npass) {
                           nsubargc++;
                        } else {
                           if (isubargc >= nsubargc)
                              return 9+perr("script overflow (%d/%d) @ %s\n",isubargc,nsubargc,ptok);
                           psubargx[isubargc++] = ptok;
                        }
                     } else {
                        // fix sfk1813: missing or wrong parm with perline
                        // nrc==1 means an empty token, which is counted
                        // by the first pass. correct that in second pass:
                        if (npass)
                           nsubargc--;
                     }
 
                     // reached "+end"?
                     if (isEndToken(ptok, ntoklen)) // !strncmp(ptok, "+end", 4))
                        break;
 
                  }  // endif *psz1
 
               }  // endwhile *psz1
 
               // at end of first pass, alloc token array
               if (!npass) {
                  psubargx = new char*[nsubargc+10];
                  if (!psubargx) { perr("outofmem (psubargx,%d)",nsubargc); return 19; }
               }
 
            }  // endfor pass
 
            if (bVerbose > 1) {
               printf("loaded %d words from perline script:\n", nsubargc);
               for (int i=0; i<nsubargc; i++)
                  printf("%s,",psubargx[i]);
               printf("\n");
            }

            char *pszSubCmd = psubargx[0];
            int iSubDir = 1;
            // if script starts like "sfk ...", skip "sfk":
            if (!strcmp(pszSubCmd, "sfk")) {
               pszSubCmd = psubargx[1];
               iSubDir = 2;
            }
            if (bVerbose > 0) {
               for (int i=0; i<nsubargc; i++)
                  printf("%s ", psubargx[i]);
               printf("\n");
            }

            // commands in script must start as with no previous chain
            chain.reset();
            resetStats();     // sfk1914: missing per entry, see STEP_CHAIN

            if (bYes)
            {
               iGlblInScript++;
                lRC = submain(nsubargc, psubargx, penv, pszSubCmd, iSubDir, bFatal); // perline
               iGlblInScript--;
            }

            if (bVerbose && lRC)
               printf("... rc %d for %s\n", lRC, pszSubCmd);
 
            if (psubargx) delete [] psubargx;
            oDynaStrings.resetEntries();
         }

         if (bNoStop == 0 && lRC >= iStopRC)
            break;

      }  // endwhile input line

      delete pinput;
      delete pinvar;

      if (bSim && !bNoHead)
         printx("$[add -yes to execute.]\n");

      // === stop using cs. end ===

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0); // perline
         }
      }

      bDone = 1;
   }

   #ifdef _WIN32
   #ifndef VFILEMAX
   if (!strcmp(pszCmd, "donate"))
   {
      if (blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported
 
      char *pszURL = str("http://stahlworks.com/donate/");
 
      printf("opening: %s\n", pszURL);

      ShellExecute(NULL, "open", pszURL, NULL, NULL, SW_SHOWNORMAL);

      bDone = 1;
   }
   #endif
   #endif

   if (!strcmp(pszCmd, "to")) // internal
   {
      ifhelp (1)
      printx("<help>$sfk cmd1 +to cmd2\n"
             "\n"
             "   force first command to pass chain text or binary data\n"
             "   to second command, instead of printing output to terminal.\n"
             "   output redirection is supported by some but not all commands.\n"
             "\n"
             "   $see also\n"
             "      #sfk help chain<def>       command chain overview\n"
             "      #sfk cmd1 +then cmd2<def>  forbid passing of data\n"
             );
      ehelp;

      return 9;
   }

   ifcmd (!strcmp(pszCmd, "sfk") || !strcmp(pszCmd, "then")) // actually +sfk
   {
      ifhelp (!strcmp(pszCmd, "then") && (argc < 3))
      printx("<help>$sfk then ...\n"
             "$sfk cmd1 +then cmd2\n"
             "\n"
             "   forbid first command to pass chain text or binary data\n"
             "   to second command. force printing of output to terminal.\n"
             "\n"
             "   $see also\n"
             "      #sfk help chain<def>       command chain overview\n"
          // "      #sfk cmd1 +to cmd2<def>    force passing of data\n"
             );
      ehelp;

      int iChainNext = iDir;

      if (iChainNext >= argc)
         return 9+perr("missing command after \"sfk\"");

      chain.reset();

      STEP_CHAIN(iChainNext, 0); // then

      lRC = 0;
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "end")
       || !strcmp(pszCmd, "tend")
       || !strcmp(pszCmd, "fend")
      )
   {
      ifhelp (!strcmp(pszCmd, "end") && (argc < 3))
      printx("<help>$sfk ... +end\n"
             "\n"
             "   marks the end of a chain of commands\n"
             "   or of a function with commands.\n"
             "\n"
             "   $chaining input control\n"
             "      by default, \"end\" does not consume\n"
             "      text input from previous commands.\n"
             "      use #+tend<def> to expect data input,\n"
             "      use #+fend<def> to expect file list input,\n"
             "      and to return this to the caller if +end\n"
             "      marks the end of a function.\n"
             "\n"
             "   $unexpected hex data with +tend chaining\n"
             "      if you get hex output like 746573746...\n"
             "      unexpectedly add +filter before +tend\n"
             "      to force lines instead of stream data.\n"
             "      see also: xed option -tolines\n"
             "\n"
             "   $see also\n"
             "      #sfk help chain<def>    command chain overview\n"
             #ifdef _WIN32
             "      #sfk samp sfkbat<def>   script example\n"
             #else
             "      #sfk samp sfkbash<def>  script example\n"
             #endif
             );
      ehelp;

      lRC = 0;
      bDone = 1;
      // fall through to exit
   }

   // do NOT use ifcmd here.
   if (!strcmp(pszCmd, "dump-console-intro"))
   {
      // this BLOCKS, waiting for a char input.
      dumpConsoleHelp(1);
      bDone = 1;
   }

   // do NOT use ifcmd here.
   if (!strcmp(pszCmd, "dump-main-help"))
   {
      printMainHelp(bhelp, penv);
      #ifdef SFKPRINTREDIR
      printf("\nINTERNAL: chain.print+echo full redirect\n");
      #endif
      // no real action here
      return 9;
   }

   #ifdef _WIN32
   if (!strcmp(pszCmd, "dumpcp"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk dumpcp codepage|own\n");
      ehelp;

      sfkarg;

      uint nCodePage = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         if (!nCodePage) {
            if (!strcmp(pszArg, "own"))
               nCodePage = GetACP();
            else
               nCodePage = atoi(pszArg);
            continue;
         }
         return 9+perr("unexpected: %s\n",pszArg);
      }
      if (!nCodePage)
         nCodePage = GetACP();

      char   sztmp[50];
      ushort awtmp[50];

      printf("// codepage %u. unlisted codes map 1:1.\n", nCodePage);
      printf("unsigned short glblCodePage%u[] = {\n   ", nCodePage);
      int ndone=0;
      for (uint c=1; c<256; c++)
      {
         sztmp[0] = c;
         sztmp[1] = 0;
         awtmp[0] = 0;
      
         MultiByteToWideChar( // win.dumpcp
            nCodePage, 0, sztmp, 1,
            (wchar_t*)awtmp, 10
            );
      
         ushort ntmp = awtmp[0];
         if (ntmp == 0) continue;
         if (ntmp == c) continue;
         printf("0x%02x,0x%04x, ",c,ntmp);
         if ((++ndone % 8)==0)
            printf("\n   ");
      }
      if ((ndone % 8) == 0)
         printf("0,0\n};\n");
      else
         printf("\n   0,0\n};\n");
      printf("// total %u mappings.\n", ndone);

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }
   #endif

   if (!strcmp(argv[1], "basic"))   // sfk196
   {
      printHelpText("basic", bhelp);
      bDone = 1;
   }

   ifcmd (!strcmp(argv[1], "help") || !strcmp(argv[1], "ascii"))
   {
      bool bShortAscii = strcmp(argv[1], "ascii") ? 0 : 1;

      if (!bhelp && !bShortAscii && (nparm < 1)) {
         fprintf(stderr, "please type just \"sfk\" to list the sfk main help.\n");
         return 9;
      }

      char *pszSub = str("");

      if (bShortAscii)
         pszSub = str("ascii");
      else
         pszSub = bhelp ? (char*)"" : argv[2];

      if (bhelp || !strncmp(pszSub, "color", 5))
      {
         printHelpText("color", bhelp);
         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp)
      {
         printx("<help>$sfk ascii  (or \"sfk help ascii\")\n"
                "\n"
                "   print a table of ASCII characters with their codes.\n"
                "\n"
               );
      }

      if (!strcmp(pszSub, "ascii") || !strcmp(pszSub, "ASCII"))
      {
         char *pszSubSub = str("");

         int iDir = bShortAscii ? 2 : 3;

         for (; iDir<argc; iDir++)
         {
            if (!strcmp(argv[iDir], "-ansi")) { pszSubSub=argv[iDir]; continue; }
            else
            if (!strcmp(argv[iDir], "-dos")) { pszSubSub=argv[iDir]; continue; }
            else
            if (!strncmp(argv[iDir], "-", 1)) {
               if (setGeneralOption(argv, argc, iDir))
                  continue;
               else
                  return 9+perr("unknown option: %s\n", argv[iDir]);
            }
         }
 
         #ifdef _WIN32
         bool bAnsiToOem = 0;
         bool bOemToAnsi = 0;
         if (!cs.outcconv) {
            if (pszSubSub[0]) pwarn("-nocconv overrides -ansi or -dos. no conversions are done.\n");
            printf("Character set: ASCII from 0 to 127, codes above depending on your terminal.\n");
         }
         else
         if (bGlblHaveInteractiveConsole) {
            // dumping to interactive Windows console
            if (!strcmp(pszSubSub, "-dos")) {
               printf("Character set: ASCII below code 127, above OEM codepage %u.\n", sfkchars.getocp());
            } else {
               bAnsiToOem = 1;
               printf("Character set: ASCII below code 127, above ANSI %u (displayed in DOS console).\n", sfkchars.getacp());
            }
         } else {
            // dumping into a file
            if (!strcmp(pszSubSub, "-dos")) {
               bOemToAnsi = 1;
               printf("Character set: ASCII below code 127, above OEM codepage %u.\n", sfkchars.getocp());
            } else {
               printf("Character set: ASCII below code 127, above ANSI %u (unconverted).\n", sfkchars.getacp());
            }
         }
         #else
         printf("Character set: ASCII from 0 to 127, codes above depending on your terminal.\n");
         #endif
         int nCharCols = 8;
         int nCharRows = 0x20; // (255 / nCharCols) + 1;
         for (int irow=0; irow<nCharRows; irow++)
         {
            for (int icol=0; icol<nCharCols; icol++)
            {
               int i = icol * nCharRows + irow;
               if (i > 255)
                  printf("        ");
               else {
                  uchar c = (uchar)i;
                  setTextColor(nGlblHitColor);
                  if (i < 10 ) putchar(' ');
                  if (i < 100) putchar(' ');
                  printf("%d ",i);
                  setTextColor(nGlblExampColor);
                  if (i < 0x10) putchar(' ');
                  printf("%X ",i);
                  setTextColor(-1);
                  #ifdef _WIN32
                  if (c >= 0x20)
                  #else
                  if (c >= 0x20 && !(c >= 0x7F && c < 0xA0))
                  #endif
                  {
                     #ifdef _WIN32
                     if (bAnsiToOem) c = sfkchars.ansitooem(c);
                     if (bOemToAnsi) c = sfkchars.oemtoansi(c);
                     if (c == 7) c = ' '; // sfk189 0x95 exception
                     #endif
                     putchar(c);
                     // setTextColor(-1);
                     if (icol < nCharCols)
                        printf("  ");
                  }
                  else
                  switch (c) {
                     case 4   : printf("EOT"); break;
                     case 7   : printf("BEL"); break;
                     case 8   : printf("BS "); break;
                     case 12  : printf("FF "); break;
                     case 0x1A: printf("EOF"); break;
                     case 27  : printf("ESC"); break;
                     case 127 : printf("DEL"); break;
                     case '\r': printf("CR "); break;
                     case '\n': printf("LF "); break;
                     case '\t': printf("TAB"); break;
                     default:
                        putchar('.');
                        if (icol < nCharCols)
                           printf("  ");
                        break;
                  }
               }
            }
            printf("\n");
         }

         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "opt", 3))
      {
         printHelpText("opt", bhelp);
         if (bhelp) printx("\n");
         bDone = 1;
      }

      #ifdef _WIN32
      if (bhelp) {
      printx("<help>$sfk help shell\n"
             "\n"
             "   how to configure the windows command prompt "
                "for best productivity\n"
             "\n"
            );
      }
      if (!strncmp(pszSub, "shell", strlen("shell"))) {
         printHelpText("shell", bhelp);
         bDone = 1;
      }
      #endif

      if (bhelp || !strncmp(pszSub, "chain", 5))
      {
         printHelpText("chain", bhelp);
         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "var", 3))
      {
         printHelpText("var", bhelp);
         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "sel", 3))
      {
         printHelpText("sel", bhelp);
         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "pat", 3))
      {
         printHelpText("pat", bhelp);
         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strcmp(pszSub, "chars"))
      {
         printHelpText("chars", bhelp);
         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strcmp(pszSub, "nocase"))
      {
         printHelpText("nocase", bhelp);
         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strcmp(pszSub, "offtime"))
      {
         printHelpText("offtime", bhelp);
         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strcmp(pszSub, "tcp"))
      {
         printHelpText("tcp", bhelp);
         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || strBegins(pszSub, "uni") || strBegins(pszSub, "utf"))
      {
      printx("$sfk unicode support%s:\n",
             bhelp ? " (type \"sfk help unicode\")":"");
      printx("\n"
         "   $1. commands with real unicode conversion\n"
         "\n"
         #ifdef _WIN32
         "   #sfk wtoa<def>   convert UCS-2 wide character data to 8-bit data\n"
         "              in the Ansi codepage of your Windows system.\n"
         "              cannot convert characters outside your codepage.\n"
         "   #sfk atow<def>   convert 8-bit Ansi codepage data to UCS-2 wide chars.\n"
         #endif
         "   #sfk wtou<def>   convert UCS-2 wide character data to 8-bit UTF-8.\n"
         "   #sfk utow<def>   convert 8-bit UTF-8 data to UCS-2 wide characters.\n"
         #ifdef _WIN32
         "   #sfk utoa<def>   convert UTF-8 to Ansi. cannot convert characters\n"
         "              outside your codepage.\n"
         "   #sfk atou<def>   convert Ansi to UTF-8.\n"
         #endif
         );
      printx("\n"
         "   $2. primitive generic reading of wide character files\n"
         "\n"
         "   by default, sfk commands that need to read TEXT files will\n"
         "   skip utf-16 (ucs-2, wide char) files, as they look like binary,\n"
         "   containing zero bytes.\n"
         "\n"
         "   you may set option \"#-wchar<def>\" to activate utf-16 detection and decoding\n"
         "   for file READING, allowing to search for words also in unicode files.\n"
         "\n"
         "   -wchar works with text processing commands like sfk filter and sfk find.\n"
         "   (sfk hexfind will ignore the option, as it reads everything as binary)\n"
         "\n"
         "   the decoding is primitive and simply strips every 2nd byte,\n"
         "   meaning that only Latin characters can be searched.\n"
         "\n"
         "   $NOTE:<def> option \"-wchar\" is #experimental<def> and shall #not<def> be used if you want\n"
         "         to #write<def> any text file contents! (e.g. with sfk filter ... -write)\n"
         "         during write, the utf-16 format will be replaced by a primitive\n"
         "         plain ascii format (NOT a proper conversion - sfk will just\n"
         "         drop every 2nd byte from the file) which is often not desirable.\n"
         "\n"
         "   $see also\n"
         #ifdef _WIN32
         "      #sfk help chars<def>   about codepages\n"
         #endif
         "      #sfk help nocase<def>  about case insensitive search\n"
         "\n"
         "   $examples\n"
         "      #sfk -wchar filter mydir -+foo\n"
         "         filter \"foo\" in all text files of mydir, including utf-16.\n"
         "      #sfk -wchar find mydir foobar\n"
         "         find \"foobar\" in all files of mydir, including utf-16.\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || strBegins(pszSub, "compile"))
      {
      printx("$sfk compile on any linux system%s:\n",
             bhelp ? " (type \"sfk help compile\")":"");
      printx("\n"
         "   To compile SFK on any linux system like 64 bit ubuntu\n"
         "   follow these steps:\n"
         "\n"
         "   $1. make sure a C++ compiler is installed:\n"
         "      sudo apt-get install g++\n"
         "\n"
         "   $2. download the sfk source code .tar.gz\n"
         "      wget http://stahlworks.com/sfk.tar.gz\n"
         "\n"
         "   $3. compile by\n"
         "      gzip -d sfk.tar.gz\n"
         "      tar xvf sfk.tar\n"
         "      cd sfk-" SFK_VERSION "\n"
         "      ./configure\n"
         "      make\n"
         "\n"
         "   $4. IF configure/make don't work for any reason\n"
         "      $try a manual compile by:\n"
         "      g++ -osfk -s sfk.cpp sfkext.cpp sfkpack.cpp\n"
         "\n");
      printx("$sfk compile on Windows:\n"
         "\n"
         "   MSVC 14 or higher:\n"
         "      cl sfk.cpp sfkext.cpp sfkpack.cpp kernel32.lib user32.lib gdi32.lib ws2_32.lib advapi32.lib shell32.lib\n"
         "\n"
         "   mingw/gcc:\n"
         "      g++ -osfk.exe sfk.cpp sfkext.cpp sfkpack.cpp -lkernel32 -luser32 -lgdi32 -lws2_32 -ladvapi32 -lshell32\n"
         "\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strcmp(pszSub, "office"))
      {
         printHelpText("office", bhelp);

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strcmp(pszSub, "xe"))
      {
         printHelpText("xe", bhelp);

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strcmp(pszSub, "xpat"))
      {
         printx("\n");

         printSFKMatchHelp(1, 0);

         printXRepExamples(str("xhex"), 1, 1);

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strcmp(pszSub, "fileset"))
      {
      printx("$using filesets%s:\n",
             bhelp ? " (type \"sfk help fileset\")":"");
      printx("\n"
             "   if you want to process many directory trees and dir/file masks,\n"
             "   you may create a fileset, which is a text file containing directories\n"
             "   and file masks, as well as remark and blank lines for better readability.\n"
             "\n"
             "   $example file zz-myfiles.txt:\n"
             "\n"
             "      ## stat the fooproj folders.\n"
             "      ## this is a remark line.\n"
             "\n"
             "      -dir fooproj\\src\n"
             "             <not>\\save\\\n"
             "             <not>\\tmp\\\n"
             "           -file .hpp .cpp <not>.bak\n"
             "\n"
             "      -dir \"C:\\Docs With Blanks\"\n"
             "           -subdir <sla>current<sla>\n"
             "           -file <not>.tmp\n"
             "\n"
             "   $this can be used in a command like:\n"
             "\n"
             "      #sfk stat -fileset zz-myfiles.txt\n"
             "\n"
             "         lists size statistics of directory trees x:\\fooproj\\src\n"
             "         and x:\\foodb to z:\\ . any directory \"\\save\" or \"\\tmp\" within\n"
             "         fooproj\\src is excluded. within foodb, everything is included,\n"
             "         except .tmp files. you can also add remarks starting with \"##\"\n"
             "\n"
             "      #sfk snapto=mycache.txt -fileset zz-fileset.txt\n"
             "\n"
             "         collects all text specified by zz-fileset.txt into a large\n"
             "         snapfile \"mycache.txt\" (a snapshot of all text content).\n"
             "         this can be loaded by any text editor, or even better,\n"
             "         by the high speed text browser Depeche View which is\n"
             "         optimized for loading snapfiles (type \"sfk view\" for more).\n"
             "\n"
             "   $using flat filename lists:\n"
             "\n"
             "      as an alternative to specifying dir- and file masks,\n"
             "      option -fileset also accepts a flat filename list, like:\n"
             "\n"
             "         foo1.txt\n"
             "         foo2.txt\n"
             "         mydir1\\foo\\bar2.txt\n"
             "\n"
             "   the -fileset option is supported by most commands that accept\n"
             "   the -dir ... -file ... syntax, e.g. list, snapto, md5gento,\n"
             "   but not yet with sfk find or grep.\n"
             );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strcmp(pszSub, "knx"))
      {
         printHelpText("knxdump", bhelp);
         printx("\n");
         printHelpText("knxsend", bhelp);
         printx("\n");
         bDone = 1;
      }

      if (!strcmp(pszSub, "script"))
      {
         printx("please use: sfk script\n");
         bDone = 1;
      }

      if (!bhelp) {
         if (!bDone) {
            fprintf(stderr, "unknown help subject: %s.\n", pszSub);
            fprintf(stderr, "type just \"sfk\" for the main help.\n");
            fprintf(stderr, "type \"sfk ask %s\" to search all help text.\n", pszSub);
         }
         return 9;
      }
   }

   ifcmd (!strcmp(pszCmd, "faq"))
   {
      ifhelp (1)
      printHelpText("faq", bhelp);
      ehelp;
      // no real action here
      return 9;
   }

   if (!strcmp(pszCmd, "syntest")) {
      lRC = runSyntaxTests(penv);
      bDone = 1;
      // fall through to exit
   }

   if (!strcmp(pszCmd, "stacksize")) {
      bool bdummy=0;
      int icallstackload = submain(0,0,0,str("sfkstackloadint"),0,bdummy); // stacksize
      if (icallstackload<1)
          icallstackload=1;
      printf("stack load per call or perline is %d bytes.\n", icallstackload);
      printf("=== testing stack size. this will crash by intention. ===\n");
      probeStack(icallstackload, 0);
      // not reached
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "for"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk for variable from start to end [step n]\n"
             "\n"
             "   repeat sfk commands several times, from a start\n"
             "   value until an end value, setting a variable.\n"
             "\n"
             "   $command chaining notes\n"
             "      $for<def> must be followed by another chain command.\n"
             "      the command sequence to repeat must end with $+endfor<def>.\n"
             "      $+for<def> can be nested up to 5 times. further $+for<def> must\n"
             "      be put into a sub function called by $+call<def>.\n"
             "\n"
             "   $see also\n"
             "      #sfk perline<def>   do something per chain text line\n"
             "\n"
             "   $examples\n"
             "      #sfk for i from 1 to 10 +echo -var \"##(i)\" +endfor\n"
             "         print numbers 1 to 10.\n"
             "      #sfk -var for i from 5 to -5 step -3 +echo \"##(i)\" +endfor\n"
             "         print numbers 5 to -4. the -5 is not reached.\n"
             "      #sfk -var for i from 1 to 20\n"
             "       #+copy -ltarg mydir\\in##(i).jpg mydir2\\out##(02i).jpg +endfor\n"
             "         copy from mydir files in1.jpg, in2.jpg in3.jpg etc.\n"
             "         to mydir2 as out01.jpg, out02.jpg, out03.jpg, showing\n"
             "         the target filenames. add -yes after copy to confirm.\n"
             );
      ehelp;

      sfkarg;

      int istate=0;
      int isubrc=0;
      num nval=0;

      int iNextFor=iForBlock+1;

      if (iNextFor >= SFK_MAX_FOR) {
         perr("too many nested +for in one chain.");
         pinf("use +call label, then +for therein.\n");
         return 9;
      }

      struct ForBlock *pFor = &aForBlock[iNextFor];

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         // todo: check argx persistency
         char *pszArg = argx[iDir];
         // if it's not: for i from -5 to 5 ...
         if (pszArg[0]=='-' && isdigit(pszArg[1])==0)
         {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         switch (istate) {
            case 0: 
               if (!pFor->szVar[0]) {
                  if (strlen(pszArg)>sizeof(pFor->szVar)-2)
                     return 9+perr("for variable name too long: %s",pszArg);
                  strcopy(pFor->szVar,pszArg);
                  istate=1;
                  continue; 
               }
               break;
            case 1:
               if (!strcmp(pszArg,"from"))
                  { istate=2; continue; }
               break;
            case 2:
               nval=myatonum(pszArg);
               if (nval==0 && strcmp(pszArg,"0")!=0)
                  return 9+perr("invalid for start value: %s",pszArg);
               pFor->nVarSrc=nval;
               sfksetvar(pFor->szVar,(uchar*)pszArg,strlen(pszArg));
               istate=3;
               continue;
            case 3:
               if (!strcmp(pszArg,"to"))
                  { istate=4; continue; }
               break;
            case 4:
               pFor->nVarDst=myatonum(pszArg);
               if (pFor->nVarDst > pFor->nVarSrc)
                  pFor->nVarStep=1;
               else
                  pFor->nVarStep=-1;
               istate=5;
               continue;
            case 5:
               if (!strcmp(pszArg,"step"))
                  { istate=6; continue; }
               break;
            case 6: {
               num nstep = myatonum(pszArg);
               if (   (pFor->nVarStep > 0 && nstep > 0)
                   || (pFor->nVarStep < 0 && nstep < 0))
                  { }
               else
                  return 9+perr("invalid step value.\n");
               pFor->nVarStep = nstep;
               istate=7;
               continue;
            }
         }
         return 9+perr("unexpected: %s",pszArg);
      }

      iForBlock = iNextFor;

      if (!iChainNext)
         return 9+perr("%s must be followed by further chain commands.",pszCmd);

      pFor->pszCmd=argv[iChainNext];
      pFor->iDir=iChainNext;

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "endfor"))
   {
      sfkarg;

      if (iForBlock<0 || iForBlock>=SFK_MAX_FOR)
         return 9+perr("missing +for before %s",pszCmd);

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg = argx[iDir];
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argx, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argx, argc, iDir, &iChainNext))
            break;
      }

      struct ForBlock *pFor = &aForBlock[iForBlock];

      if (!pFor->szVar[0])
         return 9+perr("missing +for before %s",pszCmd);

      char *pszval=(char*)sfkgetvar(pFor->szVar,0);
      if (!pszval)
         return 9+perr("no such variable: %s",pFor->szVar);

      num nval=myatonum(pszval);

      if (nval == LLONG_MAX)
         return 9+perr("for %s stops with overflow",pFor->szVar);

      if (userInterrupt()==0)
      {
         nval += pFor->nVarStep;
         if (pFor->nVarStep > 0 && nval > pFor->nVarDst)
            { }
         else
         if (pFor->nVarStep < 0 && nval < pFor->nVarDst)
            { }
         else
         {
            pszval = numtoa(nval);
            sfksetvar(pFor->szVar,(uchar*)pszval,strlen(pszval));
            STEP_CHAIN(pFor->iDir, 0);
            // does continue
         }
      }

      // cleanup
      memset(pFor,0,sizeof(struct ForBlock));

      if (iForBlock>-1)
         iForBlock--;

      if (iChainNext) {
         STEP_CHAIN(iChainNext, 0);
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "loop"))
   {
      ifhelp (iDir == iDirStart)
      printx("<help>$sfk ... +loop\n"
             "\n"
             "   repeat (loop) the execution of a command chain.\n"
             "\n"
             "   when using +loop in an sfk script file,\n"
             "   always add +end after it (+loop +end).\n"
             "\n"
             "   $see also\n"
             "      sfk tail - a script example with looping\n"
             "\n"
             "   $examples\n"
             "      #sfk list -late mydir +sleep 5000 +loop\n"
             "         list most recent files of mydir every 5 sec.\n"
             );
      ehelp;

      if (!userInterrupt()) {
         // restart command sequence
         pszCmd = pszCmdStart;
         iDir   = iDirStart;
         nparm  = argc - iDir;
         // reset all chain settings
         chain.reset();
         // rerun from start (past global prefix options)
         bChainCycle = 1;
      }
      bDone = 1;
   }

   if (!strcmp(pszCmd, "cmd"))
   {
      char *pszbook = (char*)strstr(szGlblBookSamp, szGlblHelpCmdPat);

      if (pszbook)
      {
         pszbook += strlen(szGlblHelpCmdPat);
         char *psz2 = pszbook;
         if (*pszbook==' ') {
            pszbook++;
            psz2 = strstr(pszbook, "{EOS}");
            if (!psz2)
               return 9+perr("int. error in example text\n");
         } else {
            while (*psz2!=0 && *psz2!='\r' && *psz2!='\n')
               psz2++;
         }
         int ilen=mymin(psz2-pszbook,(int)sizeof(szGlblHelpCmdText)-10);
         memcpy(szGlblHelpCmdText,pszbook,ilen);
         szGlblHelpCmdText[ilen]='\0';
      }
      else
      {
         // szGlblHelpCmdText should now contain the searched example
         bhelp = bGlblCollectHelp = 0;
 
         if (iGlblCollectCmd != 2)
         {
            iGlblCollectCmd = 0;
            return 9+perr("example command not found: %s", szGlblHelpCmdPat);
         }
         iGlblCollectCmd = 0;
      }

      int iChainNext = 0;
      bool bRun = 0;
      char *pszFile = 0;

      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-tofile", &pszParm)) {
            if (!pszParm) return 9;
            pszFile = pszParm;
            continue;
         }
         else
         if (!strcmp(pszArg, "-run")) {
            bRun = 1;
            continue;
         }
         else
         if (sfkisopt(pszArg)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords: already done before
      }

      char szCmd[1024];

      // replace "sfk" by actual own binary name
      if (!strncmp(szGlblHelpCmdText, "sfk ", 4))
         snprintf(szCmd, sizeof(szCmd)-10, "%s %s", argv[0], szGlblHelpCmdText+4);
      else
         strcopy(szCmd, szGlblHelpCmdText);

      if (pszFile)
      {
         if (!cs.force && fileExists(pszFile)) {
            perr("file already exists: %s\n", pszFile);
            pinf("add -force to overwrite.\n");
            return 9;
         }
         if (!saveFile(pszFile, (uchar*)szCmd, strlen(szCmd)))
            printf("written: %s\n", pszFile);
      }
      else
      {
         // #ifdef _WIN32
         // printf("[copying to clipboard. add -run to execute.]\n");
         // #else
         // printf("[add -run to execute.]\n");
         // #endif

         setTextColor(nGlblHeadColor);
         printf("%s\n", szCmd);
         setTextColor(-1);
 
         #ifdef _WIN32
         if (bRun && strstr(szCmd, "sfk fromclip"))
            { }
         else
            putClipboard(szCmd);
         #endif
 
         if (bRun)
         {
            if (system(szCmd)) { }
         }
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "dumphelp") || !strcmp(pszCmd, "ask"))
   {
      // chain data is now filled with help text
      bhelp = bGlblCollectHelp = 0;

      bool bdump = !strcmp(pszCmd, "dumphelp");

      StringTable apat;
      char *ppre1=0, *ppre2=0;
      bool bdumpmiss = 0; // internal: only tell if a miss occured
      bool bhit      = 0;
      int  iDirRaw   = iDir;
      bool bprocopt  = 0;
      int  nrawpat   = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-dumpmiss")) {
            bdumpmiss  = 1;
            cs.quiet = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-opt")) {
            bprocopt = 1;
            continue;
         }
         else
         if (bprocopt && !strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // process ask patterns:
         nrawpat++;
         char *prawpat  = argv[iDir];
         char *pfiltpat = filterAskPattern(prawpat, ppre1, ppre2);
         if (pfiltpat) apat.addEntry(pfiltpat);
         ppre2 = ppre1;
         ppre1 = prawpat;
      }

      // sfk ask requires word(s)
      if (!bdump && !nrawpat) {
         perr("sfk ask requires one or more words.");
         return 9;
      }

      // did user supply a useable query phrase?
      int npat = apat.numberOfEntries();
      if (nrawpat > 0 && !npat) {
         perr("the given words are too generic, and cannot be used for search.");
         pinf("please rephrase your query with more precise words.\n");
         return 9;
      }

      // just for chaining:
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 0, &iChainNext))) return lRC;

      // if search terms are supplied
      if (!iChainNext || (npat > 0))
      {
         // dump help contents now, optionally filtered by words
         int i=0,k=0,nlastdump=-1;

         if (!bdump && !iChainNext && !cs.quiet)
         {
            // tell short info what is really used for search
            setTextColor(nGlblTimeColor, 1);
            printf("using: ");
            for (i=0; i<npat; i++) {
               printf("%s ", apat.getEntry(i, __LINE__));
            }
            printf("\n");
            setTextColor(-1, 1);
         }

         StringPipe *phelp = chain.outdata;
         bool bfirst=1,bpostlf=0;
         for (i=0; i<phelp->numberOfEntries(); i++)
         {
            char *pattr = 0;
            char *pline = phelp->getEntry(i, __LINE__, &pattr);

            if (pattr) strcopy(szAttrBuf, pattr);
            else { mclear(szAttrBuf); }

            int nhit=0,npos=0;
            for (k=0; k<npat; k++) {
               char *ppat = apat.getEntry(k, __LINE__);
               if (mystrstrip(pline, ppat, &npos)) {
                  nhit++;
                  if (npos + strlen(ppat) < MAX_LINE_LEN)
                     memset(szAttrBuf+npos, 'a', strlen(ppat));
               }
            }

            if (bdump)
               printColorText(pline, szAttrBuf);
            else
            if (nhit == npat)
            {
               int nindmax = indent(pline);

               char *pcachetxt = 0;
               char *pcacheatt = 0;

               if (nindmax <= 0) {
                  if (bfirst)
                     bfirst=0;
                  else
                  if (bpostlf) {
                     if (!bdumpmiss)
                        printf("\n");
                  }
                  bpostlf = (szAttrBuf[0] == 'i');
               }
               else
               {
                  bpostlf = 1;

                  // dump context before hit line
                  char *papre=0, *plpre=0;
                  int ictx=0,ifwd=0;
 
                  // 1. walk back to zero indent
                  for (ictx=i-1; ictx>=0 && ictx>nlastdump; ictx--)
                  {
                     plpre = phelp->getEntry(ictx, __LINE__, &papre);
                     if (plpre[0] && plpre[0] != ' ' && plpre[0] != '\t')
                        break;
                  }
                  if (ictx < 0) return 9+perr("int. #148281153");
 
                  // 2. walk forward, dump every indent change
                  if (ictx > nlastdump)
                  {
                     if (bfirst) bfirst=0; else {
                        if (!bdumpmiss)
                           printf("\n");
                     }
                     int nindcur=0;
                     for (ifwd=ictx; ifwd<i; ifwd++)
                     {
                        plpre = phelp->getEntry(ifwd, __LINE__, &papre);
                        int nindfwd = indent(plpre);
                        // whenever indent changes, dump previous.
                        // also dump zero indent line.
                        if (ifwd==ictx || (nindfwd >= nindcur && nindfwd < nindmax))
                        {
                           if ((nindfwd > nindcur) && pcachetxt) {
                              if (bdumpmiss) bhit=1; else
                              printColorText(pcachetxt, pcacheatt);
                           }
                           pcachetxt = plpre;
                           pcacheatt = papre;
                           nindcur = nindfwd;
                        }
                     }
                  }
               }
               // previous context remaining?
               if (pcachetxt) {
                  if (bdumpmiss) bhit=1; else
                  printColorText(pcachetxt, pcacheatt);
               }
               // dump hit line
               if (bdumpmiss) bhit=1; else
                  printColorText(pline, szAttrBuf);
               nlastdump = i;
            }
         }
         chain.reset();
      }

      if (bdumpmiss && !bhit) {
         printf("miss: sfk ask ");
         for (; iDirRaw<argc; iDirRaw++)
            if (!strBegins(argv[iDirRaw], "-dump"))
               printf("%s ",argv[iDirRaw]);
         printf("\n");
         return 1;
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!bDone) // sfk1892: missing stop
      break;
 }
 while (bChainCycle);

   if (cs.memcheck) sfkmem_checklist(pszCmd);

   if (bDone)
   {
      if (cs.logcmd)
      do
      {
         #ifdef _WIN32
         const char *pszLog = "zz-sfk-log.bat";
         #else
         const char *pszLog = "zz-sfk-log.sh";
         #endif
         char *pszLogEnv = getenv("SFK_CMD_LOG");
         if (pszLogEnv!=0 && strlen(pszLogEnv)>0)
            pszLog = pszLogEnv;
         static const char *szTrivial =
            "abcdefghijklmnopqrstuvwxyz"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "0123456789"
            "/\\:-+.";
         bool baddhead = fileExists((char*)pszLog,0) ? 0 : 1;
         FILE *f=fopen(pszLog, "a");
         if (!f) { perr("-yes+ cannot write command log: %s",pszLog); break; }
         if (baddhead) {
            #ifdef _WIN32
            cchar *prefix = "@rem";
            fprintf(f, "@echo on\n");
            #else
            cchar *prefix = "#";
            #endif
            fprintf(f, "%s Swiss File Knife command log created by option -yes+ or -clog\n", prefix);
            fprintf(f, "%s NOTE: some SFK commands may not wait for -yes but change files immediately.\n", prefix);
            fprintf(f, "%s If in doubt search the help text of commands for \"simulation mode\".\n", prefix);
         }
         #ifdef _WIN32
         char *pBatchParm=str("%1");
         #else
         char *pBatchParm=str("$1");
         #endif
         bool bAddedBatchParm=0;
         for (int i=0; i<gs.argc; i++) {
            char *pszArg=gs.argv[i];
            if (!strcmp(pszArg, "-clog"))
               continue;
            if (!strcmp(pszArg, "-yes+")) {
               pszArg=pBatchParm;
               bAddedBatchParm=1;
            }
            bool btrivial=1;
            for (char *psz=pszArg;*psz&&btrivial;psz++) {
               if (!strchr(szTrivial,*psz))
                  btrivial=0;
            }
            if (btrivial)
               fprintf(f, "%s ", pszArg);
            else
               fprintf(f, "\"%s\" ", pszArg);
         }
         if (!bAddedBatchParm)
            fprintf(f, "%s", pBatchParm);
         fprintf(f, "\n");
         fclose(f);
         printx("$[added command to %s]\n",pszLog);
      }
      while (0);
   }
   else
   {
      perr("unknown command: %s\n", pszCmd);
      lRC = 9;
      #ifdef SFINT
      if (paliasv && argc >= 2) {
         pwarn("this executable's name is not sfk, therefore sfk tries to run \"sfk %s\".\n", argv[1]);
         pwarn("you may set SFK_CONFIG=ignore-exec-name to disable this behaviour.\n");
         pinf("type \"sfk alias\" for more help about aliasing.\n");
      }
      #endif
   }

   return lRC;
}
// submain.end

// in: iLocalParm == -1: ignore argc, argx
//     iLocalParm >=  0: access argc, argx
int callLabel(char *pScript, // writeable
   int argc, char *argx[], char *penv[],
   char *pszLabel, int iLocalParm, int nLocalParm,
   int &lRC, bool &bFatal)
{
   lRC = 0;

   // create temporary argx[] from script file
   StringTable oDynaStrings;

   char **psubargx = 0;
   int    isubargc = 0;
   int    nsubargc = 0;

   for (int npass=0; npass<2; npass++)
   {
      char *psz1 = pScript;
      char  cold = 0; // old char before current one

      // jump to start label, if any.
      if (pszLabel) {
         // sprintf(szLineBuf, "label %s", pszLabel);
         // psz1 = strstr(pScript, szLineBuf);
         psz1 = findLabel(pScript, pszLabel);
         if (!psz1) {
            perr("label not found: %s\n", pszLabel);
            pinf("use \"sfk label %s +...\" to start with a label.\n", pszLabel);
            pinf("use \"sfk ... +label %s +...\" to insert a label.\n", pszLabel);
            lRC = 9;
            break;
         }
         // do NOT skip anything, let the chain
         // start with the "label" command.
         cold = '\0';
      }
      char *pszx = psz1+strlen(szLineBuf);
      if (*pszx==' ') pszx++;

      // main processing, until +end token.
      while (*psz1)
      {
         bool bnewline = 0;

         // note: (1) bnewline is no longer detected in 2nd pass
         nextToken(&psz1, cold, bnewline);

         if (*psz1)
         {
            // on next (non-blank) token
            char *ptok = psz1;
            if (   (bnewline==1 || npass==1) // (1)
                && isRemarkStart(ptok)
               )
            {
               // skip remark line
               while (*ptok && *ptok != '\n') ptok++;
               // do NOT skip lf, set newline on next cycle
               psz1 = ptok;
               continue;
            }

            // find end of token
            skipPastToken(&psz1, cold);
            int ntoklen = psz1 ? (psz1-ptok) : 0;

            int nrc = 0;
            if (npass && *psz1) 
            {
               // Done on SECOND pass only!
               cold = *psz1;   // e.g. lf will be overwritten
               *psz1++ = '\0';
               // post-process token: strip quotes, transform inner quotes,
               // substitute parameters.
               // uses: szLineBuf
               nrc = postProcessToken(&ptok, oDynaStrings,
                  argc, argx, iLocalParm, nLocalParm);
               if (nrc >= 9) return 9+perr("unexpected format: \"%s\"\n", ptok);
               // nrc==1 means skip EMPTY token.
            }

            // special first token "-prefix=..." ?
            if (!nrc && isubargc<3 && strBegins(ptok, "-prefix=")) {
               // give script input parameters a user-defined name
               if (npass) { // not in prescan phase
                  strcopy(cs.paramprefix, ptok+8);
               }
               continue;
            }

            // count and register token
            if (!nrc) {
               // non empty token
               if (!npass) {
                  nsubargc++;
               } else {
                  if (isubargc >= nsubargc) {
                     perr("script overflow (%d/%d) @ %s\n",isubargc,nsubargc,ptok);
                     pinf("if -prefix is used supply it as first option.\n");
                     return 9;
                  }
                  if (!psubargx)
                     return 9+perr("int. #218931");
                  psubargx[isubargc++] = ptok;
               }
            } else {
               // nrc==1 means an empty token, which is counted
               // by the first pass. correct that in second pass:
               if (npass)
                  nsubargc--;
            }

            // reached "+end"?
            if (isEndToken(ptok, ntoklen)) // !strncmp(ptok, "+end", 4))
               break;

         }  // endif *psz1

      }  // endwhile *psz1

      // at end of first pass, alloc token array
      if (!npass) {
         psubargx = new char*[nsubargc+10];
         if (!psubargx) { perr("outofmem (psubargx,%d)",nsubargc); return 19; }
      }

   }  // endfor pass

   if (cs.tracechain && psubargx) {
      printf("loaded %d words from global script:\n", nsubargc);
      for (int i=0; i<nsubargc; i++)
         printf("%s,",psubargx[i]);
      printf("\n");
   }

   if (!lRC)
   {
      if (!psubargx)
         return 9+perr("int. #218932");
      char *pszSubCmd = psubargx[0];
      int iSubDir = 1;
      // if chain starts like "sfk ...", skip "sfk":
      if (!strcmp(pszSubCmd, "sfk")) {
         pszSubCmd = psubargx[1];
         iSubDir = 2;
      }
      if (cs.tracechain > 0) {
         printf("  run call from \"%s\" (index %d) level=%d\n", pszSubCmd, iSubDir, iGlblInScript);
         for (int i=iSubDir; i<nsubargc; i++)
            printf("    arg %d/%d = \"%s\"\n",i,nsubargc,psubargx[i]);
      }
      iGlblInScript++;
       lRC = submain(nsubargc, psubargx, penv, pszSubCmd, iSubDir, bFatal);
      iGlblInScript--;
      if (cs.tracechain > 0)
         printf("  run call from \"%s\" done\n", pszSubCmd);
   }

   if (psubargx) delete [] psubargx;
   oDynaStrings.resetEntries();

   return 0;
}

#endif // USE_SFK_BASE


#ifdef VFILEBASE
// internal check: structure alignments must be same as in sfkext.cpp
void getAlignSizes1(int &n1, int &n2, int &n3)
{
   n1 = sizeof(AlignTest1);
   n2 = sizeof(AlignTest2);
   n3 = sizeof(AlignTest3);
}
#endif // VFILEBASE

